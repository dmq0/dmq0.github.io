[{"title":"33个JavaScript概念","url":"/2023/10/02/33%E4%B8%AAJavascript%E6%A6%82%E5%BF%B5/","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><strong><a href=\"#1-%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88\">调用堆栈</a></strong></li>\n<li><strong><a href=\"#2-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B\">原始类型</a></strong></li>\n<li><strong><a href=\"#3-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\">值类型和引用类型</a></strong></li>\n<li><strong><a href=\"#4-%E9%9A%90%E5%BC%8F-%E6%98%BE%E5%BC%8F-%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">隐式, 显式, 名义和鸭子类型</a></strong></li>\n<li><strong><a href=\"#5--vs--typeof-vs-instanceof\">&#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D;, typeof 与 instanceof</a></strong></li>\n<li><strong><a href=\"#6-this-call-apply-%E5%92%8C-bind\">this, call, apply 和 bind</a></strong></li>\n<li><strong><a href=\"#7-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">函数作用域, 块级作用域和词法作用域</a></strong></li>\n<li><strong><a href=\"#8-%E9%97%AD%E5%8C%85\">闭包</a></strong></li>\n<li><strong><a href=\"#9-map-reduce-filter-%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\">map, reduce, filter 等高阶函数</a></strong></li>\n<li><strong><a href=\"#10-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5\">表达式和语句</a></strong></li>\n<li><strong><a href=\"#11-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87\">变量提升</a></strong></li>\n<li><strong><a href=\"#12-promise\">Promise</a></strong></li>\n<li><strong><a href=\"#13-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\">立即执行函数, 模块化, 命名空间</a></strong></li>\n<li><strong><a href=\"#14-%E9%80%92%E5%BD%92\">递归</a></strong></li>\n<li><strong><a href=\"#15-%E7%AE%97%E6%B3%95\">算法</a></strong></li>\n<li><strong><a href=\"#16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a></strong></li>\n<li><strong><a href=\"#17-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\">消息队列和事件循环</a></strong></li>\n<li><strong><a href=\"#18-settimeout-setinterval-%E5%92%8C-requestanimationframe\">setTimeout, setInterval 和 requestAnimationFrame</a></strong></li>\n<li><strong><a href=\"#19-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8\">继承, 多态和代码复用</a></strong></li>\n<li><strong><a href=\"#20-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84\">按位操作符, 类数组对象和类型化数组</a></strong></li>\n<li><strong><a href=\"#21-dom-%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B\">DOM 树和渲染过程</a></strong></li>\n<li><strong><a href=\"#22-new-%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-instanceof-%E4%B8%8E%E5%AE%9E%E4%BE%8B\">new 与构造函数, instanceof 与实例</a></strong></li>\n<li><strong><a href=\"#23-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\">原型继承与原型链</a></strong></li>\n<li><strong><a href=\"#24-objectcreate-%E5%92%8C-objectassign\">Object.create 和 Object.assign</a></strong></li>\n<li><strong><a href=\"#25-%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB\">工厂函数和类</a></strong></li>\n<li><strong><a href=\"#26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">设计模式</a></strong></li>\n<li><strong><a href=\"#27-memoization\">Memoization</a></strong></li>\n<li><strong><a href=\"#28-%E7%BA%AF%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96\">纯函数, 函数副作用和状态变化</a></strong></li>\n<li><strong><a href=\"#29-%E8%80%97%E6%80%A7%E8%83%BD%E6%93%8D%E4%BD%9C%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">耗性能操作和时间复杂度</a></strong></li>\n<li><strong><a href=\"#30-javascript-%E5%BC%95%E6%93%8E\">JavaScript 引擎</a></strong></li>\n<li><strong><a href=\"#31-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6-%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95\">二进制, 十进制, 十六进制, 科学记数法</a></strong></li>\n<li><strong><a href=\"#32-%E5%81%8F%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-compose-%E5%92%8C-pipe\">偏函数, 柯里化, Compose 和 Pipe</a></strong></li>\n<li><strong><a href=\"#33-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93\">代码整洁之道</a></strong></li>\n</ol>\n<hr>\n<h2 id=\"1-调用堆栈\"><a href=\"#1-调用堆栈\" class=\"headerlink\" title=\"1. 调用堆栈\"></a>1. 调用堆栈</h2><h3 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9DYWxsX3N0YWNr\">Call Stack — MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTA1YjQ1NzZmYjlhMDQ1MTk2OTBkNDI=\">[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmEzMjE3MWYyNjVkYTBhYjcxOWE2ZDc=\">[译] 理解 JavaScript 中的执行上下文和执行栈 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWU4NWVlYmYyNjVkYTQzMGQ1NzFmODk=\">这一次，彻底弄懂 JavaScript 执行机制 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cub3NjaGluYS5uZXQvdHJhbnNsYXRlL2hvdy1kb2VzLWphdmFzY3JpcHQtYWN0dWFsbHktd29yay1wYXJ0LTE=\">解读 JavaScript 之引擎、运行时和堆栈调用 —— 开源中国</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDE1L3Rhc2tzLW1pY3JvdGFza3MtcXVldWVzLWFuZC1zY2hlZHVsZXMv\">Tasks, microtasks, queues and schedules —— Jake Archibald</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTVkYmQ1MWE2MGIyZjNhOTJhOGY1YmZm\">Tasks, microtasks, queues and schedules（译） —— 掘金</span></li>\n</ul>\n<h3 id=\"视频\"><a href=\"#视频\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly92LnFxLmNvbS94L3BhZ2UvaDAzNzJibGQ4cmUuaHRtbD9wdGFnPXFxYnJvd3Nlcg==\">What is the event loop anyway? —— 腾讯视频(英文字幕)</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MzM4MjQ5MzMv\">Understanding The JavaScript Call Stack, Event Queue, Event Table, &amp; Event Loop —— Bilibili</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hY2Z1bi5jbi92L2FjNDQ5NTY0MQ==\">JS 中的变量提升、堆栈内存及闭包详解 —— Acfun</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5waHAuY24vY29kZS8yMTE5NC5odG1s\">事件循环模型 —— PHP 中文网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj13NlFHRWlRY2VPTQ==\">Javascript: the Call Stack explained — Coding Blocks India</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1XOEFlTXJWdEZMWQ==\">The JS Call Stack Explained In 9 Minutes — Colt Steele</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1qVDBVU0plTkZFQQ==\">JavaScript Execution Stack — Codecademy</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj13N1FXUWxrTFlfcw==\">What is the Call Stack? — Eric Traub</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1RMnNGbXF2cEJlMA==\">The Call Stack — Kevin Drumm</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1aNmExY0x5cTdBYyZsaXN0PVBMV3JRWm5HOGwwRTRrZDFUX255dVZveFFVYVlFV0ZnY0Q=\">Understanding JavaScript Execution — Codesmith</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1tazBsdTlNS0J0bw==\">Call Stack &amp; Event Loop — movies com</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"2-原始类型\"><a href=\"#2-原始类型\" class=\"headerlink\" title=\"2. 原始类型\"></a>2. 原始类型</h2><h3 id=\"文章-1\"><a href=\"#文章-1\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9QcmltaXRpdmU=\">原始数据 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNzA5MDI3Mg==\">[译]JavaScript 是怎样编码数字的 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly95YW5oYWlqaW5nLmNvbS9qYXZhc2NyaXB0LzIwMTQvMDMvMTQvd2hhdC1ldmVyeS1qYXZhc2NyaXB0LWRldmVsb3Blci1zaG91bGQta25vdy1hYm91dC1mbG9hdGluZy1wb2ludHMv\">每一个 JavaScript 开发者应该了解的浮点知识 —— 颜海镜</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L3R5cGVzL251bWJlci5odG1s\">JavaScript 标准参考教程(基本语法之数值) —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMC8wOS8yNy90aGUtc2VjcmV0LWxpZmUtb2YtamF2YXNjcmlwdC1wcmltaXRpdmVzLw==\">The Secret Life of JavaScript Primitives —— Angus Croll</span></li>\n</ul>\n<h3 id=\"视频-1\"><a href=\"#视频-1\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL3ZpZGVvLzU2NzQ=\">javascript 六种数据类型 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5waHAuY24vY29kZS81ODA4Lmh0bWw=\">javascript 视频教程(数据类型) —— PHP 中文网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj05b29ZWVJMZGdfZw==\">JavaScript Reference vs Primitive Types — Academind</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Ic2JXUXNTQ0U1WQ==\">JavaScript Primitive Types — Simon Sez IT</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GN1liaEticEZpYw==\">Javascript Primitive and Reference Types — Baljeet Singh</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1lLV9tRHlxbTJvVQ==\">Value Types and Reference Types in JavaScript — Programming with Mosh</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xdzNqMEEzREl6UQ==\">JavaScript Primitive Data Types — Avelx</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1NcUhERHRWWUpSSQ==\">Everything you never wanted to know about JavaScript numbers — Bartek Szopka</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"3-值类型和引用类型\"><a href=\"#3-值类型和引用类型\" class=\"headerlink\" title=\"3. 值类型和引用类型\"></a>3. 值类型和引用类型</h2><h3 id=\"文章-2\"><a href=\"#文章-2\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvcHJvX2pzX3JlZmVyZW5jZXR5cGVzLmFzcA==\">ECMAScript 引用类型 —— W3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGVpdGluZy9wLzgwODE0MTMuaHRtbA==\">js 中的值类型和引用类型的区别 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmZ1bmRlYnVnLmNvbS8yMDE3LzA4LzA5L2V4cGxhaW5fdmFsdWVfcmVmZXJlbmNlX2luX2pzLw==\">JavaScript 的值传递和引用传递 —— FunDebug</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzdG9yZS5taWsudWEvb3JlbGx5L3dlYnByb2cvanNjcmlwdC9jaDA0XzA0Lmh0bQ==\">Primitive Types &amp; Reference Types in JavaScript —— Bran van der Meer</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaWFfYm9rZS9hcnRpY2xlL2RldGFpbHMvNTQ5MDY1MDk=\">JavaScript: Passing by Value or by Reference —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTQxMTE5NQ==\">js 值引用和值复制 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6emFxdWFyaXVzL2FydGljbGUvZGV0YWlscy80OTAyMjM1\">js- 引用和复制(传值和传址) —— CSDN</span></li>\n</ul>\n<h3 id=\"视频-2\"><a href=\"#视频-2\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1FLWRBbkZkcThrOA==\">Javascript Pass by Value vs Pass by Reference — techsith</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1mRDB0X0RLUkViRQ==\">JavaScript Value vs Reference Types — Programming with Mosh</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"4-隐式-显式-名义和鸭子类型\"><a href=\"#4-隐式-显式-名义和鸭子类型\" class=\"headerlink\" title=\"4. 隐式, 显式, 名义和鸭子类型\"></a>4. 隐式, 显式, 名义和鸭子类型</h2><h3 id=\"文章-3\"><a href=\"#文章-3\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvcHJvX2pzX3R5cGVjb252ZXJzaW9uLmFzcA==\">ECMAScript 类型转换 —— W3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vamF2YXNjcmlwdC8yMDEzLzA0LzA4L2phdmFzY3JpcHQtcXVpcmstMS1pbXBsaWNpdC1jb252ZXJzaW9uLW9mLXZhbHVlcy5odG1s\">JavaScript 的怪癖 1：隐式类型转换 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWFkMjU4NWYyNjVkYTI0NmEyMGUwMjY=\">JavaScript 运算符规则与隐式类型转换详解 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDQ4MjM4OA==\">聊一聊 JS 中的隐式类型转换 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVnZWdlL3AvNTI3Nzg4My5odG1s\">有趣的 JavaScript 隐式类型转换 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdqdm4vYXJ0aWNsZS9kZXRhaWxzLzQ4Mjg0MTYz\">JavaScript 显式类型转换与隐式类型转换 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NzdhODliNGVkOWE=\">你不知道的 JavaScript（中卷）强制类型转换 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwMTUxMg==\">你懂 JavaScript 嗎？#8 強制轉型 —— cythilya</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2Jvb2suNTFjdG8uY29tL2FydC8yMDE1MDUvNDc1MTUzLmh0bQ==\">动态类型语言和鸭子类型 —— 曾探</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mbG93Lm9yZy9lbi9kb2NzL2xhbmcvbm9taW5hbC1zdHJ1Y3R1cmFsLw==\">Nominal &amp; Structural Typing —— flow</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk5MTU2ODgvd2hhdC1leGFjdGx5LWlzLXR5cGUtY29lcmNpb24taW4tamF2YXNjcmlwdA==\">What exactly is Type Coercion in Javascript? —— stackoverflow</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9Zb3UtRG9udC1Lbm93LUpTL2Jsb2IvbWFzdGVyL3R5cGVzJTIwJiUyMGdyYW1tYXIvY2g0Lm1k\">You Don’t Know JS: Types &amp; Grammar —— github</span></li>\n</ul>\n<h3 id=\"视频-3\"><a href=\"#视频-3\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL3ZpZGVvLzU2NzU=\">javascript 隐式转换 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NzY3MDA5Lmh0bWw=\">Javascript 基础加强-类型转换 —— 黑马程序员</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<div id=\"5--vs--typeof-vs-instanceof\"></div>\n\n<h2 id=\"5-x3D-x3D-vs-x3D-x3D-x3D-typeof-vs-instanceof\"><a href=\"#5-x3D-x3D-vs-x3D-x3D-x3D-typeof-vs-instanceof\" class=\"headerlink\" title=\"5. &#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;, typeof vs instanceof\"></a>5. &#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;, typeof vs instanceof</h2><h3 id=\"文章-4\"><a href=\"#文章-4\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3M=\">JavaScript 中的相等性判断 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg0OTE4NjEyZjMwMWUwMDU3MTZhZGQ2\">js 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c5NzUzMS9hcnRpY2xlL2RldGFpbHMvODIyNTUyMjU=\">&#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D; in Javascript —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ldmlja3kvYXJ0aWNsZS9kZXRhaWxzLzUwMzUzODgx\">深入理解 javascript 之 typeof 和 instanceof —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vamF2YXNjcmlwdC8yMDEyLzEyLzIzL3doYXQtaXMtamF2YXNjcmlwdHMtdHlwZW9mLW9wZXJhdG9yLXVzZWQtZm9yLmh0bWw=\">JavaScript 的 typeof 的用途 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ODM1ODYwNjU3MGMzNTAwNWU0MTQyYmQ=\">一张图看懂 Function 和 Object 的关系及简述 instanceof 运算符 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjBiOWI5MDUxODgyNTE1NzczYWU3MTQ=\">浅谈 instanceof 和 typeof 的实现原理 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMDczMDk4Mg==\">typeof 和 instanceOf 的区别</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"6-this-call-apply-和-bind\"><a href=\"#6-this-call-apply-和-bind\" class=\"headerlink\" title=\"6. this, call, apply 和 bind\"></a>6. this, call, apply 和 bind</h2><h3 id=\"文章-5\"><a href=\"#文章-5\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTAvMDQvdXNpbmdfdGhpc19rZXl3b3JkX2luX2phdmFzY3JpcHQuaHRtbA==\">Javascript 的 this 用法 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2FydGljbGUvMTc1OA==\">学会 JS 的 this 这一篇就够了，根本不用记 —— 慕课网</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjlmMTc2YjZmYjlhMDVkMzgyN2QwM2Y=\">[译] this（他喵的）到底是什么 — 理解 JavaScript 中的 this、call、apply 和 bind —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWJmZTg0MzUxODgyNTMxYjczMGJhYzI=\">this、apply、call、bind —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGluZ3l1LWJsb2cvcC82MjEyMzkyLmh0bWw=\">使用 call、apply 和 bind 解决 js 中烦人的 this，事件绑定时的 this 和传参问题 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FiaWVsMTAyNC9ibG9nL2lzc3Vlcy8xNg==\">call、apply 和 bind 的原生实现 —— github</span></li>\n</ul>\n<h3 id=\"视频-4\"><a href=\"#视频-4\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXFpeWkuY29tL3dfMTlycjFhdWdzZC5odG1s\">JavaScript 关于 this 关键字解释 —— 爱奇艺</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL2JhaWR1LmlxaXlpLmNvbS93YXRjaC84NDUzMzU1MzMzODM4NzQ2ODguaHRtbD9wYWdlPXZpZGVvTXVsdGlOZWVk\">JS 关于作用域闭包和 this 的综合面试题 —— 百度视频</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NDc4NDEzLmh0bWw/Y2g9YmFpZHVfcw==\">js 面向对象闭包数组 12.函数中的 this —— 乐视视频</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI0ODM1OTExLmh0bWw/Y2g9YmFpZHVfcw==\">1.3.10-this 指向及 this 应用 —— 乐视视频</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHVkeS4xNjMuY29tL2NvdXJzZS9pbnRyb2R1Y3Rpb24vNTkwMDA1Lmh0bQ==\">珠峰培训 JavaScript 开发课程：关于 this 关键字、闭包作用域 —— 网易云课堂</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"7-函数作用域-块级作用域和词法作用域\"><a href=\"#7-函数作用域-块级作用域和词法作用域\" class=\"headerlink\" title=\"7. 函数作用域, 块级作用域和词法作用域\"></a>7. 函数作用域, 块级作用域和词法作用域</h2><h3 id=\"文章-6\"><a href=\"#文章-6\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5MzE1OTc3M2E0NjRmMzRlMTcyNDcwMGE2ZDVkZDllMjM1Y2ViN2MwMDA=\">变量作用域与解构赋值 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDkvMDgvbGVhcm5pbmdfamF2YXNjcmlwdF9jbG9zdXJlcy5odG1s\">学习 Javascript 闭包（Closure） —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjY3MTAyMA==\">JavaScript 中词法作用域、闭包与跳出闭包 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNThlNzAwNzdiMTIzZGIxNWViODhkYzdl\">JavaScript 深入之词法作用域和动态作用域 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWZiMGFlNTZmYjlhMDdhYTIxMzg0MjU=\">深入理解闭包之前置知识 → 作用域与词法作用域 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA0NzQ1NC93aGF0LWlzLWxleGljYWwtc2NvcGU=\">What is lexical scope? —— stackoverflow</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Zpc2hlbmFsL1lvdS1Eb250LUtub3ctSlMvYmxvYi9tYXN0ZXIvc2NvcGUlMjAmJTIwY2xvc3VyZXMvY2gyLm1k\">You Don’t Know JS: Scope &amp; Closures —— Kyle Simpson</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"8-闭包\"><a href=\"#8-闭包\" class=\"headerlink\" title=\"8. 闭包\"></a>8. 闭包</h2><h3 id=\"文章-7\"><a href=\"#文章-7\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9DbG9zdXJlcw==\">闭包 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvcHJvX2pzX2Z1bmN0aW9uc19jbG9zdXJlcy5hc3A=\">ECMAScript 闭包（closure）—— w3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDkvMDgvbGVhcm5pbmdfamF2YXNjcmlwdF9jbG9zdXJlcy5odG1s\">学习 Javascript 闭包（Closure） —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5MzQ1NDM0NjFjOWQ1ZGZlZWI4NDhmNWI3MmJkMDEyZTExMTNkMTUwMDA=\">闭包 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83OTZlOTAzNzU0ZjE=\">一次性搞懂 JavaScript 闭包 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjg3NTY2Mg==\">JavaScript 闭包 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTgwMGViN2RhMjJiOWQwMDViMzYxNTZl\">js 匿名自执行函数中闭包的高级使用 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTlkZjQwNTI1MTg4MjU1MWJmN2U1OGM2\">高效使用 JavaScript 闭包 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2Z1cGVuZzE5ODgvcC8zOTc3OTI0Lmh0bWw=\">深入理解 JavaScript 原型与闭包 —— 王福朋</span></li>\n</ul>\n<h3 id=\"视频-5\"><a href=\"#视频-5\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pcWl5aS5jb20vd18xOXJyMWFtYWVsLmh0bWw=\">JavaScript 闭包和闭包面试题 —— 爱奇艺</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NDc4NDEwLmh0bWw=\">js 面向对象闭包数组 11.闭包 —— 乐视</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzMwNTA1ODUyLmh0bWw=\">白贺翔_函数(闭包) —— 乐视</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"9-map-reduce-filter-等高阶函数\"><a href=\"#9-map-reduce-filter-等高阶函数\" class=\"headerlink\" title=\"9. map, reduce, filter 等高阶函数\"></a>9. map, reduce, filter 等高阶函数</h2><h3 id=\"文章-8\"><a href=\"#文章-8\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5MzU1ODI5ZWFkOTc0ZTU1MDY0NGUyZWJkOWZkOGJiMWIwZGQ3MjEwMDA=\">高阶函数 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTMvMDQvZXM1JWU2JTk2JWIwJWU1JWEyJTllJWU2JTk1JWIwJWU3JWJiJTg0JWU2JTk2JWI5JWU2JWIzJTk1Lw==\">ES5 中新增的 Array 方法详细说明 —— 张鑫旭</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ODM1ODA4MDY3ZjM1NjAwNjVlZDRhYjI=\">一张图看懂 JavaScript 中数组的迭代方法：forEach、map、filter、reduce、every、some —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjEyNzMyOQ==\">Transducing（上）－《JavaScript 轻量级函数式编程》 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0J1cHRTdEV2ZS9ibG9nL2lzc3Vlcy8xNQ==\">JavaScript 函数式编程（三） —— @BuptStEve</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"10-表达式和语句\"><a href=\"#10-表达式和语句\" class=\"headerlink\" title=\"10. 表达式和语句\"></a>10. 表达式和语句</h2><h3 id=\"文章-9\"><a href=\"#文章-9\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhbnNoZW5nbHUvcC84Mzg2OTE4Lmh0bWw=\">js 表达式与语句 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwNDEwMjgwNA==\">JS 表达式和语句的区别 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ldHRfc21pdGgvYXJ0aWNsZS9kZXRhaWxzLzc4NzYxMjQ3\">JavaScript 中的表达式（expression）和语句&#x2F;声明（statement） —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDU2NTY5Mw==\">重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovLzJhbGl0eS5jb20vMjAxMi8wOS9leHByZXNzaW9ucy12cy1zdGF0ZW1lbnRzLmh0bWw=\">Expressions versus statements in JavaScript —— Dr. Axel</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"11-变量提升\"><a href=\"#11-变量提升\" class=\"headerlink\" title=\"11. 变量提升\"></a>11. 变量提升</h2><h3 id=\"文章-10\"><a href=\"#文章-10\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydW5vb2IuY29tL2pzL2pzLWhvaXN0aW5nLmh0bWw=\">JavaScript 变量提升 —— 菜鸟教程</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTkwNWJlYTZmYjlhMDNjMzQxOTJjNTE=\">ES6 变量作用域与提升：变量的生命周期详解 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDM0NTM1NSNhcnRpY2xlSGVhZGVyNQ==\">[翻译] JavaScript Scoping and Hoisting —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hZGVxdWF0ZWx5Z29vZC5jb20vSmF2YVNjcmlwdC1TY29waW5nLWFuZC1Ib2lzdGluZy5odG1s\">JavaScript Scoping and Hoisting —— Ben Cherry</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"12-Promise\"><a href=\"#12-Promise\" class=\"headerlink\" title=\"12. Promise\"></a>12. Promise</h2><h3 id=\"文章-11\"><a href=\"#文章-11\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9Vc2luZ19wcm9taXNlcw==\">使用 promises —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==\">Promise —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NTAwODUzOTE1NWU5M2ZjMTYwNDZkNGJiNzg1NDk0MzgxNGM0ZjlkYzIwMDA=\">Promise — 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcnVieWxvdXZyZS9wLzM0OTUyODYuaHRtbA==\">JavaScript Promise：去而复返 —— 司徒正美</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wcmltZXJzL3Byb21pc2VzI18x\">(上面的原文)JavaScript Promise：简介 —— Web Fundamentals</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTgxMzkzNA==\">1 分钟读完《10 分钟学会 JavaScript 的 Async&#x2F;Await》 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTY0OTlhZTE2MGIyZDE0MDRjNGY4ODM0\">JavaScript Promise 迷你书（中文版）</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVuZmVpZmVpL3AvNDQ1MzY5MC5odG1s\">JavaScript 进阶之路——认识和使用 Promise，重构你的 Js 代码 —— 博客园</span></li>\n</ul>\n<h3 id=\"视频-6\"><a href=\"#视频-6\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzk0OQ==\">Promise 入门 —— 慕课网</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"13-立即执行函数-模块化-命名空间\"><a href=\"#13-立即执行函数-模块化-命名空间\" class=\"headerlink\" title=\"13. 立即执行函数, 模块化, 命名空间\"></a>13. 立即执行函数, 模块化, 命名空间</h2><h3 id=\"文章-12\"><a href=\"#文章-12\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMTAvamF2YXNjcmlwdF9tb2R1bGUuaHRtbA==\">Javascript 模块化编程（一）：模块的写法 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80ZGJmNGE0YzhlYmI=\">javascript 模块化编程-详解立即执行函数表达式 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTdmZWUzNjBhMjJiOWQwMDViMWQ5YWUz\">Javascript 的匿名函数与自执行 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNjk2NjM1OA==\">前端模块化——技术选型 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTk5MTg2OSNhcnRpY2xlSGVhZGVyOA==\">谈谈 Js 前端模块化规范 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3dlYi5qb2Jib2xlLmNvbS84NzUzNC8=\">函数声明与函数表达式的区别 —— 伯乐在线</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"14-递归\"><a href=\"#14-递归\" class=\"headerlink\" title=\"14. 递归\"></a>14. 递归</h2><h3 id=\"文章-13\"><a href=\"#文章-13\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwMzk0MjM0Nw==\">求解释 js 递归 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTQ4YzBkOGZlODhjMjAwNmE5MzllMmE=\">JavaScript 中的递归 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWMxZDkxZDZmYjlhMDBhNTMyNzVmNzk=\">递归（上）－《JavaScript 轻量级函数式编程》 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWM4N2ZiNDZmYjlhMDBhNDM3YjFhMmU=\">递归（下）－《JavaScript 轻量级函数式编程》 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWNkZDc0ODZmYjlhMDI4Y2E1MzU0N2M=\">尾调用和尾递归 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5xaWFuc3RkL2FydGljbGUvZGV0YWlscy83NTgwNzQ2Mg==\">几个经典递归问题用 js 实现 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hfaV94dy9hcnRpY2xlL2RldGFpbHMvNzIwMjY4Njg=\">递归函数的几个例子 —— CSDN</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"15-算法\"><a href=\"#15-算法\" class=\"headerlink\" title=\"15. 算法\"></a>15. 算法</h2><h3 id=\"文章-14\"><a href=\"#文章-14\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81N2RjZDM5NGEyMmI5ZDAwNjEwYzVlYzg=\">十大经典排序算法总结（JavaScript 描述） —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTRkZmU3OTUxODgyNTBkNzI1YTIyMGEjY29tbWVudA==\">在 JavaScript 中学习数据结构与算法 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGM5ZDVmYjFiNjllNjAwNmI2ODZiY2U=\">JS 中可能用得到的全部的排序算法 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xYjQwNjhjY2Q1MDU=\">JS 家的排序算法 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODU5MzcxNQ==\">前端常见算法的 JS 实现 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamFja3B1LmNvbS9xaWFuLWR1YW4tbWlhbi1zaGktemhvbmctZGUtY2hhbmctamlhbi1kZS1zdWFuLWZhLXdlbi10aS8=\">前端面试中的常见的算法问题 ——蒲小花的博客</span></li>\n</ul>\n<h3 id=\"视频-7\"><a href=\"#视频-7\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzg4OA==\">Javascript 实现二叉树算法 —— 慕课网</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"16-数据结构\"><a href=\"#16-数据结构\" class=\"headerlink\" title=\"16. 数据结构\"></a>16. 数据结构</h2><h3 id=\"文章-15\"><a href=\"#文章-15\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81ZTBlOGQxODMxMDI=\">来我们浅谈一下 js 的数据结构 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vbmIvMTY4MzU0OTY=\">JavaScript 中的算法与数据结构 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzdiOWM1ZTQxMDEwMTdtanQuaHRtbA==\">学 JS 必看-JavaScript 数据结构深度剖析 —— 大道至简的博客</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg2ZWZmZTBkYTJmNjAwMDUzZDg1YTlh\">js 中基础数据结构数组去重问题 —— 掘金</span></li>\n</ul>\n<h3 id=\"视频-8\"><a href=\"#视频-8\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: :tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NjA2OTY0Lmh0bWw=\">JavaScript 数据结构-运算符 —— 乐视</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"17-消息队列和事件循环\"><a href=\"#17-消息队列和事件循环\" class=\"headerlink\" title=\"17. 消息队列和事件循环\"></a>17. 消息队列和事件循环</h2><h3 id=\"文章-16\"><a href=\"#文章-16\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9FdmVudExvb3A=\">并发模型与事件循环 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMTAvZXZlbnQtbG9vcC5odG1s\">JavaScript 运行机制详解：再谈 Event Loop —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9uZy14dS9wLzcwMDAxNjMuaHRtbA==\">深入理解 JavaScript 事件循环 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjIyOTI5Mw==\">深入浅出 Javascript 事件循环机制 —— 知乎</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDk0MDkwNCNhcnRpY2xlSGVhZGVyNw==\">JS 事件循环机制（event loop）之宏任务、微任务 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDMyMjM1OA==\">JavaScript：彻底理解同步、异步和事件循环 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTY1NDdkMGYyNjVkYTNlMjgzYTFkZjc=\">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 —— 掘金</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"18-setTimeout-setInterval-和-requestAnimationFrame\"><a href=\"#18-setTimeout-setInterval-和-requestAnimationFrame\" class=\"headerlink\" title=\"18. setTimeout, setInterval 和 requestAnimationFrame\"></a>18. setTimeout, setInterval 和 requestAnimationFrame</h2><h3 id=\"文章-17\"><a href=\"#文章-17\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydW5vb2IuY29tL2pzcmVmL21ldC13aW4tc2V0dGltZW91dC5odG1s\">Window setTimeout() 方法 —— 菜鸟教程</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydW5vb2IuY29tL2pzcmVmL21ldC13aW4tc2V0aW50ZXJ2YWwuaHRtbA==\">Window setInterval() 方法 —— 菜鸟教程</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWE0YzQ3YWYyNjVkYTIzOTg2NmUyMzY=\">关于 setTimeout —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTc3ZjhjZTUxODgyNTdhNmQ2MzVkNzY=\">你不知道的 Javascript：有趣的 setTimeout —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg2MWViZjAxYjY5ZTYwMDZjZTYxZDM4\">原来你是这样的 setTimeout —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwNTk4OTQ5MQ==\">setTimeout() 和 setInterval() 本质区别在哪里？ —— SegmentFault</span></li>\n<li>book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWU=\">window.requestAnimationFrame —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9vbmVwaXhlbC9wLzcwNzg2MTcuaHRtbA==\">requestAnimationFrame 知多少？ —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMTMvMDkvY3NzMy1hbmltYXRpb24tcmVxdWVzdGFuaW1hdGlvbmZyYW1lLXR3ZWVuLSVlNSU4YSVhOCVlNyU5NCViYiVlNyVhZSU5NyVlNiViMyU5NS8=\">CSS3 动画那么强，requestAnimationFrame 还有毛线用？ —— 张鑫旭</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDY2MTAzNQ==\">「JavaScript 定时器」setInterval、setTimeout 和 requestAnimationFrame 浅析 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwMDM4NjM2OA==\">翻译：setInterval 与 requestAnimationFrame 的时间间隔测试 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAxMzkwOTQzMA==\">阿里前端面试题：requestAnimationFrame 实现类似 setInterval 的计时器 —— SegmentFault</span></li>\n</ul>\n<h3 id=\"视频-9\"><a href=\"#视频-9\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3YueW91a3UuY29tL3Zfc2hvdy9pZF9YTlRBNE9UUTBOekEwLmh0bWw=\">setTimeout 和 setInterval —— 优酷</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"19-继承-多态和代码复用\"><a href=\"#19-继承-多态和代码复用\" class=\"headerlink\" title=\"19. 继承, 多态和代码复用\"></a>19. 继承, 多态和代码复用</h2><h3 id=\"文章-18\"><a href=\"#文章-18\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTGVvX3dsL3AvNTczNDc5NC5odG1s\">JS 面向对象编程之：封装、继承、多态 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81Y2I2OTI2NTg3MDQ=\">Javascript 的继承与多态 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTM5NmM5NmZlODhjMjAwNmFmYzI3MDc=\">js:面向对象编程，带你认识封装、继承和多态 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDY5MzIwOQ==\">JavaScript 中的“多继承” —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1Rvb0J1Zy9qYXZhc2NyaXB0LnBhdHRlcm5zL2Jsb2IvbWFzdGVyL2NoYXB0ZXI2Lm1hcmtkb3du\">代码复用模式 —— github</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9Ub21YdS9hcmNoaXZlLzIwMTIvMDQvMjQvMjQzODA1MC5odG1s\">深入理解 JavaScript：代码复用模式(推荐篇) —— 汤姆大叔</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVG9tWHUvYXJjaGl2ZS8yMDEyLzA0LzIzLzI0MzgwMDUuaHRtbA==\">深入理解 JavaScript：代码复用模式(避免篇) —— 汤姆大叔</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"20-按位操作符-类数组对象和类型化数组\"><a href=\"#20-按位操作符-类数组对象和类型化数组\" class=\"headerlink\" title=\"20. 按位操作符, 类数组对象和类型化数组\"></a>20. 按位操作符, 类数组对象和类型化数组</h2><h3 id=\"文章-19\"><a href=\"#文章-19\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3Jz\">按位操作符 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9UeXBlZF9hcnJheXM=\">类数组对象 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXI=\">类型化数组 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ3JhZG9sYWJzL3AvNDc2MjEzNC5odG1s\">JavaScript ArrayBuffer 浅析 —— 博客园</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"21-DOM-树和渲染过程\"><a href=\"#21-DOM-树和渲染过程\" class=\"headerlink\" title=\"21. DOM 树和渲染过程\"></a>21. DOM 树和渲染过程</h2><h3 id=\"文章-20\"><a href=\"#文章-20\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbC9Ib3dfdG9fY3JlYXRlX2FfRE9NX3RyZWU=\">如何创建一个 DOM 树 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vaHRtbGRvbS9kb21fbm9kZXMuYXNw\">HTML DOM 节点 —— W3school</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20vZG9tL25vZGUuaHRtbA==\">DOM 概述 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xMDAzMWJiMjRkYWY=\">《JavaScript 闯关记》之 DOM（上）—— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ODliMTZkY2UxNGE=\">《JavaScript 闯关记》之 DOM（下）—— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTgzMTRlZmQ4YWMyNDcwMDYxYmIzMGZk\">掌握 DOM 操作 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NTAwNDk0NDUxMjczZTZiM2RlYzlkNDExZDliYTg0MWRlZThjYWVjNDUwMDA=\">操作 DOM —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWM2MDY5MTUxODgyNTM5NmY0ZjcxYTE=\">原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的 —— 掘金</span></li>\n</ul>\n<h3 id=\"视频-10\"><a href=\"#视频-10\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzQ4OA==\">DOM 探索之基础详解篇 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzEzOA==\">DOM 事件探秘 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2xlYXJuLzUzMA==\">jQuery 基础(二)DOM 篇 —— 慕课网</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pcWl5aS5jb20vd18xOXJyMTlzMDhsLmh0bWw=\">JS 操作 DOM 对象属性和方法 —— 爱奇艺</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"22-new-与构造函数-instanceof-与实例\"><a href=\"#22-new-与构造函数-instanceof-与实例\" class=\"headerlink\" title=\"22. new 与构造函数, instanceof 与实例\"></a>22. new 与构造函数, instanceof 与实例</h2><h3 id=\"文章-21\"><a href=\"#文章-21\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2phdmFzY3JpcHQucnVhbnlpZmVuZy5jb20vb29wL2Jhc2ljLmh0bWw=\">构造函数与 new 命令 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTAvMDUvb2JqZWN0LW9yaWVudGVkX2phdmFzY3JpcHRfaW5oZXJpdGFuY2UuaHRtbA==\">Javascript 面向对象编程（二）：构造函数的继承 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NwaWN5Qm9pbGVkRmlzaC9hcnRpY2xlL2RldGFpbHMvNzExMjMxNjI=\">完整原型链详细图解(构造函数、原型、实例化对象) —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5waHAuY24vanMtdHV0b3JpYWwtMzc2MjQ2Lmh0bWw=\">JavaScript 中构造函数与 new 操作符的实例详解 —— PHP 中文网</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbl85OTEvYXJ0aWNsZS9kZXRhaWxzLzgwOTU0NDUz\">构造函数、实例、原型、原型链之间的关系 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlY2lsaWE2MjAvYXJ0aWNsZS9kZXRhaWxzLzcxMTU4MDQ4\">深入理解 JS—instanceof 和原型链 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xNWFjNzM5M2JjMWY=\">前端基础进阶（九）：详解面向对象、构造函数、原型与原型链 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82MGZmYzQ4MzFiZmY=\">js 用 new 实例化对象与直接调用的 this 的区别 —— 简书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vamF2YXNjcmlwdC8yMDEyLzEyLzIyL2phdmFzY3JpcHQtdmFsdWVzLW5vdC1ldmVyeXRoaW5nLWlzLWFuLW9iamVjdC5odG1s\">JavaScript 并非所有的东西都是对象 —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi93ZWIvMTMwNl9qaWFuZ2pqX2pzaW5zdGFuY2VvZi8=\">JavaScript instanceof 运算符深入剖析 —— IBM</span></li>\n</ul>\n<h3 id=\"视频-11\"><a href=\"#视频-11\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NzY2ODg5Lmh0bWw=\">改良版的构造函数 —— 乐视</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"23-原型继承与原型链\"><a href=\"#23-原型继承与原型链\" class=\"headerlink\" title=\"23. 原型继承与原型链\"></a>23. 原型继承与原型链</h2><h3 id=\"文章-22\"><a href=\"#文章-22\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9Jbmhlcml0YW5jZV9hbmRfdGhlX3Byb3RvdHlwZV9jaGFpbg==\">继承与原型链 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JpZ2RvdHMvYmxvZy9pc3N1ZXMvMQ==\">构造函数、原型与原型链 —— github</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0b25lMDA5MC9qYXZhc2NyaXB0LWxlc3NvbnMvdHJlZS9tYXN0ZXIvMi41LVByb3RvdHlwZQ==\">原型及原型链 —— github(1269 Star)</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDI4MjIwNg==\">理清 javascript 中的面向对象(一) 原型继承 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2p1c3RqYXZhYy5jb20vMjAxNS8xMi8wOS9pbmhlcml0YW5jZS1hbmQtdGhlLXByb3RvdHlwZS1jaGFpbi5odG1s\">JavaScript：继承和原型链(译) —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9zaHVpeWkvcC81MzA1NDM1Lmh0bWw=\">三张图搞懂 JavaScript 的原型对象与原型链 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9fYXBvbGxvL2FydGljbGUvZGV0YWlscy83Njc3NDY5OA==\">一张图让你搞懂 JavaScript 的继承与原型链 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW90YW9fY3NzL2FydGljbGUvZGV0YWlscy83Mjc4MjQxNg==\">JS 高级–原型链(一看就懂，但 18 岁以下请绕道) —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDM0NDQ2Njg5ODY3YjI3MTU3ZTg5NmU3NGQ1MWE4OWMyNWNjOGI0M2JkYjMwMDAvMDAxNDM0NDk5NzAxMzQwNWFiZmI3ZjBlMTkwNGEwNGJhNjg5OGEzODRiMWU5MjUwMDA=\">原型继承 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGY5NGM5YmIxMjNkYjQxMTk1MzY5MWI=\">JS 原型链与继承别再被问倒了 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg4NWRiMjIxYjY5ZTYwMDU5MjI1M2U3\">征服 JavaScript 面试系列：类继承和原型继承的区别 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2cvaXNzdWVzLzI=\">JavaScript 深入之从原型到原型链 —— 冴羽</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FuZ2Z1cGVuZzE5ODgvcC8zOTc3OTI0Lmh0bWw=\">深入理解 JavaScript 原型与闭包 —— 王福朋</span></li>\n</ul>\n<h3 id=\"视频-12\"><a href=\"#视频-12\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZS5jb20vcHR2L3ZwbGF5LzI3NTUyNzUzLmh0bWw=\">JS 高级-07-原型链继承 —— 乐视</span></li>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly92LnFxLmNvbS94L3BhZ2UvYjA1MTFud2E3ZDMuaHRtbA==\">JS 原型对象和原型链简介 —— 腾讯视频</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"24-Object-create-和-Object-assign\"><a href=\"#24-Object-create-和-Object-assign\" class=\"headerlink\" title=\"24. Object.create 和 Object.assign\"></a>24. Object.create 和 Object.assign</h2><h3 id=\"文章-23\"><a href=\"#文章-23\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZQ==\">Object.create —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbg==\">Object.assign —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW1vb2MuY29tL2FydGljbGUvMTc1OTE=\">Object.create vs Object.assign —— 慕课网手记</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlZXBMaWVzL2FydGljbGUvZGV0YWlscy81MjkxNTE0Mw==\">JS 中的 Object.assign()、Object.create()、Object.defineProperty() —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhaWtvam9zaC9PYmplY3QtQXNzaWduLURlZXA=\">Object-Assign-Deep —— github</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"25-工厂函数和类\"><a href=\"#25-工厂函数和类\" class=\"headerlink\" title=\"25. 工厂函数和类\"></a>25. 工厂函数和类</h2><h3 id=\"文章-24\"><a href=\"#文章-24\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvQ2xhc3Nlcw==\">类 —— MDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxMzc0NzM4MTI1MDk1Yzk1NWMxZTZkOGJiNDkzMTgyMTAzZmFjOTI3MDc2MmEwMDAvMDAxMzg2ODIwMDQwNzczNzZkMmQ3ZjhjYzhhNGUyYzk5ODJmOTI3ODg1ODgzMjIwMDA=\">类和实例 —— 廖雪峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDcvdGhyZWVfd2F5c190b19kZWZpbmVfYV9qYXZhc2NyaXB0X2NsYXNzLmh0bWw=\">Javascript 定义类（class）的三种方法 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWM4Yzg3NTZmYjlhMDBhNjgxYWU1YmQ=\">【译】ES6 的工厂函数 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTg3OTkyYzk2MWZmNGIwMDY1ZWRmMWZm\">JavaScript 创建对象之单例、工厂、构造函数模式 —— 掘金</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"26-设计模式\"><a href=\"#26-设计模式\" class=\"headerlink\" title=\"26. 设计模式\"></a>26. 设计模式</h2><h3 id=\"文章-25\"><a href=\"#文章-25\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWRmNGY3NGYyNjVkYTQzMGYzMTE5MDk=\">JavaScript 设计模式 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvamF2YXNjcmlwdC1kZXNpZ24tcGF0dGVybnMv\">学用 JavaScript 设计模式 —— 极客学院</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDkxNDAzMg==\">[面试专题]JS 设计模式 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2x4ai9qYXZhc2NyaXB0LnBhdHRlcm5z\">JavaScript Patterns 中译本 —— github</span></li>\n</ul>\n<h3 id=\"视频-13\"><a href=\"#视频-13\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cHM6Ly90di5zb2h1LmNvbS92L2RYTXZNalF3TnpZd056UTRMemc1TnpNMk1EQTNMbk5vZEcxcy5odG1s\">HTML5 课程大纲 2-11JS 设计模式</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"27-Memoization\"><a href=\"#27-Memoization\" class=\"headerlink\" title=\"27. Memoization\"></a>27. Memoization</h2><h3 id=\"文章-26\"><a href=\"#文章-26\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcnVieWxvdXZyZS9hcmNoaXZlLzIwMDkvMDgvMDYvMTU0MDY3OC5odG1s\">JavaScript Memoization —— 司徒正美</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWluZ3NodWl6eS9wLzQ1MTcxMDIuaHRtbA==\">memoization 提升递归效率 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2RldmVsb3Blci41MWN0by5jb20vYXJ0LzIwMTAxMC8yMzE1MTMuaHRt\">如何提升 JavaScript 的递归效率 —— 51CTO</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNjcwMzEwNg==\">JavaScript 高级技巧 Memoization —— SegmentFaut</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"28-纯函数-函数副作用和状态变化\"><a href=\"#28-纯函数-函数副作用和状态变化\" class=\"headerlink\" title=\"28. 纯函数, 函数副作用和状态变化\"></a>28. 纯函数, 函数副作用和状态变化</h2><h3 id=\"文章-27\"><a href=\"#文章-27\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2h1emlrZXRhbmcubWFuZ29qdWljZS50b3AvYm9va3MvcmVhY3QvbGVzc29uMzI=\">纯函数(Pure Function) —— React.js 小书</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9uaW5naGFvLm5ldC9ibG9nLzQ2MzQ=\">JavaScript Functional Programming：纯函数 —— 宁皓网</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yODA3OS5odG0=\">js 函数的副作用分析 —— 脚本之家</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjgyYmRiMzUxODgyNTQyZTI0MWVkMzI/dXRtX21lZGl1bT1oYW8uY2FpYmFvamlhbi5jb20mdXRtX3NvdXJjZT1oYW8uY2FpYmFvamlhbi5jb20=\">如何使用纯函数式 JavaScript 处理脏副作用 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS96aGFuZ3ljdW4vcC85NDAzMzM1Lmh0bWw=\">原生 JavaScript 实现 state 状态管理系统 —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0J1cHRTdEV2ZS9ibG9nL2lzc3Vlcy8xMA==\">JavaScript 函数式编程 —— @BuptStEve</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"29-耗性能操作和时间复杂度\"><a href=\"#29-耗性能操作和时间复杂度\" class=\"headerlink\" title=\"29. 耗性能操作和时间复杂度\"></a>29. 耗性能操作和时间复杂度</h2><h3 id=\"文章-28\"><a href=\"#文章-28\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTkzZjU2NTI4ZDZkODEwMDU4YTM1NWY0\">时间复杂度 O(log n) 意味着什么？ —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWE0OWY3ZDM2ZmI5YTA0NTBhNjdiMjY5\">算法的时间复杂度和空间复杂度 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGQxNWYxMDQ0ZDkwNDAwNjkxODM0ZDQ=\">算法（一）时间复杂度 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5icmFkb25jb2RlLmNvbS9ibG9nLzIwMTIvMDQvYmlnLW8tYWxnb3JpdGhtLWV4YW1wbGVzLWluLWphdmFzY3JpcHQuaHRtbA==\">Big O Search Algorithms in JavaScript —— Bradley Braithwaite</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamVubmlmZXJibGFuZC5jb20vdGltZS1jb21wbGV4aXR5LWFuYWx5c2lzLWluLWphdmFzY3JpcHQv\">Time Complexity Analysis in JavaScript — Jennifer Bland</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"30-JavaScript-引擎\"><a href=\"#30-JavaScript-引擎\" class=\"headerlink\" title=\"30. JavaScript 引擎\"></a>30. JavaScript 引擎</h2><h3 id=\"文章-29\"><a href=\"#文章-29\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9qYXZhc2NyaXB0JUU1JUJDJTk1JUU2JTkzJThFLzUzNTYxMDg=\">javascript 引擎 —— 百度百科</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9WOC82MTc4MTI1\">V8(JavaScript 引擎) —— 百度百科</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTYzMDlmNzZmYjlhMDFjYWIyODU4YjE=\">图解搞懂 JavaScript 引擎 Event Loop —— 掘金</span>3</li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDgxOTAyMA==\">V8 JavaScript 引擎：高性能的 ES2015+ —— justjavac</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjgwNjYzNw==\">10 分钟理解 JS 引擎的执行机制 —— SegmentFaut</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2VpcmRvUWkvcC82NjA5ODExLmh0bWw=\">V8 javascript 引擎 —— 博客园</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"31-二进制-十六进制-十进制-科学记数法\"><a href=\"#31-二进制-十六进制-十进制-科学记数法\" class=\"headerlink\" title=\"31. 二进制, 十六进制, 十进制, 科学记数法\"></a>31. 二进制, 十六进制, 十进制, 科学记数法</h2><h3 id=\"文章-30\"><a href=\"#文章-30\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9nYWl6YWkvcC80MjMzNzgwLmh0bWw=\">二、八、十、十六进制转换(图解篇) —— 博客园</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjkzZGFkYWYyNjVkYTBhODU3YTU4YTM=\">JavaScript 读写二进制数据 —— 掘金</span></li>\n</ul>\n<h3 id=\"视频-14\"><a href=\"#视频-14\" class=\"headerlink\" title=\"视频\"></a>视频</h3><ul>\n<li>:tv: <span class=\"exturl\" data-url=\"aHR0cDovL2JhaXNoaS5iYWlkdS5jb20vd2F0Y2gvNzg3MzA2MDk2MzQ3MTQ3ODQ1Ni5odG1s\">二进制、十进制、十六进制互相转化很难吗？ —— 百度视频</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"32-偏函数-柯里化-Compose-和-Pipe\"><a href=\"#32-偏函数-柯里化-Compose-和-Pipe\" class=\"headerlink\" title=\"32. 偏函数, 柯里化, Compose 和 Pipe\"></a>32. 偏函数, 柯里化, Compose 和 Pipe</h2><h3 id=\"文章-31\"><a href=\"#文章-31\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTI5MDYzL2FydGljbGUvZGV0YWlscy84MTg3NDMxNA==\">Javascript 函数式编程之偏函数 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDY4NjE0NA==\">JavaScript 专题之偏函数 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwODYyNjA1OA==\">柯里化和偏函数有什么区别？ —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ld2Vhc3RzdW4vYXJ0aWNsZS9kZXRhaWxzLzc1OTQ3Nzg1\">Javascript 偏函数与柯里化 —— CSDN</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sbGg5MTEwMDEuZ2l0Ym9va3MuaW8vbW9zdGx5LWFkZXF1YXRlLWd1aWRlLWNoaW5lc2UvY29udGVudC9jaDQuaHRtbA==\">柯里化(curry) —— JS 函数式编程指南</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sbGg5MTEwMDEuZ2l0Ym9va3MuaW8vbW9zdGx5LWFkZXF1YXRlLWd1aWRlLWNoaW5lc2UvY29udGVudC9jaDUuaHRtbA==\">代码组合(compose) —— JS 函数式编程指南</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODM5NDc0OQ==\">关于 javascript 函数式编程中 compose 的实现 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTQ0NzE2NA==\">实现 compose 的五种思路 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTEwMjgwNA==\">JavaScript 函数式编程之函数组合函数 compose 和 pipe 的实现 —— SegmentFault</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWE2MmYzZDZmYjlhMDI0ODM2M2ZkOWQjY29tbWVudA==\">JavaScript 轻量级函数式编程-第 4 章:组合函数 ——掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0J1cHRTdEV2ZS9ibG9nL2lzc3Vlcy8xMQ==\">JavaScript 函数式编程（二） —— @BuptStEve</span></li>\n</ul>\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n<h2 id=\"33-代码整洁之道\"><a href=\"#33-代码整洁之道\" class=\"headerlink\" title=\"33. 代码整洁之道\"></a>33. 代码整洁之道</h2><h3 id=\"文章-32\"><a href=\"#文章-32\" class=\"headerlink\" title=\"文章\"></a>文章</h3><ul>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemNmeS5jYy9hcnRpY2xlL2NsZWFuLWNvZGUtamF2YXNjcmlwdC1yZWFkbWUtbWQtYXQtbWFzdGVyLXJ5YW5tY2Rlcm1vdHQtY2xlYW4tY29kZS1qYXZhc2NyaXB0LWdpdGh1Yi0yMjczLmh0bWw=\">[译] JavaScript 代码整洁之道 —— 边城</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDQvamF2YXNjcmlwdF9wcm9ncmFtbWluZ19zdHlsZS5odG1s\">Javascript 编程风格 —— 阮一峰</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTViMmE1YzZmYjlhMDFjYmM2ZTU5Zjk=\">重构 - 代码整洁之道 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTdkNzE4MzZmYjlhMDYzNDM1ZWNmNTE=\">让你的代码更简短，更整洁，更易读的 ES6 小技巧 —— 掘金</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMjM2MTcv\">Web 前端：11 个让你代码整洁的原则 —— 伯乐在线</span></li>\n<li>:book: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3J5YW5tY2Rlcm1vdHQvY2xlYW4tY29kZS1qYXZhc2NyaXB0\">Clean Code concepts adapted for JavaScript —— ryanmcdermott</span></li>\n</ul>\n<br>\n\n<p><strong><a href=\"#%E7%9B%AE%E5%BD%95\">:arrow_up: 返回目录</a></strong></p>\n<hr>\n","categories":["JS"],"tags":["JS","概念"]},{"title":"ArrayBuffer","url":"/2023/09/02/ArrayBuffer/","content":"<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer:\"></a>ArrayBuffer:</h1><p>ArrayBuffer 是 JavaScript 中用于表示通用的固定长度的二进制数据缓冲区的对象。它可以在内存中分配一块连续的内存空间，用于存储二进制数据。</p>\n<p>ArrayBuffer 对象本身只是一个占用了一定字节数的内存块，它没有提供直接的方法来读取或写入数据。为了操作 ArrayBuffer 中的数据，我们需要使用不同的视图（如 TypedArray 或 DataView）来读取、写入和操作底层的二进制数据。</p>\n<p>在内存中，ArrayBuffer 对象以连续的字节序列表示。这意味着存储在 ArrayBuffer 中的数据是紧密排列的，没有额外的空隙或填充。每个字节都有一个唯一的地址，我们可以通过偏移量来访问和操作特定位置的字节。</p>\n<p>以下是一个示例，展示了如何创建和使用 ArrayBuffer：</p>\n<pre><code class=\"javascript\">javascriptCopy Code// 创建一个包含 16 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(16);\n\n// 使用一个 Int32Array 视图来读取和写入数据\nconst int32Array = new Int32Array(buffer);\n\n// 写入数据\nint32Array[0] = 42;\nint32Array[1] = 99;\n\n// 读取数据\nconsole.log(int32Array[0]); // 输出 42\nconsole.log(int32Array[1]); // 输出 99\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 16 字节的 ArrayBuffer。然后，我们使用 Int32Array 视图来操作这个 ArrayBuffer，将数据写入到数组中，并通过下标直接访问和读取数据。在内存中，这些数据被紧密排列在连续的字节中。</p>\n<p>需要注意的是，ArrayBuffer 的长度是固定的，一旦分配了特定大小的内存空间，就无法改变它的大小。如果我们需要更改数据的长度，我们需要创建一个新的 ArrayBuffer，并将旧数据拷贝到新的 ArrayBuffer 中。</p>\n<p>总之，ArrayBuffer 提供了一种在 JavaScript 中操作底层二进制数据的机制，它在内存中以连续的字节序列表示，可以用于存储和操作各种类型的二进制数据。</p>\n","categories":["JS"],"tags":["JS","ArrayBuffer"]},{"title":"Blob","url":"/2023/12/07/Blob/","content":"<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob:\"></a>Blob:</h1><p>Blob（Binary Large Object）对象是 JavaScript 中用来表示二进制数据的对象，通常用于存储和操作文件或其他类型的二进制数据。Blob 对象可以表示大型数据对象，比如图像、视频、音频文件等。</p>\n<p>Blob 对象通常由两部分组成：数据和数据的类型。数据部分包含实际的二进制数据，而类型部分描述了数据的 MIME 类型，例如 “image&#x2F;png” 或 “application&#x2F;pdf”。</p>\n<p>Blob 对象可以通过 new Blob() 构造函数创建，传入一个数组作为参数，数组中包含要存储的二进制数据。另外，你还可以通过传入一个可选的对象参数，来指定数据的 MIME 类型。例如：</p>\n<pre><code class=\"javascript\">javascriptCopy Codevar binaryData = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; // 用十六进制表示的字符串 &quot;Hello&quot;\nvar blob = new Blob([binaryData], &#123; type: &quot;text/plain&quot; &#125;);\n</code></pre>\n<p>在上面的例子中，我们使用 new Blob() 创建了一个包含 “Hello” 文本数据的 Blob 对象，并指定了它的 MIME 类型为 “text&#x2F;plain”。</p>\n<p>Blob 对象可以被用于多种用途，比如：</p>\n<p>通过 URL.createObjectURL() 方法创建一个临时的 URL，用于在页面中显示或下载文件,一般配置a标签（download属性）。<br>作为 XMLHttpRequest 的响应数据类型，用于接收和处理文件或二进制数据。<br>作为 FormData 对象的值，用于将二进制数据发送到服务器。<br>总之，Blob 对象在 JavaScript 中提供了一种方便的方式来处理和操作二进制数据，特别适合于文件操作和网络通信中的数据传输</p>\n","categories":["JS"],"tags":["JS","Blob"]},{"title":"DataView","url":"/2023/12/08/DataView/","content":"<h1 id=\"DataView视图：\"><a href=\"#DataView视图：\" class=\"headerlink\" title=\"DataView视图：\"></a>DataView视图：</h1><p>DataView 是 JavaScript 中的一个类型化数组视图，用于以不同的字节序（如大端序或小端序）和不同的数据类型（如整数、浮点数等）来读取和写入 ArrayBuffer 中的二进制数据。与 TypedArray 不同，DataView 可以指定任意的字节偏移量和长度，可以更加灵活地操作二进制数据。</p>\n<p>以下是一个使用 DataView 读取 ArrayBuffer 中的二进制数据的示例：</p>\n<pre><code class=\"javascript\">javascriptCopy Code// 创建一个包含 8 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(8);\n\n// 使用一个 DataView 视图来读取和写入数据\nconst dataView = new DataView(buffer);\n\n// 写入数据\ndataView.setInt16(0, 42); // 在第 1 和第 2 个字节中写入 42\ndataView.setInt32(2, -100); // 在第 3 到第 6 个字节中写入 -100\n\n// 读取数据\nconsole.log(dataView.getInt16(0)); // 输出 42\nconsole.log(dataView.getInt32(2)); // 输出 -100\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 8 字节的 ArrayBuffer。然后，我们使用一个 DataView 视图来操作这个 ArrayBuffer，分别在前两个字节和后四个字节中写入两个不同的数据，然后通过 DataView 的方法来读取这些数据。</p>\n<p>需要注意的是，DataView 的方法名都以数据类型名称开头，并以字节偏移量作为第一个参数。例如，setInt16(offset, value) 方法将一个 16 位整数值写入到指定偏移量处，而 getInt32(offset) 方法则从指定偏移量处读取一个 32 位整数值。这些方法还可以接受一个可选的第二个参数，用于指定字节序，以帮助正确地解释二进制数据。</p>\n<p>总之，DataView 提供了一种灵活和可定制的方式来读取和写入 ArrayBuffer 中的二进制数据，可以指定不同的字节序和数据类型，并支持任意偏移量和长度。</p>\n","categories":["JS"],"tags":["JS","DataView"]},{"title":"Blob、File和FileReader","url":"/2024/05/17/Blob%E5%92%8CFile/","content":"<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h1><p>Blob的全称为：binary larget object（二进制大对象），blob的本质是一个js对象，里面可以存储大量的二进制编码的数据。</p>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><ul>\n<li>不可修改</li>\n<li>只能使用FileReader读取内容</li>\n<li>存储大量二进制数据的 js 对象</li>\n</ul>\n<h3 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p><strong>new Blob(array,options)</strong></p>\n<ul>\n<li><p>array是由ArrayBuffer、ArrayBufferView、Blob和DOMString对象构成的，将对被放进blob中</p>\n</li>\n<li><p>options配置项有：</p>\n<ul>\n<li><p>type：默认值为：” “，表示将会被放入到blob中的数组内容的MIME类型。</p>\n</li>\n<li><p>endings：默认值为：”transparent“，用于指定包含行结束符\\n的字符串如何被写入，不常用。</p>\n<table>\n<thead>\n<tr>\n<th>MIME类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>text&#x2F;plain</td>\n<td>纯文本文档</td>\n</tr>\n<tr>\n<td>text&#x2F;html</td>\n<td>HTML文档</td>\n</tr>\n<tr>\n<td>text&#x2F;javascript</td>\n<td>JavaScript文档</td>\n</tr>\n<tr>\n<td>text&#x2F;css</td>\n<td>CSS文件</td>\n</tr>\n<tr>\n<td>application&#x2F;json</td>\n<td>JSON文件</td>\n</tr>\n<tr>\n<td>application&#x2F;pdf</td>\n<td>pdf文件</td>\n</tr>\n<tr>\n<td>application&#x2F;xml</td>\n<td>XML文件</td>\n</tr>\n<tr>\n<td>image&#x2F;jpeg</td>\n<td>JPEG文件</td>\n</tr>\n<tr>\n<td>image&#x2F;png</td>\n<td>PNG文件</td>\n</tr>\n<tr>\n<td>image&#x2F;gif</td>\n<td>GIF文件</td>\n</tr>\n<tr>\n<td>image&#x2F;svg+xml</td>\n<td>SVG+XML文件</td>\n</tr>\n<tr>\n<td>audio&#x2F;mpeg</td>\n<td>MP3文件</td>\n</tr>\n<tr>\n<td>video&#x2F;mpeg</td>\n<td>MP4文件</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\n</code></pre>\n<h3 id=\"分片：\"><a href=\"#分片：\" class=\"headerlink\" title=\"分片：\"></a>分片：</h3><p>Blob 对象内置了 slice() 方法用来将 blob 对象分片</p>\n<p>其有三个参数：</p>\n<p>start：设置切片的起点，即切片开始位置。默认值为 0，这意味着切片应该从第一个字节开始；</p>\n<p>end：设置切片的结束点，会对该位置之前的数据进行切片。默认值为blob.size；</p>\n<p>contentType：设置新 blob 的 MIME 类型。如果省略 type，则默认为 blob 的原始值。</p>\n<pre><code class=\"javascript\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\nlet blob1 = blob.slice(0,2,&quot;text/plain&quot;);\n</code></pre>\n<h3 id=\"读取：\"><a href=\"#读取：\" class=\"headerlink\" title=\"读取：\"></a>读取：</h3><p>blob对象只能通过FileReader读取内容。</p>\n<pre><code class=\"javascript\">let blob = new Blob([&#39;hello world&#39;],&#123;type:&quot;text/plain&quot;&#125;);\nlet reader = new fileReader();\nreader.readAsText(blob);\nconsole.log(reader.result);\n</code></pre>\n<h1 id=\"File\"><a href=\"#File\" class=\"headerlink\" title=\"File\"></a>File</h1><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>File对象是特殊的Blob对象。是基于Blob对象的进一步封装，js中主要有两种方式获得FIle对象：</p>\n<ol>\n<li>input元素选择后返回的FileList对象（通过change事件的event.target.files获取）</li>\n<li>文件拖放操作生成的DataTransfer对象（通过ondrop事件的event.dataTransfer.files获取）</li>\n</ol>\n<h1 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h1><h3 id=\"介绍：-1\"><a href=\"#介绍：-1\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>FileReader用于读取Blob对象（包含File对象）内容的方法，通过result属性获取。</p>\n<ul>\n<li><p>readAsArrayBuffer方法：读取为ArrayBuffer</p>\n</li>\n<li><p>readAsDataURL方法：读取为data:URL的Base64字符串表示文件内容</p>\n</li>\n<li><p>readAsText方法：读取为原始text文件内容</p>\n</li>\n<li><p>readAsBinaryString方法：读取为原始二进制数据</p>\n<p>但是直接使用此方法还是会得到原始的文本内容，因为二进制数据需要使用ArrayBuffer对象来进行处理。</p>\n</li>\n</ul>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h1><h3 id=\"介绍：-2\"><a href=\"#介绍：-2\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>ArrayBuffer可以理解为一个特殊的数组，其本身是一个黑盒，不能直接读写所存储的数据，需要借助视图对象来读写。它只是一个用于存储二进制数据的缓冲区，创建时只能传一个空间大小biteLength。</p>\n<p><strong>读写ArrayBuffer的方式：</strong></p>\n<ol>\n<li>TypedArray</li>\n<li>DataView</li>\n<li>TextDecoder</li>\n<li>用Blob存储，然后用FileReader读写</li>\n</ol>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><p>ArrayBuffer提供了一个slice方法用于切片。参数为：开始位置，结束位置和解析类型。</p>\n<h3 id=\"使用：-1\"><a href=\"#使用：-1\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"javascript\">const buffer = new ArrayBuffer(32);\nbuffer.slice(0,4,&#39;text/plain&#39;);\n</code></pre>\n<h1 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h1><p>TypedArray只是一个概念，提供了一种机制来解读ArrayBuffer中的数据（相当于一个视图，将ArrayBuffer中的数据进行展示和操作），实际上是那九个类型对象（每个类型对应一个特定的数据类型和大小）：</p>\n<ul>\n<li><code>Int8Array</code>：8位有符号整数</li>\n<li><code>Uint8Array</code>：8位无符号整数</li>\n<li><code>Int16Array</code>：16位有符号整数</li>\n<li><code>Uint16Array</code>：16位无符号整数</li>\n<li><code>Int32Array</code>：32位有符号整数</li>\n<li><code>Uint32Array</code>：32位无符号整数</li>\n<li><code>Float32Array</code>：32位浮点数</li>\n<li><code>Float64Array</code>：64位浮点数</li>\n</ul>\n<h3 id=\"使用：-2\"><a href=\"#使用：-2\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"javascript\">const buffer = new ArrayBuffer(32);\nconst slice = buffer.slice(0,4,&#39;text/plain&#39;);\nconst sliceView = new Int8Array(slice);\nsliceView.set([10,20,30]);\nsliceView.forEach((value,index)=&gt;&#123;\n    console.log(value,index);\n&#125;)\n</code></pre>\n<h1 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h1><h3 id=\"读取：-1\"><a href=\"#读取：-1\" class=\"headerlink\" title=\"读取：\"></a>读取：</h3><p>DataView数据视图可以用于读写buffer,DataView实例提供了许多方法来读取内存，他们呢的参数都是一个字节序号。表示开始读取的字节位置：</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数</li>\n<li>getUint8：读取1个字节，返回一个无符号8位整数</li>\n<li>getInt16：读取2个字节，返回一个16位整数</li>\n<li>getUnit16：读取2个字节，返回一个无符号16位整数</li>\n<li>getInt32：读取4个字节，返回一个32位整数</li>\n<li>getUnit32：读取4个字节，返回一个无符号32位整数</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数</li>\n<li>getUnit64：读取8个字节，返回一个64位浮点数</li>\n</ul>\n<h3 id=\"写入：\"><a href=\"#写入：\" class=\"headerlink\" title=\"写入：\"></a>写入：</h3><p>DataView实例提供以下方法写入内存，他们都接受两个参数，第一个参数表示开始写入数据的字节序号，第二个参数为写入的数据：</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数</li>\n<li>setUint8：写入1个字节的8位无符号整数</li>\n<li>setInt16：写入2个字节的16位整数</li>\n<li>setUint16：写入2个字节的16位无符号整数</li>\n<li>setInt32：写入4个字节的32位整数</li>\n<li>setUnit32：写入4个字节的32位无符号整数</li>\n<li>setFloat32：写入4个字节的32位浮点数</li>\n<li>setFloat64：写入8个自己的64位浮点数</li>\n</ul>\n<h1 id=\"Object-URL\"><a href=\"#Object-URL\" class=\"headerlink\" title=\"Object URL\"></a>Object URL</h1><p>Object URL是一个用于表示File Object或者Blob Object的URL，可以将<strong>Blob对象（包括File对象）</strong>变为一个URL地址。</p>\n<h3 id=\"使用：-3\"><a href=\"#使用：-3\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p>使用URL.createObjectURL来创建。</p>\n<pre><code class=\"javascript\">const blob = new Blob([&#39;你好世界&#39;],&#123;type:&#39;text/plain&#39;&#125;);\nconst newUrl = URL.createObjectURL(blob);\n</code></pre>\n<h1 id=\"base64编码\"><a href=\"#base64编码\" class=\"headerlink\" title=\"base64编码\"></a>base64编码</h1><h3 id=\"介绍：-3\"><a href=\"#介绍：-3\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>base64是一个保存二进制数据的工具，将多种形式的二进制数据或其构成的文件<strong>以ASCII的形式保存</strong>，因为很多地方不支持直接的二进制文件保存或呈现，比如可以将图片直接转换成base64码嵌入HTML文档中，而避免使用网络http加载图片。另外，将数据编码为 base64 进行传输，然后解码获得数据，可以一定程度上保证数据的完整并且不用在传输过程中修改这些数据，避免在传输过程中可能出现的问题；</p>\n<h3 id=\"组成：\"><a href=\"#组成：\" class=\"headerlink\" title=\"组成：\"></a>组成：</h3><p><code>A-Z a-z 0-9 + /</code> 共64个字符组成;</p>\n<h3 id=\"使用：-4\"><a href=\"#使用：-4\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><p>JS中有两个函数用于base64格式（ASCII码）的转换:</p>\n<ul>\n<li><p>btoa()：编码（Binary To ASCII  二进制转ASCII）</p>\n<p>该函数用于将二进制转为Base64字符串（ASCII码）</p>\n</li>\n<li><p>atob()：解码（ASCII To Binary  ASCII码转二进制）</p>\n<p>该函数用于将Base64字符串（ASCII码）解码为二进制</p>\n</li>\n</ul>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>btoa和atob方法有个弊端就是只能处理拉丁字符集内的字符，其不包括中文或非西欧语言的字符（<strong>只能处理单字节字符</strong>）。要处理多字节字符需要使用TextEncoder API将字符串转为Uint8Array，然后手动将这些字节转为一个字符串（String.fromCharCode）。</p>\n<h1 id=\"TextEncoder\"><a href=\"#TextEncoder\" class=\"headerlink\" title=\"TextEncoder\"></a>TextEncoder</h1><h3 id=\"介绍：-4\"><a href=\"#介绍：-4\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>TextEncoder构造函数创建一个编码器，encode方法用于将字符串编码为一个UTF-8编码文本的Uint8Array视图。</p>\n<h3 id=\"使用：-5\"><a href=\"#使用：-5\" class=\"headerlink\" title=\"使用：\"></a>使用：</h3><pre><code class=\"javascript\">const encoder = new TextEncoder();\nconst view = encoder.encode(&quot;$&quot;);\nconsole.log(view)\n</code></pre>\n","categories":["Blob"],"tags":["Blob","FileReader"]},{"title":"ES6","url":"/2023/08/02/ES6/","content":"<h2 id=\"ECMAScript-6简介\"><a href=\"#ECMAScript-6简介\" class=\"headerlink\" title=\"ECMAScript 6简介\"></a>ECMAScript 6简介</h2><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n<h2 id=\"let和const命名\"><a href=\"#let和const命名\" class=\"headerlink\" title=\"let和const命名\"></a>let和const命名</h2><h3 id=\"let基本用法-块级作用域\"><a href=\"#let基本用法-块级作用域\" class=\"headerlink\" title=\"let基本用法-块级作用域\"></a>let基本用法-块级作用域</h3><p>在es6中可以使用let声明变量，用法类似于var</p>\n<blockquote>\n<p>⚠️ let声明的变量，只在<code>let</code>命令所在的代码块内有效</p>\n</blockquote>\n<pre><code class=\"javascript\">&#123;\n    let a = 10;\n    var b = 20;\n&#125;\nconsole.log(a); //a is not defined\nconsole.log(b); //20\n \n</code></pre>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p><code>var</code>命令会发生<code>变量提升</code>现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>\n<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定在声明后使用，否则报错</p>\n<pre><code class=\"javascript\">//var的情况\nconsole.log(c);//输出undefined\nvar c = 30;\n\n\n//let的情况\nconsole.log(c);// 报错ReferenceError\nlet c = 30;\n \n</code></pre>\n<h4 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量</p>\n<pre><code class=\"javascript\">let c = 10;\nlet c = 30;\nconsole.log(c); //报错\n\nfunction func(arg) &#123;\n  let arg; // 报错\n&#125;\n \n</code></pre>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>了解的一个名词，说的就是<code>let</code>和<code>const</code>命令声明变量的特征。</p>\n<p>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为<code>暂时性死区</code>(temporal dead zone，简称 TDZ)</p>\n<h3 id=\"为什么需要块级作用域？\"><a href=\"#为什么需要块级作用域？\" class=\"headerlink\" title=\"为什么需要块级作用域？\"></a>为什么需要块级作用域？</h3><h4 id=\"原因一：内层变量可能会覆盖外层变量\"><a href=\"#原因一：内层变量可能会覆盖外层变量\" class=\"headerlink\" title=\"原因一：内层变量可能会覆盖外层变量\"></a>原因一：内层变量可能会覆盖外层变量</h4><pre><code class=\"javascript\">function foo(a)&#123;\n    console.log(a);\n    if(1===2)&#123;\n        var a = &#39;hello 小马哥&#39;;\n    &#125;\n&#125;\nvar a = 10;\nfoo(a);\n \n</code></pre>\n<h4 id=\"原因二：用来计数的循环遍历泄露为全局变量\"><a href=\"#原因二：用来计数的循环遍历泄露为全局变量\" class=\"headerlink\" title=\"原因二：用来计数的循环遍历泄露为全局变量\"></a>原因二：用来计数的循环遍历泄露为全局变量</h4><pre><code class=\"javascript\">var arr = []\nfor(var i = 0; i &lt; 10; i++)&#123;\n    arr[i] = function()&#123;\n        return i;\n    &#125;\n&#125;\nconsole.log(arr[5]());\n \n</code></pre>\n<p>变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，用于变量提升，泄露成了全局变量。</p>\n<p><strong>解决循环计数问题</strong></p>\n<pre><code class=\"javascript\">//解决方式一：使用闭包\nvar arr = []\nfor(var i = 0; i &lt; 10; i++)&#123;\n    arr[i] = (function(n)&#123;\n        \n        return function()&#123;\n            return n;\n        &#125;\n    &#125;)(i)\n&#125;\n//解决方式二：使用let声明i\n\nvar arr = []\nfor(let i = 0; i &lt; 10; i++)&#123;\n    arr[i] = function () &#123;\n        return i;\n    &#125;\n&#125;\n \n</code></pre>\n<h3 id=\"const基本用法-声明只读的常量\"><a href=\"#const基本用法-声明只读的常量\" class=\"headerlink\" title=\"const基本用法-声明只读的常量\"></a>const基本用法-声明只读的常量</h3><p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。对于<code>const</code>来说，只声明不赋值，就会报错。</p>\n<pre><code class=\"javascript\">const a = 10;\na = 20;//报错\n\nconst b; //报错\n \n</code></pre>\n<h3 id=\"与let命令相同点\"><a href=\"#与let命令相同点\" class=\"headerlink\" title=\"与let命令相同点\"></a>与<code>let</code>命令相同点</h3><ul>\n<li>块级作用域</li>\n<li>暂时性死区</li>\n<li>不可重复声明</li>\n</ul>\n<h3 id=\"let和const使用建议\"><a href=\"#let和const使用建议\" class=\"headerlink\" title=\"let和const使用建议\"></a><code>let</code>和<code>const</code>使用建议</h3><blockquote>\n<p>在默认情况下用const,而只有你在知道变量值需要被修改的情况下使用let</p>\n</blockquote>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>传统的 JavaScript 语言，输出模板通常是这样写的</p>\n<pre><code class=\"javascript\">const oBox = document.querySelector(&#39;.box&#39;);\n// 模板字符串\nlet id = 1,name = &#39;小马哥&#39;;\nlet htmlTel = &quot;&lt;ul&gt;&lt;li&gt;&lt;p&gt;id:&quot; + id + &quot;&lt;/p&gt;&lt;p&gt;name:&quot; + name + &quot;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&quot;;\noBox.innerHTML = htmlTel;\n \n</code></pre>\n<p>上面的这种写法相当繁琐不方便,ES6引入了模板字符串解决这个问题</p>\n<pre><code class=\"javascript\">let htmlTel = `&lt;ul&gt;\n    &lt;li&gt;\n    &lt;p&gt;id:$&#123;id&#125;&lt;/p&gt;\n    &lt;p&gt;name:$&#123;name&#125;&lt;/p&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;`;\n \n</code></pre>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>解构赋值是对赋值运算符的一种扩展。它通常针对数组和对象进行操作。</p>\n<blockquote>\n<p>优点：代码书写简洁且易读性高</p>\n</blockquote>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p>在以前，为变量赋值，只能直接指定值</p>\n<pre><code class=\"javascript\">let a = 1;\nlet b = 2;\nlet c = 3;\n \n</code></pre>\n<p>ES6允许我们这样写:</p>\n<pre><code class=\"javascript\">let [a,b,c] = [1,2,3];\n \n</code></pre>\n<blockquote>\n<p>如果解构不成功，变量的值就等于<code>undefined</code></p>\n</blockquote>\n<pre><code class=\"javascript\">let [foo] = [];\nlet [bar, foo] = [1];\n \nfoo`的值都会等于`undefined\n</code></pre>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h3><p>解构可以用于对象</p>\n<pre><code class=\"javascript\">let node = &#123;\n    type:&#39;identifier&#39;,\n    name:&#39;foo&#39;\n&#125;\n\nlet &#123;type,name&#125; = node;\nconsole.log(type,name)//identifier foo\n \n</code></pre>\n<p>对象的解构赋值时，可以对属性忽略和使用剩余运算符</p>\n<pre><code class=\"css\">let obj = &#123;\n    a:&#123;\n        name:&#39;张三&#39;\n    &#125;,\n    b:[],\n    c:&#39;hello world&#39;\n&#125;\n//可忽略 忽略b,c属性\nlet &#123;a&#125; = obj;\n//剩余运算符 使用此法将其它属性展开到一个对象中存储\nlet &#123;a,...res&#125; = obj;\nconsole.log(a,res);\n \n</code></pre>\n<p><strong>默认值</strong></p>\n<pre><code class=\"css\">let &#123;a,b = 10&#125; = &#123;a:20&#125;;\n \n</code></pre>\n<h3 id=\"函数参数解构赋值\"><a href=\"#函数参数解构赋值\" class=\"headerlink\" title=\"函数参数解构赋值\"></a>函数参数解构赋值</h3><p>直接看例子</p>\n<pre><code class=\"javascript\">function add([x, y])&#123;\n  return x + y;\n&#125;\n\nadd([1, 2]); // 3\n \n</code></pre>\n<p>使用默认值</p>\n<pre><code class=\"javascript\">function addCart(n,num=0)&#123;\n    \n    return n+num;\n&#125;\naddCart(10);//10\naddCart(10,20); //30\n \n</code></pre>\n<h3 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h3><ul>\n<li><p>交换变量的值</p>\n<pre><code class=\"javascript\">let x = 1;\nlet y = 2;\nlet [x,y] = [y,x];\n \n</code></pre>\n<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n</li>\n<li><p>从函数返回多个值</p>\n<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>\n<pre><code class=\"javascript\">// 返回一个数组\n\nfunction example() &#123;\n  return [1, 2, 3];\n&#125;\nlet [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() &#123;\n  return &#123;\n    foo: 1,\n    bar: 2\n  &#125;;\n&#125;\nlet &#123; foo, bar &#125; = example();\n \n</code></pre>\n</li>\n<li><p>函数参数的定义</p>\n<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<pre><code class=\"javascript\">// 参数是一组有次序的值\nfunction f([x, y, z]) &#123; ... &#125;\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f(&#123;x, y, z&#125;) &#123; ... &#125;\nf(&#123;z: 3, y: 2, x: 1&#125;);\n \n</code></pre>\n</li>\n<li><p>提取JSON数据</p>\n<p>解构赋值对提取 JSON 对象中的数据，尤其有用</p>\n<pre><code class=\"typescript\">let jsonData = &#123;\n  id: 42,\n  status: &quot;OK&quot;,\n  data: [867, 5309]\n&#125;;\n\nlet &#123; id, status, data: number &#125; = jsonData;\n//对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者\nconsole.log(id, status, number);\n// 42, &quot;OK&quot;, [867, 5309]\n \n</code></pre>\n</li>\n<li><p>函数参数的默认值</p>\n</li>\n<li><p>输入模块的指定方法</p>\n<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>\n<pre><code class=\"scss\">const &#123;ajax&#125; = require(&#39;xxx&#39;)\n\najax()\n \n</code></pre>\n</li>\n</ul>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h2><h3 id=\"带参数默认值的函数\"><a href=\"#带参数默认值的函数\" class=\"headerlink\" title=\"带参数默认值的函数\"></a>带参数默认值的函数</h3><p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法</p>\n<pre><code class=\"javascript\">function log(x,y)&#123;\n    y = y || &#39;world&#39;;\n    console.log(x,y);\n&#125;\nlog(&#39;hello&#39;);//hello world\nlog(&#39;hello&#39;,&#39;china&#39;) //hello china\nlog(&#39;hello&#39;,&#39;&#39;)//hello world\n \n</code></pre>\n<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<pre><code class=\"js\">function log(x, y = &#39;World&#39;) &#123;\n  console.log(x, y);\n&#125;\n\nlog(&#39;Hello&#39;) // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China\nlog(&#39;Hello&#39;, &#39;&#39;) // Hello\n \n</code></pre>\n<blockquote>\n<p>ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>\n</blockquote>\n<p><strong>默认的表达式可以是一个函数</strong></p>\n<pre><code class=\"javascript\">function getVal(val) &#123;\n    return val + 5;\n&#125;\nfunction add2(a, b = getVal(5)) &#123;\n    return a + b;\n&#125;\nconsole.log(add2(10));\n \n</code></pre>\n<p><strong>小练习</strong></p>\n<p>请问下面两种写法有什么区别？</p>\n<pre><code class=\"javascript\">// 写法一\nfunction m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;\n  return [x, y];\n&#125;\n\n// 写法二\nfunction m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;\n  return [x, y];\n&#125;\n \n</code></pre>\n<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>\n<pre><code class=\"scss\">// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x 和 y 都有值的情况\nm1(&#123;x: 3, y: 8&#125;) // [3, 8]\nm2(&#123;x: 3, y: 8&#125;) // [3, 8]\n\n// x 有值，y 无值的情况\nm1(&#123;x: 3&#125;) // [3, 0]\nm2(&#123;x: 3&#125;) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1(&#123;&#125;) // [0, 0];\nm2(&#123;&#125;) // [undefined, undefined]\n\nm1(&#123;z: 3&#125;) // [0, 0]\nm2(&#123;z: 3&#125;) // [undefined, undefined]\n \n</code></pre>\n<h3 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h3><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<pre><code class=\"javascript\">function add(...values) &#123;\n \n  let sum = 0;\n\n  for (var val of values) &#123;\n    sum += val;\n  &#125;\n\n  return sum;\n&#125;\n\nadd(2, 5, 3) // 10\n \n</code></pre>\n<p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数 ***\"></a>箭头函数 ***</h3><p>ES6允许使用箭头<code>=&gt;</code>定义函数</p>\n<pre><code class=\"javascript\">let f = v=&gt;v;\n//等同于\nlet f = function(v)&#123;\n    return v;\n&#125;\n\n// 有一个参数\nlet add = value =&gt; value;\n\n// 有两个参数\nlet add = (value,value2) =&gt; value + value2;\n\nlet add = (value1,value2)=&gt;&#123;\n    \n    return value1 + value2;\n&#125; \n// 无参数\nlet fn = () =&gt; &quot;hello world&quot;;\n\nlet doThing = () =&gt; &#123;\n\n&#125;\n//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\nlet getId = id =&gt; (&#123;id: id,name: &#39;mjj&#39;&#125;) //注意\nlet obj = getId(1);\n \n</code></pre>\n<h3 id=\"箭头函数的作用\"><a href=\"#箭头函数的作用\" class=\"headerlink\" title=\"箭头函数的作用\"></a>箭头函数的作用</h3><ul>\n<li><p>使表达更加简洁</p>\n<pre><code class=\"javascript\">const isEven = n =&gt; n % 2 == 0;\nconst square = n =&gt; n * n;\n \n</code></pre>\n</li>\n<li><p>简化回调函数</p>\n<pre><code class=\"ini\">// 正常函数写法\n[1,2,3].map(function (x) &#123;\n  return x * x;\n&#125;);\n\n// 箭头函数写法\n[1,2,3].map(x =&gt; x * x);\n \n</code></pre>\n</li>\n</ul>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><ul>\n<li><p>没有this绑定</p>\n<pre><code class=\"javascript\">let PageHandler = &#123;\n    id:123,\n    init:function()&#123;\n        document.addEventListener(&#39;click&#39;,function(event) &#123;\n            this.doSomeThings(event.type);\n        &#125;,false);\n    &#125;,\n    doSomeThings:function(type)&#123;\n        console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`);\n    &#125;\n&#125;\nPageHandler.init();\n\n//解决this指向问题\nlet PageHandler = &#123;\n    id: 123,\n    init: function () &#123;\n        // 使用bind来改变内部函数this的指向\n        document.addEventListener(&#39;click&#39;, function (event) &#123;\n            this.doSomeThings(event.type);\n        &#125;.bind(this), false);\n    &#125;,\n    doSomeThings: function (type) &#123;\n        console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`);\n    &#125;\n&#125;\nPageHandler.init();\n\nlet PageHandler = &#123;\n    id: 123,\n    init: function () &#123;\n        // 箭头函数没有this的指向，箭头函数内部的this值只能通过查找作用域链来确定\n\n        // 如果箭头函数被一个非箭头函数所包括，那么this的值与该函数的所属对象相等，否则 则是全局的window对象\n        document.addEventListener(&#39;click&#39;, (event) =&gt; &#123;\n            console.log(this);\n            this.doSomeThings(event.type);\n        &#125;, false);\n    &#125;,\n    doSomeThings: function (type) &#123;\n        console.log(`事件类型:$&#123;type&#125;,当前id:$&#123;this.id&#125;`);\n    &#125;\n&#125;\nPageHandler.init();\n \n</code></pre>\n</li>\n<li><p>箭头函数中没有arguments对象</p>\n<pre><code class=\"javascript\">var getVal = (a,b) =&gt; &#123;\n    console.log(arguments);\n    return a + b;\n&#125;\nconsole.log(getVal(1,2)); //arguments is not defined\n \n</code></pre>\n</li>\n<li><p>箭头函数不能使用new关键字来实例化对象</p>\n<pre><code class=\"ini\">let Person = ()=&gt;&#123;&#125;\nlet p1 = new Person();// Person is not a constructor\n \n</code></pre>\n</li>\n</ul>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h2><h3 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h3><pre><code class=\"javascript\">const name = &#39;张三&#39;;\nconst age = 19;\nconst person = &#123;\n    name, //等同于name:name\n    age,\n    // 方法也可以简写\n    sayName() &#123;\n        console.log(this.name);\n    &#125;\n&#125;\nperson.sayName();\n</code></pre>\n<p>这种写法用于函数的返回值，将会非常方便。</p>\n<pre><code class=\"ini\">function getPoint() &#123;\n  const x = 1;\n  const y = 10;\n  return &#123;x, y&#125;;\n&#125;\n\ngetPoint()\n// &#123;x:1, y:10&#125;\n \n</code></pre>\n<h4 id=\"对象扩展运算符\"><a href=\"#对象扩展运算符\" class=\"headerlink\" title=\"对象扩展运算符\"></a>对象扩展运算符</h4><pre><code class=\"less\">const [a, ...b] = [1, 2, 3];\na // 1\nb // [2, 3]\n \n</code></pre>\n<h4 id=\"解构赋值-1\"><a href=\"#解构赋值-1\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n<pre><code class=\"yaml\">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;\nx // 1\ny // 2\nz // &#123; a: 3, b: 4 &#125;\n \n</code></pre>\n<blockquote>\n<p>解构赋值必须是最后一个参数，否则会报错</p>\n<pre><code class=\"csharp\">let &#123; ...x, y, z &#125; = obj; // 句法错误\nlet &#123; x, ...y, ...z &#125; = obj; // 句法错误\n \n</code></pre>\n</blockquote>\n<h3 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h3><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<pre><code class=\"ini\">let z = &#123; a: 3, b: 4 &#125;;\nlet n = &#123; ...z &#125;;\nn // &#123; a: 3, b: 4 &#125;\n \n</code></pre>\n<p>扩展运算符可以用于合并两个对象。</p>\n<pre><code class=\"ini\">let ab = &#123; ...a, ...b &#125;;\n// 等同于\nlet ab = Object.assign(&#123;&#125;, a, b);\n \n</code></pre>\n<h2 id=\"Promise-对象\"><a href=\"#Promise-对象\" class=\"headerlink\" title=\"Promise 对象\"></a>Promise 对象</h2><p>异步编程模块在前端开发中，显得越来越重要。从最开始的XHR到封装后的Ajax都在试图解决异步编程过程中的问题。随着ES6新标准的到来，处理异步数据流又有了新的解决方案。在传统的ajax请求中，当异步请求之间的数据存在依赖关系的时候，就可能产生不优雅的多层回调，俗称”回调地域“(callback hell)，这却让人望而生畏，Promise的出现让我们告别回调地域，写出更优雅的异步代码。</p>\n<p>回调地狱带来的负面作用有以下几点：</p>\n<ul>\n<li>代码臃肿。</li>\n<li>可读性差。</li>\n<li>耦合度过高，可维护性差。</li>\n<li>代码复用性差。</li>\n<li>容易滋生 bug。</li>\n<li>只能在回调里处理异常。</li>\n</ul>\n<blockquote>\n<p>在实践过程中，却发现Promise并不完美，Async&#x2F;Await是近年来JavaScript添加的最革命性的的特性之一，<strong>Async&#x2F;Await提供了一种使得异步代码看起来像同步代码的替代方法</strong>。接下来我们介绍这两种处理异步编程的方案。</p>\n</blockquote>\n<h3 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h3><blockquote>\n<p>Promise 是异步编程的一种解决方案：</p>\n<p>从语法上讲，Promise是一个对象，通过它可以获取异步操作的消息；</p>\n<p>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>\n<p>promise有三种<strong>状态</strong>：**pending(等待态)，fulfilled(成功态)，rejected(失败态)**；</p>\n<p>状态一旦改变，就不会再变。</p>\n<p>创造promise实例后，它会立即执行。</p>\n</blockquote>\n<p>看段习以为常的代码：</p>\n<pre><code class=\"javascript\">// Promise是一个构造函数，自己身上有all,reject,resolve,race方法，原型上有then、catch等方法\nlet p = new Promise((resolve,reject)=&gt;&#123;\n    // 做一些异步操作\n    setTimeout(()=&gt;&#123;\n    /* \tlet res = &#123;\n            ok:1,\n            data:&#123;\n                name:&quot;张三&quot;\n            &#125;\n        &#125; */\n        let res = &#123;\n            ok:0,\n            error:new Error(&#39;有错&#39;)\n        &#125;\n        if(res.ok === 1)&#123;\n            resolve(res.data);\n        &#125;else&#123;\n            reject(res.error.message)\n        &#125;\n\n    &#125;, 1000)\n&#125;)\n\n \n</code></pre>\n<h3 id=\"Promise的状态和值\"><a href=\"#Promise的状态和值\" class=\"headerlink\" title=\"Promise的状态和值\"></a>Promise的状态和值</h3><p><code>Promise</code>对象存在以下三种状态</p>\n<ul>\n<li>Pending(进行中)</li>\n<li>Fulfilled(已成功)</li>\n<li>Rejected(已失败)</li>\n</ul>\n<blockquote>\n<p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或由 <code>Pending</code> 变为 <code>Rejected</code> ，且状态改变之后不会在发生变化，会一直保持这个状态。</p>\n</blockquote>\n<p><code>Promise</code>的值是指状态改变时传递给回调函数的值</p>\n<p>上面例子中的参数为resolve和reject，他们都是函数，用他们可以改变Promise的状态和传入的Promise的值</p>\n<pre><code>resolve` 和 `reject\n</code></pre>\n<ul>\n<li><code>resolve</code> : 将Promise对象的状态从 <code>Pending(进行中)</code> 变为 <code>Fulfilled(已成功)</code></li>\n<li><code>reject</code> : 将Promise对象的状态从 <code>Pending(进行中)</code> 变为 <code>Rejected(已失败)</code></li>\n<li><code>resolve</code> 和 <code>reject</code> 都可以传入任意类型的值作为实参，表示 <code>Promise</code> 对象成功<code>（Fulfilled）</code>和失败<code>（Rejected）</code>的值</li>\n</ul>\n<h3 id=\"then方法\"><a href=\"#then方法\" class=\"headerlink\" title=\"then方法\"></a>then方法</h3><pre><code class=\"javascript\">p.then((data)=&gt;&#123;\n    console.log(data);\n    return data;\n&#125;,(error)=&gt;&#123;\n    console.log(error)\n&#125;).then(data=&gt;&#123;\n    console.log(data);\n&#125;)\n \n</code></pre>\n<p>promise的then方法返回一个promise对象，所以可以继续链式调用</p>\n<p>上述代码我们可以继续改造，因为上述代码不能传参</p>\n<pre><code class=\"javascript\">function timeout(ms) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(&#39;hello world&#39;)\n        &#125;, ms);\n    &#125;)\n&#125;\ntimeout(1000).then((value) =&gt; &#123;\n    console.log(value);\n&#125;)\n \n</code></pre>\n<h3 id=\"then方法的规则\"><a href=\"#then方法的规则\" class=\"headerlink\" title=\"then方法的规则\"></a>then方法的规则</h3><ul>\n<li><code>then</code>方法下一次的输入需要上一次的输出</li>\n<li>如果一个promise执行完后 返回的还是一个promise，会把这个promise 的执行结果，传递给下一次<code>then</code>中</li>\n<li>如果<code>then</code>中返回的不是Promise对象而是一个普通值，则会将这个结果作为下次then的成功的结果</li>\n<li>如果当前<code>then</code>中失败了 会走下一个<code>then</code>的失败</li>\n<li>如果返回的是undefined 不管当前是成功还是失败 都会走下一次的成功</li>\n<li>catch是错误没有处理的情况下才会走</li>\n<li><code>then</code>中不写方法则值会穿透，传入下一个<code>then</code>中</li>\n</ul>\n<h3 id=\"Promise封装XHR对象\"><a href=\"#Promise封装XHR对象\" class=\"headerlink\" title=\"Promise封装XHR对象\"></a>Promise封装XHR对象</h3><pre><code class=\"javascript\">const getJSON = function (url) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        const xhr = new XMLHttpRequest();\n        xhr.open(&#39;GET&#39;, url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = &#39;json&#39;;\n        xhr.setRequestHeader(&#39;Accept&#39;, &#39;application/json&#39;);\n        xhr.send();\n        function handler() &#123;\n            console.log(this.readyState);\n            if (this.readyState !== 4) &#123;\n                return;\n            &#125;\n            if (this.status === 200) &#123;\n                resolve(this.response);\n            &#125; else &#123;\n                reject(new Error(this.statusText));\n            &#125;\n        &#125;\n    &#125;)\n&#125;\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((res) =&gt; &#123;\n    console.log(res);\n\n&#125;, function (error) &#123;\n    console.error(error);\n\n&#125;)\n\n//then方法的链式调用\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((res)=&gt;&#123;\n    return res.HeWeather6;\n&#125;).then((HeWeather6)=&gt;&#123;\n    console.log(HeWeather6);\n&#125;)\n \n</code></pre>\n<h3 id=\"catch方法\"><a href=\"#catch方法\" class=\"headerlink\" title=\"catch方法\"></a>catch方法</h3><blockquote>\n<p>then里面第二个参数捕捉错误只能捕捉上级的 不能捕捉同级的第一个参数里的错误 所以要用catch</p>\n</blockquote>\n<pre><code>catch(err=&gt;&#123;&#125;)`方法等价于`then(null,err=&gt;&#123;&#125;)\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((json) =&gt; &#123;\n    console.log(json);\n&#125;).then(null,err=&gt;&#123;\n    console.log(err);   \n&#125;)\n//等价于\ngetJSON(&#39;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#39;)\n    .then((json) =&gt; &#123;\n    console.log(json);\n&#125;).catch(err=&gt;&#123;\n    console.log(err);   \n&#125;)\n \n</code></pre>\n<h3 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve()\"></a>resolve()</h3><p><code>resolve()</code>方法将现有对象转换成Promise对象，该实例的状态为fulfilled</p>\n<pre><code class=\"javascript\">let p = Promise.resolve(&#39;foo&#39;);\n//等价于 new Promise(resolve=&gt;resolve(&#39;foo&#39;));\np.then((val)=&gt;&#123;\n    console.log(val);\n&#125;)\n \n</code></pre>\n<h3 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject()\"></a>reject()</h3><p><code>reject()</code>方法返回一个新的Promise实例，该实例的状态为rejected</p>\n<pre><code class=\"javascript\">let p2 = Promise.reject(new Error(&#39;出错了&#39;));\n//等价于 let p2 = new Promise((resolve,reject)=&gt;reject(new Error(&#39;出错了)));\np2.catch(err =&gt; &#123;\n    console.log(err);\n&#125;)\n \n</code></pre>\n<h3 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all()方法\"></a>all()方法</h3><p>all()方法提供了并行执行异步操作的能力，并且再所有异步操作执行完后才执行回调</p>\n<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all实现如下</p>\n<pre><code class=\"javascript\">let meInfoPro = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 500, &#39;P1&#39;);\n&#125;);\nlet youInfoPro = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 600, &#39;P2&#39;);\n&#125;);\n// 同时执行p1和p2，并在它们都完成后执行then:\nPromise.all([meInfoPro, youInfoPro]).then( (results)=&gt; &#123;\n    console.log(results); // 获得一个Array: [&#39;P1&#39;, &#39;P2&#39;]\n&#125;);\n</code></pre>\n<h3 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race()方法\"></a>race()方法</h3><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>\n<pre><code class=\"javascript\">let meInfoPro1 = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 500, &#39;P1&#39;);\n&#125;);\nlet meInfoPro2 = new Promise( (resolve, reject)=&gt; &#123;\n    setTimeout(resolve, 600, &#39;P2&#39;);\n&#125;);\nPromise.race([meInfoPro1, meInfoPro2]).then((result)=&gt; &#123;\n    console.log(result); // P1\n&#125;);\n</code></pre>\n<blockquote>\n<p><strong>Promise.all接受一个promise对象的数组，待全部完成之后，统一执行success</strong>;</p>\n<p><strong>Promise.race接受一个包含多个promise对象的数组，只要有一个完成，就执行success</strong></p>\n</blockquote>\n<p>举个更具体的例子，加深对race()方法的理解</p>\n<p>当我们请求某个图片资源，会导致时间过长，给用户反馈</p>\n<p>用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p>\n<pre><code class=\"javascript\">function requestImg(imgSrc) &#123;\n   return new Promise((resolve, reject) =&gt; &#123;\n        var img = new Image();\n        img.onload = function () &#123;\n            resolve(img);\n        &#125;\n        img.src = imgSrc;\n    &#125;);\n&#125;\n//延时函数，用于给请求计时\nfunction timeout() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;图片请求超时&#39;);\n        &#125;, 5000);\n    &#125;);\n&#125;\nPromise.race([requestImg(&#39;images/2.png&#39;), timeout()]).then((data) =&gt; &#123;\n    console.log(data);\n&#125;).catch((err) =&gt; &#123;\n    console.log(err);\n&#125;); \n</code></pre>\n<h2 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h2><p>异步操作是JavaScript编程的麻烦事，很多人认为async函数是异步编程的解决方案</p>\n<p><span style=\"color:red\">async函数执行返回的结果一定是一个promise</span></p>\n<h3 id=\"Async-x2F-await介绍\"><a href=\"#Async-x2F-await介绍\" class=\"headerlink\" title=\"Async&#x2F;await介绍\"></a>Async&#x2F;await介绍</h3><ul>\n<li>async&#x2F;await是写异步代码的新方式，优于回调函数和Promise。</li>\n<li>async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数。</li>\n<li>async&#x2F;await与Promise一样，是非阻塞的。</li>\n<li>async&#x2F;await使得异步代码看起来像同步代码，再也没有回调函数。但是改变不了JS单线程、异步的本质。(<strong>异步代码同步化</strong>)</li>\n</ul>\n<h3 id=\"Async-x2F-await的使用规则\"><a href=\"#Async-x2F-await的使用规则\" class=\"headerlink\" title=\"Async&#x2F;await的使用规则\"></a>Async&#x2F;await的使用规则</h3><ul>\n<li><p><strong>凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象</strong></p>\n<pre><code class=\"javascript\">async function test() &#123;\n    \n&#125;\n\nlet result = test()\nconsole.log(result)  //即便代码里test函数什么都没返回，我们依然打出了Promise对象\n</code></pre>\n</li>\n<li><p><strong>await必须在async函数里使用，不能单独使用</strong></p>\n<pre><code class=\"javascript\">async test() &#123;\n    let result = await Promise.resolve(&#39;success&#39;)\n    console.log(result)\n&#125;\ntest()\n</code></pre>\n</li>\n<li><p><strong>await后面需要跟Promise对象，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数。</strong></p>\n<pre><code class=\"javascript\">function fn() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(&#39;success&#39;)\n        &#125;)\n    &#125;)\n&#125;\n\nasync test() &#123;\n    let result = await fn() //因为fn会返回一个Promise对象\n    console.log(result)    //这里会打出Promise成功后传递过来的&#39;success&#39;\n&#125;\n\ntest()\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Async-x2F-Await的用法\"><a href=\"#Async-x2F-Await的用法\" class=\"headerlink\" title=\"Async&#x2F;Await的用法\"></a>Async&#x2F;Await的用法</h3><ul>\n<li>使用await，函数必须用async标识</li>\n<li>await后面跟的是一个Promise实例，最后返回的是Promise.resolved后的值,不是Promise的话会被封装为一个Promise</li>\n</ul>\n<pre><code class=\"javascript\">function loadImg(src) &#123;\n    const promise = new Promise(function (resolve, reject) &#123;\n        const img = document.createElement(&#39;img&#39;)\n        img.onload = function () &#123;\n            resolve(img)\n        &#125;\n        img.onerror = function () &#123;\n            reject(&#39;图片加载失败&#39;)\n        &#125;\n        img.src = src\n    &#125;)\n    return promise\n&#125;\nconst src1 = &#39;https://hcdn1.luffycity.com/static/frontend/index/banner@2x_1574647618.8112254.png&#39;\nconst src2 = &#39;https://hcdn2.luffycity.com/media/frontend/index/%E7%94%BB%E6%9D%BF.png&#39;\nconst load = async function () &#123;\n    const result1 = await loadImg(src1)\n    console.log(result1)\n    const result2 = await loadImg(src2)\n    console.log(result2)\n&#125;\nload()\n</code></pre>\n<p><strong>当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</strong></p>\n<h3 id=\"async-x2F-await的错误处理\"><a href=\"#async-x2F-await的错误处理\" class=\"headerlink\" title=\"async&#x2F;await的错误处理\"></a>async&#x2F;await的错误处理</h3><p>关于错误处理，如规则三所说，await可以直接获取到后面Promise成功状态传递的参数，但是却捕捉不到失败状态。在这里，我们通过给包裹await的async函数添加then&#x2F;catch方法来解决，因为根据规则一，async函数本身就会返回一个Promise对象。</p>\n<pre><code class=\"javascript\">const load = async function () &#123;\n    try&#123;\n        const result1 = await loadImg(src1)\n        console.log(result1)\n        const result2 = await loadImg(src2)\n        console.log(result2)\n    &#125;catch(err)&#123;\n        console.log(err);\n    &#125;\n&#125;\nload()\n</code></pre>\n<h3 id=\"为什么Async-x2F-Await更好？\"><a href=\"#为什么Async-x2F-Await更好？\" class=\"headerlink\" title=\"为什么Async&#x2F;Await更好？\"></a>为什么Async&#x2F;Await更好？</h3><p>Async&#x2F;Await较Promise有诸多好处，以下介绍其中三种优势：</p>\n<ul>\n<li><p><strong>简洁</strong></p>\n<p>使用Async&#x2F;Await明显节约了不少代码。我们不需要写.then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。</p>\n</li>\n<li><p><strong>中间值</strong></p>\n</li>\n</ul>\n<p>在前端编程中，我们偶尔会遇到这样一个场景：我们需要发送多个请求，而<strong>后面请求的发送总是需要依赖上一个请求返回的数据</strong>。对于这个问题，我们既可以用的Promise的链式调用来解决，也可以用async&#x2F;await来解决，然而后者会更简洁些</p>\n<pre><code class=\"javascript\">const makeRequest = () =&gt; &#123;\n  return promise1()\n    .then(value1 =&gt; &#123;\n      return promise2(value1)\n        .then(value2 =&gt; &#123;        \n          return promise3(value1, value2)\n        &#125;)\n    &#125;)\n&#125;\n</code></pre>\n<p>使用async&#x2F;await的话，代码会变得异常简单和直观</p>\n<pre><code class=\"javascript\">const makeRequest = async () =&gt; &#123;\n  const value1 = await promise1()\n  const value2 = await promise2(value1)\n  return promise3(value1, value2)\n&#125;\n</code></pre>\n<ul>\n<li><strong>提高可读性</strong></li>\n</ul>\n<p>下面示例中，需要获取数据，然后根据返回数据决定是直接返回，还是继续获取更多的数据。</p>\n<pre><code class=\"javascript\">const makeRequest = () =&gt; &#123;\n  return getJSON()\n    .then(data =&gt; &#123;\n      if (data.needsAnotherRequest) &#123;\n        return makeAnotherRequest(data)\n          .then(moreData =&gt; &#123;\n            console.log(moreData)\n            return moreData\n          &#125;)\n      &#125; else &#123;\n        console.log(data)\n        return data\n      &#125;\n    &#125;)\n&#125;\n</code></pre>\n<p>代码嵌套（6层）可读性较差，它们传达的意思只是需要将最终结果传递到最外层的Promise。使用async&#x2F;await编写可以大大地提高可读性:</p>\n<pre><code class=\"javascript\">const makeRequest = async () =&gt; &#123;\n  const data = await getJSON()\n  if (data.needsAnotherRequest) &#123;\n    const moreData = await makeAnotherRequest(data);\n    console.log(moreData)\n    return moreData\n  &#125; else &#123;\n    console.log(data)\n    return data    \n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"Class的基本用法\"><a href=\"#Class的基本用法\" class=\"headerlink\" title=\"Class的基本用法\"></a>Class的基本用法</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>JavaScript语言中，生成实例对象的传统方法是通过构造函数</p>\n<pre><code class=\"javascript\">function Person(name,age) &#123;\n    this.name = name;\n    this.age = age;\n&#125;\nPerson.prototype.sayName  = function() &#123;\n    return this.sayName;\n&#125;\nlet p = new Person(&#39;小马哥&#39;,18);\nconsole.log(p);\n</code></pre>\n<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑</p>\n<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>\n<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样</p>\n<h1 id=\"new关键字补充\"><a href=\"#new关键字补充\" class=\"headerlink\" title=\"new关键字补充\"></a>new关键字补充</h1><blockquote>\n<p>当使用new关键字调用一个构造函数或者类时，会创建一个虚拟上下文，包含new.target指向这个构造函数或者类，当构造完毕后返回构造的实例，并且销毁这个虚拟上下文（不管内部是否引用new.target）。</p>\n</blockquote>\n<h1 id=\"async补充\"><a href=\"#async补充\" class=\"headerlink\" title=\"async补充\"></a>async补充</h1><blockquote>\n<p>async关键字修饰的函数相当于一个语法糖，会将后面跟随的函数进行封装，变为一个返回Promise的函数，也就是说：async修饰的函数的返回值一定是Promise对象。</p>\n</blockquote>\n<h1 id=\"await补充\"><a href=\"#await补充\" class=\"headerlink\" title=\"await补充\"></a>await补充</h1><blockquote>\n<p>await关键字修饰的一定是一个Promise对象，如果不是JS内部会对该值进行封装，封装为一个Promise对象，Promise内部resolve的返回值，就是await修饰后的Promise的返回值，如果Promise内部reject了，就会抛出异常，这时就可以使用try catch进行捕获。</p>\n</blockquote>\n<pre><code class=\"javascript\">class Person &#123;\n    // constructor方法 是类的默认方法,通过new命令生成对象实例时,自动调用该方法,一个类必须有constructor方法,如果没有定义,会被默认添加\n    constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    //等同于Person.prototype = function sayName()&#123;&#125;\n    sayName()&#123;\n        return this.name;\n    &#125;\n&#125;\nconsole.log(Person===Person.prototype.constructor)\n</code></pre>\n<blockquote>\n<p>类的方法内部如果含有<code>this</code>，它默认指向类的实例</p>\n</blockquote>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><pre><code class=\"javascript\">class Animal &#123;\n    constructor(name, age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    sayName()&#123;\n        return this.name;\n    &#125;\n    sayAge()&#123;\n        return this.age;\n    &#125;\n&#125;\n\nclass Dog extends Animal&#123;\n    constructor(name, age,color) &#123;\n          super(name,age);\n        this.color = color;\n    &#125;\n    //子类自己的方法\n    sayColor()&#123;\n        return `$&#123;this.name&#125;是$&#123;this.age&#125;岁了，它的颜色是$&#123;this.color&#125;`;\n    &#125;\n    //重写父类的方法\n    sayName()&#123;\n        return super.sayName() + this.color;\n    &#125;\n&#125;\nlet d1 = new Dog(&#39;小红&#39;,8,&#39;red&#39;);\nconsole.log(d1); //=&gt;Dog &#123;name: &#39;小红&#39;, age: 8, color: &#39;red&#39;&#125;\nconsole.log(d1.sayName()); //=&gt;&#39;小红&#39;\nconsole.log(d1.sayColor());//=&gt;&#39;小红是8岁了，它的颜色是red&#39;\nconsole.log(d1.sayName()); //=&gt;&#39;小红red&#39;\n</code></pre>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><h2 id=\"Module-模块化\"><a href=\"#Module-模块化\" class=\"headerlink\" title=\"Module 模块化\"></a>Module 模块化</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<h3 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>\n<pre><code class=\"javascript\">//module/index.js\nexport const name = &#39;zhangsan &#39;;\nexport const age = 18;\nexport const color = &#39;red &#39;;\nexport const sayName = function() &#123;\n    console.log(fristName);\n&#125;\n\n//也可以这样\nconst name = &#39;zhangsan &#39;;\nconst age = 18;\nconst color = &#39;red &#39;;\nconst sayName = function() &#123;\n    console.log(fristName);\n&#125;\nexport &#123;name,age,color,sayName&#125;\n</code></pre>\n<h3 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h3><p><span style=\"color:red\">在一个文件或模块中，export可以导出多个，对应的 import导入加{ }</span></p>\n<p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>\n<pre><code class=\"javascript\">//main.js\nimport &#123;name,age,color,sayName,fn&#125; from &#39;./modules/index.js&#39;;\n</code></pre>\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名</p>\n<pre><code class=\"javascript\">import * as obj from &#39;./modules/index.js&#39;;\nconsole.log(obj);\n</code></pre>\n<h3 id=\"export-default-命令\"><a href=\"#export-default-命令\" class=\"headerlink\" title=\"export default 命令\"></a>export default 命令</h3><p><span style=\"color:red\">export default仅可以导出一个，对应的import导入时候不用加花括号</span></p>\n<p>使用<code>export default</code>命令为模块指定默认输出</p>\n<pre><code class=\"javascript\">//export-default.js\nexport default function()&#123;\n    console.log(&#39;foo&#39;);\n&#125;\n\n//或者写成\nfunction foo() &#123;\n  console.log(&#39;foo&#39;);\n&#125;\n\nexport default foo;\n</code></pre>\n<p>在其它模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字</p>\n<pre><code class=\"javascript\">//import-default.js\nimport customName from &#39;./export-default.js&#39;\ncustomNmae();//foo\n</code></pre>\n<p>如果想在一条import语句中，同事输入默认方法和其他接口，可以写成下面这样</p>\n<pre><code class=\"csharp\">import customName,&#123;add&#125; from &#39;export-default.js&#39;\n</code></pre>\n<p>对应上面<code>export</code>语句如下</p>\n<pre><code class=\"javascript\">//export-default.js\nexport default function()&#123;\n    console.log(&#39;foo&#39;);\n&#125;\n\nexport function add()&#123;\n    console.log(&#39;add&#39;)\n&#125;\n</code></pre>\n<p><code>export default</code>也可以用来输出类。</p>\n<pre><code class=\"javascript\">// MyClass.js\nexport default class Person&#123; ... &#125;\n\n// main.js\nimport Person from &#39;MyClass&#39;;\nlet o = new Person();\n</code></pre>\n<p><span style=\"color:red\">export与export default均可用于导出常量、函数、文件、模块等</span></p>\n","categories":["ES6"],"tags":["JS","ES6"]},{"title":"JS进阶","url":"/2023/08/02/JS/","content":"<h1 id=\"JavaScript-进阶-第1天\"><a href=\"#JavaScript-进阶-第1天\" class=\"headerlink\" title=\"JavaScript 进阶 - 第1天\"></a>JavaScript 进阶 - 第1天</h1><blockquote>\n<p>学习作用域、变量提升、闭包等语言特征，加深对 JavaScript 的理解，掌握变量赋值、函数声明的简洁语法，降低代码的冗余度。</p>\n</blockquote>\n<ul>\n<li>理解作用域对程序执行的影响</li>\n<li>能够分析程序执行的作用域范围</li>\n<li>理解闭包本质，利用闭包创建隔离作用域</li>\n<li>了解什么变量提升及函数提升</li>\n<li>掌握箭头函数、解析剩余参数等简洁语法</li>\n</ul>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><blockquote>\n<p>了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。</p>\n</blockquote>\n<p>作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。</p>\n<h3 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h3><p>局部作用域分为<strong>函数作用域</strong>和<strong>块作用域</strong>。</p>\n<h4 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><p>在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 声明 counter 函数\n  function counter(x, y) &#123;\n    // 函数内部声明的变量\n    const s = x + y\n    console.log(s) // 18\n  &#125;\n  // 设用 counter 函数\n  counter(10, 8)\n  // 访问变量 s\n  console.log(s)// 报错\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>函数内部声明的变量，在函数外部无法被访问</li>\n<li>函数的参数也是函数内部的局部变量</li>\n<li>不同函数内部声明的变量无法互相访问</li>\n<li>函数执行完毕后，函数内部的变量实际被清空了</li>\n</ol>\n<h4 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h4><p>在 JavaScript 中使用 <code>&#123;&#125;</code> 包裹的代码称为<strong>代码块</strong>，代码块内部声明的变量外部将【<code>有可能</code>】无法被访问。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  &#123;\n    // age 只能在该代码块中被访问\n    let age = 18;\n    console.log(age); // 正常\n  &#125;\n  \n  // 超出了 age 的作用域\n  console.log(age) // 报错\n  \n  let flag = true;\n  if(flag) &#123;\n    // str 只能在该代码块中被访问\n    let str = &#39;hello world!&#39;\n    console.log(str); // 正常\n  &#125;\n  \n  // 超出了 age 的作用域\n  console.log(str); // 报错\n  \n  for(let t = 1; t &lt;= 6; t++) &#123;\n    // t 只能在该代码块中被访问\n    console.log(t); // 正常\n  &#125;\n  \n  // 超出了 t 的作用域\n  console.log(t); // 报错\n&lt;/script&gt;\n</code></pre>\n<p>JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 必须要有值\n  const version = &#39;1.0.0&#39;;\n\n  // 不能重新赋值\n  // version = &#39;1.0.1&#39;;\n\n  // 常量值为对象类型\n  const user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  // 不能重新赋值\n  user = &#123;&#125;;\n\n  // 属性和方法允许被修改\n  user.name = &#39;小小明&#39;;\n  user.gender = &#39;男&#39;;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>let</code> 声明的变量会产生块作用域，<code>var</code> 不会产生块作用域</li>\n<li><code>const</code> 声明的常量也会产生块作用域</li>\n<li>不同代码块之间的变量无法互相访问</li>\n<li>推荐使用 <code>let</code> 或 <code>const</code></li>\n</ol>\n<p>注：开发中 <code>let</code> 和 <code>const</code> 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 <code>const</code> 声明成常量。</p>\n<h3 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h3><p><code>&lt;script&gt;</code> 标签和 <code>.js</code> 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 此处是全局\n  \n  function sayHi() &#123;\n    // 此处为局部\n  &#125;\n\n  // 此处为全局\n&lt;/script&gt;\n</code></pre>\n<p>全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n    // 全局变量 name\n    const name = &#39;小明&#39;\n  \n      // 函数作用域中访问全局\n    function sayHi() &#123;\n      // 此处为局部\n      console.log(&#39;你好&#39; + name)\n    &#125;\n\n    // 全局变量 flag 和 x\n    const flag = true\n    let x = 10\n  \n      // 块作用域中访问全局\n    if(flag) &#123;\n      let y = 5\n      console.log(x + y) // x 是全局的\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p>注意：</p>\n<ol>\n<li>为 <code>window</code> 对象动态添加的属性默认也是全局的，不推荐！</li>\n<li>函数中未使用任何关键字声明的变量为全局变量，不推荐！！！</li>\n<li>尽可能少的声明全局变量，防止全局变量被污染</li>\n</ol>\n<p>JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>在解释什么是作用域链前先来看一段代码：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 全局作用域\n  let a = 1\n  let b = 2\n  // 局部作用域\n  function f() &#123;\n    let c\n    // 局部作用域\n    function g() &#123;\n      let d = &#39;yo&#39;\n    &#125;\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<p>函数内部允许创建新的函数，<code>f</code> 函数内部创建的新函数 <code>g</code>，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。</p>\n<p>如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。</p>\n<p>作用域链本质上是底层的<strong>变量查找机制</strong>，在函数被执行时，会<strong>优先查找当前</strong>函数作用域中查找变量，如果当前作用域查找不到则会依次<strong>逐级查找父级作用域</strong>直到全局作用域，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 全局作用域\n  let a = 1\n  let b = 2\n\n  // 局部作用域\n  function f() &#123;\n    let c\n    // let a = 10;\n    console.log(a) // 1 或 10\n    console.log(d) // 报错\n    \n    // 局部作用域\n    function g() &#123;\n      let d = &#39;yo&#39;\n      // let b = 20;\n      console.log(b) // 2 或 20\n    &#125;\n    \n    // 调用 g 函数\n    g()\n  &#125;\n\n  console.log(c) // 报错\n  console.log(d) // 报错\n  \n  f();\n&lt;/script&gt;\n</code></pre>\n<p><strong>总结</strong>：</p>\n<ol>\n<li>嵌套关系的作用域串联起来形成了作用域链</li>\n<li>相同作用域链中按着从小到大的规则查找变量</li>\n<li>子作用域能够访问父作用域，父级作用域无法访问子级作用域</li>\n</ol>\n<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p>垃圾回收机制 (Garbage Collection) 简称 GC&#96;</p>\n<p>JS中<code>内存</code>的分配和回收都是<code>自动完成</code>的，内存在不使用的时候会被<code>垃圾回收器</code>自动回收</p>\n<ul>\n<li><p><strong>内存的生命周期</strong></p>\n<p>Js 环境中分配的内存，一般有如下<code>生命周期</code></p>\n<ol>\n<li><code>内存分配: </code> 当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</li>\n<li><code>内存使用:  </code>即读写内存，也就是使用变量、函数等</li>\n<li><code>内存回收:  </code>使用完毕，由<code>垃圾回收器</code>自动回收不再使用的内存</li>\n</ol>\n</li>\n<li><p><strong>说明:</strong></p>\n<ul>\n<li>全局变量一般不会回收 (关闭页面回收)</li>\n<li>一般情况下<code>局部变量的值</code>，不用了，会被<code>自动回收</code>掉</li>\n</ul>\n</li>\n<li><p>**内存泄漏: ** 程序中分配的<code>内存</code>由于某种原因程序<code>未释放</code>或<code>无法释放</code>叫做<code>内存泄漏</code></p>\n</li>\n</ul>\n<p>堆栈空间分配的区别:</p>\n<ol>\n<li>栈 (操作系统) :  由<code>操作系统自动分配释放</code>函数的参数值、局部变量等，基本数据类型放到栈里面。</li>\n<li>堆 (操作系统) :  一般由程序员分配释放，若程序员不释放，由<code>垃圾回收机制</code>回收。<code>复杂数据类型</code>放到堆里面。<br>两种常见的浏览器<code>垃圾回收算法</code>  :  <code>引用计数法</code>和<code>标记清除法</code></li>\n</ol>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示：</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 1. 闭包 : 内层函数 + 外层函数变量\n    // function outer() &#123;\n    //   const a = 1\n    //   function f() &#123;\n    //     console.log(a)\n    //   &#125;\n    //   f()\n    // &#125;\n    // outer()\n\n    // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数\n    // let count = 1\n    // function fn() &#123;\n    //   count++\n    //   console.log(`函数被调用$&#123;count&#125;次`)\n    // &#125;\n\n    // 3. 闭包的写法  统计函数的调用次数\n    function outer() &#123;\n      let count = 1\n      function fn() &#123;\n        count++\n        console.log(`函数被调用$&#123;count&#125;次`)\n      &#125;\n      return fn\n    &#125;\n    const re = outer()\n    // const re = function fn() &#123;\n    //   count++\n    //   console.log(`函数被调用$&#123;count&#125;次`)\n    // &#125;\n    re()\n    re()\n    // const fn = function() &#123; &#125;  函数表达式\n    // 4. 闭包存在的问题： 可能会造成内存泄漏\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>总结：</p>\n<p>1.怎么理解闭包？</p>\n<ul>\n<li><strong>闭包 &#x3D; 内层函数 + 外层函数的变量</strong></li>\n</ul>\n<p>2.闭包的作用？</p>\n<ul>\n<li>封闭数据，实现数据私有，外部也可以访问函数内部的变量</li>\n<li>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来</li>\n</ul>\n<p>3.闭包可能引起的问题？</p>\n<ul>\n<li>内存泄漏</li>\n</ul>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问，</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 访问变量 str\n  console.log(str + &#39;world!&#39;);\n\n  // 声明变量 str\n  var str = &#39;hello &#39;;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>变量在未声明即被访问时会报语法错误</li>\n<li>变量在声明之前即被访问，变量的值为 <code>undefined</code></li>\n<li><code>let</code> 声明的变量不存在变量提升，推荐使用 <code>let</code></li>\n<li>变量提升出现在相同作用域当中</li>\n<li><code>实际开发中推荐先声明再访问变量</code></li>\n</ol>\n<p>注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 <code>let</code> 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMzkxNTkzNQ==\">查阅资料</span>。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><blockquote>\n<p>知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。</p>\n</blockquote>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3><p>函数提升与变量提升比较类似，是指函数在声明之前即可被调用。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 调用函数\n  foo()\n  // 声明函数\n  function foo() &#123;\n    console.log(&#39;声明之前即被调用...&#39;)\n  &#125;\n\n  // 不存在提升现象\n  bar()  // 错误\n  var bar = function () &#123;\n    console.log(&#39;函数表达式不存在提升现象...&#39;)\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>函数提升能够使函数的声明调用更灵活</li>\n<li>函数表达式不存在提升的现象</li>\n<li>函数提升出现在相同作用域当中</li>\n</ol>\n<h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>函数参数的使用细节，能够提升函数应用的灵活度。</p>\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><pre><code class=\"html\">&lt;script&gt;\n  // 设置参数默认值\n  function sayHi(name=&quot;小明&quot;, age=18) &#123;\n    document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`);\n  &#125;\n  // 调用函数\n  sayHi();\n  sayHi(&#39;小红&#39;);\n  sayHi(&#39;小刚&#39;, 21);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>声明函数时为形参赋值即为参数的默认值</li>\n<li>如果参数未自定义默认值时，参数的默认值为 <code>undefined</code></li>\n<li>调用函数时没有传入对应实参时，参数的默认值被当做实参传入</li>\n</ol>\n<h4 id=\"动态参数\"><a href=\"#动态参数\" class=\"headerlink\" title=\"动态参数\"></a>动态参数</h4><p><code>arguments</code> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 求生函数，计算所有参数的和\n  function sum() &#123;\n    // console.log(arguments)\n    let s = 0\n    for(let i = 0; i &lt; arguments.length; i++) &#123;\n      s += arguments[i]\n    &#125;\n    console.log(s)\n  &#125;\n  // 调用求和函数\n  sum(5, 10)// 两个参数\n  sum(1, 2, 4) // 两个参数\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>arguments</code> 是一个伪数组</li>\n<li><code>arguments</code> 的作用是动态获取函数的实参</li>\n</ol>\n<h4 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h4><pre><code class=\"html\">&lt;script&gt;\n  function config(baseURL, ...other) &#123;\n    console.log(baseURL) // 得到 &#39;http://baidu.com&#39;\n    console.log(other)  // other  得到 [&#39;get&#39;, &#39;json&#39;]\n  &#125;\n  // 调用函数\n  config(&#39;http://baidu.com&#39;, &#39;get&#39;, &#39;json&#39;);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>...</code> 是语法符号，置于最末函数形参之前，用于获取多余的实参</li>\n<li>借助 <code>...</code> 获取的剩余实参，是个真数组</li>\n</ol>\n<p><strong>展开运算符</strong> (…)</p>\n<p>说明:</p>\n<ol>\n<li>不会修改原数组</li>\n</ol>\n<pre><code class=\"html\">&lt;script&gt;\n    const arr1 = [1,2,3]\n    // 展开运算符，可以展开数组\n    // console.log(...arr1)\n\n    // ...arr1 === 1,2,3\n    // 1.求数组最大值\n    console.log(Math.max(...arr1))  // 3\n    console.log(Math.min(...arr1))  // 1\n    // 2.合并数组\n    const arr2 = [3,4,5]\n    const arr = [...arr1,...arr2]\n    console.log(arr)  // [1, 2, 3, 3, 4, 5]\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // const fn = function () &#123;\n    //   console.log(123)\n    // &#125;\n    // 1. 箭头函数 基本语法\n    // const fn = () =&gt; &#123;\n    //   console.log(123)\n    // &#125;\n    // fn()\n    // const fn = (x) =&gt; &#123;\n    //   console.log(x)\n    // &#125;\n    // fn(1)\n    // 2. 只有一个形参的时候，可以省略小括号\n    // const fn = x =&gt; &#123;\n    //   console.log(x)\n    // &#125;\n    // fn(1)\n    // // 3. 只有一行代码的时候，我们可以省略大括号\n    // const fn = x =&gt; console.log(x)\n    // fn(1)\n    // 4. 只有一行代码的时候，可以省略return\n    // const fn = x =&gt; x + x\n    // console.log(fn(1))\n    // 5. 箭头函数可以直接返回一个对象\n    // const fn = (uname) =&gt; (&#123; uname: uname &#125;)\n    // console.log(fn(&#39;刘德华&#39;))\n\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>箭头函数属于表达式函数，因此不存在函数提升</li>\n<li>箭头函数只有一个参数时可以省略圆括号 <code>()</code></li>\n<li>箭头函数函数体只有一行代码时可以省略花括号 <code>&#123;&#125;</code>，并自动做为返回值被返回</li>\n</ol>\n<h4 id=\"箭头函数参数\"><a href=\"#箭头函数参数\" class=\"headerlink\" title=\"箭头函数参数\"></a>箭头函数参数</h4><p>箭头函数中没有 <code>arguments</code>，只能使用 <code>...</code> 动态获取实参</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 1. 利用箭头函数来求和\n    const getSum = (...arr) =&gt; &#123;\n      let sum = 0\n      for (let i = 0; i &lt; arr.length; i++) &#123;\n        sum += arr[i]\n      &#125;\n      return sum\n    &#125;\n    const result = getSum(2, 3, 4)\n    console.log(result) // 9\n  &lt;/script&gt;\n</code></pre>\n<h4 id=\"箭头函数-this\"><a href=\"#箭头函数-this\" class=\"headerlink\" title=\"箭头函数 this\"></a>箭头函数 this</h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。</p>\n<pre><code class=\"html\"> &lt;script&gt;\n    // 以前this的指向：  谁调用的这个函数，this 就指向谁\n    // console.log(this)  // window\n    // // 普通函数\n    // function fn() &#123;\n    //   console.log(this)  // window\n    // &#125;\n    // window.fn()\n    // // 对象方法里面的this\n    // const obj = &#123;\n    //   name: &#39;andy&#39;,\n    //   sayHi: function () &#123;\n    //     console.log(this)  // obj\n    //   &#125;\n    // &#125;\n    // obj.sayHi()\n\n    // 2. 箭头函数的this  是上一层作用域的this 指向\n    // const fn = () =&gt; &#123;\n    //   console.log(this)  // window\n    // &#125;\n    // fn()\n    // 对象方法箭头函数 this\n    // const obj = &#123;\n    //   uname: &#39;pink老师&#39;,\n    //   sayHi: () =&gt; &#123;\n    //     console.log(this)  // this 指向谁？ window\n    //   &#125;\n    // &#125;\n    // obj.sayHi()\n\n    const obj = &#123;\n      uname: &#39;pink老师&#39;,\n      sayHi: function () &#123;\n        console.log(this)  // obj\n        let i = 10\n        const count = () =&gt; &#123;\n          console.log(this)  // obj \n        &#125;\n        count()\n      &#125;\n    &#125;\n    obj.sayHi()\n\n  &lt;/script&gt;\n</code></pre>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><blockquote>\n<p>知道解构的语法及分类，使用解构简洁语法快速为变量赋值。</p>\n</blockquote>\n<p>解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。</p>\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><p><strong>数组解构</strong>是将数组的<strong>单元值</strong>快速批量<strong>赋值</strong>给一系列变量的<strong>简洁语法</strong>，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通的数组\n  let arr = [1, 2, 3]\n  // 批量声明变量 a b c \n  // 同时将数组单元值 1 2 3 依次赋值给变量 a b c\n  let [a, b, c] = arr\n  console.log(a); // 1\n  console.log(b); // 2\n  console.log(c); // 3\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>赋值运算符 <code>=</code> 左侧的 <code>[]</code> 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量</li>\n<li>变量的顺序对应数组单元值的位置依次进行赋值操作</li>\n<li>变量的数量大于单元值数量时，多余的变量将被赋值为  <code>undefined</code></li>\n<li>变量的数量小于单元值数量时，可以通过 <code>...</code> 获取剩余单元值，但只能置于最末位</li>\n<li>允许初始化变量的默认值，且只有单元值为 <code>undefined</code> 时默认值才会生效</li>\n</ol>\n<p>注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析</p>\n<h3 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h3><p>对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;;\n  // 批量声明变量 name age\n  // 同时将数组单元值 小明  18 依次赋值给变量 name  age\n  const &#123;name, age&#125; = user\n\n  console.log(name) // 小明\n  console.log(age) // 18\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>赋值运算符 <code>=</code> 左侧的 <code>&#123;&#125;</code> 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量</li>\n<li>对象属性的值将被赋值给与属性名<code>相同的</code>变量</li>\n<li>对象中找不到与变量名一致的属性时变量值为 <code>undefined</code></li>\n<li>允许初始化变量的默认值，属性不存在或单元值为 <code>undefined</code> 时默认值才会生效</li>\n</ol>\n<p>注：支持多维解构赋值</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 1. 这是后台传递过来的数据\n    const msg = &#123;\n      &quot;code&quot;: 200,\n      &quot;msg&quot;: &quot;获取新闻列表成功&quot;,\n      &quot;data&quot;: [\n        &#123;\n          &quot;id&quot;: 1,\n          &quot;title&quot;: &quot;5G商用自己，三大运用商收入下降&quot;,\n          &quot;count&quot;: 58\n        &#125;,\n        &#123;\n          &quot;id&quot;: 2,\n          &quot;title&quot;: &quot;国际媒体头条速览&quot;,\n          &quot;count&quot;: 56\n        &#125;,\n        &#123;\n          &quot;id&quot;: 3,\n          &quot;title&quot;: &quot;乌克兰和俄罗斯持续冲突&quot;,\n          &quot;count&quot;: 1669\n        &#125;,\n\n      ]\n    &#125;\n\n    // 需求1： 请将以上msg对象  采用对象解构的方式 只选出  data 方面后面使用渲染页面\n    // const &#123; data &#125; = msg\n    // console.log(data)\n    // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数\n    // const &#123; data &#125; = msg\n    // msg 虽然很多属性，但是我们利用解构只要 data值\n    function render(&#123; data &#125;) &#123;\n      // const &#123; data &#125; = arr\n      // 我们只要 data 数据\n      // 内部处理\n      console.log(data)\n\n    &#125;\n    render(msg)\n\n    // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData\n    function render(&#123; data: myData &#125;) &#123;\n      // 要求将 获取过来的 data数据 更名为 myData\n      // 内部处理\n      console.log(myData)\n\n    &#125;\n    render(msg)\n\n  &lt;/script&gt;\n</code></pre>\n<h2 id=\"综合案例\"><a href=\"#综合案例\" class=\"headerlink\" title=\"综合案例\"></a>综合案例</h2><h3 id=\"forEach遍历数组\"><a href=\"#forEach遍历数组\" class=\"headerlink\" title=\"forEach遍历数组\"></a>forEach遍历数组</h3><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数</p>\n<p><strong>语法:</strong> </p>\n<pre><code class=\"javascript\">被遍历的数组.forEach(function(当前数组元素,当前元素索引号)&#123;\n    // 函数体\n&#125;)\n</code></pre>\n<blockquote>\n<p>注意：  </p>\n<ol>\n<li><p>forEach 主要是遍历数组</p>\n</li>\n<li><p>参数当前数组元素是必须要写的， 索引号可选。</p>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // forEach 就是遍历  加强版的for循环  适合于遍历数组对象\n    const arr = [&#39;red&#39;, &#39;green&#39;, &#39;pink&#39;]\n    const result = arr.forEach(function (item, index) &#123;\n      console.log(item)  // 数组元素 red  green pink\n      console.log(index) // 索引号\n    &#125;)\n    // console.log(result)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"filter筛选数组\"><a href=\"#filter筛选数组\" class=\"headerlink\" title=\"filter筛选数组\"></a>filter筛选数组</h3><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</p>\n<p>主要使用场景： <code>筛选数组符合条件的元素</code>，<strong>并返回筛选之后元素的新数组</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    const arr = [10, 20, 30]\n    // const newArr = arr.filter(function (item, index) &#123;\n    //   // console.log(item)\n    //   // console.log(index)\n    //   return item &gt;= 20\n    // &#125;)\n    // 返回的符合条件的新数组\n\n    const newArr = arr.filter(item =&gt; item &gt;= 20)\n    console.log(newArr)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h1 id=\"JavaScript-进阶-第2天\"><a href=\"#JavaScript-进阶-第2天\" class=\"headerlink\" title=\"JavaScript 进阶 - 第2天\"></a>JavaScript 进阶 - 第2天</h1><blockquote>\n<p>了解面向对象编程的基础概念及构造函数的作用，体会 JavaScript 一切皆对象的语言特征，掌握常见的对象属性和方法的使用。</p>\n</blockquote>\n<ul>\n<li>了解面向对象编程中的一般概念</li>\n<li>能够基于构造函数创建对象</li>\n<li>理解 JavaScript 中一切皆对象的语言特征</li>\n<li>理解引用对象类型值存储的的特征</li>\n<li>掌握包装类型对象常见方法的使用</li>\n</ul>\n<h2 id=\"深入对象\"><a href=\"#深入对象\" class=\"headerlink\" title=\"深入对象\"></a>深入对象</h2><blockquote>\n<p>了解面向对象的基础概念，能够利用构造函数创建对象。</p>\n</blockquote>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>创建对象有三种方式: </p>\n<p><img data-src=\"/./assets/f5ecf72264886ba2724b6a413d1aee2bf5e148c3.png\" alt=\"/images/image-20230224115719324\"></p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><strong>构造函数</strong>是专门用于创建对象的函数，如果一个函数使用 <code>new</code> 关键字调用，那么这个函数就是构造函数。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 定义函数\n  function foo() &#123;\n    console.log(&#39;通过 new 也能调用函数...&#39;);\n  &#125;\n  // 调用函数\n  new foo;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>使用 <code>new</code> 关键字调用函数的行为被称为<strong>实例化</strong></p>\n</li>\n<li><p>实例化构造函数时没有参数时可以省略 <code>()</code></p>\n</li>\n<li><p>构造函数的返回值即为新创建的对象</p>\n</li>\n<li><p>构造函数内部的 <code>return</code> 返回的值无效！所以不要写return</p>\n</li>\n<li><p><code>new Object()</code>和 <code>new Date()</code>也是实例化构造函数</p>\n</li>\n</ol>\n<p>注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的<strong>首字母大写</strong>。</p>\n<h3 id=\"实例化过程\"><a href=\"#实例化过程\" class=\"headerlink\" title=\"实例化过程\"></a>实例化过程</h3><ol>\n<li>创建新空对象</li>\n<li>构造函数this指向新对象</li>\n<li>执行构造函数代码，修改this，添加新的属性</li>\n<li>返回新对象</li>\n</ol>\n<h3 id=\"实例成员\"><a href=\"#实例成员\" class=\"headerlink\" title=\"实例成员\"></a>实例成员</h3><p>通过构造函数创建的对象称为实例对象，<code>实例对象中</code>的属性和方法称为<code>实例成员</code> (实例属性和实例方法)。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 构造函数\n  function Person() &#123;\n    // 构造函数内部的 this 就是实例对象\n    // 实例对象中动态添加属性\n    this.name = &#39;小明&#39;\n    // 实例对象动态添加方法\n    this.sayHi = function () &#123;\n      console.log(&#39;大家好~&#39;)\n    &#125;\n  &#125;\n  // 实例化，p1 是实例对象\n  // p1 实际就是 构造函数内部的 this\n  const p1 = new Person()\n  console.log(p1)\n  console.log(p1.name) // 访问实例属性\n  p1.sayHi() // 调用实例方法\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>构造函数内部 <code>this</code> 实际上就是实例对象，为其动态添加的属性和方法即为实例成员</li>\n<li>为构造函数传入参数，动态创建结构相同但值不同的对象</li>\n</ol>\n<p>注：构造函数创建的实例对象彼此独立互不影响。</p>\n<h3 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h3><p>在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 构造函数\n  function Person(name, age) &#123;\n    // 省略实例成员\n  &#125;\n  // 静态属性\n  Person.eyes = 2\n  Person.arms = 2\n  // 静态方法\n  Person.walk = function () &#123;\n    console.log(&#39;^_^人都会走路...&#39;)\n    // this 指向 Person\n    console.log(this.eyes)\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li>静态成员指的是添加到构造函数本身的属性和方法</li>\n<li>一般公共特征的属性或方法静态成员设置为静态成员</li>\n<li>静态成员方法中的 <code>this</code> 指向构造函数本身</li>\n</ol>\n<h2 id=\"内置构造函数\"><a href=\"#内置构造函数\" class=\"headerlink\" title=\"内置构造函数\"></a>内置构造函数</h2><blockquote>\n<p>掌握各引用类型和包装类型对象属性和方法的使用。</p>\n</blockquote>\n<p>在 JavaScript 中<strong>最主要</strong>的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。</p>\n<p>在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 <code>Date</code> 就是内置的构造函数。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 实例化\n    let date = new Date();\n  \n  // date 即为实例对象\n  console.log(date);\n&lt;/script&gt;\n</code></pre>\n<p>甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。</p>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p><code>Object</code> 是内置的构造函数，用于创建普通对象。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 通过构造函数创建普通对象\n  const user = new Object(&#123;name: &#39;小明&#39;, age: 15&#125;)\n\n  // 这种方式声明的变量称为【字面量】\n  let student = &#123;name: &#39;杜子腾&#39;, age: 21&#125;\n  \n  // 对象语法简写\n  let name = &#39;小红&#39;;\n  let people = &#123;\n    // 相当于 name: name\n    name,\n    // 相当于 walk: function () &#123;&#125;\n    walk () &#123;\n      console.log(&#39;人都要走路...&#39;);\n    &#125;\n  &#125;\n\n  console.log(student.constructor);\n  console.log(user.constructor);\n  console.log(student instanceof Object);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>推荐使用字面量方式声明对象，而不是 <code>Object</code> 构造函数</p>\n</li>\n<li><p><code>Object.assign</code> 静态方法创建新的对象，经常使用给对象添加属性的场景</p>\n<p><strong>语法</strong>: <code>Object.assign(target, ...sources)</code></p>\n<p><strong>参数:</strong> </p>\n<ul>\n<li><p><code>target</code> 目标对象，接收源对象属性的对象，也是修改后的返回值。</p>\n</li>\n<li><p><code>sources</code> 源对象，包含将被合并的属性。</p>\n</li>\n</ul>\n<p><strong>返回值:</strong> 目标对象</p>\n<pre><code class=\"javascript\">// 拷贝对象 把 o 拷贝给 obj\nconst o = &#123; name: &#39;佩奇&#39;, age: 6 &#125;\nconst obj = &#123;&#125;\nconst newObj = Object.assign(obj, o)\nconsole.log(obj)  // &#123;name: &#39;佩奇&#39;, age: 6&#125;\nconsole.log(newObj)  // &#123;name: &#39;佩奇&#39;, age: 6&#125;\n\n// 给 o 添加属性\nObject.assign(o,&#123; gender: &#39;女&#39; &#125;)\nconsole.log(o)  // &#123;name: &#39;佩奇&#39;, age: 6, gender: &#39;女&#39;&#125;\n\n// 源对象存在目标对象相同的值，则会修改目标对象的该数据\nObject.assign(o,&#123;name:&#39;小猪佩奇&#39;&#125;)\nconsole.log(o) // &#123;name: &#39;小猪佩奇&#39;, age: 6, gender: &#39;女&#39;&#125;\n</code></pre>\n</li>\n<li><p><code>Object.keys</code> 静态方法获取对象中所有属性</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">const o = &#123;uname:&#39;pink&#39;,age:18&#125;\n// 获得所有的属性名\nconsole.log(Object.keys(o))  //=&gt;返回数组 [&#39;uname&#39;, &#39;age&#39;]\n</code></pre>\n<p>  <strong>注意:</strong>  返回的是一个数组</p>\n<ol start=\"4\">\n<li><p><code>Object.values</code> 表态方法获取对象中所有属性值</p>\n<pre><code class=\"javascript\">const o = &#123;uname:&#39;pink&#39;,age:18&#125;\n// 获得所有的属性值\nconsole.log(Object.values(o)) //=&gt;返回数组 [&#39;pink&#39;, 18]\n</code></pre>\n<p><strong>注意:</strong>  返回的是一个数组</p>\n</li>\n</ol>\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p><code>Array</code> 是内置的构造函数，用于创建数组。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 构造函数创建数组\n  let arr = new Array(5, 7, 8);\n\n  // 字面量方式创建数组\n  let list = [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n\n&lt;/script&gt;\n</code></pre>\n<p>数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">作用</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">forEach</td>\n<td align=\"center\"><code>遍历</code>数组</td>\n<td align=\"center\">不返回数组，经常用于<code>查找遍历数组元素</code></td>\n</tr>\n<tr>\n<td align=\"center\">filter</td>\n<td align=\"center\"><code>过滤</code>数组</td>\n<td align=\"center\"><code>返回新数组</code>，返回的是<code>筛选满足条件</code>的数组元素</td>\n</tr>\n<tr>\n<td align=\"center\">map</td>\n<td align=\"center\"><code>迭代</code>数组</td>\n<td align=\"center\"><code>返回新数组，</code>返回的是<code>处理之后</code>的数组元素，想要使用返回的新数组</td>\n</tr>\n<tr>\n<td align=\"center\">reduce</td>\n<td align=\"center\"><code>累计器</code></td>\n<td align=\"center\">返回累计处理的结果，经常用于求和等</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>总结：</p>\n<ol>\n<li><p>推荐使用字面量方式声明数组，而不是 <code>Array</code> 构造函数</p>\n</li>\n<li><p>实例方法 <code>forEach</code> 用于遍历数组，替代 <code>for</code> 循环 (重点)</p>\n</li>\n<li><p>实例方法 <code>filter</code> 过滤数组单元值，生成新数组(重点)</p>\n</li>\n<li><p>实例方法 <code>map</code> 迭代原数组，生成新数组(重点)</p>\n</li>\n<li><p>实例方法 <code>join</code> 数组元素拼接为字符串，返回字符串(重点)</p>\n</li>\n<li><p>实例方法  <code>find</code>  查找元素， 返回符合测试条件的<code>第一个数组元素值</code>，如果没有符合条件的则返回 undefined(重点)</p>\n<pre><code class=\"javascript\">// const arr = [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;]\n// const re = arr.find(function(item)&#123;\n//     return item === &#39;blue&#39;\n// &#125;)\n// console.log(re) //=&gt;blue\n\nconst arr = [\n    &#123;\n        name: &#39;小米&#39;,\n        price: 1999\n    &#125;,\n    &#123;\n        name: &#39;华为&#39;,\n        price: 3999\n    &#125;\n]\n// 找小米 这个对象，并且返回这个对象\nconst mi = arr.find(item =&gt; item.name === &#39;小米&#39;)\nconsole.log(mi) //=&gt;&#123;name: &#39;小米&#39;, price: 1999&#125;\n</code></pre>\n</li>\n<li><p>实例方法<code>every</code> 检测数组所有元素是否都符合指定条件，如果<strong>所有元素</strong>都通过检测返回 true，否则返回 false(重点)</p>\n</li>\n<li><p>实例方法<code>some</code> 检测数组中的元素是否满足指定条件   <strong>如果数组中有</strong>元素满足条件返回 true，否则返回 false</p>\n</li>\n<li><p>实例方法 <code>concat</code>  合并两个数组，返回生成新数组</p>\n</li>\n<li><p>实例方法 <code>sort</code> 对原数组单元值排序</p>\n</li>\n<li><p>实例方法 <code>splice</code> 删除或替换原数组单元</p>\n</li>\n<li><p>实例方法 <code>reverse</code> 反转数组</p>\n</li>\n<li><p>实例方法 <code>findIndex</code>  查找元素的索引值</p>\n</li>\n</ol>\n<p><code>reduce</code></p>\n<ul>\n<li><p><strong>作用</strong>: <code>reduce</code> 返回<code>累计处理的结果</code>，经常用于<code>求和等</code></p>\n</li>\n<li><p><strong>基本语法:</strong> <code>arr.reduce(function()&#123;&#125;, 起始值)</code></p>\n<p><code>arr.reduce(function(上一次值, 当前值)&#123;&#125;, 初始值)</code></p>\n</li>\n<li><p><strong>参数:</strong></p>\n<ol>\n<li>如果<code>有起始值</code>，则把初始值累加到里面</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"javascript\">const arr = [1, 5, 8]\n\n// 1. 没有初始值\nconst total = arr.reduce(function (prev, current) &#123;\n        return prev + current\n&#125;)\nconsole.log(total)  //=&gt;14\n// 2.有初始值\nconst total1 = arr.reduce(function (prev, current) &#123;\n        return prev + current\n&#125;, 10)\nconsole.log(total1) //=&gt;24\n// 3. 箭头函数的写法\nconst total2 = arr.reduce((prev, current) =&gt; prev + current, 10)\nconsole.log(total2) //=&gt;24\n</code></pre>\n<ul>\n<li>reduce 执行过程<ol>\n<li>如果<code>没有起始值</code>，则<code>上一次值以</code>数组的<code>第一个数组元素的值</code></li>\n<li>每一次循环，把<code>返回值</code>给做为 下一次循环的<code>上一次值</code></li>\n<li>如果<code>有起始值</code>，则起始值做为<code>上一次值</code></li>\n</ol>\n</li>\n</ul>\n<p><code>Array.from()</code></p>\n<blockquote>\n<p>把伪数组转换为真数组</p>\n</blockquote>\n<pre><code class=\"javascript\">// Array.from(lis) 把伪数组转换为真数组\nconst lis = document.querySelectorAll(&#39;ul li&#39;)\n// console.log(lis)\n// lis.pop()  //报错\nconst liss = Array.from(lis)\nliss.pop()\nconsole.log(liss)\n</code></pre>\n<h3 id=\"包装类型\"><a href=\"#包装类型\" class=\"headerlink\" title=\"包装类型\"></a>包装类型</h3><p>在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 字符串类型\n  const str = &#39;hello world!&#39;\n     // 统计字符的长度（字符数量）\n  console.log(str.length)\n  \n  // 数值类型\n  const price = 12.345\n  // 保留两位小数\n  price.toFixed(2) // 12.34\n&lt;/script&gt;\n</code></pre>\n<p>之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。</p>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h4><p><code>String</code> 是内置的构造函数，用于创建字符串。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 使用构造函数创建字符串\n  let str = new String(&#39;hello world!&#39;);\n\n  // 字面量创建字符串\n  let str2 = &#39;你好，世界！&#39;;\n\n  // 检测是否属于同一个构造函数\n  console.log(str.constructor === str2.constructor); // true\n  console.log(str instanceof String); // false\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>实例属性 <code>length</code> 用来获取字符串的度长(重点)</p>\n</li>\n<li><p>实例方法 <code>split(&#39;分隔符&#39;)</code> 用来将字符串拆分成数组(重点)</p>\n<pre><code class=\"javascript\">// split 把字符串 转换为 数组  和 join()  相反\nconst str = &#39;pink,red&#39;\nconst arr = str.split(&#39;,&#39;)\nconsole.log(arr)   //=&gt; [&#39;pink&#39;, &#39;red&#39;]\nconst str1 = &#39;2023-2-26&#39;\nconst arr1 = str1.split(&#39;-&#39;)\nconsole.log(arr1)  //=&gt; [&#39;2023&#39;, &#39;2&#39;, &#39;26&#39;]\n</code></pre>\n</li>\n<li><p>实例方法 <code>substring（需要截取的第一个字符的索引[,结束的索引号]）</code> 用于字符串截取(重点)</p>\n<pre><code class=\"javascript\">// 字符串的截取  substring(开始的索引号[,借宿的索引号])\n// 1. 如果省略 结束索引号，默认取到最后\nconst str = &#39;今天又要做核酸了&#39;\nconsole.log(str.substring(5))  //=&gt;核酸了\n// 2. 结束的索引号不包含想要截取的部分\nconsole.log(str.substring(5,6))  //=&gt;核\n</code></pre>\n</li>\n<li><p>实例方法 <code>startsWith(检测字符串[, 检测位置索引号])</code> 检测是否以某字符开头(重点)</p>\n<pre><code class=\"javascript\">// startsWith 判断是不是以某个字符开头\nconst str = &#39;pink老师上课中&#39;\nconsole.log(str.startsWith(&#39;pink&#39;))  //=&gt;true\n</code></pre>\n</li>\n<li><p>实例方法 <code>includes(搜索的字符串[, 检测位置索引号])</code> 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点)</p>\n<pre><code class=\"javascript\">// includes 判断某个字符是不是包含在一个字符里面\nconst str = &#39;我是pink老师&#39;\nconsole.log(str.includes(&#39;pink&#39;)) //=&gt;true\n</code></pre>\n</li>\n<li><p>实例方法 <code>toUpperCase</code> 用于将字母转换成大写</p>\n</li>\n<li><p>实例方法 <code>toLowerCase</code> 用于将就转换成小写</p>\n</li>\n<li><p>实例方法 <code>indexOf</code>  检测是否包含某字符</p>\n</li>\n<li><p>实例方法 <code>endsWith</code> 检测是否以某字符结尾</p>\n</li>\n<li><p>实例方法 <code>replace</code> 用于替换字符串，支持正则匹配</p>\n</li>\n<li><p>实例方法 <code>match</code> 用于查找字符串，支持正则匹配</p>\n</li>\n</ol>\n<p>注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。</p>\n<ul>\n<li>转换为字符串 <code>String()</code>  <code>xxx.toString()</code></li>\n</ul>\n<pre><code class=\"javascript\">const num = 10\nconsole.log(String(num))  //=&gt;&#39;10&#39;\nconsole.log(num.toString()) //=&gt;&#39;10&#39;\n</code></pre>\n<h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h4><p><code>Number</code> 是内置的构造函数，用于创建数值。</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 使用构造函数创建数值\n  let x = new Number(&#39;10&#39;)\n  let y = new Number(5)\n\n  // 字面量创建数值\n  let z = 20\n\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><p>推荐使用字面量方式声明数值，而不是 <code>Number</code> 构造函数</p>\n</li>\n<li><p>实例方法 <code>toFixed</code> 用于设置保留小数位的长度</p>\n<pre><code class=\"javascript\">// 数值类型\nconst price = 12.345\n// 保留2位小数   四舍五入\nconsole.log(price.toFixed(2))   // 12.35\n// toFixed 方法可以让数字指定保留的小数位数\nconst num = 10.123\nconsole.log(num.toFixed()) //=&gt;10\nconst num1 = 10.923\nconsole.log(num1.toFixed()) //=&gt;11\nconsole.log(num1.toFixed(2)) //=&gt;10.92\nconst num2 = 10\nconsole.log(num2.toFixed(2))  //=&gt; 10.00\n</code></pre>\n</li>\n</ol>\n<h1 id=\"JavaScript-进阶-第3天笔记\"><a href=\"#JavaScript-进阶-第3天笔记\" class=\"headerlink\" title=\"JavaScript 进阶 - 第3天笔记\"></a>JavaScript 进阶 - 第3天笔记</h1><blockquote>\n<p>了解构造函数原型对象的语法特征，掌握 JavaScript 中面向对象编程的实现方式，基于面向对象编程思想实现 DOM 操作的封装。</p>\n</blockquote>\n<ul>\n<li>了解面向对象编程的一般特征</li>\n<li>掌握基于构造函数原型对象的逻辑封装</li>\n<li>掌握基于原型对象实现的继承</li>\n<li>理解什么原型链及其作用</li>\n<li>能够处理程序异常提升程序执行的健壮性</li>\n</ul>\n<h2 id=\"编程思想\"><a href=\"#编程思想\" class=\"headerlink\" title=\"编程思想\"></a>编程思想</h2><blockquote>\n<p>学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。</p>\n</blockquote>\n<h3 id=\"面向过程\"><a href=\"#面向过程\" class=\"headerlink\" title=\"面向过程\"></a>面向过程</h3><p><code>面向过程</code>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p>\n<p> 举个栗子：蛋炒饭</p>\n<p><img data-src=\"/./assets/14bda17553a6194cece2f5a77a64de961cf09568.png\" alt=\"67679290689\"></p>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><p><code>面向对象</code>是把事务分解成为一个个对象，然后由对象之间分工与合作。</p>\n<p><img data-src=\"/./assets/e21855e43c8f34c5fea9bad603b6783b6ec7b734.png\" alt=\"67679293032\"></p>\n<p><code>面向对象是以对象功能来划分问题，而不是步骤</code></p>\n<ul>\n<li><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。</p>\n</li>\n<li><p>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p>\n</li>\n<li><p>面向对象的特性：</p>\n<ul>\n<li>封装性</li>\n<li>继承性</li>\n<li>多态性</li>\n</ul>\n<img data-src=\"./assets/50db4fbd7ed6cedec6f0470c957382a5a7c5a6f7.png\" alt=\"image-20230312190436206\" style=\"zoom:67%;\" />\n\n\n\n<p><img data-src=\"/./assets/a5d69da6775129eaeb31b57fd0576ef586fc9c1d.png\" alt=\"/images/image-20230312190839380\"></p>\n</li>\n</ul>\n<h2 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>对比以下通过面向对象的构造函数实现的封装：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n    this.name = &#39;佚名&#39;\n    // 设置名字\n    this.setName = function (name) &#123;\n      this.name = name\n    &#125;\n    // 读取名字\n    this.getName = () =&gt; &#123;\n      console.log(this.name)\n    &#125;\n  &#125;\n\n  // 实例对像，获得了构造函数中封装的所有逻辑\n  let p1 = new Person()\n  p1.setName(&#39;小明&#39;)\n  console.log(p1.name)\n\n  // 实例对象\n  let p2 = new Person()\n  console.log(p2.name)\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li><p>封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p>\n</li>\n<li><p>同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的</p>\n</li>\n</ul>\n<blockquote>\n<p>总结：</p>\n<ol>\n<li>构造函数体现了面向对象的封装特性</li>\n<li>构造函数实例创建的对象彼此独立、互不影响</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p>\n</li>\n<li><p>前面我们学过的构造函数方法很好用，但是 <code>存在浪费内存的问题</code></p>\n</li>\n</ul>\n<h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><blockquote>\n<p>构造函数通过原型分配的函数是所有对象所 <code>共享的</code>。</p>\n</blockquote>\n<ul>\n<li>JavaScript 规定，<code>每一个构造函数都有一个 prototype 属性</code>，指向另一个对象，所以我们也称为原型对象</li>\n<li>这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</li>\n<li><code>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</code></li>\n<li><code>构造函数和原型对象中的this 都指向 实例化的对象</code></li>\n</ul>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n    \n  &#125;\n\n  // 每个函数都有 prototype 属性\n  console.log(Person.prototype)\n&lt;/script&gt;\n</code></pre>\n<p>了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n    // 此处未定义任何方法\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n    \n  // 实例化\n  let p1 = new Person();\n  p1.sayHi(); // 输出结果为 Hi~\n&lt;/script&gt;\n</code></pre>\n<p>构造函数 <code>Person</code> 中未定义任何方法，这时实例对象调用了原型对象中的方法 <code>sayHi</code>，接下来改动一下代码：</p>\n<pre><code class=\"html\">&lt;script&gt;\n    // 1. 公共的属性写到 构造函数里面\n    function Person() &#123;\n        // 此处定义同名方法 sayHi\n        this.sayHi = function () &#123;\n            console.log(&#39;嗨!&#39;);\n        &#125;\n    &#125;\n\n    // 为构造函数的原型对象添加方法\n    // 2. 公共的方法写到原型对象身上\n    Person.prototype.sayHi = function () &#123;\n        console.log(&#39;Hi~&#39;);\n    &#125;\n\n    let p1 = new Person();\n    p1.sayHi(); // 输出结果为 嗨!\n&lt;/script&gt;\n</code></pre>\n<p>构造函数 <code>Person</code> 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 <code>sayHi</code>。</p>\n<p>通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：<strong>当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。</strong></p>\n<pre><code class=\"html\">&lt;script&gt;\n    function Person() &#123;\n    // 此处定义同名方法 sayHi\n    this.sayHi = function () &#123;\n      console.log(&#39;嗨!&#39; + this.name)\n    &#125;\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39; + this.name)\n  &#125;\n  // 在构造函数的原型对象上添加属性\n  Person.prototype.name = &#39;小明&#39;\n\n  let p1 = new Person()\n  p1.sayHi(); // 输出结果为 嗨!\n  \n  let p2 = new Person()\n  p2.sayHi()\n&lt;/script&gt;\n</code></pre>\n<p>总结：<strong>结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。</strong></p>\n<h3 id=\"constructor-属性\"><a href=\"#constructor-属性\" class=\"headerlink\" title=\"constructor 属性\"></a>constructor 属性</h3><p><strong>在哪里？</strong> 每个原型对象里面都有个constructor 属性（constructor 构造函数）</p>\n<p><strong>作用：</strong>该属性<code>指向</code>该原型对象的<code>构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子</code></p>\n<p><img data-src=\"/./assets/10b6985c6b63efeb93ebed57e6af7b5d9ffec8d4.png\" alt=\"/images/image-20230313133307629\"></p>\n<p><strong>使用场景：</strong></p>\n<p>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值.</p>\n<p>但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了</p>\n<p>此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p>\n<pre><code class=\"javascript\">// constructor 单词 构造函数\nfunction Star() &#123;\n\n&#125;\n// Star.prototype.sing = function()&#123;\n//   console.log(&#39;唱歌&#39;)\n// &#125;\n// Star.prototype.dance = function()&#123;\n//   console.log(&#39;跳舞&#39;)\n// &#125;\nconsole.log(Star.prototype)\n\nStar.prototype = &#123;\n  // 重新指回创造这个原型对象的 构造函数\n  constructor: Star,\n  sing: function () &#123;\n    console.log(&#39;唱歌&#39;)\n  &#125;,\n  dance: function () &#123;\n    console.log(&#39;跳舞&#39;)\n  &#125;\n&#125;\nconsole.log(Star.prototype)\n</code></pre>\n<h3 id=\"对象原型\"><a href=\"#对象原型\" class=\"headerlink\" title=\"对象原型\"></a>对象原型</h3><p><img data-src=\"/./assets/184b0e68c0d40752b14cd1dc98a00b23f9c3d0ae.png\" alt=\"/images/image-20230313134524527\"></p>\n<p><code>对象都会有一个属性 </code><strong>proto</strong>&#96;&#96; 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 <code>__proto__</code> 原型的存在。</p>\n<p>注意：</p>\n<ul>\n<li><code>__proto__</code> 是JS非标准属性</li>\n<li>[[prototype]]和<code>__proto__</code>意义相同</li>\n<li>用来表明当前实例对象指向哪个原型对象prototype</li>\n<li><code>__proto__</code>对象原型里面也有一个 constructor属性，<code>指向创建该实例对象的构造函数</code></li>\n</ul>\n<p><img data-src=\"/./assets/b68304e0222a56ad4b7b10a992a782ac66f6e434.png\" alt=\"/images/image-20230313140005994\"></p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><p>继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。</p>\n<p>龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义。</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // 继续抽取   公共的部分放到原型上\n    // const Person1 = &#123;\n    //   eyes: 2,\n    //   head: 1\n    // &#125;\n    // const Person2 = &#123;\n    //   eyes: 2,\n    //   head: 1\n    // &#125;\n    // 构造函数  new 出来的对象 结构一样，但是对象不一样\n    function Person() &#123;\n      this.eyes = 2\n      this.head = 1\n    &#125;\n    // console.log(new Person)\n    // 女人  构造函数   继承  想要 继承 Person\n    function Woman() &#123;\n\n    &#125;\n    // Woman 通过原型来继承 Person\n    // 父构造函数（父类）   子构造函数（子类）\n    // 子类的原型 =  new 父类  \n    Woman.prototype = new Person()   // &#123;eyes: 2, head: 1&#125; \n    // 指回原来的构造函数\n    Woman.prototype.constructor = Woman\n\n    // 给女人添加一个方法  生孩子\n    Woman.prototype.baby = function () &#123;\n      console.log(&#39;宝贝&#39;)\n    &#125;\n    const red = new Woman()\n    console.log(red)\n    // console.log(Woman.prototype)\n    // 男人 构造函数  继承  想要 继承 Person\n    function Man() &#123;\n\n    &#125;\n    // 通过 原型继承 Person\n    Man.prototype = new Person()\n    Man.prototype.constructor = Man\n    const pink = new Man()\n    console.log(pink)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链。<br><img data-src=\"/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"/images/image-20240123164938769\"><br><img data-src=\"/./assets/178d2b04cfc677d701530b37f70eb2925fe1cba0.png\" alt=\"67679338869\"></p>\n<ul>\n<li><p>只要是对象就有<code>__proto__</code>对象原型 指向原型对象</p>\n</li>\n<li><p>只要是原型对象就有<code>constructor</code>指回 创造该原型对象的构造函数</p>\n</li>\n</ul>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    // function Objetc() &#123;&#125;\n    console.log(Object.prototype)\n    console.log(Object.prototype.__proto__)\n\n    function Person() &#123;\n\n    &#125;\n    const ldh = new Person()\n    // console.log(ldh.__proto__ === Person.prototype)\n    // console.log(Person.prototype.__proto__ === Object.prototype)\n    console.log(ldh instanceof Person)\n    console.log(ldh instanceof Object)\n    console.log(ldh instanceof Array)\n    console.log([1, 2, 3] instanceof Array)\n    console.log(Array instanceof Object)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><code>查找规则</code></p>\n<p>① 当访问一个对象的属性（包括方法）时，首先查找这个<code>对象自身</code>有没有该属性。</p>\n<p>② 如果没有就查找它的原型（也就是 <code>__proto__</code>指向的<code> prototype 原型对象</code>）</p>\n<p>③ 如果还没有就查找原型对象的原型（<code>Object的原型对象</code>）</p>\n<p>④ 依此类推一直找到 Object 为止（<code>null</code>）</p>\n<p>⑤ <code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p>\n<p>⑥ 可以使用 <code>instanceof</code> 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>\n<pre><code class=\"javascript\">function Person() &#123;\n\n&#125;\nconst ldh = new Person()\nconsole.log(ldh instanceof Person)  //=&gt;true\nconsole.log(ldh instanceof Object)  //=&gt;true\nconsole.log(ldh instanceof Array)   //=&gt;false\nconsole.log([1, 2, 3] instanceof Array) //=&gt;true\nconsole.log(Array instanceof Object)  //=&gt;true\n</code></pre>\n<p>原型链其实就是一个查找规则，为对象成员查找机制提供一个方向。因为构造函数的 prototype 和其实例的 <code>__proto__</code> 都是指向原型对象的，所以可以通过 <code>__proto__</code> 查找当前的原型对象有没有该属性 ,没有就找原型的原型 , 依次类推一直找到 Object( null ) 为止，这种链式查找过程称之为原型链</p>\n<h1 id=\"JavaScript-进阶-第4天\"><a href=\"#JavaScript-进阶-第4天\" class=\"headerlink\" title=\"JavaScript 进阶 - 第4天\"></a>JavaScript 进阶 - 第4天</h1><h2 id=\"深浅拷贝\"><a href=\"#深浅拷贝\" class=\"headerlink\" title=\"深浅拷贝\"></a>深浅拷贝</h2><h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>首先浅拷贝和深拷贝只针对引用类型</p>\n<p>浅拷贝：拷贝的是地址</p>\n<p><strong>常见方法：</strong></p>\n<ol>\n<li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li>\n<li>拷贝数组：Array.prototype.concat() 或者 […arr]</li>\n</ol>\n<blockquote>\n<p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)</p>\n</blockquote>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>首先浅拷贝和深拷贝只针对引用类型</p>\n<p>深拷贝：拷贝的是对象，不是地址</p>\n<p><strong>常见方法：</strong></p>\n<h6 id=\"通过递归实现深拷贝\"><a href=\"#通过递归实现深拷贝\" class=\"headerlink\" title=\"通过递归实现深拷贝\"></a>通过递归实现深拷贝</h6><h6 id=\"通过JSON-stringify-实现\"><a href=\"#通过JSON-stringify-实现\" class=\"headerlink\" title=\"通过JSON.stringify()实现\"></a>通过JSON.stringify()实现</h6><p>限制和缺点：<br>1 .循环引用： JSON.stringify() 无法处理具有循环引用的对象。如果一个对象的属性直接或间接引<br>用了自身， JSON.stringify() 将抛出一个错误，表示存在循环引用。<br>2 .undefined 、函数和Symbol忽略： JSON.stringify() 不会序列化对象中的 undefined 、函数和<br>Symbol类型的属性。这些属性将被忽略，不会出现在生成的JSON字符串中，单独转换则会返回<br>undefined 。<br>3 .丢失原型链：在对象序列化后，原型链上的属性和方法将丢失。只有对象自身的可枚举属性会被序<br>列化。因此，在反序列化（使用 JSON.parse() ）后，原始对象的原型链信息将不复存在。<br>4 .日期对象处理：当使用 JSON.stringify() 序列化日期对象时，日期对象会被转换为它们的ISO字<br>符串表示形式。在反序列化时，这些日期将被视为普通字符串，而不是日期对象。<br>5 .非数组和非对象的值：对于不是数组或对象的顶层值（例如：字符串、数字、布尔值等），<br>JSON.stringify() 会直接返回其对应的JSON表示，而不会将其包装在对象或数组中。</p>\n<h4 id=\"递归实现深拷贝\"><a href=\"#递归实现深拷贝\" class=\"headerlink\" title=\"递归实现深拷贝\"></a>递归实现深拷贝</h4><p><strong>函数递归：</strong></p>\n<p><code>如果一个函数在内部可以调用其本身，那么这个函数就是递归函数</code></p>\n<ul>\n<li>简单理解:函数内部自己调用自己, 这个函数就是递归函数</li>\n<li>递归函数的作用和循环效果类似</li>\n<li>由于递归很容易发生“栈溢出”错误（stack overflow），所以<code>必须要加退出条件 return</code></li>\n</ul>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o = &#123;&#125;\n    // 拷贝函数\n    function deepCopy(newObj, oldObj) &#123;\n      debugger\n      for (let k in oldObj) &#123;\n        // 处理数组的问题  一定先写数组 在写 对象 不能颠倒\n        if (oldObj[k] instanceof Array) &#123;\n          newObj[k] = []\n          //  newObj[k] 接收 []  hobby\n          //  oldObj[k]   [&#39;乒乓球&#39;, &#39;足球&#39;]\n          deepCopy(newObj[k], oldObj[k])\n        &#125; else if (oldObj[k] instanceof Object) &#123;\n          newObj[k] = &#123;&#125;\n          deepCopy(newObj[k], oldObj[k])\n        &#125;\n        else &#123;\n          //  k  属性名 uname age    oldObj[k]  属性值  18\n          // newObj[k]  === o.uname  给新对象添加属性\n          newObj[k] = oldObj[k]\n        &#125;\n      &#125;\n    &#125;\n    deepCopy(o, obj) // 函数调用  两个参数 o 新对象  obj 旧对象\n    console.log(o)\n    o.age = 20\n    o.hobby[0] = &#39;篮球&#39;\n    o.family.baby = &#39;老pink&#39;\n    console.log(obj)\n    console.log([1, 23] instanceof Object)\n    // 复习\n    // const obj = &#123;\n    //   uname: &#39;pink&#39;,\n    //   age: 18,\n    //   hobby: [&#39;乒乓球&#39;, &#39;足球&#39;]\n    // &#125;\n    // function deepCopy(&#123; &#125;, oldObj) &#123;\n    //   // k 属性名  oldObj[k] 属性值\n    //   for (let k in oldObj) &#123;\n    //     // 处理数组的问题   k 变量\n    //     newObj[k] = oldObj[k]\n    //     // o.uname = &#39;pink&#39;\n    //     // newObj.k  = &#39;pink&#39;\n    //   &#125;\n    // &#125;\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h4 id=\"js库lodash里面cloneDeep内部实现了深拷贝\"><a href=\"#js库lodash里面cloneDeep内部实现了深拷贝\" class=\"headerlink\" title=\"js库lodash里面cloneDeep内部实现了深拷贝\"></a>js库lodash里面cloneDeep内部实现了深拷贝</h4><pre><code class=\"html\">&lt;body&gt;\n  &lt;!-- 先引用 --&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o = _.cloneDeep(obj)\n    console.log(o)\n    o.family.baby = &#39;老pink&#39;\n    console.log(obj)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h4 id=\"H5新增structuredClone\"><a href=\"#H5新增structuredClone\" class=\"headerlink\" title=\"H5新增structuredClone\"></a>H5新增structuredClone</h4><p>结构化克隆解决了该JSON.stringify()技术的许多（尽管不是全部）缺点。结构化克隆可以处理循环依赖，支持许多内置数据类型，并且更健壮且速度更快。<br>但是，它仍然有一些限制：</p>\n<p>原型：如果你使用structuredClone()类实例，你将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。<br>函数：如果你的对象包含函数，它们将被悄悄丢弃。<br>不可克隆：有些值不是结构化可克隆的，尤其是Error、 DOM 节点 和 Function。尝试这样做将引发 DataCloneError 异常。<br>属性描述符：setter和getter(以及类似元数据的功能)不会被复制。例如，如果使用属性描述符将对象标记为只读，则复制后的对象中是可读写(默认配置)。<br>RegExp：RegExp对象的lastIndex字段不会保留。</p>\n<h4 id=\"JSON序列化\"><a href=\"#JSON序列化\" class=\"headerlink\" title=\"JSON序列化\"></a>JSON序列化</h4><pre><code class=\"html\">&lt;body&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    // 把对象转换为 JSON 字符串\n    // console.log(JSON.stringify(obj))\n    const o = JSON.parse(JSON.stringify(obj))\n    console.log(o)\n    o.family.baby = &#39;123&#39;\n    console.log(obj)\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><blockquote>\n<p>了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。</p>\n</blockquote>\n<h3 id=\"throw\"><a href=\"#throw\" class=\"headerlink\" title=\"throw\"></a>throw</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p>\n<p>总结：</p>\n<ol>\n<li>throw 抛出异常信息，程序也会终止执行</li>\n<li>throw 后面跟的是错误提示信息</li>\n<li>Error 对象配合 throw 使用，能够设置更详细的错误信息</li>\n</ol>\n<pre><code class=\"html\">&lt;script&gt;\n  function counter(x, y) &#123;\n\n    if(!x || !y) &#123;\n      // throw &#39;参数不能为空!&#39;;\n      throw new Error(&#39;参数不能为空!&#39;)\n    &#125;\n\n    return x + y\n  &#125;\n\n  counter()\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>throw</code> 抛出异常信息，程序也会终止执行</li>\n<li><code>throw</code> 后面跟的是错误提示信息</li>\n<li><code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息</li>\n</ol>\n<h3 id=\"try-…-catch\"><a href=\"#try-…-catch\" class=\"headerlink\" title=\"try … catch\"></a>try … catch</h3><pre><code class=\"html\">&lt;script&gt;\n   function foo() &#123;\n      try &#123;\n        // 查找 DOM 节点\n        const p = document.querySelector(&#39;.p&#39;)\n        p.style.color = &#39;red&#39;\n      &#125; catch (error) &#123;\n        // 拦截错误，提示浏览器提供的错误信息，但是不中断程序的执行\n        // try 代码段中执行有错误时，会执行 catch 代码段\n        // 查看错误信息\n        console.log(error.message)\n        // 终止代码继续执行\n        return\n\n      &#125;\n      finally &#123;\n          // 不管你程序对不对，一定会执行的代码\n          alert(&#39;执行&#39;)\n      &#125;\n      console.log(&#39;如果出现错误，我的语句不会执行&#39;)\n    &#125;\n    foo()\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>try...catch</code> 用于捕获错误信息</li>\n<li>将预估可能发生错误的代码写在 <code>try</code> 代码段中</li>\n<li>如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li>\n<li><code>finally</code> 不管是否有错误，都会执行</li>\n</ol>\n<h3 id=\"debugger\"><a href=\"#debugger\" class=\"headerlink\" title=\"debugger\"></a>debugger</h3><p>相当于断点调试</p>\n<h2 id=\"处理this\"><a href=\"#处理this\" class=\"headerlink\" title=\"处理this\"></a>处理this</h2><blockquote>\n<p>了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。</p>\n</blockquote>\n<p><code>this</code> 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 <code>this</code> 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 <code>this</code> 默认的取值】情况进行归纳和总结。</p>\n<h3 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h3><p><strong>普通函数</strong>的调用方式决定了 <code>this</code> 的值，即【谁调用 <code>this</code> 的值指向谁】，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)  \n  &#125;\n  // 函数表达式\n  const sayHello = function () &#123;\n    console.log(this)\n  &#125;\n  // 函数的调用方式决定了 this 的值\n  sayHi() // window\n  window.sayHi()\n    \n\n// 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    walk: function () &#123;\n      console.log(this)\n    &#125;\n  &#125;\n  // 动态为 user 添加方法\n  user.sayHi = sayHi\n  uesr.sayHello = sayHello\n  // 函数调用方式，决定了 this 的值\n  user.sayHi()\n  user.sayHello()\n&lt;/script&gt;\n</code></pre>\n<p>注： 普通函数没有明确调用者时 <code>this</code> 值为 <code>window</code>，严格模式下没有调用者时 <code>this</code> 的值为 <code>undefined</code>。</p>\n<h3 id=\"箭头函数-1\"><a href=\"#箭头函数-1\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p><strong>箭头函数</strong>中的 <code>this</code> 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 <code>this</code> ！箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p>\n<ol>\n<li>箭头函数会默认帮我们绑定外层 <code>this</code> 的值，所以在箭头函数中 <code>this</code> 的值和外层的 <code>this</code> 是一样的</li>\n<li>箭头函数中的 <code>this</code> 引用的就是最近作用域中的 <code>this</code></li>\n<li>向外层作用域中，一层一层查找 <code>this</code>，直到有 <code>this</code> 的定义</li>\n</ol>\n<pre><code class=\"html\">&lt;script&gt;\n    \n  console.log(this) // 此处为 window\n  // 箭头函数\n  const sayHi = function() &#123;\n    console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致\n  &#125;\n  // 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    // 该箭头函数中的 this 为函数声明环境中 this 一致\n    walk: () =&gt; &#123;\n      console.log(this)\n    &#125;,\n    \n    sleep: function () &#123;\n      let str = &#39;hello&#39;\n      console.log(this)\n      let fn = () =&gt; &#123;\n        console.log(str)\n        console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致\n      &#125;\n      // 调用箭头函数\n      fn();\n    &#125;\n  &#125;\n\n  // 动态添加方法\n  user.sayHi = sayHi\n  \n  // 函数调用\n  user.sayHi()\n  user.sleep()\n  user.walk()\n&lt;/script&gt;\n</code></pre>\n<p>在开发中【使用箭头函数前需要考虑函数中 <code>this</code> 的值】，<strong>事件回调函数</strong>使用箭头函数时，<code>this</code> 为全局的 <code>window</code>，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // DOM 节点\n  const btn = document.querySelector(&#39;.btn&#39;)\n  // 箭头函数 此时 this 指向了 window\n  btn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    console.log(this)\n  &#125;)\n  // 普通函数 此时 this 指向了 DOM 对象\n  btn.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(this)\n  &#125;)\n&lt;/script&gt;\n</code></pre>\n<p>同样由于箭头函数 <code>this</code> 的原因，<strong>基于原型的面向对象也不推荐采用箭头函数</strong>，如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  function Person() &#123;\n  &#125;\n  // 原型对像上添加了箭头函数\n  Person.prototype.walk = () =&gt; &#123;\n    console.log(&#39;人都要走路...&#39;)\n    console.log(this); // window\n  &#125;\n  const p1 = new Person()\n  p1.walk()\n&lt;/script&gt;\n</code></pre>\n<p><strong>总结:</strong></p>\n<ol>\n<li>函数内不存在 <code>this</code>，沿用上一级的，过程: 向外层作用域中，一层一层查找this，直到有this的定义</li>\n<li>不适用<ul>\n<li>构造函数，原型函数，dom 事件函数等等</li>\n</ul>\n</li>\n<li>适用<ul>\n<li>需要使用上层 <code>this</code> 的地方</li>\n</ul>\n</li>\n<li>使用正确的话，它会在很多地方带来方便，后面我们会大量使用慢慢体会</li>\n</ol>\n<h3 id=\"改变this指向\"><a href=\"#改变this指向\" class=\"headerlink\" title=\"改变this指向\"></a>改变this指向</h3><p>以上归纳了普通函数和箭头函数中关于 <code>this</code> 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 <code>this</code> 的指向，有 3 个方法可以动态指定普通函数中 <code>this</code> 的指向：</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h4><blockquote>\n<p>使用 <code>call</code> 方法调用函数，同时指定函数中 <code>this</code> 的值</p>\n</blockquote>\n<p><strong>语法:</strong> <code>fun.call(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>thisArg: 在 fun 函数运行时指定的 this 值</li>\n<li>arg1，arg2: 传递的其它参数</li>\n<li>返回值就是函数的返回值，因为它就是调用函数</li>\n</ul>\n<p>使用方法如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this);\n  &#125;\n\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student = &#123;\n    name: &#39;小红&#39;,\n    age: 16\n  &#125;\n\n  // 调用函数并指定 this 的值\n  sayHi.call(user); // this 值为 user\n  sayHi.call(student); // this 值为 student\n\n  // 求和函数\n  function counter(x, y) &#123;\n    return x + y;\n  &#125;\n\n  // 调用 counter 函数，并传入参数\n  let result = counter.call(null, 5, 10);\n  console.log(result);\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>call</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>\n<li>使用 <code>call</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>\n<li><code>call</code> 方法的其余参数会依次自动传入函数做为函数的参数</li>\n</ol>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><blockquote>\n<p> 使用 <code>apple</code> 方法<strong>调用函数</strong>，同时指定函数中 <code>this</code> 的值</p>\n</blockquote>\n<p><strong>语法:</strong> <code>fun.apply(thisArg, [argsArray])</code></p>\n<ul>\n<li>thisArg: 在fun函数运行时指定的 <code>this</code> 的值</li>\n<li>argsArray: 传递的值，必须包含在<code>数组</code>里面</li>\n<li>返回值就是函数的返回值，因为它就是调用函数</li>\n<li>因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</li>\n</ul>\n<p>使用方法如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student = &#123;\n    name: &#39;小红&#39;,\n    age: 16\n  &#125;\n\n  // 调用函数并指定 this 的值\n  sayHi.apply(user) // this 值为 user\n  sayHi.apply(student) // this 值为 student\n\n  // 求和函数\n  function counter(x, y) &#123;\n    return x + y\n  &#125;\n  // 调用 counter 函数，并传入参数\n  let result = counter.apply(null, [5, 10])\n  console.log(result)\n&lt;/script&gt;\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>\n<li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>\n<li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li>\n</ol>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h4><blockquote>\n<p><code>bind</code>方法并<strong>不会调用函数</strong>，而是创建一个指定了<code>this</code>值的新函数，能改变函数内部<code>this</code>指向</p>\n</blockquote>\n<p><strong>语法:</strong> <code>fun.bind(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>thisArg: 在 fun 函数运行时指定的 this 值</li>\n<li>arg1，arg2: 传递的其它参数</li>\n<li>返回由指定的 this 值和初始化参数改造的 <code>原函数拷贝 (新函数)</code></li>\n<li>因此当我们只是想改变 this 指向，并不想调用这个函数的时候，可以使用bind，比如改变定时器内部的 this 指向</li>\n</ul>\n<p>使用方法如下代码所示：</p>\n<pre><code class=\"html\">&lt;script&gt;\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n  // 调用 bind 指定 this 的值\n  let sayHello = sayHi.bind(user);\n  // 调用使用 bind 创建的新函数\n  sayHello()\n&lt;/script&gt;\n</code></pre>\n<p>注：<code>bind</code> 方法创建新的函数，与原函数的唯一的变化是改变了 <code>this</code> 的值。</p>\n<h2 id=\"防抖节流\"><a href=\"#防抖节流\" class=\"headerlink\" title=\"防抖节流\"></a>防抖节流</h2><h3 id=\"防抖（debounce）\"><a href=\"#防抖（debounce）\" class=\"headerlink\" title=\"防抖（debounce）\"></a>防抖（debounce）</h3><blockquote>\n<p>单位时间内，频繁触发事件，<code>只执行最后一次</code></p>\n</blockquote>\n<p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</p>\n<p><img data-src=\"/./assets/17e1df201247e0e8932960349141428cedc4a0a3.png\" alt=\"/images/image-20230314171133289\"></p>\n<p><strong>利用lodash实现防抖</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 添加事件\n    // box.addEventListener(&#39;mousemove&#39;, mouseMove)\n\n    // 利用lodash库实现防抖 - 500ms 之后采取 +1\n    // 语法: _.debounce(fun, 时间)\n    box.addEventListener(&#39;mousemove&#39;, _.debounce(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>手写一个防抖函数</strong></p>\n<p><strong>核心思路:</strong> 防抖的核心就是利用定时器(<code>setTimeout</code>)来实现</p>\n<ol>\n<li>声明一个定时器<code>变量</code></li>\n<li>当鼠标每次滑动都先判断<code>是否有定时器</code>了，如果有定时器先<code>清除以前</code>的定时器</li>\n<li>如果没有定时器则<code>开启</code>定时器，记得<code>存到变量</code>里面</li>\n<li>在<code>定时器里面调用</code>要执行的函数</li>\n</ol>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 手写防抖函数\n    // 核心是利用 setTimeout 定时器 来实现\n    // 1. 声明定时器变量\n    // 2. 每次鼠标移动 (事件触发) 的时候要先判断是否有定时器，如果有先清除以前的定时器\n    // 3. 如果没有定时器，则开启定时器，存入到定时器变量里面\n    // 4. 定时器里面写函数调用\n    function debounce(fn, t) &#123;\n      // 1\n      let timer\n      // return 返回一个匿名函数\n      return function () &#123; //=&gt;debounce(mouseMove,500) = function()&#123;&#125;\n        // 2,3,4\n        if (timer) clearTimeout(timer)\n        timer = setTimeout(function () &#123;\n          fn()  // 加小括号调用 fn 函数 \n        &#125;, t)\n      &#125;\n    &#125;\n    box.addEventListener(&#39;mousemove&#39;, debounce(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h3 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h3><blockquote>\n<p>单位时间内，频繁触发事件，<code>只执行一次</code></p>\n</blockquote>\n<p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数</p>\n<img data-src=\"./assets/4e7441c2dccb471fb3909eae14bf976377d82003.png\" alt=\"image-20230314203247627\" style=\"zoom:67%;\" />\n\n<p><strong>利用lodash实现节流</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 添加事件\n    // box.addEventListener(&#39;mousemove&#39;, mouseMove)\n\n    // 利用lodash库实现节流 - 500ms 之后采取 +1\n    // 语法: _.throttle(fun, 时间)\n    box.addEventListener(&#39;mousemove&#39;, _.throttle(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>手写一个节流函数</strong></p>\n<p><strong>核心思路:</strong> 节流的核心就是利用定时器(<code>setTimeout</code>)来实现</p>\n<ol>\n<li>声明一个定时器<code>变量</code></li>\n<li>当鼠标每次滑动都先判断<code>是否有定时器</code>了，如果有定时器则<code>不开启</code>新定时器</li>\n<li>如果没有定时器则<code>开启</code>定时器，记得<code>存到变量</code>里面<ul>\n<li>定时器里面<code>调用</code>执行的函数</li>\n<li>定时器里面要把定时器<code>清空</code></li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 利用防抖实现性能优化\n    // 需求: 鼠标在盒子上移动，里面的数字就会变化 + 1\n    const box = document.querySelector(&#39;.box&#39;)\n    let i = 1\n    function mouseMove() &#123;\n      box.innerHTML = i++\n      // 如果里面存在大量消耗性能的代码，比如 dom 操作，比如数据处理，可能造成卡顿\n\n    &#125;\n    // 手写节流函数\n    // 核心是利用 setTimeout 定时器 来实现\n    // 1. 声明一个定时器变量\n    // 2. 当鼠标每次滑动都先判断是否有定时器了，如果有定时器则不开启新定时器\n    // 3. 如果没有定时器，则开启定时器，记得存到变量里面\n    //    3.1 定时器里面调用执行的函数\n    //    3.2 定时器里面要把定时器清空\n    function throttle(fn, t) &#123;\n      let timer = null\n      // return 返回一个匿名函数\n      return function () &#123; //=&gt;debounce(mouseMove,500) = function()&#123;&#125;\n        // 2,3,4\n        if (!timer) &#123;\n          timer = setTimeout(function () &#123;\n            fn()  // 加小括号调用 fn 函数 \n            // 清空定时器\n            timer = null\n          &#125;, t)\n        &#125;\n      &#125;\n    &#125;\n    box.addEventListener(&#39;mousemove&#39;, throttle(mouseMove, 500))\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img data-src=\"/./assets/6f9421c1f81e9a4f171f98cc467654db79381b38.png\" alt=\"/images/image-20230315000258205\"></p>\n","categories":["JS进阶"],"tags":["JS进阶"]},{"title":"HTTP","url":"/2023/05/02/HTTP/","content":"<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"#目录\"></a>#目录</h1><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h1 id=\"浅学浏览器工作原理\"><a href=\"#浅学浏览器工作原理\" class=\"headerlink\" title=\"浅学浏览器工作原理\"></a>浅学浏览器工作原理</h1><h1 id=\"一、浏览器工作流程概览\"><a href=\"#一、浏览器工作流程概览\" class=\"headerlink\" title=\"一、浏览器工作流程概览\"></a>一、<strong>浏览器工作流程</strong>概览</h1><blockquote>\n<p>•浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；</p>\n<p>•把请求回来的 HTML 代码经过解析，构建成 DOM 树；</p>\n<p>•计算 DOM 树上的 CSS 属性；</p>\n<p>•根据 CSS 属性对元素逐个进行渲染，得到内存中的<code>位图</code>①；</p>\n<p>•一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；</p>\n<p>•合成之后，再绘制到界面上。</p>\n<p><img data-src=\"/images/image-20210621175650437.png\" alt=\"该图来自视频课程截图\"> </p>\n</blockquote>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><blockquote>\n<p>位图，又称为点阵图像、像素图或栅格图像，是由像素（图片元素）的单个点组成。这些点可以进行不同的排列和染色以构成图样。</p>\n<p>位图的单位：像素（Pixel）</p>\n</blockquote>\n<h1 id=\"二、HTTP协议底层原理概览\"><a href=\"#二、HTTP协议底层原理概览\" class=\"headerlink\" title=\"二、HTTP协议底层原理概览\"></a>二、HTTP协议底层原理概览</h1><blockquote>\n<p>Http是基于Tcp协议基础上出现的,HTTP在Tcp基础上规定了Request与Response</p>\n<p>http1标准:</p>\n<ul>\n<li>HTTP1.1 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTY=\">https://tools.ietf.org/html/rfc2616</span></li>\n<li>HTTP1.1 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzQ=\">https://tools.ietf.org/html/rfc7234</span></li>\n</ul>\n<p>http2标准: <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MTg=\">https://tools.ietf.org/html/rfc2818</span></p>\n<p>HTTPS标准: <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MTg=\">https://tools.ietf.org/html/rfc2818</span></p>\n</blockquote>\n<h2 id=\"1-HTTP请求-是一种规则，无状态，无记忆：\"><a href=\"#1-HTTP请求-是一种规则，无状态，无记忆：\" class=\"headerlink\" title=\"1.HTTP请求:是一种规则，无状态，无记忆：\"></a>1.HTTP请求:是一种规则，无状态，无记忆：</h2><h3 id=\"Ⅰ-HTTP请求过程\"><a href=\"#Ⅰ-HTTP请求过程\" class=\"headerlink\" title=\"Ⅰ- HTTP请求过程\"></a>Ⅰ- HTTP请求过程</h3><blockquote>\n<p>（1）建立TCP连接</p>\n<p>（2）web浏览器向web服务器发送请求指令</p>\n<p>（3）web浏览器发送请求头信息</p>\n<p>（4）web服务器应答</p>\n<p>（5）web服务器发送应答头信息</p>\n<p>（6）web服务器向浏览器发送数据</p>\n<p>（7）web服务器关闭TCP连接</p>\n</blockquote>\n<h3 id=\"Ⅱ-HTTP请求的四个组成部分：\"><a href=\"#Ⅱ-HTTP请求的四个组成部分：\" class=\"headerlink\" title=\"Ⅱ- HTTP请求的四个组成部分：\"></a>Ⅱ- HTTP请求的四个组成部分：</h3><blockquote>\n<p> a、HTTP请求方法或者动作(GET&#x2F;POST)</p>\n<p> b、正在请求的URL</p>\n<p> c、请求头，包含客户环境信息、身份信息等</p>\n<p> d、请求体（正文），包含客户提交的查询字符串信息、表单信息</p>\n</blockquote>\n<h3 id=\"Ⅲ-HTTP响应的三个组成部分：\"><a href=\"#Ⅲ-HTTP响应的三个组成部分：\" class=\"headerlink\" title=\"Ⅲ- HTTP响应的三个组成部分：\"></a>Ⅲ- HTTP响应的三个组成部分：</h3><blockquote>\n<p> a、一个数字和文字组成的转态码。作用：显示请求是否成功</p>\n<p> b、响应头，包含服务器类型、日期、内容类型、长度等</p>\n<p> c、响应体，即响应正文，字符串、HTML等 </p>\n</blockquote>\n<h2 id=\"2、HTTP-协议格式\"><a href=\"#2、HTTP-协议格式\" class=\"headerlink\" title=\"2、HTTP 协议格式\"></a>2、<strong>HTTP</strong> <strong>协议格式</strong></h2><blockquote>\n<p><img data-src=\"/images/image-20210622195949961.png\" alt=\"/images//image-20210622195949961\"> </p>\n</blockquote>\n<h3 id=\"Ⅰ-HTTP-Method\"><a href=\"#Ⅰ-HTTP-Method\" class=\"headerlink\" title=\"Ⅰ- HTTP Method\"></a>Ⅰ- <strong>HTTP Method</strong></h3><blockquote>\n<p>GET POST  HEAD PUT  DELETE CONNECT  <code>OPTIONS TRACE(通常这两种是调试时才使用的)</code></p>\n</blockquote>\n<h3 id=\"Ⅱ-HTTP-Status-code\"><a href=\"#Ⅱ-HTTP-Status-code\" class=\"headerlink\" title=\"Ⅱ- HTTP Status code\"></a>Ⅱ- <strong>HTTP Status code</strong></h3><blockquote>\n<p>•1xx：临时回应，表示客户端请继续。</p>\n<p>•2xx：请求成功。 &#x3D;&gt;表示用户请求被正确接收、理解和处理，如200</p>\n<p>•3xx: 表示请求的目标有变化，希望客户端进一步处理。 &#x3D;&gt;做定向使用  如nginx请求转发 再如303前端使用重定向</p>\n<p>•4xx：客户端请求错误。  </p>\n<p>•5xx：服务端请求错误。</p>\n</blockquote>\n<h3 id=\"Ⅲ-HTTP-Head\"><a href=\"#Ⅲ-HTTP-Head\" class=\"headerlink\" title=\"Ⅲ- HTTP Head\"></a>Ⅲ- <strong>HTTP Head</strong></h3><h4 id=\"①-Request-Header\"><a href=\"#①-Request-Header\" class=\"headerlink\" title=\"① Request Header\"></a>① <em>Request Header</em></h4><blockquote>\n<p><img data-src=\"/images/image-20210622202103234.png\" alt=\"/images//image-20210622202103234\"> </p>\n</blockquote>\n<h4 id=\"②-Response-Header\"><a href=\"#②-Response-Header\" class=\"headerlink\" title=\"② Response Header\"></a>② <em>Response Header</em></h4><blockquote>\n<p><img data-src=\"/images/image-20210622202158322.png\" alt=\"/images//image-20210622202158322\"> </p>\n</blockquote>\n<h4 id=\"③-HTTP-Request-Body\"><a href=\"#③-HTTP-Request-Body\" class=\"headerlink\" title=\"③ HTTP Request Body\"></a>③ <em><strong>HTTP Request Body</strong></em></h4><blockquote>\n<p>•application&#x2F;json \t\t\t\t  –&gt;最常用的json格式</p>\n<p>•application&#x2F;x-www-form-urlencoded  –&gt;常用的from表单提交格式</p>\n<p>•multipart&#x2F;form-data   \t\t\t –&gt;常用的文件上传格式</p>\n<p>•text&#x2F;xml               \t\t\t–&gt;常用xml文件格式</p>\n</blockquote>\n<h4 id=\"④-HTTP-head\"><a href=\"#④-HTTP-head\" class=\"headerlink\" title=\"④ HTTP head\"></a>④ <em>HTTP head</em></h4><blockquote>\n<p>略</p>\n</blockquote>\n<h2 id=\"3、OSI模型图\"><a href=\"#3、OSI模型图\" class=\"headerlink\" title=\"3、OSI模型图\"></a>3、OSI模型图</h2><blockquote>\n<p><img data-src=\"/images/image-20210622203341816.png\"> </p>\n</blockquote>\n<h2 id=\"4、数据传输简单基础原理-x3D-gt-服务端-浏览器-POST-GET\"><a href=\"#4、数据传输简单基础原理-x3D-gt-服务端-浏览器-POST-GET\" class=\"headerlink\" title=\"4、数据传输简单基础原理&#x3D;&gt;(服务端,浏览器,POST,GET)\"></a>4、数据传输简单基础原理&#x3D;&gt;(服务端,浏览器,POST,GET)</h2><blockquote>\n<h5 id=\"1-浏览器访问原理-x3D-gt\"><a href=\"#1-浏览器访问原理-x3D-gt\" class=\"headerlink\" title=\"1. 浏览器访问原理&#x3D;&gt;\"></a>1. 浏览器访问原理&#x3D;&gt;</h5><ul>\n<li><code>协议=&gt;ip=&gt;端口=&gt;uri</code></li>\n</ul>\n<h5 id=\"2-服务端-前端-数据传输过程-x3D-gt\"><a href=\"#2-服务端-前端-数据传输过程-x3D-gt\" class=\"headerlink\" title=\"2. 服务端(前端)数据传输过程&#x3D;&gt;\"></a>2. 服务端(前端)数据传输过程&#x3D;&gt;</h5><ul>\n<li><code>控制层=&gt;逻辑层=&gt;数据层=&gt;后端(数据持久层)</code></li>\n</ul>\n<h5 id=\"3-GET与POST区别-x3D-gt\"><a href=\"#3-GET与POST区别-x3D-gt\" class=\"headerlink\" title=\"3. GET与POST区别:&#x3D;&gt;\"></a>3. GET与POST区别:&#x3D;&gt;</h5><ul>\n<li>GET是进行明文传递,POST非明文请求数据放在请求体中</li>\n</ul>\n</blockquote>\n<h2 id=\"5、请求响应与跨域概念\"><a href=\"#5、请求响应与跨域概念\" class=\"headerlink\" title=\"5、请求响应与跨域概念\"></a>5、请求响应与跨域概念</h2><blockquote>\n<h5 id=\"1-req-request（请求对象）-x3D-gt\"><a href=\"#1-req-request（请求对象）-x3D-gt\" class=\"headerlink\" title=\"1.req:request（请求对象）&#x3D;&gt;\"></a>1.req:request（请求对象）&#x3D;&gt;</h5><ul>\n<li><pre><code>代表,所有跟请求有关的东西都在req对象里头,包括请求参数 请求头 请求头 cookie\n</code></pre>\n</li>\n</ul>\n<h5 id=\"2-res-response（响应对象）-x3D-gt\"><a href=\"#2-res-response（响应对象）-x3D-gt\" class=\"headerlink\" title=\"2.res:response（响应对象）&#x3D;&gt;\"></a>2.res:response（响应对象）&#x3D;&gt;</h5><ul>\n<li>所有响应客户端的东西都在res里头,包括相应参数,响应头(跨域处理就是在这)</li>\n</ul>\n<h5 id=\"3-跨域请求的本质与原理-x3D-gt\"><a href=\"#3-跨域请求的本质与原理-x3D-gt\" class=\"headerlink\" title=\"3.跨域请求的本质与原理&#x3D;&gt;\"></a>3.跨域请求的本质与原理&#x3D;&gt;</h5><ul>\n<li><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p>\n</li>\n<li><p>请求本质是成功的,但是浏览器判断本次请求不安全</p>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"目录-1\"><a href=\"#目录-1\" class=\"headerlink\" title=\"#目录\"></a>#目录</h1><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h1 id=\"从URL输入到页面展现-这中间发生了什么？\"><a href=\"#从URL输入到页面展现-这中间发生了什么？\" class=\"headerlink\" title=\"从URL输入到页面展现,这中间发生了什么？\"></a>从URL输入到页面展现,这中间发生了什么？</h1><blockquote>\n<p>完整流程图<img data-src=\"/images/image-20210623183143882.png\" alt=\"/images//image-20210623183143882\"></p>\n<p>总体来说分为以下几个过程：</p>\n<ul>\n<li>DNS 解析:将域名解析成 IP 地址</li>\n<li>TCP 连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>\n</blockquote>\n<h2 id=\"一、什么是URL？\"><a href=\"#一、什么是URL？\" class=\"headerlink\" title=\"一、什么是URL？\"></a>一、什么是URL？</h2><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p>\n<p><strong><code>scheme</code>: &#x2F;&#x2F; <code>host</code>.<code>domain</code>:<code>port</code> &#x2F; <code>path</code> &#x2F;<code>filename</code> ?<code> query</code> # <code>fragment</code></strong></p>\n<blockquote>\n<ul>\n<li>scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file -其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host         - 定义域主机（http 的默认主机是 www）</li>\n<li>domain       - 定义因特网域名，比如 baidu.com</li>\n<li>port         - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path         - 定义服务器上的路径（如缺省则文档必须位于网站的根目录中）。</li>\n<li>filename     - 定义文档&#x2F;资源的名称  (如缺省文件必须位于前面<code>path</code>后的根目录中)</li>\n<li>query        - 即 ? 后的查询参数 <code>可以缺省</code></li>\n<li>fragment     - 即 # 后的hash值，一般用来定位到某个位置  <code>可以缺省</code></li>\n</ul>\n<p>举个栗子:</p>\n<p><img data-src=\"/images/image-20210623184854722.png\" alt=\"/images//image-20210623184854722\"> </p>\n</blockquote>\n<h2 id=\"二、DNS域名解析\"><a href=\"#二、DNS域名解析\" class=\"headerlink\" title=\"二、DNS域名解析\"></a>二、DNS域名解析</h2><blockquote>\n<p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址</p>\n</blockquote>\n<h3 id=\"1、IP地址是什么\"><a href=\"#1、IP地址是什么\" class=\"headerlink\" title=\"1、IP地址是什么?\"></a>1、IP地址是什么?</h3><blockquote>\n<p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>\n</blockquote>\n<h3 id=\"2、域名是什么\"><a href=\"#2、域名是什么\" class=\"headerlink\" title=\"2、域名是什么?\"></a>2、域名是什么?</h3><blockquote>\n<p><code>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</code>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称,相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生</p>\n<p>举个栗子:<a href=\"https://gitee.com/hongjilin\"><code>47.100.xxx.xxx.xx:80/hongjilin</code></a>&#x3D;&#x3D;&#x3D;<a href=\"https://gitee.com/hongjilin\"><code>gitee.com/hongjilin</code></a>,对于我们肯定是<a href=\"https://gitee.com/hongjilin\"><code>gitee.com/hongjilin</code></a>更便于记忆,而对计算机而言更擅长前者</p>\n</blockquote>\n<h3 id=\"3、什么是域名解析\"><a href=\"#3、什么是域名解析\" class=\"headerlink\" title=\"3、什么是域名解析?\"></a>3、什么是域名解析?</h3><blockquote>\n<p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。**<code>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录</code>**</p>\n<p>举个栗子 <code>baidu.com</code> &#x3D;&#x3D;解析&#x3D;&#x3D;&gt; <code>220.114.23.56(服务器外网IP地址)80(服务器端口)</code></p>\n</blockquote>\n<h3 id=\"4、浏览器如何通过域名去查询-URL-对应的-IP-呢\"><a href=\"#4、浏览器如何通过域名去查询-URL-对应的-IP-呢\" class=\"headerlink\" title=\"4、浏览器如何通过域名去查询 URL 对应的 IP 呢?\"></a>4、浏览器如何通过域名去查询 URL 对应的 IP 呢?</h3><blockquote>\n<ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<p><img data-src=\"/images/image-20210623191500569.png\" alt=\"/images//image-20210623191500569\"></p>\n<p><code>结论</code>:<strong>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</strong> </p>\n</blockquote>\n<h3 id=\"5、DNS的优化与应用\"><a href=\"#5、DNS的优化与应用\" class=\"headerlink\" title=\"5、DNS的优化与应用\"></a>5、DNS的优化与应用</h3><blockquote>\n<ol>\n<li>DNS缓存 <code>DNS存在着多级缓存</code>，从离浏览器的距离排序的话，有以下几种: <code>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</code>。</li>\n<li>DNS负载均衡<code>(DNS重定向) DNS负载均衡技术</code>的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</li>\n</ol>\n<ul>\n<li>大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</li>\n</ul>\n<ol start=\"3\">\n<li>dns-prefetch <code>DNS Prefetch 是一种 DNS 预解析技术</code>。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li>\n</ol>\n</blockquote>\n<h2 id=\"三、TCP三次握手\"><a href=\"#三、TCP三次握手\" class=\"headerlink\" title=\"三、TCP三次握手\"></a>三、TCP三次握手</h2><blockquote>\n<p><strong>HTTP 请求分为三个部分：<code>TCP 三次握手</code>、http 请求响应信息、关闭 TCP 连接。</strong></p>\n<ol>\n<li>比喻图</li>\n</ol>\n<p> <img data-src=\"/images/image-20210623192336724.png\" alt=\"/images//image-20210623192336724\"> </p>\n<ol start=\"2\">\n<li>三次握手时序图(该图来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vdXNlci8zMzg2MTUxNTQ1ODY5Nzgz\">williamife</span>)</li>\n</ol>\n<p> <img data-src=\"/images/1692e4385f72aae4\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"1、TCP三次握手的过程如下\"><a href=\"#1、TCP三次握手的过程如下\" class=\"headerlink\" title=\"1、TCP三次握手的过程如下:\"></a>1、TCP三次握手的过程如下:</h3><blockquote>\n<p>客户端发送一个带 SYN&#x3D;1，Seq&#x3D;X 的数据包到服务器端口<code>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</code></p>\n<p>服务器发回一个带 SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y 的响应包以示传达确认信息<code>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</code></p>\n<p>客户端再回传一个带 ACK&#x3D;Y+1， Seq&#x3D;Z 的数据包，代表“握手结束”<code>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</code></p>\n</blockquote>\n<h3 id=\"2、为何需要三次握手\"><a href=\"#2、为何需要三次握手\" class=\"headerlink\" title=\"2、为何需要三次握手?\"></a>2、为何需要三次握手?</h3><blockquote>\n<p>“三次握手”的目的是“**<code>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</code>**”。</p>\n</blockquote>\n<h2 id=\"四、发送-HTTP-请求\"><a href=\"#四、发送-HTTP-请求\" class=\"headerlink\" title=\"四、发送 HTTP 请求\"></a>四、发送 HTTP 请求</h2><blockquote>\n<p>TCP 三次握手结束后，开始发送 HTTP 请求报文。</p>\n</blockquote>\n<h2 id=\"五、服务器处理请求并返回-HTTP-报文\"><a href=\"#五、服务器处理请求并返回-HTTP-报文\" class=\"headerlink\" title=\"五、服务器处理请求并返回 HTTP 报文\"></a>五、服务器处理请求并返回 HTTP 报文</h2><h3 id=\"1、服务器\"><a href=\"#1、服务器\" class=\"headerlink\" title=\"1、服务器\"></a>1、服务器</h3><blockquote>\n<p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。<br><strong><code>web server</code> 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（常见的web server产品有apache、<code>nginx</code>、IIS、Lighttpd等），然后返回后台程序处理产生的结果作为响应。</p>\n</blockquote>\n<h3 id=\"2、http-响应报文\"><a href=\"#2、http-响应报文\" class=\"headerlink\" title=\"2、http 响应报文\"></a>2、http 响应报文</h3><blockquote>\n<p>此处同上</p>\n</blockquote>\n<h2 id=\"六、浏览器解析渲染页面\"><a href=\"#六、浏览器解析渲染页面\" class=\"headerlink\" title=\"六、浏览器解析渲染页面\"></a>六、浏览器解析渲染页面</h2><blockquote>\n<p>相关详细内容包括如何优化已在‘浏览器解析渲染页面原理及回流重绘优化笔记’中有叙述  –》 <strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaG9uZ2ppbGluL2hvbmdzLXN0dWR5LW5vdGVzL3RyZWUvbWFzdGVyLyVFNyVCQyU5NiVFNyVBOCU4Ql8lRTUlODklOEQlRTclQUIlQUYlRTUlQkMlODAlRTUlOEYlOTElRTUlQUQlQTYlRTQlQjklQTAlRTclQUMlOTQlRTglQUUlQjAvQ2hyb21lJUU1JUJDJTgwJUU1JThGJTkxJUU0JUJEJUJGJUU3JTk0JUE4JUU1JThGJThBJUU1JUFEJUE2JUU0JUI5JUEwJUU3JUFDJTk0JUU4JUFFJUIwLyVFNiVCNSU4RiVFOCVBNyU4OCVFNSU5OSVBOCVFOCVBNyVBMyVFNiU5RSU5MCVFNiVCOCVCMiVFNiU5RiU5MyVFOSVBMSVCNSVFOSU5RCVBMiVFNSU4RSU5RiVFNyU5MCU4NiVFNSU4RiU4QSVFNSU5QiU5RSVFNiVCNSU4MSVFOSU4NyU4RCVFNyVCQiU5OCVFNCVCQyU5OCVFNSU4QyU5NiVFNyVBQyU5NCVFOCVBRSVCMA==\">浏览器解析渲染页面原理及回流重绘优化笔记</span></strong> </p>\n<p>浏览器解析渲染页面分为一下五个步骤：</p>\n<ol>\n<li>根据HTML解析出DOM树</li>\n<li>根据CSS解析生成CSS规则树</li>\n<li>结合DOM树和CSS规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ol>\n</blockquote>\n<h3 id=\"1、根据HTML解析DOM树\"><a href=\"#1、根据HTML解析DOM树\" class=\"headerlink\" title=\"1、根据HTML解析DOM树\"></a>1、根据HTML解析DOM树</h3><blockquote>\n<ul>\n<li>根据HTML的内容，将标签按照结构解析成为DOM树，DOM树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取HTML文档，构建DOM树的过程中，若遇到script标签，则DOM树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n</blockquote>\n<h3 id=\"2、根据CSS解析生成CSS规则树-–》【CSSOM树】\"><a href=\"#2、根据CSS解析生成CSS规则树-–》【CSSOM树】\" class=\"headerlink\" title=\"2、根据CSS解析生成CSS规则树 –》【CSSOM树】\"></a>2、根据CSS解析生成CSS规则树 –》【CSSOM树】</h3><blockquote>\n<ul>\n<li>解析CSS规则树时js 执行将暂停，直至CSS规则树就绪。</li>\n<li>浏览器在CSS规则树生成之前不会进行渲染。</li>\n</ul>\n</blockquote>\n<h3 id=\"3、结合DOM树和CSS规则树，生成渲染树\"><a href=\"#3、结合DOM树和CSS规则树，生成渲染树\" class=\"headerlink\" title=\"3、结合DOM树和CSS规则树，生成渲染树\"></a>3、结合DOM树和CSS规则树，生成渲染树</h3><blockquote>\n<ul>\n<li>DOM树和CSS规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快CSS规则树的构建，从而加快页面相应速度。</li>\n</ul>\n</blockquote>\n<h3 id=\"4、根据渲染树计算每一个节点的信息（布局）\"><a href=\"#4、根据渲染树计算每一个节点的信息（布局）\" class=\"headerlink\" title=\"4、根据渲染树计算每一个节点的信息（布局）\"></a>4、根据渲染树计算每一个节点的信息（布局）</h3><blockquote>\n<ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n</blockquote>\n<h3 id=\"5、根据计算好的信息绘制页面\"><a href=\"#5、根据计算好的信息绘制页面\" class=\"headerlink\" title=\"5、根据计算好的信息绘制页面\"></a>5、根据计算好的信息绘制页面</h3><blockquote>\n<ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的<code>重绘</code>。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n</blockquote>\n<h2 id=\"七、断开连接\"><a href=\"#七、断开连接\" class=\"headerlink\" title=\"七、断开连接\"></a>七、断开连接</h2><p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手</strong>。<br><img data-src=\"/%E6%B5%85%E6%9E%90%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/1460000017184713.png\" alt=\"img\"></p>\n<ul>\n<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态</strong>。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态</strong>。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态</strong>。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭</strong>。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ul>\n<h2 id=\"1、前端缓存\"><a href=\"#1、前端缓存\" class=\"headerlink\" title=\"1、前端缓存\"></a>1、前端缓存</h2><blockquote>\n<p>当我们第一次访问网站时,电脑会把网站上的图片与数据下载到电脑上,当我们再次访问该网站时,网站就会从电脑中直接加载出来,这就是缓存</p>\n<ul>\n<li>web缓存是指一个Web资源(如html页面、图、JS等)存在于web服务器和客户端(浏览器)之间的副本</li>\n<li>缓存会根据进来的请求保存输出内容的副本: 当下一个请求来到的时候,如果是相同的Url,缓存会根据缓存机制决定是直接使用副本响应访问请求还是像源服务器再次发起请求</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅰ-缓存有哪些好处\"><a href=\"#Ⅰ-缓存有哪些好处\" class=\"headerlink\" title=\"Ⅰ - 缓存有哪些好处\"></a>Ⅰ - 缓存有哪些好处</h3><blockquote>\n<ul>\n<li>缓解服务端压力,不用每次都去请求某些数据</li>\n<li>提升性能,打开本地资源肯定比请求服务器来的更快 </li>\n<li>减少宽带消耗,当我们使用缓存的时候,只会产生很小的网络消耗,至于为什么打开本地资源也会产生网络消耗?</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-前端缓存种类\"><a href=\"#Ⅱ-前端缓存种类\" class=\"headerlink\" title=\"Ⅱ - 前端缓存种类\"></a>Ⅱ - 前端缓存种类</h3><blockquote>\n<ol>\n<li>数据库缓存</li>\n<li>CDN缓存</li>\n<li>代理服务器缓存</li>\n<li>浏览器缓存</li>\n</ol>\n<p><strong>此图截取自网上相关文章</strong></p>\n<p><img data-src=\"/images/image-20211027182618788.png\" alt=\"/images//image-20211027182618788\"></p>\n</blockquote>\n<h2 id=\"2、什么是浏览器缓存策略\"><a href=\"#2、什么是浏览器缓存策略\" class=\"headerlink\" title=\"2、什么是浏览器缓存策略\"></a>2、什么是浏览器缓存策略</h2><blockquote>\n<p>良好的缓存策略可以降低资源的重复加载从而提高页面整体加载速度,通常浏览器缓存策略分为两种结果</p>\n<ul>\n<li>强缓存</li>\n<li>协商缓存</li>\n</ul>\n<p><img data-src=\"/images/image-20211027184535569.png\" alt=\"/images//image-20211027184535569\"> </p>\n</blockquote>\n<h3 id=\"Ⅰ-基本原理\"><a href=\"#Ⅰ-基本原理\" class=\"headerlink\" title=\"Ⅰ - 基本原理\"></a>Ⅰ - 基本原理</h3><blockquote>\n<ul>\n<li>浏览器在加载资源时,根据请求头的 <code>Expires(过期时间)</code> 和<code>chche-control(缓存控制)</code>判断是否命中强缓存,命中则直接从缓存中读取资源,不会发送到服务器</li>\n<li>如果没有命中强缓存,浏览器一定会发送一个请求到服务器,通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存,如果命中,服务器回将这个请求返回,但是不会返回这个资源的数据,依然是从缓存中读取资源</li>\n<li>如果前面两者都没有命中,则直接从服务器加载资源</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-根据什么规则缓存\"><a href=\"#Ⅱ-根据什么规则缓存\" class=\"headerlink\" title=\"Ⅱ - 根据什么规则缓存\"></a>Ⅱ - 根据什么规则缓存</h3><blockquote>\n<ol>\n<li><strong>新鲜度</strong>(过期机制):也就是缓存副本有效期. 一个缓存副本必须满足以下条件,浏览器会认为它是有效的,足够新的</li>\n</ol>\n<ul>\n<li>含有完整的过期时间控制头信息(HTTP协议报头),并且仍在有效期内</li>\n<li>浏览器已经使用过这个缓存副本,并且在一个会话中已经检查过新鲜度</li>\n<li><strong>通常是强缓存阶段使用的机制</strong></li>\n</ul>\n<ol start=\"2\">\n<li><strong>校验值</strong>(验证机制): 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签<code>Etag</code>,</li>\n</ol>\n<ul>\n<li>它可以用来作为浏览器再次请求过程的校验标识</li>\n<li>如果发现校验标识不匹配,说明资源已经被修改或者过期,浏览器需要重新获取资源内容</li>\n<li><strong>所以通常是协商缓存中使用的机制</strong></li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-HTTP缓存的两个阶段\"><a href=\"#Ⅲ-HTTP缓存的两个阶段\" class=\"headerlink\" title=\"Ⅲ - HTTP缓存的两个阶段\"></a>Ⅲ - HTTP缓存的两个阶段</h3><blockquote>\n<p>浏览器缓存一般分为两类: <strong>强缓存</strong>(也称本地缓存) 和 <strong>协商缓存</strong>(也称弱缓存)</p>\n<h6 id=\"强缓存阶段\"><a href=\"#强缓存阶段\" class=\"headerlink\" title=\"强缓存阶段\"></a>强缓存阶段</h6><blockquote>\n<p>浏览器发送请求前,会去缓存里查看是否命中强缓存,如果命中,则直接从缓存中读取资源,不会发送请求到服务器;</p>\n</blockquote>\n<h6 id=\"协商缓存阶段\"><a href=\"#协商缓存阶段\" class=\"headerlink\" title=\"协商缓存阶段\"></a>协商缓存阶段</h6><blockquote>\n<p>当强缓存没有命中时,浏览器一定会向服务器发起请求</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>服务器会根据 <code>request header</code> 中的一些字段来判断是否命中协商缓存</li>\n<li>如果命中,服务端会返回304响应,但是不会携带任何响应实体,只是高速浏览器可以直接从浏览器缓存中获取这个资源</li>\n<li>如果 <strong>强缓存</strong> 和 <strong>协商缓存</strong> 都没有命中,则直接从服务器加载资源</li>\n</ul>\n</blockquote>\n<p><img data-src=\"/images/image-20211027190616969.png\" alt=\"/images//image-20211027190616969\"> </p>\n</blockquote>\n<h3 id=\"Ⅳ-优先级\"><a href=\"#Ⅳ-优先级\" class=\"headerlink\" title=\"Ⅳ - 优先级\"></a>Ⅳ - 优先级</h3><blockquote>\n<ul>\n<li><code>Cache-Control</code>优先级大于 <code>expires</code></li>\n<li><code>Etag</code> 优先级大于 <code>last - Modified/if-Modified-since</code>,同时存在时会以Etag为准</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅴ-浏览器缓存流程图\"><a href=\"#Ⅴ-浏览器缓存流程图\" class=\"headerlink\" title=\"Ⅴ - 浏览器缓存流程图\"></a>Ⅴ - 浏览器缓存流程图</h3><blockquote>\n<p><img data-src=\"/images/image-20211027190721706.png\" alt=\"/images//image-20211027190721706\"> </p>\n</blockquote>\n<h2 id=\"3、强缓存与协商缓存\"><a href=\"#3、强缓存与协商缓存\" class=\"headerlink\" title=\"3、强缓存与协商缓存\"></a>3、强缓存与协商缓存</h2><h3 id=\"Ⅰ-强缓存\"><a href=\"#Ⅰ-强缓存\" class=\"headerlink\" title=\"Ⅰ - 强缓存\"></a>Ⅰ - 强缓存</h3><blockquote>\n<h6 id=\"通过Expires-过yu期-和cache-control-缓存控制器-两种响应头实现\"><a href=\"#通过Expires-过yu期-和cache-control-缓存控制器-两种响应头实现\" class=\"headerlink\" title=\"通过Expires(过yu期)和cache-control(缓存控制器)两种响应头实现\"></a>通过<code>Expires(过yu期)</code>和<code>cache-control(缓存控制器)</code>两种响应头实现</h6><p>浏览器在加载资源时,根据请求头的 <code>Expires(过期时间)</code> 和<code>chche-control(缓存控制)</code>判断是否命中强缓存,命中则直接从缓存中读取资源,不会发送到服务器</p>\n</blockquote>\n<h4 id=\"①-Expires-过期\"><a href=\"#①-Expires-过期\" class=\"headerlink\" title=\"①  Expires(过期)\"></a>①  Expires(过期)</h4><blockquote>\n<p><code>Expires</code>是 http1.0 提出的表示资源过期时间的header, 它描述的是一个绝对时间,由服务端返回;当我们准备再次发起请求时,本地时间未超过这个设置的时间,那么就不会真正的发出请求,而是读取缓存</p>\n<p>expires受限于本地时间,如果修改了本地时间,可能会造成缓存失效</p>\n</blockquote>\n<h4 id=\"②-cache-control\"><a href=\"#②-cache-control\" class=\"headerlink\" title=\"②  cache-control\"></a>②  cache-control</h4><blockquote>\n<p><code>cache-control</code>出现于HTTP1.1, 优先级高于Expires ,表示的是相对时间</p>\n<ul>\n<li><code>cache-control:no-cache</code> 的响应实际上是可以存储在本地缓存去中的,只是在与原始服务器进行新鲜度再验证之前,缓存不能将其提供给客户端使用</li>\n<li><code>Cache-Control: no-store</code> 真正的不缓存到本地</li>\n<li><code>Cache-Control: public</code> 可以被所有用户缓存(多用户共享),包括终端和CDN等中间代理服务器</li>\n<li><code>Cache-Control: private</code>只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存</li>\n</ul>\n<p>Cache-Control除了在响应中使用，在请求中也可以使用。我们用开发者工具来模拟下请求时带上Cache-Control：勾选Disable cache，刷新页面，可以看到Request Headers中有个字段Cache-Control: no-cache。</p>\n<p><img data-src=\"/images/image-20220225160543826.png\" alt=\"/images//image-20220225160543826\"></p>\n</blockquote>\n<h3 id=\"Ⅱ-协商缓存\"><a href=\"#Ⅱ-协商缓存\" class=\"headerlink\" title=\"Ⅱ - 协商缓存\"></a>Ⅱ - 协商缓存</h3><blockquote>\n<h6 id=\"协商缓存是通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的\"><a href=\"#协商缓存是通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的\" class=\"headerlink\" title=\"协商缓存是通过【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的\"></a>协商缓存是通过<code>【Last-Modified，If-Modified-Since】</code>和<code>【ETag、If-None-Match】</code>这两对Header来管理的</h6><ul>\n<li>当浏览器对某个资源的请求没有命中强缓存(换句话说就是: <strong>强缓存失效后</strong>)</li>\n<li>就会发一个请求到服务器,验证协商缓存是否命中; </li>\n<li>如果协商缓存命中,请求响应返回的http状态为<code>304</code> 并且会显示一个<code>Not Modified(未修改的)</code>的字符串</li>\n</ul>\n</blockquote>\n<h4 id=\"①-Last-Modified，If-Modified-Since\"><a href=\"#①-Last-Modified，If-Modified-Since\" class=\"headerlink\" title=\"①  Last-Modified，If-Modified-Since\"></a>①  Last-Modified，If-Modified-Since</h4><blockquote>\n<ol>\n<li><code>Last-Modified</code>表示本地文件最后修改日期</li>\n</ol>\n<ul>\n<li>浏览器会在request header 加上 <code>If-Modified-Since</code>(上此返回的<code>Last-Modified</code>的值)</li>\n<li>询问服务器在该日期后资源是否有更新</li>\n<li>有更新的话就会将新的资源发送过来</li>\n</ul>\n<ol start=\"2\">\n<li>但如果在本地打开缓存文件,就会造成<code>Last-Modified</code>的修改,所以在HTTP1.1中出现了<code>Etag</code></li>\n<li>当资源过期时（使用<code>Cache-Control</code>标识的max-age&#x2F;s-maxage）</li>\n</ol>\n<ul>\n<li>发现资源具有<code>Last-Msodified</code>声明，则向服务器请求时带上头 <code>If-Modified-Since</code>（即响应头中的<code>Last-Modified</code>值），表示请求时间。</li>\n<li>这个时候服务器收到请求后发现有头<code>If-Modified-Since</code>则与<strong>被请求资源</strong>的最后修改时间进行比对</li>\n<li>若最后修改时间较新，说明资源有被改动过，将新资源返回并返回状态<code>200</code>，否则返回<code>304</code>表示资源没被更新使用缓存即可。</li>\n</ul>\n</blockquote>\n<h4 id=\"②-ETag、If-None-Match\"><a href=\"#②-ETag、If-None-Match\" class=\"headerlink\" title=\"② ETag、If-None-Match\"></a>② ETag、If-None-Match</h4><blockquote>\n<ol>\n<li><code>Etag</code>就行是一个直问,资源变化都会导致Etag变化,跟最后修改时间没有关系,Etag可以保证每一个资源都是唯一的</li>\n<li>当资源过期时（使用Cache-Control标识的max-age&#x2F;s-maxage）</li>\n</ol>\n<ul>\n<li>发现资源具有<code>Etage</code>声明，则向服务器请求时带上头<code>If-None-Match</code>（即响应头中<code>Etag</code>的值）</li>\n<li>服务器收到请求后发现有头<code>If-None-Match</code> 则与被请求资源的相应校验串进行比对</li>\n<li>决定返回200或304（<strong>注意：服务器会优先验证If-None-Match</strong>）</li>\n</ul>\n<h6 id=\"两者优先级\"><a href=\"#两者优先级\" class=\"headerlink\" title=\"两者优先级?\"></a>两者优先级?</h6><blockquote>\n<p><strong><code>ETag</code>的优先级比<code>Last-Modified</code>更高</strong></p>\n</blockquote>\n<blockquote>\n<p>具体为什么要用<code>ETag</code>，主要出于下面几种情况考虑：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>一些文件也许会周期性的更改,但是它的内容并不会改变(仅仅只改变了修改时间),这种时候我们并不希望客户端认为这个文件被修改了,而重新GET</li>\n<li>某些文件修改非常频繁,比如在秒以下的时间内进行修改(比如说1s内修改了N次),而其他方法检查到的粒度是s级的,这种修改无法判断</li>\n<li>某些服务器不能精确的得到文件的最后修改时间</li>\n</ul>\n</blockquote>\n<h6 id=\"服务端返回-304-流程图\"><a href=\"#服务端返回-304-流程图\" class=\"headerlink\" title=\"服务端返回 304 流程图\"></a>服务端返回 304 流程图</h6><p><img data-src=\"/images/image-20211027175045937-16353282573951.png\" alt=\"/images//image-20211027175045937\"></p>\n</blockquote>\n<h3 id=\"Ⅲ-强缓存与协商缓存简单异同点\"><a href=\"#Ⅲ-强缓存与协商缓存简单异同点\" class=\"headerlink\" title=\"Ⅲ -强缓存与协商缓存简单异同点\"></a>Ⅲ -强缓存与协商缓存简单异同点</h3><blockquote>\n<ul>\n<li><strong>相同点</strong>: 如果命中,都是从客户端缓存中加载资源,而不是从服务器加载资源数据</li>\n<li><strong>不同点</strong>: 强缓存不发送请求到服务器,协商缓存会发送请求到服务器</li>\n</ul>\n</blockquote>\n<h2 id=\"4、常见几种状态码的区别\"><a href=\"#4、常见几种状态码的区别\" class=\"headerlink\" title=\"4、常见几种状态码的区别\"></a>4、常见几种状态码的区别</h2><blockquote>\n<p>缓存中: 200状态码总是强缓存, 304总是协商缓存</p>\n<ul>\n<li><code>200</code>: 强缓存<code>expires/Cache-Control</code>失效时,返回新的资源文件</li>\n<li><code>200(form cache)</code>: 强缓存两者都存在且未过期; <code>Cache-Control</code> 优先<code>Expirs</code>(默认就是这个优先级)时–&gt;浏览器从本地获取资源成功  (这个状态还能更详细分类,在下面再给出详解)</li>\n<li><code>304(Not Modified)</code>:协商缓存<code>Last-modified/Etag</code>没有过期时,服务端返回状态码304</li>\n</ul>\n<h6 id=\"这里给出个截图-安装了中文包-所以显示的中文\"><a href=\"#这里给出个截图-安装了中文包-所以显示的中文\" class=\"headerlink\" title=\"这里给出个截图(安装了中文包,所以显示的中文)\"></a>这里给出个截图(安装了中文包,所以显示的中文)</h6><p><img data-src=\"/images/image-20211102140503290.png\" alt=\"/images//image-20211102140503290\"> </p>\n</blockquote>\n<h2 id=\"5、缓存位置\"><a href=\"#5、缓存位置\" class=\"headerlink\" title=\"5、缓存位置\"></a>5、缓存位置</h2><blockquote>\n<h6 id=\"强缓存我们会把资源放在-memory-cache-内存缓存-和disk-cache-磁盘缓存-中-那么他们的区别在哪呢-为何要如此区分\"><a href=\"#强缓存我们会把资源放在-memory-cache-内存缓存-和disk-cache-磁盘缓存-中-那么他们的区别在哪呢-为何要如此区分\" class=\"headerlink\" title=\"强缓存我们会把资源放在 memory cache(内存缓存)和disk cache(磁盘缓存) 中,那么他们的区别在哪呢?为何要如此区分?\"></a>强缓存我们会把资源放在 <code>memory cache(内存缓存)</code>和<code>disk cache(磁盘缓存)</code> 中,那么他们的区别在哪呢?为何要如此区分?</h6><p><img data-src=\"/images/image-20211102140503290.png\" alt=\"/images//image-20211102140503290\"></p>\n<ul>\n<li>存储图像和网页等资源主要存储在<code>disk cache(磁盘存储)</code></li>\n<li>操作系统缓存文件等资源大部分都会缓存在<code>memory cache</code>中</li>\n<li>具体操作浏览器自动分配,看谁的资源利用率不高就给谁</li>\n<li>查找浏览器缓存时会按照 <code>Service Worker</code> –&gt; <code>Memory Cache</code> –&gt; <code>Disk Cache</code> –&gt;  <code>Push Cache</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅰ-Service-Worker\"><a href=\"#Ⅰ-Service-Worker\" class=\"headerlink\" title=\"Ⅰ -  Service Worker\"></a>Ⅰ -  Service Worker</h3><blockquote>\n<ul>\n<li>是运行在浏览器背后的独立线程,一般可以用来实现缓存功能. </li>\n<li>使用<code>Service Worker</code> 的话,因为其中涉及到请求拦截,所以传输协议必须为<code>HTTPS</code>来保障安全</li>\n<li><code>Service Worker</code>的缓存和浏览器其他内建的缓存机制不同,它可以让我们自由控制缓存那些文件,如何匹配缓存、读取缓存,并且缓存时持续性的</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-Memory-Cache\"><a href=\"#Ⅱ-Memory-Cache\" class=\"headerlink\" title=\"Ⅱ - Memory Cache\"></a>Ⅱ - Memory Cache</h3><blockquote>\n<ul>\n<li><strong>内存中的缓存</strong>: 主要包含的是当前页面中已经抓取到的资源: 例如页面下载的样式、脚本、图片等</li>\n<li>读取 <strong>内存</strong> 中的数据肯定比 <strong>磁盘</strong> 的快</li>\n<li><strong>内存缓存</strong> 虽然读取高效,但是缓存持续性很短,会随着进程的释放而释放: 如我们关闭了tab页面 ,内存中的缓存也就被释放了</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-Disk-Cache\"><a href=\"#Ⅲ-Disk-Cache\" class=\"headerlink\" title=\"Ⅲ -  Disk Cache\"></a>Ⅲ -  Disk Cache</h3><blockquote>\n<ul>\n<li>存储在 <strong>硬盘</strong> 中的缓存,读取速度慢点,但是什么都能存储到磁盘中,比之 <code>Memory Cache</code> 胜在容量和存储时效性上</li>\n<li>在所有浏览器缓存中,<code>Disk Cache</code>覆盖面基本是最大的</li>\n<li>他会根据 <code>HTTP Header</code> 中的字段判断哪些资源需要缓存,哪些资源可以不请求直接使用,哪些资源已经过期需要重新请求</li>\n<li>并且即便在跨站点的情况下,相同地址的资源一旦被硬盘缓存下来,就不会再去请求数据,绝大部分数据都来自<code>Disk Cache</code></li>\n<li><strong>磁盘缓存</strong> 比 <strong>内存缓存</strong> 慢的多</li>\n</ul>\n<h6 id=\"举个🌰\"><a href=\"#举个🌰\" class=\"headerlink\" title=\"举个🌰\"></a>举个🌰</h6><blockquote>\n<p>从远程 Web 服务器直接提取访问文件可能需要 <strong>500毫秒(半秒)</strong>, 那么磁盘访问可能需要 <strong>10~20毫秒</strong> ; 而内存访问可能只需要 <strong>100纳秒</strong>; 更高级的还有 <strong>L1缓存访问</strong> 只需要0.5纳秒 (最快和最小的CPU缓存,详见此笔记 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaG9uZ2ppbGluL2hvbmdzLXN0dWR5LW5vdGVzL2Jsb2IvbWFzdGVyLyVFNyVCQyU5NiVFNyVBOCU4Ql8lRTclQUUlOTclRTYlQjMlOTUlRTUlOEYlOEElRTglQUYlQkUlRTclQTglOEIlRTUlOUYlQkElRTclQTElODAlRTUlQUQlQTYlRTQlQjklQTAlRTclQUMlOTQlRTglQUUlQjAvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJCJTg0JUU2JTg4JTkwJUU1JThFJTlGJUU3JTkwJTg2LyVFNyVCQyU5MyVFNSVBRCU5OCVFMyU4MCU4MSVFNSU4NiU4NSVFNSVBRCU5OCVFMyU4MCU4MUNQVSVFNyU5RiVBNSVFOCVBRiU4NiVFNyU4MiVCOSVFOCVBNyVBMyVFNiU5RSU5MCVFNyVBQyU5NCVFOCVBRSVCMC5tZCMlRTUlOUIlOUJjcHUlRTclOUElODQlRTUlQTQlOUElRTclQkElQTclRTclQkMlOTMlRTUlQUQlOTglRTklQUIlOTglRTklODAlOUYlRTclQkMlOTMlRTUlQUQlOTg=\">缓存、内存、CPU知识点解析</span> )</p>\n</blockquote>\n</blockquote>\n<h3 id=\"Ⅳ-prefetch-cache-预取缓存\"><a href=\"#Ⅳ-prefetch-cache-预取缓存\" class=\"headerlink\" title=\"Ⅳ -  prefetch cache(预取缓存)\"></a>Ⅳ -  prefetch cache(预取缓存)</h3><blockquote>\n<ul>\n<li><strong>link</strong> 标签带上 <strong>prefetch</strong> ,再次加载时会出现</li>\n<li><code>prefetch</code> 是 <strong>预加载</strong> 的一种方式: 被标记为 <code>prefetch</code> 的资源,将会被浏览器在空闲时间加载</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅴ-Push-Cache\"><a href=\"#Ⅴ-Push-Cache\" class=\"headerlink\" title=\"Ⅴ -  Push Cache\"></a>Ⅴ -  Push Cache</h3><blockquote>\n<ul>\n<li><code>Push Cache(推送缓存)</code> 是 <strong>HTTP&#x2F;2</strong> 中的内容,当以上三种缓存都没有命中时,它才会被使用</li>\n<li>它只在 <strong>会话 (Session)</strong> 中存在,一旦会话结束就会被释放,并且缓存时间也会很短暂</li>\n<li>在Chrome浏览器中只有 <strong>5分钟</strong> 左右,同时它也并非严格执行HTTP头中的缓存指令</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅵ-CPU、内存、硬盘概述\"><a href=\"#Ⅵ-CPU、内存、硬盘概述\" class=\"headerlink\" title=\"Ⅵ -  CPU、内存、硬盘概述\"></a>Ⅵ -  CPU、内存、硬盘概述</h3><blockquote>\n<h6 id=\"可能有小伙伴对于此处知识点没什么直观的概念-此处给出一个大概叙述-想了解更多的话此部分知识点本人有专门梳理笔记文件\"><a href=\"#可能有小伙伴对于此处知识点没什么直观的概念-此处给出一个大概叙述-想了解更多的话此部分知识点本人有专门梳理笔记文件\" class=\"headerlink\" title=\"可能有小伙伴对于此处知识点没什么直观的概念,此处给出一个大概叙述; 想了解更多的话此部分知识点本人有专门梳理笔记文件\"></a>可能有小伙伴对于此处知识点没什么直观的概念,此处给出一个大概叙述; 想了解更多的话此部分知识点本人有专门梳理笔记文件</h6><h6 id=\"–-gt-点我传送\"><a href=\"#–-gt-点我传送\" class=\"headerlink\" title=\"–&gt; 点我传送\"></a>–&gt; <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaG9uZ2ppbGluL2hvbmdzLXN0dWR5LW5vdGVzL2Jsb2IvbWFzdGVyLyVFNyVCQyU5NiVFNyVBOCU4Ql8lRTclQUUlOTclRTYlQjMlOTUlRTUlOEYlOEElRTglQUYlQkUlRTclQTglOEIlRTUlOUYlQkElRTclQTElODAlRTUlQUQlQTYlRTQlQjklQTAlRTclQUMlOTQlRTglQUUlQjAvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJCJTg0JUU2JTg4JTkwJUU1JThFJTlGJUU3JTkwJTg2LyVFNyVCQyU5MyVFNSVBRCU5OCVFMyU4MCU4MSVFNSU4NiU4NSVFNSVBRCU5OCVFMyU4MCU4MUNQVSVFNyU5RiVBNSVFOCVBRiU4NiVFNyU4MiVCOSVFOCVBNyVBMyVFNiU5RSU5MCVFNyVBQyU5NCVFOCVBRSVCMC5tZA==\">点我传送</span></h6><ul>\n<li>CPU、内存、硬盘都是计算机的主要组成部分</li>\n<li><strong>CPU</strong>: 中央处理单元的缩写,也叫做 <code>处理器</code>,是计算机的运算核心和控制核心; 电脑靠CPU来运算、控制. 让电脑各个部件顺利工作,起到协调作用</li>\n<li><strong>硬盘</strong>: 存储资料和软件等数据的设备,有容量大、断电数据不丢失的特点</li>\n<li><strong>内存</strong>: 负责 <strong>硬盘</strong> 等硬件上的数据与 <strong>CPU</strong> 之间数据的交换处理. 特点是: <code>体积小</code>、<code>速度快</code>、<code>有电可存</code>、<code>无电清空</code>,即电脑在开机状态时内存中可存储数据,关机后将自动清空其中的所有数据</li>\n</ul>\n</blockquote>\n<h2 id=\"6、强缓存有协商缓存的区别\"><a href=\"#6、强缓存有协商缓存的区别\" class=\"headerlink\" title=\"6、强缓存有协商缓存的区别\"></a>6、强缓存有协商缓存的区别</h2><blockquote>\n<p>这里再次总结整理一下两者之间的区别</p>\n<ul>\n<li>强缓存不发请求到服务端,所以有时候资源更新了浏览器还不知道; </li>\n<li>但是协商缓存会发请求到服务器,所以资源是否更新,服务器肯定知道</li>\n<li>大部分web服务器都默认开启协商缓存</li>\n</ul>\n</blockquote>\n<h2 id=\"7、刷新对于强缓存和协商缓存的影响\"><a href=\"#7、刷新对于强缓存和协商缓存的影响\" class=\"headerlink\" title=\"7、刷新对于强缓存和协商缓存的影响\"></a>7、刷新对于强缓存和协商缓存的影响</h2><blockquote>\n<ul>\n<li>当 <code>ctrl+F5</code>强制刷新网页时: 直接从服务器加载, <strong>跳过强缓存和协商缓存</strong></li>\n<li>当 f5 刷新网页时,跳过强缓存,但是会检查协商缓存</li>\n<li>浏览器地址写入URL并回车: 浏览器发现缓存中有这个文件了,就不用继续请求了,直接去缓存拿 (最快)</li>\n</ul>\n</blockquote>\n","categories":["HTTP"],"tags":["HTTP","协议"]},{"title":"OSI七层网络模型","url":"/2024/05/27/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","content":"<h1 id=\"OSI七层网络模型\"><a href=\"#OSI七层网络模型\" class=\"headerlink\" title=\"OSI七层网络模型\"></a>OSI七层网络模型</h1><p><img data-src=\"/images/e3cc1860482648d5a2b2f6bac23280d3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp\" alt=\"images\"></p>\n<h1 id=\"七、应用层（应用）\"><a href=\"#七、应用层（应用）\" class=\"headerlink\" title=\"七、应用层（应用）\"></a>七、应用层（应用）</h1><p>应用层就是我们最接近我们、最常用的一层，例如：</p>\n<ul>\n<li>ajax调用接口发送<strong>http请求</strong></li>\n<li>使用<strong>DNS域名查询</strong>系统</li>\n<li><strong>邮件协议SMTP</strong></li>\n<li><strong>websock长连接</strong></li>\n<li><strong>SSH协议</strong></li>\n<li>等。</li>\n</ul>\n<h1 id=\"六、表示层（安全、压缩、翻译）\"><a href=\"#六、表示层（安全、压缩、翻译）\" class=\"headerlink\" title=\"六、表示层（安全、压缩、翻译）\"></a>六、表示层（安全、压缩、翻译）</h1><p>表示层做了几件重要的事情如：</p>\n<ul>\n<li>压缩</li>\n<li>安全（数据发送前进行加密，在接受者的表示层进行解密）</li>\n<li>程序在网络中的翻译官（对图片文件等格式进行解码和编码）</li>\n</ul>\n<h1 id=\"五、会话层（检查点机制）\"><a href=\"#五、会话层（检查点机制）\" class=\"headerlink\" title=\"五、会话层（检查点机制）\"></a>五、会话层（检查点机制）</h1><ul>\n<li>会话层是在发送方和接收方之间进行通信时创建、维持、之后终止或断开连接的地方</li>\n<li>会话层定义了一种机制，允许发送方和接收方启动或停止请求会话，当及当双方发生拥塞时仍然能保持对话</li>\n<li>会话层包含了一种<strong>检查点的机制</strong>来维持可靠会话，检查点定义了一个最接近成功通信的点，并且定义了当发生内容丢失或者损坏时需要回滚以便回复丢失或损坏数据的点，即断点下载的原理</li>\n</ul>\n<h1 id=\"四、传输层（TCP、UDP连接）\"><a href=\"#四、传输层（TCP、UDP连接）\" class=\"headerlink\" title=\"四、传输层（TCP、UDP连接）\"></a>四、传输层（TCP、UDP连接）</h1><ul>\n<li>传输层主要就是定义端口号，以及控流和校验</li>\n<li>TCP（面向连接的协议并且TCP是可靠的），因为TCP会进行三报文握手和四报文挥手，所以是可靠的，但是这样会降低速度</li>\n<li>UDP（UDP没有三报文握手和四报文挥手，因此不够稳定，但是速度快，常用于直播和游戏）</li>\n</ul>\n<h1 id=\"三、网络层（IP地址）\"><a href=\"#三、网络层（IP地址）\" class=\"headerlink\" title=\"三、网络层（IP地址）\"></a>三、网络层（IP地址）</h1><ul>\n<li>网络层是最复杂的一层，在网络层定义了IP</li>\n<li>网络层控制数据链路层与传输层之间的信息转发，建立，维持和终止网络的连接。</li>\n<li>数据链路层的数据在网络层被转换为数据包，然后通过路径选择、分段组合、顺序、进&#x2F;出路由等控制，将信息从一个网络设备传送到另一个网络设备</li>\n<li>寻址：对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信（类似于数据链路层的MAC地址）</li>\n<li>路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li>\n<li>如果所有的使用互联网的用户在同一个网段中，<strong>会产生广播风暴，所以要将用户进行划分</strong>，让他们在不同的网段中，自己在自己的小网段中广播。而<strong>互联网就是这无数的子网络构成的一个巨型网络</strong>。</li>\n<li>在网络层中引入了一套新的地址，让我们能够区分不同的网段。这套地址就叫做“网络地址”，简称“网址”。于是，<strong>”网络层”出现以后，每台计算机有了两种地址</strong>，<strong>一种是MAC地址，另一种是网络地址</strong>。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。<strong>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。</strong>因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</li>\n<li>这一层中有一个<strong>规定网络地址的协议，叫做IP协议</strong>，它所定义的地址，就被称为IP地址。</li>\n<li>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。因为IPv4的地址已经不够用了，所以现在推广IPv6，</li>\n</ul>\n<h1 id=\"二、数据链路层（MAC地址）\"><a href=\"#二、数据链路层（MAC地址）\" class=\"headerlink\" title=\"二、数据链路层（MAC地址）\"></a>二、数据链路层（MAC地址）</h1><ul>\n<li>建立逻辑连接、进行硬件地址寻址、差错校验等功能（底层网络定义协议）</li>\n<li>及比特组合成字节进而组合成帧，用MAC地址访问介质，此时可以发现错误但不能纠正。</li>\n<li>MAC地址是每个网卡的唯一标识，有了MAC地址就能知道谁是接收者，谁是发送者，并且知道了数据的内容，并且进行分组。</li>\n<li>传播数据是通过广播的方式进行传输，在局域网中的所有计算机都能接收到消息</li>\n</ul>\n<h1 id=\"一、物理层（物理信道）\"><a href=\"#一、物理层（物理信道）\" class=\"headerlink\" title=\"一、物理层（物理信道）\"></a>一、物理层（物理信道）</h1><ul>\n<li><p>物理层是直接和物理介质打交道的。</p>\n</li>\n<li><p>物理层的设备 网卡，网线，集线器，中继器，调制解调器</p>\n</li>\n</ul>\n<p><strong>物理层信道：</strong></p>\n<ul>\n<li><p>有线信道</p>\n<ul>\n<li>明线（平行架设在电线杆上的架空线路）</li>\n<li>对称电缆（对多双绞线组成）</li>\n<li>同轴电缆（具有外层屏蔽层）</li>\n<li>光纤（利用光在纤维中的反射原理进行传输）</li>\n</ul>\n</li>\n<li><p>无线信道</p>\n<p>以辐射无线电波为传输方式无线信道主要有地波传输，天波传输和视距传输 例如：卫星通讯，电台广播</p>\n</li>\n</ul>\n<p>物理层通过以上的方式，会获取他们对应的传送信号，电压，转换成010101010101但是数据还未组织，仅作为原始的电气电压处理<code>单位为bit</code></p>\n","categories":["OSI七层网络模型"],"tags":["OSI七层网络模型"]},{"title":"Sass笔记","url":"/2023/01/10/Sass/","content":"<h1 id=\"Scss相关介绍\"><a href=\"#Scss相关介绍\" class=\"headerlink\" title=\"Scss相关介绍\"></a>Scss相关介绍</h1><h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"#目录\"></a>#目录</h3><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h3 id=\"一、CSS预处理器出现的原因\"><a href=\"#一、CSS预处理器出现的原因\" class=\"headerlink\" title=\"一、CSS预处理器出现的原因\"></a>一、CSS预处理器出现的原因</h3><ol>\n<li>无法嵌套书写导致代码繁重、冗杂、逻辑混乱。</li>\n<li>没有变量和样式复用机制，属性值只能以字面量的形式重复输出。</li>\n</ol>\n<pre><code class=\"shell\"># 总结：代码复用性低；不易于维护\n# 注：现在，现在的CSS是可以定义变量的！！！\n</code></pre>\n<pre><code class=\"css\">:root&#123;\n    --red: #f3e1e1;\n&#125;\n</code></pre>\n<hr>\n<h3 id=\"二、出名的CSS预处理器介绍\"><a href=\"#二、出名的CSS预处理器介绍\" class=\"headerlink\" title=\"二、出名的CSS预处理器介绍\"></a>二、出名的CSS预处理器介绍</h3><h3 id=\"1-SCSS-x2F-SASS\"><a href=\"#1-SCSS-x2F-SASS\" class=\"headerlink\" title=\"1. SCSS&#x2F;SASS\"></a>1. SCSS&#x2F;SASS</h3><p>SASS (.scss)。于2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。</p>\n<h3 id=\"2-LESS\"><a href=\"#2-LESS\" class=\"headerlink\" title=\"2. LESS\"></a>2. LESS</h3><p>LESS (.less)。于2009年诞生，借鉴了SASS的长处，并兼容了CSS语法，使得开发者使用起来更为方便顺手，但是相比于SASS，其编程功能不够丰富，反而促使SASS进化成为了SCSS。</p>\n<h3 id=\"3-Stylus\"><a href=\"#3-Stylus\" class=\"headerlink\" title=\"3. Stylus\"></a>3. Stylus</h3><p>Stylus (.styl)。于2010年诞生，出自Node.js社区，主要用来给Node项目进行CSS预处理支持，人气较前两者偏低。</p>\n<hr>\n<h3 id=\"三、SCSS和SASS之间的关系\"><a href=\"#三、SCSS和SASS之间的关系\" class=\"headerlink\" title=\"三、SCSS和SASS之间的关系\"></a>三、SCSS和SASS之间的关系</h3><p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706194107318.png\" alt=\"/images/image-20200706194107318\"></p>\n<p>简而言之：</p>\n<pre><code>Sass有两套语法：\n\n1.第一种或更新的语法被称为SCSS。它是CSS语法的扩展。这意味着每个有效的CSS样式表都是具有相同含义的有效SCSS文件。下文描述的Sass功能增强了此语法。使用此语法的文件扩展名为.scss。\n\n2.第二种或更旧的语法被称为SASS。提供了一种更为简洁的CSS编写方式。它使用缩进而不是方括号来表示选择器的嵌套，并使用换行符而不是分号来分隔属性。使用此语法的文件扩展名为.sass。\n\n任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式\n</code></pre>\n<hr>\n<h3 id=\"四、使用CSS预处理器的优劣\"><a href=\"#四、使用CSS预处理器的优劣\" class=\"headerlink\" title=\"四、使用CSS预处理器的优劣\"></a>四、使用CSS预处理器的优劣</h3><h3 id=\"1-优点\"><a href=\"#1-优点\" class=\"headerlink\" title=\"1.优点\"></a>1.优点</h3><pre><code>CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题。支持嵌套、变量和逻辑等。可以让CSS更加简洁、提高代码复用性、逻辑分明等等\n</code></pre>\n<h3 id=\"2-缺点\"><a href=\"#2-缺点\" class=\"headerlink\" title=\"2.缺点\"></a>2.缺点</h3><pre><code>css的文件体积和复杂度不可控；增加了调试难度和成本等。\n</code></pre>\n<h3 id=\"五、选择SCSS的原因\"><a href=\"#五、选择SCSS的原因\" class=\"headerlink\" title=\"五、选择SCSS的原因\"></a>五、选择SCSS的原因</h3><ol>\n<li><p>官方介绍</p>\n<pre><code>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。\n</code></pre>\n</li>\n<li><p>特色功能</p>\n<ul>\n<li>完全兼容 CSS3</li>\n<li>在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能</li>\n<li>通过函数进行颜色值与属性值的运算</li>\n<li>提供控制指令 (control directives)等高级功能</li>\n<li>自定义输出格式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><pre><code>less、scss(sass)和stylus代码并不能被浏览器直接解析，所以必须先将它们编译成css代码\n\n现有框架已经提供了css预处理器选项，编译相关配置会自动帮我们生成！所以只有在&quot;练习&quot;情况下才有必要安装该环境\n</code></pre>\n<h3 id=\"一、安装分类\"><a href=\"#一、安装分类\" class=\"headerlink\" title=\"一、安装分类\"></a>一、安装分类</h3><h3 id=\"1-不依赖编辑器\"><a href=\"#1-不依赖编辑器\" class=\"headerlink\" title=\"1.不依赖编辑器\"></a>1.不依赖编辑器</h3><pre><code class=\"shell\"># 全局安装scss预处理器，使用终端命令实现编译\n\na. Node环境下的node-sass模块\nb. Node环境下的dart-sass模块\nc. Ruby环境下的sass模块\nd. Dart环境下的sass模块\n\n# 注：这里的推荐顺序针对的是&quot;练习&quot;场景，而开发环境下推荐使用的是dart-sass\n# 本质：某个语言的第三方库或者命令行工具\n</code></pre>\n<h3 id=\"2-依赖编辑器\"><a href=\"#2-依赖编辑器\" class=\"headerlink\" title=\"2.依赖编辑器\"></a>2.依赖编辑器</h3><pre><code>a. IDE代表：Webstrom\t前提是安装上述&quot;1&quot;中的命令行编译工具，配置自动命令，另安装一个代码提示插件scss\nb. 编辑器代表：vscode   安装Easy Sass（编译）和Sass（代码提示）两个插件\n</code></pre>\n<h3 id=\"二、安装步骤\"><a href=\"#二、安装步骤\" class=\"headerlink\" title=\"二、安装步骤\"></a>二、安装步骤</h3><h3 id=\"1-不依赖编辑器-1\"><a href=\"#1-不依赖编辑器-1\" class=\"headerlink\" title=\"1.不依赖编辑器\"></a>1.不依赖编辑器</h3><h4 id=\"😀-Node环境\"><a href=\"#😀-Node环境\" class=\"headerlink\" title=\"😀 Node环境\"></a>😀 Node环境</h4><h5 id=\"node-sass\"><a href=\"#node-sass\" class=\"headerlink\" title=\"- node-sass\"></a>- node-sass</h5><h6 id=\"a-安装\"><a href=\"#a-安装\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h6><pre><code class=\"shell\">1. 安装node  https://nodejs.org(官网) 或 https://npm.taobao.org/mirrors/node(镜像)\n2. *安装cnpm(不推荐直接将源换为淘宝镜像!!) $npm i -g cnpm --registry=https://registry.npm.taobao.org\n3. 安装node-sass $npm i -g node-sass  或  $cnpm i -g node-sass\n4. 检查是否安装成功$node-sass -v\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706124420782.png\" alt=\"/images/image-20200706124420782\"></p>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706132832305.png\" alt=\"/images/image-20200706132832305\"></p>\n<h6 id=\"b-使用\"><a href=\"#b-使用\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h6><ol>\n<li><p>单文件编译</p>\n<pre><code class=\"shell\">$node-sass  原有的scss文件 生成的css文件\n$node-sass  原有的scss文件 -o 生成目录\n\n# example:\n$node-sass a.scss b.css\n$node-sass a.scss css_files\n</code></pre>\n</li>\n<li><p>多文件编译</p>\n<pre><code class=\"shell\">$node-sass 原有的scss文件目录 -o 生成的css文件目录\n\n# example:\n$node-sass c -o d\n</code></pre>\n</li>\n<li><p>文件监听模式</p>\n<pre><code class=\"shell\"># 在&quot;1&quot;和&quot;2&quot;的基础上填加&quot;-w&quot;命令行参数即可\n$node-sass -w 原有的scss文件 -o 生成目录\n$node-sass -w 原有的scss文件目录 -o 生成的css文件目录\n\n# example:\n$node-sass -w scss -o css\n\n# 效果：编译进程不结束，监听文件内容\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706134612609.png\" alt=\"/images/image-20200706134612609\"></p>\n</li>\n</ol>\n<h5 id=\"dart-sass\"><a href=\"#dart-sass\" class=\"headerlink\" title=\"- dart-sass\"></a>- dart-sass</h5><h6 id=\"a-安装-1\"><a href=\"#a-安装-1\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h6><pre><code class=\"shell\">1. 安装node  https://nodejs.org(官网) 或 https://npm.taobao.org/mirrors/node(镜像)\n2. *安装cnpm(不推荐直接将源换为淘宝镜像!!) $npm i -g cnpm --registry=https://registry.npm.taobao.org\n3. 安装dart-sass $npm i -g sass  或  $cnpm i -g sass\n\n\n# 注：该模块为第三方库，所以可以考虑使用cnpm i sass -D(-D == --save-dev)仅对某个小项目当做开发时依赖进行使用\n</code></pre>\n<h6 id=\"b-使用-1\"><a href=\"#b-使用-1\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h6><pre><code class=\"js\">/* 该模块的官方文档：https://sass-lang.com/documentation/js-api */\n\n\nconst sass = require(&#39;sass&#39;);\n\nsass.render(&#123;file: scss_filename&#125;, function(err, result) &#123; /* ... */ &#125;);\n// OR\nconst result = sass.renderSync(&#123;file: scss_filename&#125;);\n\n// 注：默认情况下renderSync()的速度是render()的两倍以上，这是由于异步回调所带来的开销而导致的\n</code></pre>\n<hr>\n<h4 id=\"😀-Ruby环境\"><a href=\"#😀-Ruby环境\" class=\"headerlink\" title=\"😀 Ruby环境\"></a>😀 Ruby环境</h4><h5 id=\"a-安装-2\"><a href=\"#a-安装-2\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h5><pre><code class=\"shell\">1.安装Ruby\thttps://rubyinstaller.org/downloads\n2.*配置镜像\t$gem sources -a https://gems.ruby-china.com/ -r https://rubygems.org/\n3.*查看源 $gem sources -l # 确保只有gems.ruby-china.com一个源\n4.安装scss $gem install sass\n5.检查是否安装成功 $sass -v\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706141653304.png\" alt=\"/images/image-20200706141653304\"></p>\n<pre><code class=\"shell\">#注：如果出现了SSL错误，修改 ~/.gemrc 文件，增加 ssl_verify_mode: 0 配置\n# ~表示用户根目录，windows的文件位置为C:\\Users\\用户名\\.gemrc\n\n---\n:sources:\n- https://gems.ruby-china.com\n:ssl_verify_mode: 0\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706142100322.png\" alt=\"/images/image-20200706142100322\"></p>\n<h5 id=\"b-使用-2\"><a href=\"#b-使用-2\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h5><pre><code class=\"shell\"># 注：最好带上&quot;-C --sourcemap=none &quot;参数\n# 注：Sass 命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时 sass 命令默认编译 .sass 文件，添加 --scss 选项或者使用 scss 命令编译 SCSS 文件。\n</code></pre>\n<ol>\n<li><p>单文件编译</p>\n<pre><code class=\"shell\">$sass  原有的scss文件[:]生成的css文件\n\n# example:\n$sass a.scss b.css\n</code></pre>\n</li>\n<li><p>多文件编译</p>\n<pre><code class=\"shell\">$sass --watch 原有的scss文件目录:生成的css文件目录\n# 注：必须加&quot;--watch&quot;\n</code></pre>\n</li>\n<li><p>文件监听模式</p>\n<pre><code class=\"shell\">$sass --watch 原有的scss文件:生成的css文件\n$sass --watch 原有的scss文件目录:生成的css文件目录\n\n# example:\n$sass --watch -C --sourcemap=none scss:css\n\n# 效果：编译进程不结束，监听文件内容\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706143409397.png\" alt=\"/images/image-20200706143409397\"></p>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706164519533.png\" alt=\"/images/image-20200706164519533\"></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"😀-Dart环境\"><a href=\"#😀-Dart环境\" class=\"headerlink\" title=\"😀 Dart环境\"></a>😀 Dart环境</h4><h5 id=\"a-安装-3\"><a href=\"#a-安装-3\" class=\"headerlink\" title=\"a.安装\"></a>a.安装</h5><pre><code class=\"shell\">1.安装Dart\thttps://dart.dev/tools/sdk/archive\n2.*配置镜像，添加环境变量 https://pub.flutter-io.cn 或 https://mirrors.tuna.tsinghua.edu.cn/dart-pub/\nwindows打开此电脑,添加系统变量 PUB_HOSTED_URL=https://pub.flutter-io.cn\nLinux键入$echo &#39;export PUB_HOSTED_URL=&quot;https://pub.flutter-io.cn&quot;&#39; &gt;&gt; ~/.bashrc 或 /etc/profile\n\n4.安装sass\n全局安装：$pub global activate sass\t\t\t\t(可执行文件)\n项目安装：pubspec.yaml填写好依赖后，执行 $pub get\t  (.dart代码)\n5.检查是否安装成功$sass -v\n</code></pre>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706152755791.png\" alt=\"/images/image-20200706152755791\"></p>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706153705517.png\" alt=\"/images/image-20200706153705517\"></p>\n<h5 id=\"b-使用-3\"><a href=\"#b-使用-3\" class=\"headerlink\" title=\"b.使用\"></a>b.使用</h5><h6 id=\"全局安装模式\"><a href=\"#全局安装模式\" class=\"headerlink\" title=\"全局安装模式\"></a>全局安装模式</h6><ol>\n<li><p>单文件编译</p>\n<pre><code class=\"shell\">$sass  原有的scss文件[:]生成的css文件\n\n# example:\n$sass a.scss b.css\n</code></pre>\n</li>\n<li><p>多文件编译</p>\n<pre><code class=\"shell\">$sass 原有的scss文件目录/:生成的css文件目录/\n\n# example:\n$sass scss/:css/\n</code></pre>\n</li>\n<li><p>文件监听模式</p>\n<pre><code class=\"shell\">$sass --watch 原有的scss文件:生成的css文件\n$sass --watch 原有的scss文件目录:生成的css文件目录\n# 注：都必须加上&quot;:&quot;\n\n# example:\n$sass --watch scss:css\n\n# 效果：编译进程不结束，监听文件内容\n</code></pre>\n</li>\n</ol>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706160732312.png\" alt=\"/images/image-20200706160732312\"></p>\n<h6 id=\"局部安装模式\"><a href=\"#局部安装模式\" class=\"headerlink\" title=\"局部安装模式\"></a>局部安装模式</h6><pre><code class=\"dart\">2.运行.dart代码\n    // 前提是在pubsepc.yaml文件中添加依赖\n    // dev_dependencies:\n      //\t\tsass: lastest\n\n// main.dart\nimport &#39;package:sass/sass.dart&#39; as sass;\n\nvoid main(List&lt;String&gt; args) &#123;\n  print(sass.compile(args.first));\n&#125;\n// or\nvoid main(List&lt;String&gt; args) &#123;\n  var result = sass.compile(arguments[0]);\n  new File(arguments[1]).writeAsStringSync(result);\n&#125;\n// dart main.dart styles.scss styles.css\n</code></pre>\n<hr>\n<h3 id=\"2-依赖编辑器-1\"><a href=\"#2-依赖编辑器-1\" class=\"headerlink\" title=\"2.依赖编辑器\"></a>2.依赖编辑器</h3><h4 id=\"😀-WebStrom\"><a href=\"#😀-WebStrom\" class=\"headerlink\" title=\"😀 WebStrom\"></a>😀 WebStrom</h4><ul>\n<li>安装上述命令行工具之一（以node-sass为例演示）</li>\n<li>依次打开并点击：webstrom -&gt; Settings -&gt; Tools -&gt; Files Watchers -&gt; + -&gt; 选择SCSS文件标识</li>\n<li>Name随意写，供自己看而已</li>\n<li>File Type选择SCSS Style Sheet </li>\n<li>Scope选择All Places</li>\n<li>Program选择可执行文件的路径（这里以node-sass为例）</li>\n<li>Arguments按需选择（这里以*$FileName$:$FileNameWithoutExtension$.css*为例）</li>\n<li>Output paths to refresh按需选择（这里以*$FileNameWithoutExtension$.css*为例）</li>\n<li>点击OK，配置完成</li>\n</ul>\n<h4 id=\"😀-VSCode\"><a href=\"#😀-VSCode\" class=\"headerlink\" title=\"😀 VSCode\"></a>😀 VSCode</h4><ul>\n<li>安装Easy Sass（编译）和Sass（代码提示）两个插件（注意大小写，否则找不到）</li>\n<li>点击插件右下角的设置图标后点击”扩展设置”，最后点击”在settings.json中编辑”，开始设置关于Easy Sass的配置</li>\n<li>会自动生成下方图片内的配置</li>\n</ul>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706185328878.png\" alt=\"/images/image-20200706185328878\"></p>\n<ul>\n<li>添加*”easysass.targetDir”: $path<em>，可将编译后的css文件放入</em>$path*路径下(默认为当前路径)。例如生成到css文件下内</li>\n</ul>\n<p><img data-src=\"H:\\record\\前端\\css预编译器\\scss\\sources.assets\\image-20200706185722811.png\" alt=\"/images/image-20200706185722811\"></p>\n<h3 id=\"实战配置-安装sass\"><a href=\"#实战配置-安装sass\" class=\"headerlink\" title=\"实战配置(安装sass)\"></a>实战配置(安装sass)</h3><blockquote>\n<p>以上述方法配置会造成卡顿,这个方法安装sass进行监听</p>\n</blockquote>\n<pre><code>$FileName$ $FileNameWithoutExtension$.css\n$FileNameWithoutExtension$.css\n或者 -     sass --watch x.scss index.css\n</code></pre>\n<h1 id=\"Scss语法\"><a href=\"#Scss语法\" class=\"headerlink\" title=\"Scss语法\"></a>Scss语法</h1><blockquote>\n<p>本人笔记地址分享:<a href=\"https://gitee.com/hongjilin/hongs-study-notes\"><code>全部笔记</code></a>、<a href=\"https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Scss%E7%AC%94%E8%AE%B0\"><code>Sass所有学习笔记</code></a></p>\n</blockquote>\n<h3 id=\"目录-1\"><a href=\"#目录-1\" class=\"headerlink\" title=\"#目录\"></a>#目录</h3><blockquote>\n<p>[TOC]</p>\n</blockquote>\n<h3 id=\"SassScript\"><a href=\"#SassScript\" class=\"headerlink\" title=\"SassScript\"></a>SassScript</h3><blockquote>\n<p>在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。</p>\n<p>弱类型语言, 对语法要求没那么严格</p>\n</blockquote>\n<h4 id=\"一、注释\"><a href=\"#一、注释\" class=\"headerlink\" title=\"一、注释\"></a>一、注释</h4><blockquote>\n<ol>\n<li><p>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释 <code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</p>\n</li>\n<li><p>将 <code>!</code> 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p>\n</li>\n<li><p>插值语句 (interpolation) 也可写进多行注释中输出变量值</p>\n</li>\n</ol>\n<p>  例如：</p>\n<pre><code class=\"scss\">// compile scss files to css\n// it&#39;s ready to do it.\n$pink: #f3e1e1;\nhtml&#123;\n   background-color: $pink;\n&#125;\n\n$author: &#39;gdream@126.com&#39;;\n/*!\nAuthor: #&#123;$author&#125;.\n*/\n</code></pre>\n<p>开发模式编译后:</p>\n<pre><code class=\"css\">/* \nhello\nworld!\n*/\nhtml&#123;\n   background-color: #f3e1e1;\n&#125;\n/*!\nAuthor: &#39;gdream@126.com&#39;.\n*/\n</code></pre>\n<p>压缩输出模式编译后：</p>\n<pre><code class=\"css\">html&#123;\n   background-color: #f3e1e1;\n&#125;\n/*!\nAuthor: &#39;gdream@126.com&#39;.\n*/\n</code></pre>\n</blockquote>\n<hr>\n<h4 id=\"二、变量\"><a href=\"#二、变量\" class=\"headerlink\" title=\"二、变量\"></a>二、变量</h4><h6 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h6><blockquote>\n<p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p>\n</blockquote>\n<pre><code class=\"scss\">$width: 1600px;\n$pen-size: 3em;\n</code></pre>\n<h6 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h6><blockquote>\n<p>直接使用变量的名称即可调用变量</p>\n</blockquote>\n<pre><code class=\"scss\">#app &#123;\n    height: $width;\n    font-size: $pen-size;\n&#125;\n</code></pre>\n<h6 id=\"3-作用域\"><a href=\"#3-作用域\" class=\"headerlink\" title=\"3.作用域\"></a>3.作用域</h6><blockquote>\n<p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明</p>\n</blockquote>\n<pre><code class=\"scss\">#foo &#123;\n  $width: 5em !global;\n  width: $width;\n&#125;\n\n#bar &#123;\n  width: $width;\n&#125;\n</code></pre>\n<p>编译后：</p>\n<pre><code class=\"css\">#foo &#123;\n  width: 5em;\n&#125;\n\n#bar &#123;\n  width: 5em;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"三、数据类型\"><a href=\"#三、数据类型\" class=\"headerlink\" title=\"三、数据类型\"></a>三、数据类型</h4><blockquote>\n<p>SassScript 支持 7 种主要的数据类型：</p>\n<ul>\n<li>数字，<code>1, 2, 13, 10px</code></li>\n<li>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></li>\n<li>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)</code></li>\n<li>布尔型，<code>true, false</code></li>\n<li>空值，<code>null</code></li>\n<li>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></li>\n<li>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></li>\n</ul>\n<p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p>\n<p>判断数据类型的方式：<code>type-of($value)</code></p>\n</blockquote>\n<h6 id=\"1-字符串-Strings\"><a href=\"#1-字符串-Strings\" class=\"headerlink\" title=\"1.字符串 (Strings)\"></a>1.字符串 (Strings)</h6><blockquote>\n<p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p>\n</blockquote>\n<pre><code class=\"scss\">$name: &#39;Tom Bob&#39;;\n$container: &quot;top bottom&quot;;\n$what: heart;\n\n// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#&#123;&#125;` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名\n</code></pre>\n<h6 id=\"2-数字-Numbers\"><a href=\"#2-数字-Numbers\" class=\"headerlink\" title=\"2.数字(Numbers)\"></a>2.数字(Numbers)</h6><blockquote>\n<h6 id=\"SassScript支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\"><a href=\"#SassScript支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\" class=\"headerlink\" title=\"SassScript支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\"></a>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可正可浮点）</h6></blockquote>\n<pre><code class=\"scss\">$my-age: 19;\n$your-age: 19.5;\n$height: 120px;\n\n// 注：单位会和数字当做一个整体，进行算数运算\n</code></pre>\n<h6 id=\"3-空值-Null\"><a href=\"#3-空值-Null\" class=\"headerlink\" title=\"3.空值(Null)\"></a>3.空值(Null)</h6><blockquote>\n<p>只有一个取值<code>null</code></p>\n</blockquote>\n<pre><code class=\"scss\">$value: null;\n\n// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算\n</code></pre>\n<h6 id=\"4-布尔型-Booleans\"><a href=\"#4-布尔型-Booleans\" class=\"headerlink\" title=\"4.布尔型(Booleans)\"></a>4.布尔型(Booleans)</h6><blockquote>\n<p>只有两个取值：<code>true</code>和<code>false</code></p>\n</blockquote>\n<pre><code class=\"scss\">$a: true;\n$b: false;\n\n// 注：只有自身是false和null才会返回false，其他一切都将返回true\n</code></pre>\n<h6 id=\"5-数组-Lists\"><a href=\"#5-数组-Lists\" class=\"headerlink\" title=\"5.数组 (Lists)\"></a>5.数组 (Lists)</h6><blockquote>\n<p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p>\n</blockquote>\n<pre><code class=\"scss\">$list0: 1px 2px 5px 6px;\n$list1: 1px 2px, 5px 6px;\n$list2: (1px 2px) (5px 6px);\n</code></pre>\n<blockquote>\n<p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p>\n<p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p>\n<p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p>\n<p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p>\n</blockquote>\n<h3 id=\"6-映射-Maps\"><a href=\"#6-映射-Maps\" class=\"headerlink\" title=\"6.映射(Maps)\"></a>6.映射(Maps)</h3><blockquote>\n<p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p>\n</blockquote>\n<pre><code class=\"scss\">$map: ( \n  $key1: value1, \n  $key2: value2, \n  $key3: value3 \n)\n</code></pre>\n<h3 id=\"7-颜色-Colors\"><a href=\"#7-颜色-Colors\" class=\"headerlink\" title=\"7.颜色 (Colors)\"></a>7.颜色 (Colors)</h3><blockquote>\n<p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词</p>\n<p>SCSS提供了内置Colors函数，从而更方便地使用颜色</p>\n</blockquote>\n<pre><code class=\"scss\">$color0: green;\n$color1: lighten($color, 15%);\n$color2: darken($color, 15%);\n$color3: saturate($color, 15%);\n$color4: desaturate($color, 15%);\n$color5: (green + red);\n</code></pre>\n<hr>\n<h4 id=\"四、运算\"><a href=\"#四、运算\" class=\"headerlink\" title=\"四、运算\"></a>四、运算</h4><h3 id=\"1-数字运算符\"><a href=\"#1-数字运算符\" class=\"headerlink\" title=\"1.数字运算符\"></a>1.数字运算符</h3><blockquote>\n<p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p>\n<p>如果要保留运算符号，则应该使用插值语法</p>\n</blockquote>\n<ul>\n<li><p><code>+</code></p>\n<pre><code class=\"scss\">// 纯数字\n$add1: 1 + 2;\t// 3\n$add2: 1 + 2px; // 3px\n$add3: 1px + 2; // 3px\n$add4: 1px + 2px;//3px\n\n// 纯字符串\n$add5: &quot;a&quot; + &quot;b&quot;; // &quot;ab&quot;\n$add6: &quot;a&quot; + b;\t  // &quot;ab&quot;\n$add7: a + &quot;b&quot;;\t  // ab\n$add8: a + b;\t  // ab\n\n// 数字和字符串\n$add9: 1 + a;\t// 1a\n$adda: a + 1;\t// a1\n$addb: &quot;1&quot; + a; // &quot;1a&quot;\n$addc: 1 + &quot;a&quot;; // &quot;1a&quot;\n$addd: &quot;a&quot; + 1; // &quot;a1&quot;\n$adde: a + &quot;1&quot;; // a1\n$addf: 1 + &quot;1&quot;; // &quot;11&quot;\n</code></pre>\n<pre><code class=\"scss\">// 总结：\na.纯数字：只要有单位，结果必有单位\nb.纯字符串：第一个字符串有无引号决定结果是否有引号\nc数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号\n</code></pre>\n</li>\n<li><p><code>-</code></p>\n<pre><code class=\"scss\">$add1: 1 - 2;\t// -1\n$add2: 1 - 2px; // -1px\n$add3: 1px - 2; // -1px\n$add4: 1px - 2px;//-1px\n\n$sub1: a - 1;  // a-1\n$sub2: 1 - a;  // 1-a\n$sub3: &quot;a&quot; - 1;// &quot;a&quot;-1\n$sub4: a - &quot;1&quot;;// a-&quot;1&quot;\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。\n只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来\n</code></pre>\n</li>\n<li><p><code>*</code></p>\n<pre><code class=\"scss\">$num1: 1 * 2;    // 2\n$mul2: 1 * 2px;  // 2px\n$num3: 1px * 2;  // 2px\n$num4: 2px * 2px;// 编译不通过\n\n$num5: 1 * 2abc; // 2abc\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过\n</code></pre>\n</li>\n<li><p><code>/</code></p>\n<pre><code class=\"scss\">// 总结：\na.不会四舍五入，精确到小数点后5位\nb.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。\n(因为此时后缀被当被单位看待了)\n</code></pre>\n</li>\n<li><p><code>%</code></p>\n<pre><code class=\"scss\">// 总结：\na.值与&quot;%&quot;之间必须要有空格，否则会被看做字符串\n</code></pre>\n</li>\n</ul>\n<h3 id=\"2-关系运算符\"><a href=\"#2-关系运算符\" class=\"headerlink\" title=\"2.关系运算符\"></a>2.关系运算符</h3><blockquote>\n<p>大前提：两端必须为<code>数字</code> 或 <code>前部分数字后部分字符</code></p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n</blockquote>\n<ul>\n<li><p><code>&gt;</code></p>\n<pre><code class=\"scss\">$a: 1 &gt; 2; // false\n</code></pre>\n</li>\n<li><p><code>&lt;</code></p>\n<pre><code class=\"scss\">$a: 1 &gt; 2; // true\n</code></pre>\n</li>\n<li><p><code>&gt;=</code></p>\n<pre><code class=\"scss\">$a: 1 &gt;= 2; // false\n</code></pre>\n</li>\n<li><p><code>&lt;=</code></p>\n<pre><code class=\"scss\">$a: 1 &lt;= 2; // true\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-相等运算符\"><a href=\"#3-相等运算符\" class=\"headerlink\" title=\"3.相等运算符\"></a>3.相等运算符</h3><blockquote>\n<p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p>\n<p>返回值：<code>true</code> or <code>false</code></p>\n</blockquote>\n<pre><code class=\"scss\">$a: 1 == 1px; // true\n$b: &quot;a&quot; == a; // true\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应\n</code></pre>\n<h3 id=\"4-布尔运算符\"><a href=\"#4-布尔运算符\" class=\"headerlink\" title=\"4.布尔运算符\"></a>4.布尔运算符</h3><blockquote>\n<p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p>\n</blockquote>\n<pre><code class=\"scss\">$a: 1&gt;0 and 0&gt;=5; // fasle\n</code></pre>\n<pre><code class=\"scss\">// 总结：\n值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串\n</code></pre>\n<h3 id=\"5-颜色值运算\"><a href=\"#5-颜色值运算\" class=\"headerlink\" title=\"5.颜色值运算\"></a>5.颜色值运算</h3><blockquote>\n<p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p>\n</blockquote>\n<ul>\n<li><p><code>颜色值与颜色值</code></p>\n<pre><code class=\"scss\">p &#123;\n  color: #010203 + #040506;\n&#125;\n\n// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n// p &#123;\n  color: #050709; &#125;\n</code></pre>\n</li>\n<li><p><code>颜色值与数字</code></p>\n<pre><code class=\"scss\">p &#123;\n  color: #010203 * 2;\n&#125;\n\n// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为\n// p &#123;\n  color: #020406; &#125;\n</code></pre>\n</li>\n<li><p><code>RGB和HSL</code></p>\n<pre><code class=\"scss\">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n\np &#123;\n  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n&#125;\n\n// p &#123;\n  color: rgba(255, 255, 0, 0.75); &#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"6-运算优先级\"><a href=\"#6-运算优先级\" class=\"headerlink\" title=\"6.运算优先级\"></a>6.运算优先级</h3><ol start=\"0\">\n<li><p><code>()</code></p>\n</li>\n<li><p><code>*</code>、<code>/</code>、<code>%</code></p>\n</li>\n<li><p><code>+</code>、<code>-</code></p>\n</li>\n<li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"五、嵌套语法\"><a href=\"#五、嵌套语法\" class=\"headerlink\" title=\"五、嵌套语法\"></a>五、嵌套语法</h4><blockquote>\n<p>此部分不计入笔记</p>\n</blockquote>\n<hr>\n<h4 id=\"六、杂货语法\"><a href=\"#六、杂货语法\" class=\"headerlink\" title=\"六、杂货语法\"></a>六、杂货语法</h4><h3 id=\"1-插值语法\"><a href=\"#1-插值语法\" class=\"headerlink\" title=\"1.插值语法\"></a>1.<code>插值语法</code></h3><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p>\n<p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p>\n<pre><code class=\"scss\">$name: foo;\n$attr: border;\np.#&#123;$name&#125; &#123;\n  #&#123;$attr&#125;-color: $name;\n&#125;\n\n// 编译后：\np.foo &#123;\n  border-color: foo;\n&#125;\n</code></pre>\n<h3 id=\"2-amp-in-SassScript\"><a href=\"#2-amp-in-SassScript\" class=\"headerlink\" title=\"2.&amp; in SassScript\"></a>2.<code>&amp; in SassScript</code></h3><p><code>&amp;</code>为父选择器</p>\n<pre><code class=\"scss\">a &#123;\n    color: yellow;\n    &amp;:hover&#123;\n        color: green;\n    &#125;\n    &amp;:active&#123;\n        color: blank;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-default\"><a href=\"#3-default\" class=\"headerlink\" title=\"3.!default\"></a>3.<code>!default</code></h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p>\n<pre><code class=\"scss\">$content: &quot;First content&quot;;\n$content: &quot;Second content?&quot; !default;\n$new_content: &quot;First time reference&quot; !default;\n\n#main &#123;\n  content: $content;\n  new-content: $new_content;\n&#125;\n\n// 编译为：\n#main &#123;\n  content: &quot;First content&quot;;\n  new-content: &quot;First time reference&quot;; &#125;\n</code></pre>\n<p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。</p>\n<h3 id=\"3-global\"><a href=\"#3-global\" class=\"headerlink\" title=\"3.!global\"></a>3.<code>!global</code></h3><p>将局部变量提升为全局变量</p>\n<h3 id=\"4-optional\"><a href=\"#4-optional\" class=\"headerlink\" title=\"4.!optional\"></a>4.<code>!optional</code></h3><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123;@extend .notice&#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p>\n<p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的.</p>\n<p>简而言之：当<code>@extend</code>相关代码出现语法错误时，编译器可能会给我们”乱”编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码</p>\n<hr>\n<h4 id=\"七、-Rules与指令\"><a href=\"#七、-Rules与指令\" class=\"headerlink\" title=\"七、@-Rules与指令\"></a>七、@-Rules与指令</h4><h3 id=\"1-import\"><a href=\"#1-import\" class=\"headerlink\" title=\"1.@import\"></a>1.<code>@import</code></h3><blockquote>\n<p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p>\n<p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p>\n<ul>\n<li>文件拓展名是 <code>.css</code>；</li>\n<li>文件名以 <code>http://</code> 开头；</li>\n<li>文件名是 <code>url()</code>；</li>\n<li><code>@import</code> 包含 media queries。</li>\n</ul>\n<p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p>\n</blockquote>\n<pre><code class=\"scss\">@import &quot;foo.scss&quot;;\n@import &quot;foo&quot;;\n// 以上两种方式均可\n\n\n// 以下方式均不可行\n@import &quot;foo.css&quot;;\n@import &quot;foo&quot; screen;\n@import &quot;http://foo.com/bar&quot;;\n@import url(foo);\n</code></pre>\n<blockquote>\n<p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p>\n</blockquote>\n<pre><code class=\"scss\">@import &quot;rounded-corners&quot;, &quot;text-shadow&quot;;\n</code></pre>\n<blockquote>\n<p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式：</p>\n</blockquote>\n<pre><code class=\"scss\">$family: unquote(&quot;Droid+Sans&quot;);\n@import url(&quot;http://fonts.googleapis.com/css?family=\\#&#123;$family&#125;&quot;);\n\n// 编译为：\n@import url(&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;);\n</code></pre>\n<blockquote>\n<p>如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p>\n<p>除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p>\n</blockquote>\n<h3 id=\"2-media\"><a href=\"#2-media\" class=\"headerlink\" title=\"2.@media\"></a>2.<code>@media</code></h3><blockquote>\n<p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p>\n</blockquote>\n<pre><code class=\"scss\">.sidebar &#123;\n  width: 300px;\n  @media screen and (orientation: landscape) &#123;\n    width: 500px;\n  &#125;\n&#125;\n// 编译为\n.sidebar &#123;\n  width: 300px;\n  @media screen and (orientation: landscape) &#123;\n    width: 500px;\n  &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p>\n</blockquote>\n<pre><code class=\"scss\">@media screen &#123;\n  .sidebar &#123;\n    @media (orientation: landscape) &#123;\n      width: 500px;\n    &#125;\n  &#125;\n&#125;\n// 编译为：\n@media screen and (orientation: landscape) &#123;\n  .sidebar &#123;\n    width: 500px; &#125; &#125;\n</code></pre>\n<blockquote>\n<p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p>\n</blockquote>\n<pre><code class=\"scss\">$media: screen;\n$feature: -webkit-min-device-pixel-ratio;\n$value: 1.5;\n\n@media #&#123;$media&#125; and ($feature: $value) &#123;\n  .sidebar &#123;\n    width: 500px;\n  &#125;\n&#125;\n// 编译为：\n@media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123;\n  .sidebar &#123;\n    width: 500px; &#125; &#125;\n</code></pre>\n<h3 id=\"3-extend\"><a href=\"#3-extend\" class=\"headerlink\" title=\"3.*@extend\"></a>3.<code>*@extend</code></h3><blockquote>\n<p><code>@extend</code>即<code>继承</code>。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。</p>\n<p>总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）</p>\n</blockquote>\n<p>a. <code>基本延伸</code></p>\n<pre><code class=\"scss\">.error &#123;\n  border: 1px #f00;\n  background-color: #fdd;\n&#125;\n.seriousError &#123;\n  @extend .error;\n  border-width: 3px;\n&#125;\n// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n</code></pre>\n<blockquote>\n<p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）</p>\n</blockquote>\n<p>注意理解以下情况：</p>\n<pre><code class=\"scss\">.error &#123;\n  border: 1px #f00;\n  background-color: #fdd;\n&#125;\n.error.intrusion &#123;\n  background-image: url(&quot;/image/hacked.png&quot;);\n&#125;\n.seriousError &#123;\n  @extend .error;\n  border-width: 3px;\n&#125;\n// .error, .seriousError &#123;\n  border: 1px #f00;\n  background-color: #fdd; &#125;\n\n.error.intrusion, .seriousError.intrusion &#123;\n  background-image: url(&quot;/image/hacked.png&quot;); &#125;\n\n.seriousError &#123;\n  border-width: 3px; &#125;\n</code></pre>\n<blockquote>\n<p>当合并选择器时，<code>@extend</code> 会很聪明地避免无谓的重复，<code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code>，不能匹配任何元素的选择器也会删除。</p>\n</blockquote>\n<p>b.  <code>延伸复杂的选择器</code>：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等</p>\n<p>c. <code> 多重延伸</code>：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器</p>\n<p>d. <code>继续延伸</code>：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个</p>\n<p>e.<code>*选择器列</code>：暂时不可以将选择器列 (Selector Sequences)，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code>，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。</p>\n<p>尽量不使用<code>合并选择器列</code>，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。</p>\n<ol>\n<li><p>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前</p>\n<pre><code class=\"scss\">#admin .tabbar a &#123;\n  font-weight: bold;\n&#125;\n#demo .overview .fakelink &#123;\n  @extend a;\n&#125;\n// 编译为：\n#admin .tabbar a,\n#admin .tabbar #demo .overview .fakelink,\n#demo .overview #admin .tabbar .fakelink &#123;\n  font-weight: bold; &#125;\n</code></pre>\n</li>\n<li><p>如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出</p>\n<pre><code class=\"scss\">#admin .tabbar a &#123;\n  font-weight: bold;\n&#125;\n#admin .overview .fakelink &#123;\n  @extend a;\n&#125;\n// 编译为\n#admin .tabbar a,\n#admin .tabbar .overview .fakelink,\n#admin .overview .tabbar .fakelink &#123;\n  font-weight: bold; &#125;\n</code></pre>\n</li>\n</ol>\n<p>f. <code>在指令中延伸</code></p>\n<p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS.</p>\n<p>g.  <code>%placeholder</code>为选择器占位符，配合<code>@extend-Only选择器</code>使用。</p>\n<p>效果：只定义了样式，但不会对原有选择器匹配的元素生效</p>\n<pre><code class=\"scss\">// example1:\n%img &#123;\n    color: red;\n&#125;\n.path&#123;\n    @extend %img;\n&#125;\n// 编译后：\n.path &#123;\n  color: red;\n&#125;\n</code></pre>\n<pre><code class=\"scss\">// example2:\n#context a%extreme &#123;\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n&#125;\n// 编译后：\n.notice &#123;\n  @extend %extreme;\n&#125;\n\n// 注：必须是&quot;.&quot;和&quot;#&quot;选择器\n</code></pre>\n<h3 id=\"4-at-root\"><a href=\"#4-at-root\" class=\"headerlink\" title=\"4.@at-root\"></a>4.<code>@at-root</code></h3><blockquote>\n<p>The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector</p>\n<p>译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用</p>\n<p>且@at-root 使多个规则跳出嵌套</p>\n<p>@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题</p>\n<p>了解即可</p>\n</blockquote>\n<h3 id=\"5-debug\"><a href=\"#5-debug\" class=\"headerlink\" title=\"5.@debug\"></a>5.<code>@debug</code></h3><p>用于调试，按标准错误输出流输出</p>\n<pre><code class=\"scss\">$size: 9px;\n\n.file&#123;\n  @debug $size;\n&#125;\n</code></pre>\n<h3 id=\"6-warn\"><a href=\"#6-warn\" class=\"headerlink\" title=\"6.@warn\"></a>6.<code>@warn</code></h3><p>用于警告，按标准错误输出流输出</p>\n<h3 id=\"7-error\"><a href=\"#7-error\" class=\"headerlink\" title=\"7.@error\"></a>7.<code>@error</code></h3><p>用于报错，按标准错误输出流输出</p>\n<table>\n<thead>\n<tr>\n<th>序列</th>\n<th>@-rules</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>@import</td>\n<td>导入sass或scss文件</td>\n</tr>\n<tr>\n<td>2</td>\n<td>@media</td>\n<td>用于将样式规则设置为不同的媒体类型</td>\n</tr>\n<tr>\n<td>3</td>\n<td>@extend</td>\n<td>以继承的方式共享选择器</td>\n</tr>\n<tr>\n<td>4</td>\n<td>@at-root</td>\n<td>转到根节点</td>\n</tr>\n<tr>\n<td>5</td>\n<td>@debug</td>\n<td>用于调试，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>6</td>\n<td>@warn</td>\n<td>用于警告，按标准错误输出流输出</td>\n</tr>\n<tr>\n<td>7</td>\n<td>@error</td>\n<td>用于报错，按标准错误输出流输出</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"八、控制指令\"><a href=\"#八、控制指令\" class=\"headerlink\" title=\"八、控制指令\"></a>八、控制指令</h4><h3 id=\"1-if\"><a href=\"#1-if\" class=\"headerlink\" title=\"1.if()\"></a>1.<code>if()</code></h3><p><em>三元运算符</em></p>\n<p>表达式：<code>if(expression, value1, value2)</code></p>\n<pre><code class=\"scss\">p &#123;\n    color: if(1 + 1 = 2, green, yellow);\n&#125;\n\n// compile:\np&#123;\n    color: green;&#125;\n</code></pre>\n<h3 id=\"2-if\"><a href=\"#2-if\" class=\"headerlink\" title=\"2.@if\"></a>2.<code>@if</code></h3><p><em>条件语句</em></p>\n<p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p>\n<p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p>\n<ul>\n<li><p><code>单@if</code></p>\n<pre><code class=\"scss\">  p &#123;\n      @if 1 + 1 == 2 &#123;\n          color: red;\n      &#125;\n  &#125;\n\n  // compile:\n  p &#123;\n    color: red;\n  &#125;\n</code></pre>\n</li>\n<li><p><code>@if - @else</code></p>\n<pre><code class=\"scss\">p &#123;\n    @if 1 + 1 != 2 &#123;\n        color: red;\n    &#125; @else &#123;\n        color: blue;\n    &#125;\n&#125;\n\n// compile:\np &#123;\n  color: blue;\n&#125;\n</code></pre>\n</li>\n<li><p><code>@if - @else if - @else</code></p>\n<pre><code class=\"scss\">$age: 19;\n\np &#123;\n    @if $age == 18 &#123;\n        color: red;\n    &#125; @else if $age == 19 &#123;\n        color: blue;\n    &#125; @else &#123;\n        color: green;\n    &#125;\n&#125;\n\n// compile:\np &#123;\n  color: blue;\n&#125;\n</code></pre>\n</li>\n</ul>\n<h3 id=\"3-for\"><a href=\"#3-for\" class=\"headerlink\" title=\"3.@for\"></a>3.<code>@for</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p>\n<p>through 和 to 的相同点与不同点：</p>\n<ul>\n<li>相同点：两者均包含<start>的值</li>\n<li>不同点：through包含<end>的值，但to不包含<end>的值</li>\n</ul>\n<pre><code class=\"scss\">@for $i from 1 through 3 &#123;\n  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;\n&#125;\n\n// compile:\n.item-1 &#123;\n  width: 2em; &#125;\n.item-2 &#123;\n  width: 4em; &#125;\n.item-3 &#123;\n  width: 6em; &#125;\n</code></pre>\n<h3 id=\"4-while\"><a href=\"#4-while\" class=\"headerlink\" title=\"4.@while\"></a>4.<code>@while</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>@while expression</code></p>\n<p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到</p>\n<pre><code class=\"scss\">$i: 6;\n@while $i &gt; 0 &#123;\n  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;\n  $i: $i - 2;\n&#125;\n\n// compile:\n.item-6 &#123;\n  width: 12em; &#125;\n.item-4 &#123;\n  width: 8em; &#125;\n.item-2 &#123;\n  width: 4em; &#125;\n</code></pre>\n<h3 id=\"5-each\"><a href=\"#5-each\" class=\"headerlink\" title=\"5.@each\"></a>5.<code>@each</code></h3><p><em>循环语句</em></p>\n<p>表达式：<code>$var in $vars</code></p>\n<p><code>$var</code> 可以是任何变量名</p>\n<p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p>\n<ul>\n<li><p>一维列表</p>\n<pre><code class=\"scss\">@each $animal in puma, sea-slug, egret, salamander &#123;\n  .#&#123;$animal&#125;-icon &#123;\n    background-image: url(&#39;/images/#&#123;$animal&#125;.png&#39;);\n  &#125;\n&#125;\n\n// compile:\n.puma-icon &#123;\n  background-image: url(&#39;/images/puma.png&#39;); &#125;\n.sea-slug-icon &#123;\n  background-image: url(&#39;/images/sea-slug.png&#39;); &#125;\n.egret-icon &#123;\n  background-image: url(&#39;/images/egret.png&#39;); &#125;\n.salamander-icon &#123;\n  background-image: url(&#39;/images/salamander.png&#39;); &#125;\n</code></pre>\n</li>\n<li><p>二维列表</p>\n<pre><code class=\"scss\">@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) &#123;\n  .#&#123;$animal&#125;-icon &#123;\n    background-image: url(&#39;/images/#&#123;$animal&#125;.png&#39;);\n    border: 2px solid $color;\n    cursor: $cursor;\n  &#125;\n&#125;\n\n// compile:\n.puma-icon &#123;\n  background-image: url(&#39;/images/puma.png&#39;);\n  border: 2px solid black;\n  cursor: default; &#125;\n.sea-slug-icon &#123;\n  background-image: url(&#39;/images/sea-slug.png&#39;);\n  border: 2px solid blue;\n  cursor: pointer; &#125;\n.egret-icon &#123;\n  background-image: url(&#39;/images/egret.png&#39;);\n  border: 2px solid white;\n  cursor: move; &#125;\n</code></pre>\n</li>\n<li><p>maps</p>\n<pre><code class=\"scss\">@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123;\n  #&#123;$header&#125; &#123;\n    font-size: $size;\n  &#125;\n&#125;\n\n// compile:\nh1 &#123;\n  font-size: 2em; &#125;\nh2 &#123;\n  font-size: 1.5em; &#125;\nh3 &#123;\n  font-size: 1.2em; &#125;\n</code></pre>\n</li>\n</ul>\n<hr>\n<h4 id=\"九、混合指令\"><a href=\"#九、混合指令\" class=\"headerlink\" title=\"九、混合指令\"></a>九、混合指令</h4><blockquote>\n<p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p>\n</blockquote>\n<p>注意：这不是函数！没有返回值！！</p>\n<h3 id=\"1-定义混合指令\"><a href=\"#1-定义混合指令\" class=\"headerlink\" title=\"1.定义混合指令\"></a>1.定义混合指令</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p>\n<pre><code class=\"scss\">// 格式：\n@mixin name &#123;\n    // 样式....\n&#125;\n</code></pre>\n<pre><code class=\"scss\">// example：\n@mixin large-text &#123;\n  font: &#123;\n    family: Arial;\n    size: 20px;\n    weight: bold;\n  &#125;\n  color: #ff0000;\n&#125;\n</code></pre>\n<h3 id=\"2-引用混合样式\"><a href=\"#2-引用混合样式\" class=\"headerlink\" title=\"2.引用混合样式\"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p>\n<pre><code class=\"scss\">// 格式：\n@include name;\n\n// 注：无参数或参数都有默认值时，带不带括号都可以\n</code></pre>\n<pre><code class=\"scss\">// example：\np &#123;\n    @include large-text;\n&#125;\n\n// compile:\np &#123;\n  font-family: Arial;\n  font-size: 20px;\n  font-weight: bold;\n  color: #ff0000;\n&#125;\n</code></pre>\n<h3 id=\"3-参数\"><a href=\"#3-参数\" class=\"headerlink\" title=\"3.参数\"></a>3.参数</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p>\n<p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p>\n<h4 id=\"a-位置传参\"><a href=\"#a-位置传参\" class=\"headerlink\" title=\"a. 位置传参\"></a>a. 位置传参</h4><pre><code class=\"scss\">@mixin mp($width) &#123;\n    margin: $width;\n&#125;\n\nbody &#123;\n    @include mp(300px);\n&#125;\n</code></pre>\n<h4 id=\"b-关键词传参\"><a href=\"#b-关键词传参\" class=\"headerlink\" title=\"b.关键词传参\"></a>b.关键词传参</h4><pre><code class=\"scss\">@mixin mp($width) &#123;\n    margin: $width;\n&#125;\n\nbody &#123;\n    @include mp($width: 300px);\n&#125;\n</code></pre>\n<h4 id=\"c-参数默认值\"><a href=\"#c-参数默认值\" class=\"headerlink\" title=\"c.参数默认值\"></a>c.参数默认值</h4><pre><code class=\"scss\">@mixin mp($width: 500px) &#123;\n    margin: $width;\n&#125;\n\nbody &#123;\n    @include mp($width: 300px);\n    // or\n    @include mp(300px);\n&#125;\n</code></pre>\n<h4 id=\"d-不定参数\"><a href=\"#d-不定参数\" class=\"headerlink\" title=\"d.不定参数\"></a>d.不定参数</h4><blockquote>\n<p>官方：Variable Arguments</p>\n<p>译文：参数变量</p>\n<p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理</p>\n</blockquote>\n<pre><code class=\"scss\">@mixin mar($value...) &#123;\n    margin: $value;\n&#125;\n</code></pre>\n<h3 id=\"4-向混合样式中导入内容\"><a href=\"#4-向混合样式中导入内容\" class=\"headerlink\" title=\"4.向混合样式中导入内容\"></a>4.向混合样式中导入内容</h3><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方</p>\n<p>可以看作参数的升级版</p>\n<pre><code class=\"scss\">@mixin example &#123;\n    html &#123;\n        @content;\n    &#125;\n&#125;\n@include example&#123;\n    background-color: red;\n    .logo &#123;\n        width: 600px;\n    &#125;\n&#125;\n\n// compile:\nhtml &#123;\n  background-color: red;\n&#125;\n\nhtml .logo &#123;\n  width: 600px;\n&#125;\n</code></pre>\n<h3 id=\"5-混合指令用例\"><a href=\"#5-混合指令用例\" class=\"headerlink\" title=\"5.混合指令用例\"></a>5.混合指令用例</h3><blockquote>\n<p><img data-src=\"/A_SassScript%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%E7%94%A8%E4%BE%8B.png\" alt=\"混合指令用例\"></p>\n</blockquote>\n<hr>\n<h4 id=\"十、函数指令\"><a href=\"#十、函数指令\" class=\"headerlink\" title=\"十、函数指令\"></a>十、函数指令</h4><h3 id=\"1-内置函数\"><a href=\"#1-内置函数\" class=\"headerlink\" title=\"1.内置函数\"></a>1.内置函数</h3><h4 id=\"a-字符串函数\"><a href=\"#a-字符串函数\" class=\"headerlink\" title=\"a. 字符串函数\"></a>a. 字符串函数</h4><blockquote>\n<p>索引第一个为1，最后一个为-1；切片两边均为闭区间</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">quote($string)</td>\n<td align=\"center\">添加引号</td>\n</tr>\n<tr>\n<td align=\"left\">unquote($string)</td>\n<td align=\"center\">除去引号</td>\n</tr>\n<tr>\n<td align=\"left\">to-lower-case($string)</td>\n<td align=\"center\">变为小写</td>\n</tr>\n<tr>\n<td align=\"left\">to-upper-case($string)</td>\n<td align=\"center\">变为大写</td>\n</tr>\n<tr>\n<td align=\"left\">str-length($string)</td>\n<td align=\"center\">返回$string的长度(汉字算一个)</td>\n</tr>\n<tr>\n<td align=\"left\">str-index($string，$substring)</td>\n<td align=\"center\">返回$substring在$string的位置</td>\n</tr>\n<tr>\n<td align=\"left\">str-insert($string, $insert, $index)</td>\n<td align=\"center\">在$string的$index处插入$insert</td>\n</tr>\n<tr>\n<td align=\"left\">str-slice($string, $start-at, $end-at）</td>\n<td align=\"center\">截取$string的$start-at和$end-at之间的字符串</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-数字函数\"><a href=\"#b-数字函数\" class=\"headerlink\" title=\"b. 数字函数\"></a>b. 数字函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>percentage($number)</td>\n<td align=\"center\">转换为百分比形式</td>\n</tr>\n<tr>\n<td>round($number)</td>\n<td align=\"center\">四舍五入为整数</td>\n</tr>\n<tr>\n<td>ceil($number)</td>\n<td align=\"center\">数值向上取整</td>\n</tr>\n<tr>\n<td>floor($number)</td>\n<td align=\"center\">数值向下取整</td>\n</tr>\n<tr>\n<td>abs($number)</td>\n<td align=\"center\">获取绝对值</td>\n</tr>\n<tr>\n<td>min($number…)</td>\n<td align=\"center\">获取最小值</td>\n</tr>\n<tr>\n<td>max($number…)</td>\n<td align=\"center\">获取最大值</td>\n</tr>\n<tr>\n<td>random($number?:number)</td>\n<td align=\"center\">不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭）</td>\n</tr>\n</tbody></table>\n<h4 id=\"c-数组函数\"><a href=\"#c-数组函数\" class=\"headerlink\" title=\"c. 数组函数\"></a>c. 数组函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>length($list)</td>\n<td align=\"center\">获取数组长度</td>\n</tr>\n<tr>\n<td>nth($list, n)</td>\n<td align=\"center\">获取指定下标的元素</td>\n</tr>\n<tr>\n<td>set-nth($list, $n, $value)</td>\n<td align=\"center\">向$list的$n处插入$value</td>\n</tr>\n<tr>\n<td>join($list1, $list2, $separator)</td>\n<td align=\"center\">拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>append($list, $val, $separator)</td>\n<td align=\"center\">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td>\n</tr>\n<tr>\n<td>index($list, $value)</td>\n<td align=\"center\">返回$value值在$list中的索引值</td>\n</tr>\n<tr>\n<td>zip($lists…)</td>\n<td align=\"center\">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td>\n</tr>\n</tbody></table>\n<h4 id=\"d-映射函数\"><a href=\"#d-映射函数\" class=\"headerlink\" title=\"d. 映射函数\"></a>d. 映射函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>map-get($map, $key)</td>\n<td align=\"center\">获取$map中$key对应的$value</td>\n</tr>\n<tr>\n<td>map-merge($map1, $map2)</td>\n<td align=\"center\">合并$map1和$map2，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-remove($map, $key)</td>\n<td align=\"center\">从$map中删除$key，返回一个新$map</td>\n</tr>\n<tr>\n<td>map-keys($map)</td>\n<td align=\"center\">返回$map所有的$key</td>\n</tr>\n<tr>\n<td>map-values($map)</td>\n<td align=\"center\">返回$map所有的$value</td>\n</tr>\n<tr>\n<td>map-has-key($map, $key)</td>\n<td align=\"center\">判断$map中是否存在$key，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>keywords($args)</td>\n<td align=\"center\">返回一个函数的参数，并可以动态修改其值</td>\n</tr>\n</tbody></table>\n<h4 id=\"e-颜色函数\"><a href=\"#e-颜色函数\" class=\"headerlink\" title=\"e. 颜色函数\"></a>e. 颜色函数</h4><ul>\n<li><p><strong>RGB函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rgb($red, $green, $blue)</td>\n<td align=\"center\">返回一个16进制颜色值</td>\n</tr>\n<tr>\n<td>rgba($red,$green,$blue,$alpha)</td>\n<td align=\"center\">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td>\n</tr>\n<tr>\n<td>red($color)</td>\n<td align=\"center\">从$color中获取其中红色值</td>\n</tr>\n<tr>\n<td>green($color)</td>\n<td align=\"center\">从$color中获取其中绿色值</td>\n</tr>\n<tr>\n<td>blue($color)</td>\n<td align=\"center\">从$color中获取其中蓝色值</td>\n</tr>\n<tr>\n<td>mix($color1,$color2,$weight?)</td>\n<td align=\"center\">按照$weight比例，将$color1和$color2混合为一个新颜色</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>HSL函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th>函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hsl($hue,$saturation,$lightness)</td>\n<td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>hsla($hue,$saturation,$lightness,$alpha)</td>\n<td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td>\n</tr>\n<tr>\n<td>saturation($color)</td>\n<td>从一个颜色中获取饱和度（saturation）值</td>\n</tr>\n<tr>\n<td>lightness($color)</td>\n<td>从一个颜色中获取亮度（lightness）值</td>\n</tr>\n<tr>\n<td>adjust-hue($color,$degrees)</td>\n<td>通过改变一个颜色的色相值，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>lighten($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>darken($color,$amount)</td>\n<td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td>\n</tr>\n<tr>\n<td>hue($color)</td>\n<td>从一个颜色中获取亮度色相（hue）值</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Opacity函数</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>alpha($color)&#x2F;opacity($color)</td>\n<td>获取颜色透明度值</td>\n</tr>\n<tr>\n<td>rgba($color,$alpha)</td>\n<td>改变颜色的透明度</td>\n</tr>\n<tr>\n<td>opacify($color, $amount) &#x2F; fade-in($color, $amount)</td>\n<td>使颜色更不透明</td>\n</tr>\n<tr>\n<td>transparentize($color, $amount) &#x2F; fade-out($color, $amount)</td>\n<td>使颜色更加透明</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"f-Introspection函数\"><a href=\"#f-Introspection函数\" class=\"headerlink\" title=\"f. Introspection函数\"></a>f. Introspection函数</h4><table>\n<thead>\n<tr>\n<th>函数名和参数类型</th>\n<th align=\"center\">函数作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>type-of($value)</td>\n<td align=\"center\">返回$value的类型</td>\n</tr>\n<tr>\n<td>unit($number)</td>\n<td align=\"center\">返回$number的单位</td>\n</tr>\n<tr>\n<td>unitless($number)</td>\n<td align=\"center\">判断$number是否带单位，返回对应的布尔值</td>\n</tr>\n<tr>\n<td>comparable($number1, $number2)</td>\n<td align=\"center\">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-自定义函数\"><a href=\"#2-自定义函数\" class=\"headerlink\" title=\"2.自定义函数\"></a>2.自定义函数</h3><blockquote>\n<p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p>\n<p>Params: 与Mixin一致</p>\n<p>支持返回值</p>\n</blockquote>\n<p><strong>基本格式：</strong></p>\n<pre><code class=\"scss\">@function fn-name($params...) &#123;\n    @return $params;\n&#125;\n</code></pre>\n<pre><code class=\"scss\">// example:\n@function fn-name($params...) &#123;\n    @return nth($params, 1);\n&#125;\np &#123;\n    height: fn-name(1px);\n&#125;\n\n// compiled:\np &#123;\n  height: 1px;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"十一、-extend、-Mixin和-function的选择\"><a href=\"#十一、-extend、-Mixin和-function的选择\" class=\"headerlink\" title=\"十一、@extend、@Mixin和@function的选择\"></a>十一、@extend、@Mixin和@function的选择</h4><blockquote>\n<p>本部分来自csswizardry的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jc3N3aXphcmRyeS5jb20vMjAxNi8wMi9taXhpbnMtYmV0dGVyLWZvci1wZXJmb3JtYW5jZS8=\">原文链接</span></p>\n</blockquote>\n<h3 id=\"1、为何有这个问题\"><a href=\"#1、为何有这个问题\" class=\"headerlink\" title=\"1、为何有这个问题\"></a>1、为何有这个问题</h3><blockquote>\n<p>当谈到预处理器时，我被问到的最常见的问题之一是 Mixins 或<code>@extend</code>? 关于这个话题，我坚信你应该避免<code>@extend</code>的一些原因：</p>\n<ol>\n<li>它改变了你的源顺序，这在 CSS 中总是有风险的。</li>\n<li>它会在您的代码中创建笨拙的分组，将不相关的选择器放在一起。</li>\n<li>它非常贪婪，<code>@extend</code>对给定主题的每个实例进行处理，而不仅仅是您真正想要的那个。</li>\n<li>它<span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9kcm9vYi9zdGF0dXMvNTYxMTYxNzgzMjM5Mzg5MTg1\">真的会失控</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9nYWVsbWV0YWlzL3N0YXR1cy81NjQxMDk3NzU5OTU0MzcwNTc=\">真的很快</span>。</li>\n</ol>\n<p><code>@extend</code> 现在被广泛认为是一种反模式，所以它的使用正在逐渐消失，但我们还没有完全到那里。</p>\n<p>昨天我正在与一个客户进行研讨会，并被问及 mixin 与 <code>@extend</code>情况，对此我给出了我通常的回答“永远不要使用” <code>@extend</code>！，作为回报，我被问到但是<code>@extend</code>性能不是更好吗？它生成的代码更少。</p>\n<p>确实<code>@extend</code>（如果使用得当）会产生更少的 CSS，但我的回答是坚决不：<strong>mixin 对性能更好</strong>。</p>\n<p>尽管实际上从未做过任何测试，但我还是很有信心地回答了这个问题。我有信心的原因是我有一个非常可靠的理论：</p>\n<p><strong>因为 gzip 有利于重复，所以如果我们共享完全相同的声明，比如 1000 次，肯定会比我们共享 1000 个独特的类两次获得更好的压缩率。</strong></p>\n<p>你看，当人们谈论 mixin 的性能时，他们通常会考虑文件系统上的文件大小。但是因为我们启用了 gzip（您 <em>确实</em>启用了 gzip，对吧？），我们应该考虑<em>网络上的</em>文件大小</p>\n</blockquote>\n<h3 id=\"2、操作实践\"><a href=\"#2、操作实践\" class=\"headerlink\" title=\"2、操作实践\"></a>2、操作实践</h3><blockquote>\n<ol>\n<li><p>我创建了两个 CSS 文件。</p>\n</li>\n<li><p>每个文件都有 1000 个独特的类，使用 Sass 生成：</p>\n</li>\n</ol>\n<pre><code class=\"scss\">@for $i from 1 through 1000 &#123;\n  .#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>我给了每个类一个唯一的声明，通过使用父选择器简单地重复使用形成名称本身的相同随机字符串，并且我在其两侧放置了一些无意义的字符串：</li>\n</ol>\n<pre><code class=\"scss\">@for $i from 1 through 1000 &#123;\n  .#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n    content: &quot;ibf#&#123;&amp;&#125;jaslbw&quot;;\n  &#125;\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>然后我选择了三个简单的声明，它们在所有 1000 个类中都保持不变：</li>\n</ol>\n<pre><code class=\"scss\">color: red;\nfont-weight: bold;\nline-height: 2;\n</code></pre>\n<ol start=\"5\">\n<li>在一个文件中，我通过 mixin 共享了这些声明：</li>\n</ol>\n<pre><code class=\"scss\">@mixin foo &#123;\n  color: red;\n  font-weight: bold;\n  line-height: 2;\n&#125;\n\n.#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n  @include foo;\n  content: &quot;ibf#&#123;&amp;&#125;jaslbw&quot;;\n&#125;\n</code></pre>\n<ol start=\"6\">\n<li>在另一个中，我通过<code>@extend</code>以下方式分享了它们：</li>\n</ol>\n<pre><code class=\"scss\">%foo &#123;\n  color: red;\n  font-weight: bold;\n  line-height: 2;\n&#125;\n\n.#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;\n  @extend %foo;\n  content: &quot;ibf#&#123;&amp;&#125;jaslbw&quot;;\n&#125;\n</code></pre>\n<p>所有这些测试文件（以及更多）都可以<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nzc3dpemFyZHJ5L2V4dGVuZC12cy1taXhpbg==\">在 GitHub 上找到</span>。</p>\n<p>这给我留下了两个由完全独特的类和 1000 个独特声明组成的文件，以及以两种不同方式共享的三个相同声明。</p>\n<p>这些文件大小丝毫不会让您感到惊讶：</p>\n<ul>\n<li><code>mixin.css</code>进来<strong>108K</strong>。</li>\n<li><code>extend.css</code>进来<strong>72K</strong>。</li>\n<li>这导致文件大小的差异为<strong>36K</strong>。</li>\n<li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li>\n</ul>\n<p>这正是我所期待的，混入<em>不</em>产生更多的CSS比<code>@extend</code> 呢。</p>\n<p>但！我们必须记住，我们不应该担心文件系统上的文件大小——我们只关心我们的 gzip 文件的大小。</p>\n<p>我缩小并压缩了这两个文件并得到了我预期的结果：</p>\n<ul>\n<li><code>mixin.css</code>进来<strong>12K</strong>。</li>\n<li><code>extend.css</code>进来<strong>18K</strong>。</li>\n<li>这导致文件大小的差异为<strong>6K</strong>。</li>\n<li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li>\n</ul>\n<p>惊人！我们已经从 mixin 比 using 大 1.5 倍<code>@extend</code>，到 mixin比 using<strong>小 0.3 倍</strong><code>@extend</code>。我的理论似乎是正确的！</p>\n</blockquote>\n<h3 id=\"3、让事情更现实\"><a href=\"#3、让事情更现实\" class=\"headerlink\" title=\"3、让事情更现实\"></a>3、让事情更现实</h3><blockquote>\n<p>我确实觉得测试文件很公平——为类名创建唯一的字符串是为了阻碍压缩，这样我们就可以更准确地测试 gzip 对我们实际主题的影响：共享声明。</p>\n<p>也就是说，测试文件非常不切实际，所以我决定让事情变得更合理一些。</p>\n<p>我从现有项目中获取编译好的 CSS，制作了两份副本，并将我的<code>@import</code>每个测试文件分别放入每个项目中。这意味着我的测试文件被大约 1794 行真实的 CSS 包围着。</p>\n<p>我编译了每个新的测试文件，结果如下：</p>\n<ul>\n<li><code>mixin.css</code>进来<strong>16K</strong>。</li>\n<li><code>extend.css</code>进来了<strong>22K</strong>。</li>\n<li>这导致文件大小的差异为<strong>6K</strong>。</li>\n<li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li>\n</ul>\n<p>绝对数字似乎微不足道（仅 6K），但相对而言，我们可以通过选择使用 mixin 一遍又一遍地重复声明，而不是使用<code>@extend</code>重复少数选择器来实现 27% 的网络节省。</p>\n</blockquote>\n<h3 id=\"4、总结\"><a href=\"#4、总结\" class=\"headerlink\" title=\"4、总结\"></a>4、总结</h3><p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p>\n<blockquote>\n<p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p>\n<p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p>\n</blockquote>\n<h4 id=\"十二、项目中实战\"><a href=\"#十二、项目中实战\" class=\"headerlink\" title=\"十二、项目中实战\"></a>十二、项目中实战</h4><h3 id=\"Ⅰ-Scss混入\"><a href=\"#Ⅰ-Scss混入\" class=\"headerlink\" title=\"Ⅰ-Scss混入\"></a>Ⅰ-Scss混入</h3><blockquote>\n<p>在工作中提出的对于同事代码的优化–&gt;使用<code>sass混合指令知识</code>,方便后期维护</p>\n<p><img data-src=\"/A_SassScript%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%E7%94%A8%E4%BE%8B.png\" alt=\"混合指令用例\"></p>\n</blockquote>\n","categories":["Sass"],"tags":["Sass"]},{"title":"typeScript笔记","url":"/2023/12/11/TS/","content":"<h1 id=\"TS\"><a href=\"#TS\" class=\"headerlink\" title=\"TS\"></a>TS</h1><h3 id=\"定义数据类型\"><a href=\"#定义数据类型\" class=\"headerlink\" title=\"定义数据类型\"></a>定义数据类型</h3><pre><code class=\"ts\">/**\n * 定义数据类型\n */\nlet num: number = 1;\nlet bool: boolean = false;\n/**\n * 定义固定类型数组\n */\nlet arr1: number[] = [1, 2, 3];\nlet arr2: string[] = [&quot;1&quot;, &quot;2&quot;];\n/**\n * 使用泛型定义固定类型数组\n */\nlet arr3: Array&lt;number&gt; = [1, 2, 3];\n/**\n * 不声明类型定义数组\n */\n// 此时不生命类型则自动分配好了类型，不能赋值数组中不存在的类型\n// ts中数组中的类型默认声明好了，不能添加原本数组中不存在的类型\nlet arr4 = [1, 2, 3];\nlet arr5 = [1, &quot;2&quot;];\n/**\n * 定义混合类型any数组\n */\n// 定义混合类型any的数组可以存放任何类型的值\nlet arr6: any[] = [1, &quot;ds&quot;, false];\n</code></pre>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><pre><code class=\"ts\">/**\n * 元组（类型写在数组外面，元组类型写在数组里面）\n */\n// 一旦定义了元组，其类型和固定顺序位置的数据类型就确定了\nlet arr7: [number, boolean] = [1, false];\n// 但是其长度可以通过push方法改变，但不能直接赋值改变\narr7.push(2);\n// arr7 =[1,false,2]  //报错\n</code></pre>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><pre><code class=\"ts\">/**\n * 联合类型\n */\nlet a: number | string = 0;\n</code></pre>\n<h3 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h3><pre><code class=\"ts\">/**\n * 字面量类型（字面量类型声明的值中只能赋值为指定的）\n */\nlet a1: 1 | 0 = 0;\n</code></pre>\n<h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><p>enmu 类型代表选取多个中的一个，枚举类型相当于对象和类型的结合，既可以当变量使用，也可以作为类型进行约束。可以使用 enum 约束变量的类型，限制使用函数时只能传入 enum 中的属性。</p>\n<p><strong>例如：</strong></p>\n<pre><code class=\"javascript\">enum STATUS &#123;\n    OPEN = &#39;OPEN&#39;,\n    CLOSE = &#39;CLOSE&#39;,\n  &#125;\n  const clickSwitch = (current: STATUS) =&gt; &#123; //限制只能传入\n    return &#39;测试&#39;\n  &#125;\n  clickSwitch(STATUS.OPEN)\n</code></pre>\n<p><strong>基本使用：</strong></p>\n<pre><code class=\"ts\">/**\n * 枚举类型 enum\n */\nenum Color &#123;\n  red,\n  green,\n  blue,\n&#125;\nlet a2 = Color.blue;\nconsole.log(a2); //默认情况下赋值为0,1,2\nenum Color &#123;\n  red1 = 1,\n  green1,\n  blue1,\n&#125;\nconsole.log(Color.blue1); //改变后为1，2，3\nenum Color &#123;\n  red2 = &quot;red&quot;,\n  green2 = &quot;green&quot;,\n  blue2 = &quot;blue&quot;,\n&#125;\nconsole.log(Color.blue2); //赋值给其中一项的如果不是可迭代的（number），则需要为每一个都赋值\n</code></pre>\n<h3 id=\"any-和-unknown-类型\"><a href=\"#any-和-unknown-类型\" class=\"headerlink\" title=\"any 和 unknown 类型\"></a>any 和 unknown 类型</h3><pre><code class=\"ts\">/**\n * any类型和unkonwn类型的区别\n * unkonwn类型表示强制类型检查（可以通过赋值改变类型,只有类型明确时才能使用对应属性或方法）\n * any类型表示不进行类型检查\n */\nlet a3: unknown = 1;\na3 = &quot;1&quot;;\na3 = &#123; a1: &quot;dsf&quot; &#125;;\n// a3.a1\n// a3()\n// a3.toString() 当定义unknown未知类型时，在类型未知的情况下不能使用方法\nif (typeof a3 === &quot;function&quot;) &#123;\n  a3();\n&#125;\nif (typeof a3 === &quot;string&quot;) &#123;\n  a3.toUpperCase();\n&#125;\n</code></pre>\n<h3 id=\"void、undefined-和-never-类型\"><a href=\"#void、undefined-和-never-类型\" class=\"headerlink\" title=\"void、undefined 和 never 类型\"></a>void、undefined 和 never 类型</h3><pre><code class=\"ts\">/**\n * void类型、undefined类型 和 never类型\n * void类型一般用于表示函数无返回值\n * undefined类型一般用于表示函数直接return或者return undefined\n * never类型一般用于表示函数死循环，永远无法return\n */\n// 1 undefined类型，此时函数返回时将返回undefined（undefined类型表示未赋值、为初始化）\nfunction a4(): undefined &#123;\n  console.log(&quot;a4&quot;);\n  return;\n&#125;\n// 2 void类型，表示变量本身就不存在，当函数没有返回值时，返回值就是void\nfunction a5() &#123;\n  console.log(&quot;a5&quot;);\n&#125;\n// 2 never类型，表示一个函数永远执行不完（报错或无限循环）\nfunction throwErr(message: string, errCode: number): never &#123;\n  throw &#123;\n    message,\n    errCode,\n  &#125;;\n&#125;\nfunction whileLoop(): never &#123;\n  while (true) &#123;\n    console.log(&quot;永远为真&quot;);\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><pre><code class=\"ts\">/**\n * 类型适配（类型断言）as\n */\nlet message: any;\nmessage = &quot;1cf&quot;; //即使这个时候赋值为字符串，类型仍然是any\nlet a6 = (&lt;string&gt;message).endsWith(&quot;c&quot;); //使用尖括号对变量进行类型断言\nlet a7 = (message as string).endsWith(&quot;f&quot;); //使用as关键字对变量进行类型断言\n</code></pre>\n<h3 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h3><pre><code class=\"ts\">/**\n * 函数的声明\n */\n// 1 ts中函数形参的个数和传参时的个数必须要保持一致\nlet a8 = (message: string, code: number) =&gt; &#123;\n  console.log(message, code);\n&#125;;\na8(&quot;a8&quot;, 8);\n// 2 可选参数，用 ?表示可选参数（可选参数必须要在必选参数之后）\nlet a9 = (message: string, code?: number) =&gt; &#123;\n  console.log(message, code);\n&#125;;\na9(&quot;你好&quot;);\n// 3 默认参数，与ES6相似\nlet a10 = (message: string = &quot;你好&quot;, code: number = 1) =&gt; &#123;\n  console.log(message, code);\n&#125;;\na10(&quot;嗨&quot;);\n</code></pre>\n<h3 id=\"具体对象类型\"><a href=\"#具体对象类型\" class=\"headerlink\" title=\"具体对象类型\"></a>具体对象类型</h3><pre><code class=\"ts\">/**\n * 具体对象类型\n */\nlet person1: &#123;\n  name: string;\n  age: number;\n&#125; = &#123;\n  name: &quot;张三&quot;,\n  age: 18,\n&#125;;\nlet person2 = &#123;\n  name: &quot;李四&quot;,\n  age: 20,\n&#125;;\n// person2.nicname 此时会报错，不能使用对象没有的属性和方法\nlet person3: any = &#123; name: &quot;王五&quot;, age: 22 &#125;;\nconsole.log(person3.nickname); //如果将对象的类型改为any，则可以使用任意类型（相当于原生js对象）\n</code></pre>\n<h3 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口 interface\"></a>接口 interface</h3><pre><code class=\"ts\">/**\n * 定义接口interface\n */\ninterface Point &#123;\n  x: number;\n  y: number;\n&#125;\nlet drawPoint = (point: Point) =&gt; &#123;\n  console.log(&#123; x: point.x, y: point.y &#125;);\n&#125;;\n// drawPoint(&#123;x:&#39;1&#39;,y:1&#125;)  这时候不满足接口就会报错.同时这样讲函数和接口分开写不利于代码的高内聚低耦合原则\ninterface Person &#123;\n  age: number;\n  name: string;\n  say: () =&gt; void; //用接口表示对应的类型生命，讲函数和接口放在一起提高代码的高内聚低耦合\n&#125;\n</code></pre>\n<h3 id=\"类和接口\"><a href=\"#类和接口\" class=\"headerlink\" title=\"类和接口\"></a>类和接口</h3><pre><code class=\"ts\">/**\n * 类 class （ES6中也有类的概念）\n */\nclass PersonClass implements Person &#123;\n  //使用类实现接口\n  age: number;\n  name: string;\n  constructor(age: number = 10, name: string = &quot;张三&quot;) &#123;\n    //js中的函数不可以重载，一个类中有且只能有一个构造函数\n    this.age = age;\n    this.name = name;\n  &#125;\n  say = () =&gt; &#123;\n    console.log(`我是：$&#123;this.name&#125;,今年$&#123;this.age&#125;碎了`);\n  &#125;;\n&#125;\nconst person4 = new PersonClass();\nperson4.say();\n</code></pre>\n<h3 id=\"类的访问修饰符\"><a href=\"#类的访问修饰符\" class=\"headerlink\" title=\"类的访问修饰符\"></a>类的访问修饰符</h3><pre><code class=\"ts\">/**\n * 构造函数中访问修饰符：public、private、protected\n */\n// 1 public访问修饰符 （没有书写时默认为：public）\nclass PersonClass2 implements Person &#123;\n  //使用类实现接口\n  // age:number;name:string;\n  constructor(public age: number, public name: string) &#123;\n    //js中的函数不可以重载，一个类中有且只能有一个构造函数\n    // 使用关键字public之后，将自动构造出静态属性，不用在赋值\n    // this.age=age;this.name=name\n  &#125;\n  say = () =&gt; &#123;\n    console.log(`我是：$&#123;this.name&#125;,今年$&#123;this.age&#125;碎了`);\n  &#125;;\n&#125;\nconst person5 = new PersonClass2(100, &quot;活活&quot;);\nperson5.say();\n// 2 private访问修饰符\ninterface pp &#123;\n  say: () =&gt; void;\n  // 添加getter和setter，用于给私有变量赋值\n  getAge: () =&gt; number;\n  getName: () =&gt; string;\n  setAge: (val: number) =&gt; void;\n  setName: (val: string) =&gt; void;\n&#125;\nclass PersonClass3 implements pp &#123;\n  //使用类实现接口\n  constructor(private age: number, private name: string) &#123;\n    //js中的函数不可以重载，一个类中有且只能有一个构造函数\n    // 使用private访问修饰符后，同样不用自动注册\n  &#125;\n  say = () =&gt; &#123;\n    console.log(`我是：$&#123;this.getName&#125;,今年$&#123;this.getAge&#125;碎了`);\n  &#125;;\n  // 定义setter方法\n  getName = () =&gt; &#123;\n    return this.name;\n  &#125;;\n  getAge = () =&gt; &#123;\n    return this.age;\n  &#125;;\n  setName = (val: string) =&gt; &#123;\n    this.name = val;\n  &#125;;\n  setAge = (val: number) =&gt; &#123;\n    this.age = val;\n  &#125;;\n&#125;\n</code></pre>\n<h3 id=\"泛型-lt-T-gt\"><a href=\"#泛型-lt-T-gt\" class=\"headerlink\" title=\"泛型&lt; T &gt;\"></a>泛型&lt; T &gt;</h3><h4 id=\"泛型是什么\"><a href=\"#泛型是什么\" class=\"headerlink\" title=\"泛型是什么\"></a>泛型是什么</h4><p>泛型是程序设计语言的一种风格或范式，它允许我们使用一些以后才指定的类型。在定义函数接口或者类时，不预先定义好具体的类型，而在使用的时候才去指定类型的一种特性。</p>\n<pre><code class=\"ts\">/**\n * 泛型&lt;T&gt;\n * 泛型定义了函数中需要使用的类型（可以动态变化，写在变量名之后，括号之前）\n * 不止函数，类和接口中都可以使用泛型\n */\n// 动态泛型保证函数返回值和参数的类型一致\nlet lastInArray = &lt;T&gt;(arr: Array&lt;T&gt;) =&gt; &#123;\n  return arr[arr.length - 1];\n&#125;;\nconst L1 = lastInArray([1, 2, 3]);\nconsole.log(L1);\nconst L2 = lastInArray([&quot;a&quot;, &quot;b&quot;]);\nconsole.log(L2);\n// 显示指明类型\nlet L3 = lastInArray&lt;string | number&gt;([&quot;1&quot;, &quot;2&quot;]);\n// 多泛型表达\nlet L4 = &lt;T, Y&gt;(x: T, y: Y) =&gt; [x, y];\nconst v1 = L4(1, &quot;one&quot;);\n//声明泛型接口\ninterface ReturnItemFn&lt;T&gt; &#123;\n  (para: T): T;\n&#125;\nconst returnItem: ReturnItemFn&lt;number&gt; = (para) =&gt; para;\n//声明泛型类\n\nclass Stack&lt;T&gt; &#123;\n  private arr: T[] = [];\n\n  public push(item: T) &#123;\n    this.arr.push(item);\n  &#125;\n\n  public pop() &#123;\n    this.arr.pop();\n  &#125;\n&#125;\nconst stack = new Stack&lt;number&gt;();\n</code></pre>\n<h3 id=\"类型-type\"><a href=\"#类型-type\" class=\"headerlink\" title=\"类型 type\"></a>类型 type</h3><pre><code class=\"ts\">/**\n * 类型type\n */\ntype Square = &#123;\n  size: number;\n&#125;;\ntype Rectangle = &#123;\n  width: number;\n  height: number;\n&#125;;\ntype Shape = Square | Rectangle; //联合类型\nfunction area(shape: Shape) &#123;\n  if (&quot;size&quot; in shape) &#123;\n    //如果shape中有size属性，说明是正方形\n    return shape.size ** 2;\n  &#125;\n  if (&quot;width&quot; in shape) &#123;\n    return shape.width * shape.height;\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"类型守护-is\"><a href=\"#类型守护-is\" class=\"headerlink\" title=\"类型守护 is\"></a>类型守护 is</h3><p>类型守护的意义就在于<code>类型的倒推</code>，由结果推导出变量的具体类型（收缩变量的类型范围），这样当结果已经知道时，就可以推导出变量为 unknow 或其他等一些未知的类型。</p>\n<p>例如：</p>\n<p>当变量使用 unknown 类型，判定结果为 boolean 类型时，不使用 as 关键字就无法在后面使用 value 对应的方法，因为它的类型是 unknown。</p>\n<pre><code class=\"ts\">const isString = (value: unknown): boolean =&gt; typeof value === &quot;string&quot;;\nfunction test(value: unknown): string &#123;\n  if (isString(value)) &#123;\n    // value.charCodeAt(0) , 抛出错误，需要使用as\n    (value as string).charCodeAt(0);\n  &#125;\n  return &quot;&quot;;\n&#125;\n</code></pre>\n<p>使用 is 类型守护，当结果类型已知时，就可以倒推出变量的类型（收缩类型），进而可以使用对应的方法</p>\n<pre><code class=\"ts\">const isString = (value: unknown): value is string =&gt; typeof value === &quot;string&quot;;\nfunction test(value: unknown): string &#123;\n  if (isString(value)) &#123;\n    value.charCodeAt(0); // is变量守护后，倒推出value为string类型\n  &#125;\n  return &quot;&quot;;\n&#125;\n</code></pre>\n<p><strong>使用：</strong></p>\n<pre><code class=\"ts\">/**\n * 类型守护\n * 类型判断：typeof,实例判断：instanceof，属性判断:in，字面量相等判断(==等)\n * 自定义类型判断，通过：&#123;形参&#125; is &#123;类型&#125;\n */\n// 将判断变为返回boolean的函数时，类型守护失效，这时候就需要使用自定义类型判断\ntype Square1 = &#123;\n  size: number;\n&#125;;\ntype Rectangle1 = &#123;\n  width: number;\n  height: number;\n&#125;;\nfunction isSquare(shape1: Shape1): boolean &#123;\n  return &quot;size&quot; in shape1;\n&#125;\nfunction isRectangle(shape1: Shape1): boolean &#123;\n  return &quot;width&quot; in shape1;\n&#125;\ntype Shape1 = Square1 | Rectangle1;\nfunction area1(shape1: Shape1) &#123;\n  if (isSquare(shape1)) &#123;\n    //如果shape中有size属性，说明是正方形\n    return shape1.size ** 2;\n  &#125;\n  if (isRectangle(shape1)) &#123;\n    return shape1.width * shape1.height;\n  &#125;\n&#125;\n/**\n * 应该将判断函数定义为类型（而不是布尔值），这样类型守卫才不会失效\n */\ntype Square1 = &#123;\n  size: number;\n&#125;;\ntype Rectangle1 = &#123;\n  width: number;\n  height: number;\n&#125;;\nfunction isSquare(shape1: Shape1): shape1 is Square1 &#123;\n  //将boolean判断上升到类型判断中，使类型一致\n  return &quot;size&quot; in shape1;\n&#125;\nfunction isRectangle(shape1: Shape1): shape1 is Rectangle1 &#123;\n  return &quot;width&quot; in shape1;\n&#125;\ntype Shape1 = Square1 | Rectangle1;\nfunction area1(shape1: Shape1) &#123;\n  if (isSquare(shape1)) &#123;\n    //如果shape中有size属性，说明是正方形\n    return shape1.size ** 2;\n  &#125;\n  if (isRectangle(shape1)) &#123;\n    return shape1.width * shape1.height;\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><pre><code class=\"ts\">/**\n * 函数重载（TS的函数重载发生在编译时而不是运行时，因为js不支持函数重载）\n */\n// 使用函数重载将会明确函数的签名，大大提升对函数使用的准确性\nfunction makeDate(timeStamp: number): Date;\nfunction makeDate(year: number, month: number, day: number): Date;\nfunction makeDate(timeStampOrYear: number, month?: number, day?: number) &#123;\n  if (month != null &amp;&amp; day != null) &#123;\n    return new Date(timeStampOrYear, month - 1, day);\n  &#125; else &#123;\n    return new Date(timeStampOrYear);\n  &#125;\n&#125;\n//当调用函数时，ts编译器会根据传入的参数类型和数量来确定应该调用哪个函数\nconsole.log(makeDate(123923892));\n</code></pre>\n<h3 id=\"函数签名\"><a href=\"#函数签名\" class=\"headerlink\" title=\"函数签名\"></a>函数签名</h3><pre><code class=\"ts\">/**\n * 调用签名（签名是函数重载中的概念，描述了函数所需的参数类型和返回值类型）\n */\n//定义了一个类型（函数类型），其中类型别名包含一个debugName属性，然后包含一个函数重载\ntype Add = &#123;\n  (a: number, b: number): number;\n  debugName: string; //添加debugName附加信息\n  (a: number, b: number, c: number): number; //进行函数的重载\n&#125;;\nconst add: Add = (a: number, b: number, c?: number) =&gt; &#123;\n  return a + b + (c != null ? c : 0);\n&#125;;\nadd.debugName = &quot;附加信息&quot;;\n/**\n * new构造函数进行签名\n */\ntype Poit = &#123;\n  new (x: number, y: number): &#123; x: number; y: number &#125;;\n  new (x: number, y: number, z: number): &#123; x: number; y: number; z: number &#125;;\n&#125;;\nconst point = class &#123;\n  constructor(public x: number, public y: number, public z?: number) &#123;&#125;\n&#125;;\n/**\n * 索引签名\n */\n// 定义字典类型\ntype Dictionary = &#123;\n  [key: string]: any;\n&#125;;\n// 定义Person类型\ntype Person1 = &#123;\n  name: string;\n  age: number;\n&#125;;\n// 定义字典对象类型\ntype PersonDictionary = &#123;\n  [username: string]: Person1;\n&#125;;\nconst persons: PersonDictionary = &#123;\n  alex: &#123;\n    name: &quot;阿莱克斯&quot;,\n    age: 18,\n  &#125;,\n  michal: &#123;\n    name: &quot;jackson&quot;,\n    age: 20,\n  &#125;,\n&#125;;\nconst alex = persons[&quot;alex&quot;];\npersons[&quot;张三&quot;] = &#123;\n  name: &quot;张三&quot;,\n  age: 100,\n&#125;;\ndelete persons[&quot;张三&quot;];\n// 注意：当访问不存在的属性时，ts不会报错\nconst aa = persons[&quot;不存在&quot;]; //undefined\n// aa.name  //ts书写时不会报错，编译时报错\n</code></pre>\n<h3 id=\"函数副作用\"><a href=\"#函数副作用\" class=\"headerlink\" title=\"函数副作用\"></a>函数副作用</h3><pre><code class=\"ts\">/**\n * 函数的副作用\n */\nfunction reverseSorted(input: number[]): number[] &#123;\n  return input.sort().reverse();\n&#125;\nlet arr8 = [1, 2, 3, 4];\nconst result = reverseSorted(arr8);\nconsole.log(result, arr8); //可以观察到两个数组都变化了，函数出现了副作用\n</code></pre>\n<h3 id=\"函数参数修饰符\"><a href=\"#函数参数修饰符\" class=\"headerlink\" title=\"函数参数修饰符\"></a>函数参数修饰符</h3><pre><code class=\"ts\">/**\n * 修饰符：public,private,readonly,protected\n */\n/**\n * readonly只读属性\n */\n// 添加readonly之后，值只可以被读取，一旦被改写就会报错\nfunction reverseSorted2(input: readonly number[]): number[] &#123;\n  // return input.slice().sort().reverse()\n  return [...input].sort().reverse();\n&#125;\nlet arr9 = [1, 2, 3, 4];\nconst result2 = reverseSorted2(arr9);\nconsole.log(result2, arr9);\n</code></pre>\n<h3 id=\"双重断言\"><a href=\"#双重断言\" class=\"headerlink\" title=\"双重断言\"></a>双重断言</h3><pre><code class=\"ts\">/**\n * 双重断言\n */\n// 断言：\ntype T2D = &#123; x: number; y: number &#125;;\ntype T3D = &#123; x: number; y: number; z: number &#125;;\nlet P2D: T2D = &#123; x: 1, y: 1 &#125;;\nlet P3D: T3D = &#123; x: 10, y: 10, z: 10 &#125;;\nP2D = P3D; //多出属性的值可以赋值给少属性的值\n// P3D=P2D  //这样会报错，少属性的值不能付给多属性的值，此时可用类型断言\nP3D = P2D as T3D; //使用类型断言，表示P2D为T3D类型的值，这样就可以赋值\n// 双重类型断言 （如果两个值连类型都不一致）\ntype PersonT = &#123; name: string; age: number &#125;;\nlet person6: PersonT = &#123; name: &quot;张三&quot;, age: 18 &#125;;\n// P3D = person6 报错\n// P3D = person6 as T3D 单重断言仍报错，因为数据类型都不对\nP3D = person6 as any as T3D; //双重断言\n</code></pre>\n<h3 id=\"字符串不可更改\"><a href=\"#字符串不可更改\" class=\"headerlink\" title=\"字符串不可更改\"></a>字符串不可更改</h3><pre><code class=\"ts\">/**\n * js中的字符串不可更改 immutable\n */\nlet king = &quot;elvis&quot;;\nking = &quot;james&quot;; //这里虽然变量变了，但是其实elvis字符串还在\nking[2]; //字符串通过索引可以访问到对应字母\n// king[2] = &#39;b&#39;  //报错，js中字符串不可修改\n</code></pre>\n<h3 id=\"常量断言-as-const\"><a href=\"#常量断言-as-const\" class=\"headerlink\" title=\"常量断言 as const\"></a>常量断言 as const</h3><pre><code class=\"ts\">/**\n * 常量断言（js中对象类型的值可以修改）\n */\nconst obj = &#123;\n  name: &quot;张三&quot;,\n  age: 19,\n&#125;;\nobj.name = &quot;李四&quot;; //此时对象中的值可以任意修改\nconst obj2 = &#123;\n  name: &quot;王五&quot;,\n  age: 100,\n  arr: [1, 2, 3],\n&#125; as const;\n// obj2.name=&#39;张三&#39; //此时报错，使用常量断言之后不能修改\n// 延展：常量断言可以断言任何一个类型（包括数组），将任何类型的成员变量都转换为readonly只读属性\n// 应用场景2：（常量断言会将值变为字面量类型）\nfunction layout(setting: &#123; align: &quot;left&quot; | &quot;center&quot; &#125;) &#123;\n  console.log(&quot;align为：&quot;, setting.align);\n&#125;\n// const test = &#123;align:&#39;left&#39;&#125;\n// layout(test) //此时会报错，因为test中的值是字符串，不是符合条件的字面量类型\nconst test = &#123; align: &quot;left&quot; &#125; as const;\nlayout(test); //使用常量类型断言，将值变为字面量类型了\n</code></pre>\n<h3 id=\"非空断言\"><a href=\"#非空断言\" class=\"headerlink\" title=\"非空断言 !\"></a>非空断言 !</h3><pre><code class=\"ts\">/**\n * 非空断言：（变量后加: ！）\n */\nlet str: string | null = &quot;hello&quot;;\nconsole.log(str.length); // 报错，str 可能为 null\nconsole.log(str!.length); // 不报错，使用非空断言操作符 ! 告诉编译器 str 不为 null\n</code></pre>\n<h3 id=\"this-关键字\"><a href=\"#this-关键字\" class=\"headerlink\" title=\"this 关键字\"></a>this 关键字</h3><p>ts 在函数中使用 this 关键字时，由于其类型要约束，因此需要在函数定义参数处声明其类型，声明方式：使用 this 关键字作为第一个参数，ts 会自动识别这是在为 this 定义类型，后面参数接收和传参时和正常一样。</p>\n<pre><code class=\"ts\">/**\n * this关键字\n */\nfunction double(this: &#123; value: number &#125;) &#123;\n  //this必须是参数的第一位（假的）\n  this.value = this.value * 2;\n&#125;\nconst valid = &#123;\n  value: 10,\n  double,\n&#125;;\nvalid.double(); //得到20\nconst valid2 = &#123;\n  val: 1,\n  double,\n&#125;;\n// valid2.double() 此时报错，因为valid2中对象没有value属性\n</code></pre>\n<h3 id=\"declare-关键字\"><a href=\"#declare-关键字\" class=\"headerlink\" title=\"declare 关键字\"></a>declare 关键字</h3><p>ts 中 declare 关键字就是用于告诉编译器，某个类型存在，并且在当前页面可以使用。</p>\n<p>declare 关键字可以描述：</p>\n<ul>\n<li>变量（const、let、var 命令声明）</li>\n<li>type 或者 interface 命令声明的类型</li>\n<li>class</li>\n<li>enum</li>\n<li>函数（function）</li>\n<li>模块（module）</li>\n<li>命名空间（namespace）</li>\n</ul>\n<pre><code class=\"javascript\">declare function sayHello(name: string): void;\nsayHello(&quot;张三&quot;);\n</code></pre>\n<h3 id=\"module-关键字\"><a href=\"#module-关键字\" class=\"headerlink\" title=\"module 关键字\"></a>module 关键字</h3><p>当我们在使用非 TypeScript 编写的库的时候，他们并没有自己的类型，在 ts 项目中引入的时候就会抛出错误，这时候通常在<code>.d.ts</code>文件中进行定义。也可以使用<code>module关键字</code>来声明某个模块的类型</p>\n<pre><code class=\"ts\">declare module &quot;url&quot; &#123;\n  export interface Url &#123;\n    protocol?: string;\n    hostname?: string;\n    pathname?: string;\n  &#125;\n\n  export function parse(\n    urlStr: string,\n    parseQueryString?,\n    slashesDenoteHost?\n  ): Url;\n&#125;\n</code></pre>\n<p>如果想要快速使用，而忽略其类型校验，可以进行简写：</p>\n<pre><code class=\"ts\">declare module &quot;url&quot;;\n</code></pre>\n<h3 id=\"typeof-操作符\"><a href=\"#typeof-操作符\" class=\"headerlink\" title=\"typeof 操作符\"></a>typeof 操作符</h3><pre><code class=\"ts\">/**\n * typeof操作符，提取已有变量的类型\n */\nconst center = &#123;\n  x: 0,\n  y: 0,\n  z: 0,\n&#125;;\n// type position = &#123;\n//     x:number,y:number,z:number\n// &#125;\ntype position = typeof center; //这里使用typeof操作符就不用重新定义\nconst unit: position = &#123;\n  x: center.x + 1,\n  y: center.y + 1,\n  z: center.z + 1,\n&#125;;\n</code></pre>\n<h3 id=\"keyof-操作符\"><a href=\"#keyof-操作符\" class=\"headerlink\" title=\"keyof 操作符\"></a>keyof 操作符</h3><pre><code class=\"ts\">/**\n * keyof操作符，拿到全部的成员变量作为联合类型\n */\ntype Person3 = &#123;\n  name: string;\n  age: number;\n&#125;;\nconst person7: Person3 = &#123;\n  name: &quot;张三&quot;,\n  age: 18,\n&#125;;\nfunction getValueByKey(obj: Person3, key: keyof Person3) &#123;\n  //keyof操作符得到联合类型\n  const value = obj[key];\n  return value;\n&#125;\nconst age = getValueByKey(person7, &quot;age&quot;);\n// const email = getValueByKey(person7,&#39;email&#39;) 这样会报错，不能得到不存在的key\n</code></pre>\n<h3 id=\"类型查找\"><a href=\"#类型查找\" class=\"headerlink\" title=\"类型查找\"></a>类型查找</h3><pre><code class=\"ts\">/**\n * 类型查找\n */\ntype res = &#123;\n  user: &#123;\n    name: string;\n    age: number;\n  &#125;;\n  data: &#123;\n    info: string;\n    msg: string;\n  &#125;;\n&#125;;\n// 通过定义的类型中的某一项进行类型查找\nfunction getInfo(): res[&quot;data&quot;] &#123;\n  return &#123;\n    info: &quot;info&quot;,\n    msg: &quot;msg&quot;,\n  &#125;;\n&#125;\n</code></pre>\n<h3 id=\"类型映射\"><a href=\"#类型映射\" class=\"headerlink\" title=\"类型映射\"></a>类型映射</h3><pre><code class=\"ts\">/**\n * 类型映射\n */\ntype Point2 = &#123;\n  x: number;\n  y: number;\n  z: number;\n&#125;;\n//定义Readonly类型，用于将变量中每一项变为只读属性\nexport type Readonly&lt;T&gt; = &#123;\n  //使用export的原因是Readonly是TS内置好的函数\n  readonly [item in keyof T]: T[item];\n&#125;;\nconst center2: Readonly&lt;Point2&gt; = &#123;\n  x: 1,\n  y: 1,\n  z: 1,\n&#125;;\n// center2.x = 100  此时会报错\n</code></pre>\n<h3 id=\"类型修饰符\"><a href=\"#类型修饰符\" class=\"headerlink\" title=\"类型修饰符\"></a>类型修饰符</h3><pre><code class=\"ts\">/**\n * 映射修饰符，readonly、?等\n */\ntype Point3 = &#123;\n  readonly x: number;\n  y?: number;\n&#125;;\ntype Mapped&lt;T&gt; = &#123;\n  // readonly [item in keyof T] ? : T[item]\n  -readonly [item in keyof T]-?: T[item];\n&#125;;\ntype Result3 = Mapped&lt;Point3&gt;;\n// 实际使用案例\nexport class State&lt;T&gt; &#123;\n  constructor(public current: T) &#123;&#125;\n  update(next: Partial&lt;T&gt;) &#123;\n    this.current = &#123; ...this.current, ...next &#125;;\n  &#125;\n&#125;\nexport type Partial&lt;T&gt; = &#123;\n  [item in keyof T]?: T[item];\n&#125;;\nconst state = new State(&#123; x: 0, y: 0 &#125;);\nstate.update(&#123; y: 124 &#125;);\nconsole.log(state.current);\n</code></pre>\n<h3 id=\"interface-和-type-的区别\"><a href=\"#interface-和-type-的区别\" class=\"headerlink\" title=\"interface 和 type 的区别\"></a>interface 和 type 的区别</h3><p>1、实现对象和类一般使用<strong>interface</strong>，</p>\n<p>而实现联合类型、元组类型、交叉类型一般使用<strong>type</strong></p>\n<pre><code class=\"ts\">// 1 类型别名可以用于其它类型 （联合类型、元组类型、交叉类型），\n// interface不支持这些，interface支持对象类型定义更好。\ntype PartialPointX = &#123; x: number &#125;;\ntype PartialPointY = &#123; y: number &#125;;\n// union(联合)\ntype PartialPoint = PartialPointX | PartialPointY;\n// tuple(元祖)\ntype Data = [PartialPointX, PartialPointY];\n//primitive(原始值)\ntype Name = Number;\n// typeof的返回值\nlet div = document.createElement(&quot;div&quot;);\ntype B = typeof div;\n</code></pre>\n<p>2 、 interface 可以多次定义 并被视为合并所有声明成员 type 不支持</p>\n<pre><code class=\"ts\">interface Point &#123;\n  x: number;\n&#125;\ninterface Point &#123;\n  y: number;\n&#125;\nconst point1: Point = &#123; x: 1, y: 2 &#125;;\n</code></pre>\n<p>3 、 type 能使用 in 关键字生成映射类型，但 interface 不行。</p>\n<pre><code class=\"ts\">type Keys = &quot;firstname&quot; | &quot;surname&quot;;\ntype DudeType = &#123;\n  [key in Keys]: string;\n&#125;;\nconst test1: DudeType = &#123;\n  firstname: &quot;Pawel&quot;,\n  surname: &quot;Grzybek&quot;,\n&#125;;\n</code></pre>\n<p>4 、 默认导出方式不同</p>\n<pre><code class=\"ts\">// inerface 支持同时声明，默认导出 而type必须先声明后导出\nexport default interface Config &#123;\n  name: string;\n&#125;\n// 同一个js模块只能存在一个默认导出哦\ntype Config2 = &#123; name: string &#125;;\nexport default Config2;\n//   type或者interface使用指南\n//   在选择使用 type 还是 interface 时，你可以根据具体情况来决定。通常来说，如果你需要定义对象的结构，或者要求类实现某个结构，使用 interface 是一个不错的选择。\n//   而如果你需要复杂的联合类型或交叉类型，或者仅仅是为了给某个类型起一个别名以提高可读性，那么使用 type 是更合适的\n</code></pre>\n<h1 id=\"——————————–\"><a href=\"#——————————–\" class=\"headerlink\" title=\"——————————–\"></a>——————————–</h1><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"ts-进阶\"><a href=\"#ts-进阶\" class=\"headerlink\" title=\"ts 进阶\"></a>ts 进阶</h1><blockquote>\n<p>类型系统</p>\n</blockquote>\n<ul>\n<li>对代码中所有的标识符（变量、函数、参数、返回值）进行类型检查</li>\n</ul>\n<blockquote>\n<p>对接 js 引擎优化：ts 虽然不能改变 js 这门动态语言的本质，但是对于 js 代码的类型约束确使得编译出来的 js 代码有利于 v8 等引擎进行优化，例如：</p>\n</blockquote>\n<ul>\n<li>js 对象由于类型确定，有利于 js 引擎编译时，对象静态编译的优化（v8 引擎会假装 js 对象属性类型确定，根据第一次获取到的形状），这样查找对象的属性更快。</li>\n<li>js 函数由于传入类型确定，有利于字节码编译为机器码时，对执行过程的缓存优化（v8 引擎将字节码编译为机器码后，机器码部分存在一个反编译优化，会将多次执行过程标记为 hot，并进行缓存）</li>\n</ul>\n<h2 id=\"配置文件-ts-config-json\"><a href=\"#配置文件-ts-config-json\" class=\"headerlink\" title=\"配置文件 ts.config.json\"></a>配置文件 ts.config.json</h2><ul>\n<li><code>tsc --init</code>生成配置文件</li>\n</ul>\n<h2 id=\"三方库\"><a href=\"#三方库\" class=\"headerlink\" title=\"三方库\"></a>三方库</h2><ul>\n<li>ts-node 将 ts 代码在内存中编译，直接执行</li>\n<li>nodemon 监听文件变化，执行命令，热启动</li>\n<li><ul>\n<li><code>nodemon --watch src -e ts --exec ts-node test.ts</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h2><ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>数组[]或 Array</li>\n<li>对象 object 或 Object</li>\n<li>null 和 undefined</li>\n<li>联合类型：多种类型任选其一，存在类型保护(例如 typeof 或 if 判断 可以触发类型保护，确定到精确类型)</li>\n<li>void 类型：通常用于约束函数的返回值，表示该函数没有任务返回</li>\n<li>never 类型：通常用于约束函数的返回值，表示该函数永远不可能结束</li>\n<li>字面量类型：使用一个值进行约束</li>\n<li>元组类型：一个固定长度的数组，并且数组中每一项的类型确定</li>\n<li>any 类型，绕过类型检查，any 类型的数据可以赋值给任意类型</li>\n</ul>\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><blockquote>\n<p>对已知的类型进行定义</p>\n</blockquote>\n<pre><code class=\"ts\">type User = &#123;\n  name: string;\n  age: number;\n&#125;;\n</code></pre>\n<h2 id=\"函数重载-1\"><a href=\"#函数重载-1\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><blockquote>\n</blockquote>\n<pre><code class=\"ts\">function combine(a: number, b: number): number;\nfunction combine(a: string, b: string): string;\nfunction combine(a: number | string, b: number | string): number | string &#123;\n  if (typeof a === &quot;number&quot; &amp;&amp; typeof b === &quot;number&quot;) &#123;\n    return a + b;\n  &#125; else if (typeof a === &quot;string&quot; &amp;&amp; typeof b === &quot;string&quot;) &#123;\n    return a + &quot;、&quot; + b;\n  &#125;\n  throw new Error(&quot;a和b必须是相同类型&quot;);\n&#125;\n</code></pre>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><pre><code class=\"ts\">function sum(a: number, b: number, c?: number): number &#123;\n  if (c) &#123;\n    return a + b + c;\n  &#125;\n  return a + b;\n&#125;\nsum(1, 2);\nsum(2, 3, 5);\n</code></pre>\n<h2 id=\"扩展类型\"><a href=\"#扩展类型\" class=\"headerlink\" title=\"扩展类型\"></a>扩展类型</h2><h3 id=\"扩展类型-type\"><a href=\"#扩展类型-type\" class=\"headerlink\" title=\"扩展类型 type\"></a>扩展类型 type</h3><pre><code class=\"ts\">type User = &#123;\n  name: string;\n  age: number;\n&#125;;\ntype Condition = (n: number) =&gt; boolean;\ntype Condition = &#123;\n  //只有一个函数时，&#123;&#125;相当于定界符，等同于上面\n  (n: number): boolean;\n&#125;;\n</code></pre>\n<h3 id=\"枚举-enum\"><a href=\"#枚举-enum\" class=\"headerlink\" title=\"枚举 enum\"></a>枚举 enum</h3><blockquote>\n<p>字面量类型配合联合类型的问题：</p>\n</blockquote>\n<ul>\n<li>字面量类型配合联合类型约定了类型的取值，但是如果后面字面量类型名需要修改时，相应的所有的变量赋值也要全部做修改。这时因为联合类型将真实的值和类型混为一体，导致后续修改类型会产生大量的修改。</li>\n<li>而枚举类型是一种赋值的效果，直接修改 enmu 中的值即可</li>\n<li>字面量类型不会进去到编译结果<br>所以需要枚举类型。</li>\n</ul>\n<pre><code class=\"ts\">enum ThemeColor &#123;\n  black = &quot;#000000&quot;,\n  white = &quot;#ffffff&quot;,\n&#125;\n</code></pre>\n<blockquote>\n<p>enum 枚举会参与到编译中，编译的结果就是一个对象，可以在运行时使用 enum 枚举。<br>注意：</p>\n</blockquote>\n<ul>\n<li>枚举的字段（key）必须是字符串或数字</li>\n<li>数字枚举的值（value）会自动自增，默认从 0 开始，第一项赋值之后从第一项开始</li>\n<li>被数字枚举约束的变量，可以直接赋值为数字</li>\n<li>数字枚举的编译结果和字符串有所差异<br>最佳实践：</li>\n<li>尽量使用统一类型的数据作为枚举项</li>\n</ul>\n<h3 id=\"接口-interface-1\"><a href=\"#接口-interface-1\" class=\"headerlink\" title=\"接口 interface\"></a>接口 interface</h3><blockquote>\n<p>接口 interface 用于约束类、对象和函数的标准<br>接口常用于对象和类的类型约束，type 常用于变量类型约束。<br>接口 interface 和类型别名 type，非常相似，但是在类的约束上有所区别，type 常用于多种类型联合结合使用或者定义函数类型常用 type，interface 常用于定义类和对象，提供精细化的接口，并且 interface 可以定义多次，被视为合并，还可以继承<br>泛型类型约束时，使用该泛型去继承 interface</p>\n</blockquote>\n<pre><code class=\"ts\">interface Person &#123;\n  name: string;\n  age: number;\n&#125;\ninterface Condition &#123;\n  (n: number): boolean;\n&#125;\n</code></pre>\n<blockquote>\n<p>接口也可以继承，可以通过接口之间的继承，实现多种接口的集合。type 的交叉类型&amp;也可以实现类似的效果，但是两者有所差别：</p>\n</blockquote>\n<ul>\n<li>子接口不能覆盖父接口的成员</li>\n<li>交叉类型会把相同成员的类型进行交叉</li>\n</ul>\n<pre><code class=\"ts\">interface User &#123;\n  readonly id: &quot;1&quot;;\n  name: &quot;张三&quot;;\n&#125;\nlet arr: readonly number[] = [1, 2, 3];\n// arr.splice 、arr[0]=3 、arr.pop()等改变数组类型的方法都会失效\narr = [3, 2, 1]; //注意可以正常赋值，因为readonly约束的是堆中的对象类型，不是栈中的\n</code></pre>\n<blockquote>\n<p>泛型中直接有对应的泛型类型，例如 readonly number[]可以替换为：ReadonlyArray<number></p>\n</blockquote>\n<h2 id=\"模块解析\"><a href=\"#模块解析\" class=\"headerlink\" title=\"模块解析\"></a>模块解析</h2><blockquote>\n<p>模块解析：应该从什么位置寻找模块，在 TS 中，有两种模块解析策略，</p>\n</blockquote>\n<ul>\n<li>classic：经典</li>\n<li>node：node 解析策略（唯一的变化是，将 js 替换为 ts）</li>\n</ul>\n<h2 id=\"类型兼容性\"><a href=\"#类型兼容性\" class=\"headerlink\" title=\"类型兼容性\"></a>类型兼容性</h2><blockquote>\n<p>类型不一致时，可以使用类型断言 as<br>基本类型完全比对<br>对象类型采用：鸭子比对法：即多类型的可以赋值给部分类型的变量，但是对象字面量赋值时不行（严格遵循类型）。</p>\n</blockquote>\n<pre><code class=\"ts\">interface Duck &#123;\n  name: string;\n&#125;\nconst b = &#123;\n  name: &quot;咯咯&quot;,\n  age: 1,\n&#125;;\nconst a: Duck = b; //可将宽泛类型的变量赋值给部分类型变量\n// const a:Duck = &#123; //但是对象字面量赋值时，严格遵循类型约束\n//     name:&quot;嘎嘎&quot;,\n//     age:1\n// &#125;\n</code></pre>\n<blockquote>\n<p>函数类型约束 参数：（传递给函数的参数可以少，但不许多）。返回值（类型必须匹配）</p>\n</blockquote>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><blockquote>\n<p>readonly 表示只读修饰符，不参与最后的编译结果，仅允许对数组或元组字面量使用 readonly 修饰符</p>\n</blockquote>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><blockquote>\n<p>访问修饰符用于 class 类中定义属性列表时使用</p>\n</blockquote>\n<ul>\n<li>public：默认的访问修饰符，公开的，所有代码均可访问</li>\n<li>static：私有的，只有在类中可以访问</li>\n<li>protected：受保护的，不能在外部使用，但是可以在子类中使用</li>\n</ul>\n<h2 id=\"类-class\"><a href=\"#类-class\" class=\"headerlink\" title=\"类 class\"></a>类 class</h2><blockquote>\n<p>ts 中不允许在 constructor 中动态的添加属性，要求使用 属性列表 来描述类中的属性。</p>\n</blockquote>\n<pre><code class=\"ts\">// 不允许在constructor中动态添加属性\nclass user &#123;\n  constructor(name: string) &#123;\n    this.name = name;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"ts\">class User &#123;\n  name: string; //需要在类中定义属性列表，提前声明类的形状\n  age: number = 18; //可以设置默认值\n  sex?: &quot;男&quot; | &quot;女&quot;; //可以设置可选\n  readonly id: string; //readonly只读，不允许该值被修改\n  private sno: string; //私有，是访问属性符，默认是public\n  constructor(name: string) &#123;\n    this.name = name;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><blockquote>\n<p>有时，书写某个函数时，会丢失一些类型信息（多个位置的类型应该保持一致或者有关联的信息），例如参数的类型未知，但是该类型又和返回值的类型相关联，这时就要使用到泛型<br>泛型是指附属于函数、类、接口、类型别名之上的类型。泛型相当于是一个类型变量，在定义时，无法预先知道具体的类型时，可以用该变量来代替，只有调用时，才会确定他的类型<br>很多时候，TS 会智能的根据传递的参数，推导出泛型的类型（前提是该参数使用了该泛型），也可以给泛型设置默认值</p>\n</blockquote>\n<h3 id=\"函数中使用泛型\"><a href=\"#函数中使用泛型\" class=\"headerlink\" title=\"函数中使用泛型\"></a>函数中使用泛型</h3><blockquote>\n<p>在函数名之后写上泛型：<code>&lt;T&gt;</code>，使用函数时，在函数名后面添加，例如：<code>&lt;string&gt;</code></p>\n</blockquote>\n<h3 id=\"类型别名中使用泛型\"><a href=\"#类型别名中使用泛型\" class=\"headerlink\" title=\"类型别名中使用泛型\"></a>类型别名中使用泛型</h3><pre><code class=\"ts\">type callback&lt;T&gt; = (n: T, i: number) =&gt; boolean;\nfunction filter&lt;T&gt;(arr: T[], callback: callback&lt;T&gt;): T[] &#123;\n  return arr;\n&#125;\n</code></pre>\n<h3 id=\"接口中使用泛型\"><a href=\"#接口中使用泛型\" class=\"headerlink\" title=\"接口中使用泛型\"></a>接口中使用泛型</h3><pre><code class=\"ts\">interface callback&lt;T&gt; &#123;\n  (n: T, i: number): boolean;\n&#125;\n</code></pre>\n<h3 id=\"类中使用泛型\"><a href=\"#类中使用泛型\" class=\"headerlink\" title=\"类中使用泛型\"></a>类中使用泛型</h3><blockquote>\n<p>在类中的属性描述中也可以使用泛型。在类中定义，可以约束整个类中所有使用到泛型的地方，和使用该类时传入的类型一致</p>\n</blockquote>\n<pre><code class=\"ts\">class Person&lt;T&gt; &#123;\n  numOrStr: T;\n  constructor(ar: T) &#123;\n    this.numOrStr = ar;\n  &#125;\n  helper(a: T): T[] &#123;\n    return [a];\n  &#125;\n&#125;\nconst a = new Person&lt;string&gt;(&quot;str&quot;);\n</code></pre>\n<h3 id=\"泛型继承\"><a href=\"#泛型继承\" class=\"headerlink\" title=\"泛型继承\"></a>泛型继承</h3><blockquote>\n<p>使用泛型约束函数时，某些时候泛型的类型未知，但是函数内部又要使用泛型参数对应的方法，这个时候就要对泛型的形状进行声明，可以使用该泛型去继承 interface 接口。<br>或者当需要对泛型的类型进一步约束时，可以使用泛型去继承 interface 接口。</p>\n</blockquote>\n<pre><code class=\"ts\">interface hasNameProperty &#123;\n  name: string;\n&#125;\nfunction nameToUpperCase&lt;T extends hasNameProperty&gt;(obj: T): T &#123;\n  obj.name;\n  return obj;\n&#125;\n</code></pre>\n<h3 id=\"多泛型\"><a href=\"#多泛型\" class=\"headerlink\" title=\"多泛型\"></a>多泛型</h3><pre><code class=\"ts\">function minxinArray&lt;T, K&gt;(arr1: T[], arr2: K[]): (T | K)[] &#123;\n  if (arr1.length !== arr2.length) throw Error(&quot;长度&quot;);\n  let result: (T | K)[] = [];\n  for (let i = 0; i &lt; arr1.length; i++) &#123;\n    result.push(arr1[i]);\n    result.push(arr2[i]);\n  &#125;\n  return result;\n&#125;\n</code></pre>\n<h1 id=\"————————————–\"><a href=\"#————————————–\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"项目中使用-ts\"><a href=\"#项目中使用-ts\" class=\"headerlink\" title=\"项目中使用 ts\"></a>项目中使用 ts</h1><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><p>直接在类型定义文件.d.ts 中书写类型，任意文件夹中直接使用，ts 会自动找对应类型</p>\n</li>\n<li><p>declare namespace 定义命名空间，这样可以防止使用混乱，还可以防止变量命名冲突</p>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">declare namespace Test &#123;\n  type Person = &#123;\n    name: string;\n    age: number;\n  &#125;;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>.d.ts 文件可以统一写在 types 文件夹中，也可以写在就近文件夹中</p>\n</li>\n<li><p>三方库声明支持：当一个三方库中没有定义类型文件时，可以自己手写一个类型声明模块，例如</p>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">declare module &quot;antd-dayjs-webpack-plugin&quot;;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>declare function 定义 TS 环境中已存在的 JS 运行时函数，不能用于定义自己手写的函数，常用于定义约束 es 语法内置的函数类型</p>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">declare function eval(x: string): any;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>declare 声明类型、接口等无效，只能用于声明 function、module 和 namespace</p>\n</li>\n<li><p>类型定义时，不能写默认参数值</p>\n</li>\n<li><p>只允许在函数或构造函数实现中使用参数初始化表达式（即参数默认值）</p>\n</li>\n<li><p>鸭子比对法的含义就是：当一个变量被类型约束之后，可以使用包含全部该类型声明，但类型声明更多的变量或字面量对该变量进行赋值</p>\n</li>\n<li><p>索引签名允许定义一个对象类型，该类型可以通过索引访问其属性，并且这些属性的值可以是相同的类型。</p>\n</li>\n<li><p>ts 只支持两种索引签名：字符串和数字，可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p>\n</li>\n<li><p>typeof 操作符用于提取某个变量或类的类型</p>\n</li>\n<li><p>keyof 操作符用于提取某个类型的字面量类型</p>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">type test = &#123;\n  name: &quot;zhang&quot;;\n  age: 18;\n&#125;;\nlet a: keyof test;\na = &quot;name&quot;;\na = &quot;age&quot;;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">interface NumberDictionary &#123;\n  [index: string]: number;\n  length: number; // 可以，length是number类型\n  name: string; // 错误，`name`的类型与索引类型返回值的类型不匹配\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>索引签名可以结合 TS 高级类型特性使用，例如：映射类型</p>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">// 这里OptionsFlags是一个映射类型，它将T类型的所有键映射为boolean类型的值，通过索引签名实现这一点\ntype OptionsFlags&lt;T&gt; = &#123;\n  [P in keyof T]: boolean;\n&#125;;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>元组用于精确数组中每一项的类型，当添加越界的元素时，类型会被限制为元组中每个类型的联合类型</p>\n</li>\n<li><ul>\n<li><pre><code class=\"ts\">let arr: [string, number];\narr = [&quot;1&quot;, 0];\narr.push(1);\narr.push(null); //报错\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>lib.es5.d.ts 中自定义的高级泛型</p>\n</li>\n<li><ul>\n<li>ArrayLike 泛型：类数组类型</li>\n</ul>\n</li>\n<li><ul>\n<li>Partial 泛型 全部属性变为：可选类型</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Partial可选泛型\ninterface User &#123;\n  name: string;\n  age: number;\n&#125;\n// 将User类型全部的属性变为可选类型\ntype UserPartial = Partial&lt;User&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Required 泛型 全部属性变为：必选类型</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Required必选泛型\ninterface User1 &#123;\n  id?: string;\n  sex?: number;\n&#125;\n//将User1类型全部的属性变为必选类型\ntype UserRequired = Required&lt;User1&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Readonly 泛型 全部属性变为：只读类型</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Readonly泛型\ntype User2 = &#123;\n  name: string;\n  id: number;\n&#125;;\n// 将User2的全部类型变为只读类型\ninterface UserReadOnly extends Readonly&lt;User2&gt; &#123;&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Pick 泛型：从类型 T 中选取部分值的类型，创建一个新的类型。（泛型使用时需要传入类型和选取的类型属性）</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Pick泛型，选取部分类型\ntype User3 = &#123;\n  name: string;\n  age: number;\n  id: number;\n&#125;;\n// 选取User3类型中的部分值和类型\ntype UserPicked = Pick&lt;User3, &quot;name&quot; | &quot;age&quot;&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Record 泛型：构造一个类型，其键为第一个泛型参数类型，值为第二个泛型参数类型</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"ts\">// Record泛型，指定对某一类键的类型统一约束\ntype User4 = &#123;\n  age: number;\n  id: number;\n&#125;;\n// 对键为string类型的值进行约束，相当于&#123; [key:string]:number; &#125;\ntype UserRecored = Record&lt;string, number&gt;;\n</code></pre>\n<ul>\n<li><ul>\n<li>Exclude 泛型：排除类型中的某一个类型选项！（适用于对象类型）</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Exclude排除泛型，用于在类型中排除某些类型选项！！\ntype Unicode = &quot;foo&quot; | &quot;bar&quot; | &quot;baz&quot;;\ntype userExclude = Exclude&lt;Unicode, &quot;foo&quot;&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Extract 泛型：指定类型中的某一个类型选项！</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Extract精确泛型，选择某个类型选项！进行精确\ntype Unicode1 = &quot;foo&quot; | &quot;bar&quot; | &quot;baz&quot;;\ntype UserExtract = Extract&lt;Unicode1, &quot;baz&quot;&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Omit 泛型：创建一个新的类型，排除类型中指定类型（第二个参数类型）（适用于联合类型）</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">// Omit泛型\ntype User5 = &#123;\n  name: string;\n  age: 13;\n&#125;;\n// 创建新类型，排除给定类型\ntype UserOmit = Omit&lt;User5, &quot;age&quot;&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>type NonNullable<T> &#x3D; T &amp; {};内置的排除 undefined 和 null 的泛型（巧妙使用了条件类型去精确类型）。</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>&amp;在交叉类型中，具有多种类型全部的属性和方法，这里传入空对象不会对原来造成影响，但是使用了&amp;条件类型，就会通过类型排除和类型首位精确定义类型定义。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Parameters 泛型，用于提取出函数参数的类型，并将其封装为元组</li>\n</ul>\n</li>\n<li><ul>\n<li>ConstructorParameters 泛型，用于提取出构造函数的参数类型（传入 typeof dmq 类），并将其封装为元组</li>\n</ul>\n</li>\n<li><ul>\n<li>ReturnType 泛型，用于提取函数返回值的类型</li>\n</ul>\n</li>\n<li><ul>\n<li>Awaited 泛型：尝试推断一个具有 then 方法（Promise）的最终完成值的类型</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">function fetchUser(): Promise&lt;&#123; id: number; name: string &#125;&gt; &#123;\n  return new Promise((resolve) =&gt; &#123;\n    resolve(&#123; id: 1, name: &quot;张三&quot; &#125;);\n  &#125;);\n&#125;\ntype User = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>instanceType 泛型：获取一个构造函数类型的实例类型</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">type InstanceTyped = InstanceType&lt;typeof MyClass&gt;; //MyClass\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Uppercase Lowercase 泛型，将一个字符串类型的所有字符转为大（小）写</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li><pre><code class=\"ts\">type UpperHello = Uppercase&lt;&quot;hello&quot;&gt;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>Capitalize 泛型，将字符串类型的首字符转为大写</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"react-项目中使用-TS\"><a href=\"#react-项目中使用-TS\" class=\"headerlink\" title=\"react 项目中使用 TS\"></a>react 项目中使用 TS</h2><blockquote>\n<p>配置 ts.config.json</p>\n</blockquote>\n<ul>\n<li>lib 选项表示编译过程中需要引入的库文件列表，react 项目中必须在 lib 中包含 dom 选项</li>\n<li>jsx 选项表示编译过程中如何处理 jsx 语法，react 项目中配置为 preserve，保留给 babel 处理即可，也可以配置为 react-jsx<br>其余部分详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi90eXBlc2NyaXB0\">官网</span></li>\n</ul>\n","categories":["typeScript"],"tags":["typeScript"]},{"title":"three.js","url":"/2023/10/24/ThreeJS/","content":"<h1 id=\"Three-js使用\"><a href=\"#Three-js使用\" class=\"headerlink\" title=\"Three.js使用\"></a>Three.js使用</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTk3MzI0Mzc3OTQzMDgxMDE5\">https://juejin.cn/post/7197324377943081019</span></p>\n<p><img data-src=\"/images/image-20240116092346688.png\" alt=\"/images/image-20240116092346688\"></p>\n<p><img data-src=\"/images/image-20240116091152273.png\" alt=\"/images/image-20240116091152273\"></p>\n<p><img data-src=\"/images/image-20240116091215611.png\" alt=\"/images/image-20240116091215611\"></p>\n<p><img data-src=\"/images/image-20240116091230059.png\" alt=\"/images/image-20240116091230059\"></p>\n<p><img data-src=\"/images/image-20240116091339847.png\" alt=\"/images/image-20240116091339847\"></p>\n<p><img data-src=\"/images/image-20240116091604079.png\" alt=\"/images/image-20240116091604079\"></p>\n<p><img data-src=\"/images/image-20240116091713722.png\" alt=\"/images/image-20240116091713722\"></p>\n","categories":["three.js"],"tags":["three.js","三维"]},{"title":"TDD测试驱动开发","url":"/2024/03/29/TDD/","content":"<h1 id=\"TDD-test-drive-development-测试驱动开发\"><a href=\"#TDD-test-drive-development-测试驱动开发\" class=\"headerlink\" title=\"TDD(test drive development)测试驱动开发\"></a>TDD(test drive development)测试驱动开发</h1><h3 id=\"测试驱动开发的口号：\"><a href=\"#测试驱动开发的口号：\" class=\"headerlink\" title=\"测试驱动开发的口号：\"></a>测试驱动开发的口号：</h3><p>测试先行</p>\n<h3 id=\"测试驱动开发的目标：\"><a href=\"#测试驱动开发的目标：\" class=\"headerlink\" title=\"测试驱动开发的目标：\"></a>测试驱动开发的目标：</h3><p>保证代码的简洁可用</p>\n<h3 id=\"TDD-的规则\"><a href=\"#TDD-的规则\" class=\"headerlink\" title=\"TDD 的规则\"></a>TDD 的规则</h3><p>在 TDD 的过程中，需要遵循两条简单的规则：</p>\n<p>仅在自动测试失败时才编写新代码。<br>消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化）。</p>\n<p>第一条规则的言下之意是每次只编写刚刚好使测试通过的代码，并且只在测试运行失败的时候才编写新的代码，因为每次增加的代码少，即使有问题定位起来也非常快，确保我们可以遵循小步快跑的节奏；第二条规则就是让小步快跑更加踏实，在自动化测试的支撑下，通过重构环节消除代码的坏味道来避免代码日渐腐烂，为接下来编码打造一个舒适的环境。<br>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“简洁”目标，每次只关注一件事</p>\n<h3 id=\"采用-TDD-的动机\"><a href=\"#采用-TDD-的动机\" class=\"headerlink\" title=\"采用 TDD 的动机\"></a>采用 TDD 的动机</h3><p>控制编程过程中的忧虑感。</p>\n<p>有一个有趣的想象，当我感觉压力越大，自身就越不想去做足够多的测试。当知道自己做的测试不够时，就会增加自身的压力，因为我担心自己写的代码有 BUG，对自己编写的代码不够自信，这是一种心态上的变化。此时测试是开发人员的试金石，可以将对压力的恐惧变为平日的琐事，采用自动化测试，就有机会选择恐惧的程度。</p>\n<p>把控编程过程中的反馈与决策之间的差距。</p>\n<p>如果我做了一周的规划，并且量化成一个个可操作的任务写到 to-do list，然后使用测试驱动编码，把完成的任务像这样划掉，那么我的工作目标将变得非常清晰，因为我明确工期，明确待办事项，明确难点，可以在持续细微的反馈中有意识地做一些适当的调整，比如添加新的任务，删除冗余的测试；还有一点更加让人振奋，我可以知道我大概什么时候可以完工。项目经理对软件开发进度可以更精确的把握。</p>\n<p>标注：本文摘抄自：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzgwOTcwOTIxOTkx\">https://juejin.cn/post/6844903780970921991</span><br>感兴趣可自行进行查看</p>\n","categories":["开发模式"],"tags":["开发模式"]},{"title":"Vue使用笔记","url":"/2023/01/12/Vue%E6%9D%82%E8%AE%B0/","content":"<h1 id=\"Vue注意事项\"><a href=\"#Vue注意事项\" class=\"headerlink\" title=\"Vue注意事项\"></a>Vue注意事项</h1><p>一、使用watch监听数组时：</p>\n<p>当使用watch监听数组时，要将deep设置为true，这样才能监听到数组内部的操作，而不是只监听引用是否变化，当需要使用newValue和oldValue时，监听部分需要写数组的拷贝而不是数组本身（否则当数组引用不变而堆数据变化时，oldValue和newValue都是变化之后的数值。）</p>\n<h1 id=\"Vue项目创建过程：\"><a href=\"#Vue项目创建过程：\" class=\"headerlink\" title=\"Vue项目创建过程：\"></a>Vue项目创建过程：</h1><p>（<br>①创建项目 <code>vue create 项目名</code><br>②安装开发依赖：<code>yarn add 包名@版本号 -D</code><br>③安装生产依赖: <code>yarn add 包名</code>，并在main.js中引入和全局属性</p>\n<p>）<br>css选择器和权重的计算<br>font-size和字体详解（小写x为基准）<br>小黑记事本案例<br>vue中结合网络数据库开发应用（axios网络请求库）、<br>前端避雷技术：Jequry、Angular js、php、rubian rails构建应用程序<br>form-serialize插件获取表单的各项</p>\n<h1 id=\"Vue知识点\"><a href=\"#Vue知识点\" class=\"headerlink\" title=\"Vue知识点\"></a>Vue知识点</h1><p>{</p>\n<p>Vue文件分类：将Vue文件分为页面文件和可复用的文件</p>\n<h6 id=\"一、vue项目初始化：\"><a href=\"#一、vue项目初始化：\" class=\"headerlink\" title=\"一、vue项目初始化：\"></a>一、vue项目初始化：</h6><p>（①vue create文件名②cd进入文件夹③yarn add添加引用包④main.js引入样式(引用方式)⑤vue.config.js中禁用eslint检查)</p>\n<h6 id=\"二、vue组件使用：\"><a href=\"#二、vue组件使用：\" class=\"headerlink\" title=\"二、vue组件使用：\"></a>二、vue组件使用：</h6><p>（①在components文件夹下添加vue文件组件②在App.vue中import组件form’路径’③在export default的componets下注册组件，有些可简写④div中用组件名使用组件）</p>\n<h6 id=\"三、vue中export-default中的属性：\"><a href=\"#三、vue中export-default中的属性：\" class=\"headerlink\" title=\"三、vue中export default中的属性：\"></a>三、vue中export default中的属性：</h6><p>（name,components,props,created,mounted,data,methods，watch,computed,activated,deactivated）</p>\n<h6 id=\"四、vue中使用axios\"><a href=\"#四、vue中使用axios\" class=\"headerlink\" title=\"四、vue中使用axios\"></a>四、vue中使用axios</h6><p>（①下载axios包（yarn add axios）②在main.js中引入(impoort axios from ‘axios’)③配置基础地址（axios.defaults.baseURL&#x3D;”<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZXNjb29rLmNu\">https://www.escook.cn&quot;）④将axios挂载到Vue原型上，作为全局属性（在main.js中添加：Vue.prototype.$axios=axios），⑤App.vue的created中使用全局属性axios⑥接口地址为/api/cart⑦进行数据渲染）</span> </p>\n<h6 id=\"五、动态组件：\"><a href=\"#五、动态组件：\" class=\"headerlink\" title=\"五、动态组件：\"></a>五、动态组件：</h6><p>（①创建要被切换的组件样式②引入到要展示的vue文件中，注册③变量承载要显示的组件名④设置承载点<component :is=\"变量\"></component>⑤点击按钮，切换comName的值为要显示的组件名⑥使用vue内置的keep-alive组件，将抱起来的组件缓存起来<keep-alive></keep-alive>  )</p>\n<h6 id=\"六、组件插槽\"><a href=\"#六、组件插槽\" class=\"headerlink\" title=\"六、组件插槽\"></a>六、组件插槽</h6><p>（①通过slot标签占位，让组件内可以接受不同的标签结构样式，为了让封装的组件显示不同的标签结构（灵活），②使用：在模板中添加<slot>默认内容</slot>占位，引入模板时在模板内添加占位标签里的内容③具名插槽：子组件，在slot上绑定name&#x3D;”name值”，在使用组件，传入自定义标签，用template标签内加v-slot&#x3D;”name值”）④作用域插槽：使用子组件时在template中使用scope</p>\n<h6 id=\"七、自定义指令\"><a href=\"#七、自定义指令\" class=\"headerlink\" title=\"七、自定义指令\"></a>七、自定义指令</h6><p>（①全局注册：Vue.directive(“指令名”,{“inserted” (el,binding){对el标签扩展额外的功能②局部注册：export.default中添加配置项directives:{“指令名”:{inserted(el,binding){对el进行操作}}}})③使用：在标签内添加属性:v-指令名&#x3D;”binding.value”(将自定义传值与指令操作相关联)）自定义指令中除了inserted方法还有update方法</p>\n<h6 id=\"八、父子组件数据交互\"><a href=\"#八、父子组件数据交互\" class=\"headerlink\" title=\"八、父子组件数据交互\"></a>八、父子组件数据交互</h6><p>（①在父组件中引入和注册并使用②子组件定义好props属性，设定值得类型与校验③子组件中使用设定的props数据④父组件data中定义好子组件中props属性中的相应类型的值⑤父组件中使用时:绑定子组件props中的数据）</p>\n<h6 id=\"九、切换组件显示\"><a href=\"#九、切换组件显示\" class=\"headerlink\" title=\"九、切换组件显示\"></a>九、切换组件显示</h6><p>（①）</p>\n<h6 id=\"十、vue组件之间传值\"><a href=\"#十、vue组件之间传值\" class=\"headerlink\" title=\"十、vue组件之间传值\"></a>十、vue组件之间传值</h6><p>（一、父组件给子组件传值：①父组件使用子组件时，:绑定值，并在data中注册②子组件props中注册相同名称的值）<br>（二、子组件给父组件传值：①在子组件中使用this.$emit方法自定义一个事件并传值②在父组件中使用该事件通过函数操作传来的值）</p>\n<h2 id=\"effct高级\"><a href=\"#effct高级\" class=\"headerlink\" title=\"effct高级\"></a>effct高级</h2><h3 id=\"effectScope\"><a href=\"#effectScope\" class=\"headerlink\" title=\"effectScope\"></a>effectScope</h3><p><strong>effectScope是vue3.2新增的一个api，用于创建一个副作用作用域，内部自动捕获副作用，进行响应化设置。</strong></p>\n<pre><code class=\"javascript\">// 一个scope可以执行一个run函数（接受一个函数作为参数，返回该函数的返回值，并且捕获所有在该函数执行过程中创建的effect，包括可以创建effect的API）\n// 例如：computed，watch，watchEffect等。\nlet a = 1;\nconst scope = effectScope();\nscope.run(()=&gt;&#123;\n const doubled = computed(()=&gt;a * 2);\n watch(doubled,()=&gt;console.log(doubled.value))\n watchEffect(()=&gt;&#123; //watchEffect函数会自动检测内部的effect副作用，进行响应化设置\n  console.log(&#39;Count&#39;,doubled.value);\n &#125;)\n&#125;)\nscope.stop();\n// 当调用scope.stop)()函数时，所有被捕获的effect都会被取消，包括nested scopes也会被递归取消\n</code></pre>\n<h3 id=\"嵌套scope\"><a href=\"#嵌套scope\" class=\"headerlink\" title=\"嵌套scope\"></a>嵌套scope</h3><p>嵌套scope也会被他们的父级scope收集，并且当父级scope销毁的时候，所有的后代scope也会被递归销毁。</p>\n<pre><code class=\"javascript\">const scope = effectScope()\nscope.run(() =&gt; &#123;\n  const doubled = computed(() =&gt; counter.value * 2)\n  // not need to get the stop handler, it will be collected by the outer scope\n  effectScope().run(() =&gt; &#123;\n    watch(doubled, () =&gt; console.log(doubled.value))\n  &#125;)\n  watchEffect(() =&gt; console.log(&#39;Count: &#39;, doubled.value))\n&#125;)\n// dispose all effects, including those in the nested scopes\nscope.stop()\n</code></pre>\n<p><strong>effectScope接受一个参数可以在分离模式下创建，detached scope不会被父级collect</strong></p>\n<pre><code class=\"javascript\">let nestedScope\nconst parentScope = effectScope()\nparentScope.run(() =&gt; &#123;\n  const doubled = computed(() =&gt; counter.value * 2)\n  // with the detected flag,\n  // the scope will not be collected and disposed by the outer scope\n  nestedScope = effectScope(true /* detached */)\n  nestedScope.run(() =&gt; &#123;\n    watch(doubled, () =&gt; console.log(doubled.value))\n  &#125;)\n  watchEffect(() =&gt; console.log(&#39;Count: &#39;, doubled.value))\n&#125;)\n// disposes all effects, but not `nestedScope`\nparentScope.stop()\n// stop the nested scope only when appropriate\nnestedScope.stop()\n</code></pre>\n<h3 id=\"onScopeDispose\"><a href=\"#onScopeDispose\" class=\"headerlink\" title=\"onScopeDispose\"></a>onScopeDispose</h3><p>全局钩子函数，相当于副作用域中的onUnmounted功能，不同的是它工作在scope中，而不是当前instance中。</p>\n<p>这使得composable functions可以通过他们的scope清楚他们的副作用。</p>\n<blockquote>\n<p>需要注意的是: 由于 setup() 默认会为当前 instance 创建一个 scope，所以当没有明确声明一个scope的时候，onScopeDispose等同于onUnmounted。</p>\n</blockquote>\n<pre><code class=\"javascript\">import &#123; onScopeDispose &#125; from &#39;vue&#39;\nconst scope = effectScope()\nscope.run(() =&gt; &#123;\n  onScopeDispose(() =&gt; &#123;\n    console.log(&#39;cleaned!&#39;)\n  &#125;)\n&#125;)\nscope.stop() // logs &#39;cleaned!&#39;\n</code></pre>\n<h3 id=\"getCurrentScope\"><a href=\"#getCurrentScope\" class=\"headerlink\" title=\"getCurrentScope\"></a>getCurrentScope</h3><p>通过getCurrentScope函数,可以获得当前scope作用域</p>\n<pre><code class=\"javascript\">import &#123;getCurrentScope&#125; from &#39;vue&#39;;\ngetCurrentScope(); //返回当前scope作用域或者undefined\n</code></pre>\n<h1 id=\"Vue-router\"><a href=\"#Vue-router\" class=\"headerlink\" title=\"Vue-router\"></a>Vue-router</h1><p>①安装npm i vue-router@(vue2用3的版本,vue3用4版本)</p>\n<p>②安装：运行命令yarn add vue-router安装</p>\n<p>③配置：src下新建router文件夹，下面的index.js中进行配置：</p>\n<pre><code class=\"javascript\">imprt Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\nVue.use(VueRouter)\n</code></pre>\n<p>④创建路由组件：src下的views文件夹下新建vue页面</p>\n<p>⑤创建路由组件：在router里index.js中引入：</p>\n<pre><code class=\"javascript\">import Home from &#39;../views/Home.vue&#39;\n</code></pre>\n<p>⑥配置路由表：将路由与组件进行映射：</p>\n<pre><code class=\"javascript\">const routes = [\n  &#123; path: &#39;/&#39;, component: Home &#125;,\n  &#123; path: &#39;/about&#39;, component: About &#125;,\n  // 更多路由配置...\n]\n</code></pre>\n<p>⑦创建router实例</p>\n<pre><code class=\"javascript\">const router = new VueRouter(&#123;\n  routes\n&#125;);\n</code></pre>\n<p>⑧Vue中挂载router</p>\n<pre><code class=\"javascript\">new Vue(&#123;\n  router,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;);\n</code></pre>\n<p>effect</p>\n<h6 id=\"十二、跨组件传值（没有引用关系）\"><a href=\"#十二、跨组件传值（没有引用关系）\" class=\"headerlink\" title=\"十二、跨组件传值（没有引用关系）\"></a>十二、跨组件传值（没有引用关系）</h6><p>（①创建文件夹EventBus，下面创建index.js文件，文件中引入Vue，并默认导出空对象②）<br>十三、this.$refs获取组件 , 通过组件中ref属性，调用组件中的函数（①组件使用时添加ref属性，使用时通过this.$refs.ref属性.函数名()  ）<br>十四、this.$nextTick(fn(){})方法中等待DOM更新后触发$nextTick中的函数（ref中的函数会在DOM更新之前触发，DOM更新是异步任务），他可以保证我们在调用子组件的方法时使用到的数据是最新的数据。$nextTick函数原地返回一个Promise对象，主动在js中触发标签事件：获取DOM对象，调用事件方法<br>十五、name属性的作用：注册时可以定义自己的名字<br>十六、组件缓存<keep-alive></keep-alive>组件，<br>十七、动态组件：<component :is=\" \"></component><br>十八、组件插槽（具名插槽）：①目的：为了让封装的组件显示不同的标签结构    ②使用：&lt;slot #name值&#x3D;“子组件传值的属性”     或   v-slot:name值&#x3D;“子组件传值的属性”&gt;     </slot>占位(**注意vue2中，只能使用v-slot，vue3中只能使用#name值)  ③使用定义的组件，传入具体的标签替换到slot<br>             ③插槽默认内容，子组件slot内部书写默认内容④作用域插槽：使用子组件内的变量：(方法:在slot上绑定属性和子组件内的值，在使用组件，传入自定义标签，父组件中用template标签scope属性）<br>十九、自定义指令：一、①全局方法②局部注册  二、自定义指令传值<br>自定义指令的生命周期:①bind②inserted③update④componentUpdated⑤unbind<br>二十、Vue生命周期【创建，挂载，更新，销毁】 （1）beforeCreated 此时拿不到data中的数据（2）created data和methods初始化之后，此时可以拿到变量 （3）beforeMount 挂载之前拿不到真实的DOM （4）mounted 挂载之后，可以使用真实DOM （5）beforeUpdate 真实DOM更新之前（6）updated 更新之后，当数据发生变化并更新页面后执行，可以获取更新之后的DOM （7）beforeDestroy 销毁之前（8）destroyed 销毁之后<br>二十一、通过ref获取标签里面的对象（尤其是组件）this.$refs.值获取组件对象【组件通信，但不常用】<br>二十二、this.$nextTick(fn()) 原地返回Promise对象，使用 $nextTick 可以在下一次 DOM 更新周期结束之后执行回调函数，确保在更新后进行相关操作。<br>二十三、动态组件:<component :is=''>多个组件在同一个挂载点出现<br>二十四、组件缓存 <keep-alive></keep-alive>将包起来的组件缓存起来<br>二十三、在使用组件缓存的时候，会多出两个钩子函数：activated 激活状态 与deactivated失去激活状态<br>二十四、slot组件插槽：在组件内部不确定内容的位置设置slot标签，标签内是默认内容，父组件使用组件时中间的内容是插槽的内容<br>二十五、作用域插槽（使用插槽时，想使用子组件内的变量）①子组件在slot上bind绑定属性和值②使用组件时用v-slot&#x3D;名 获取到组件对象，进而使用组件对象中绑定的属性和值</p>\n<h2 id=\"二十六、Vue-router路由系统\"><a href=\"#二十六、Vue-router路由系统\" class=\"headerlink\" title=\"二十六、Vue-router路由系统\"></a>二十六、Vue-router路由系统</h2><p>①下载vue-router路由系统使用<br>yarn add vue-router<br>②在main.js中引入VueRouter函数,和带切换的页面<br>import VueRouter from ‘vue-router’<br>import My from ‘@&#x2F;views&#x2F;my’<br>③添加到Vue.use（）身上-注册全局RouterLinkRouterView组件<br>Vue.use(VueRouter)<br>④创建路由规则数组-路径和组件名对应关系<br>const routes &#x3D; [{path:’&#x2F;my’,component:My},{其他}]<br>⑤用规则生成路由对象<br>const router &#x3D; new VueRouter({<br>routes })<br>⑥将路由对象注入到new Vue实例中<br>new Vue({<br>  el: ‘#app’,<br>  router, &#x2F;&#x2F; 将路由对象注入到 Vue 实例中<br>  render: h &#x3D;&gt; h(App)<br>});<br>⑦App.vue中用router-view标签作为挂载点，切换不同的路由页面<br><router-view></router-view><br>—————export default router;导出之后可以全局进行引入(App.vue中export default{router,})<br>二十七、声明式导航（传参），①可以用<router-link to=\"url\"></router-link>，其中to里面不用写#号。标签来代替要跳转到指定页面的a标签（本质上相同，但是添加了自带类名，自带导航高亮）②跳转传参：方法一：在router-link中的to属性上传值 ，to&#x3D;”url&#x2F;path?参数名&#x3D;值”。在视图vue的标签中使用。方法二： 定义路由规则时添加路径{path：”&#x2F;first&#x2F;:name“ ” ,component:First}。然后传值<router-link to=\"/first/值\">&lt;&#x2F;&gt;。再使用</p>\n<p>二十八、路由重定向，在路由规则中进行匹配({path:”&#x2F;“,redirect:”&#x2F;find”})<br>二十九、路由404设置，找不到页面时进行返回404页面（404一定要在路由规则末尾），使用{path:”<em>“,component:NotFound}<br>三十、路由模式::①hash路由：url&#x2F;#&#x2F;home（哈希路由可以直接被浏览器识别）②history路由：url&#x2F;home③将hash路由更改为history路由：在new VueRouter配置项中mode:”history”（</em>注意history路由会将路径中识别为文件夹，要在服务器端进行设置）<br>三十九、路由守卫（main.js中对路由权限进行和判断）<br> <code>router.beforeEach(to,from,next)=&gt;&#123;</code><br> <code>//next是一个函数体，只有next()执行才会让路由正常跳转，next(false)则停留，next(&quot;修改到另一个路由路径&quot;，不执行则不跳转)</code><br>      <code>router.beforeEach((to,from,next)=&gt;&#123;</code><br>            <code>if(to.path === &#39;/my&#39; &amp;&amp; isLogin === false)&#123;</code><br>            <code>alert(&#39;请登录&#39;);    next(false)</code><br><code>&#125;else&#123;    next()        &#125;&#125;)&#125;</code><br>三十一、编程式导航（js方式跳转路由，先给标签添加点击事件，然后将路径作为值传进函数），接着在函数内部，方法一：this.$router.push({path:”函数中的路径值”})<br>方法二：this.$router.push({name:”路由名称”}) 注意用name跳转时，浏览器上的url不会改变（无感知跳转，方便修改）<br>三十二、编程式导航（跳转传参）方法一：①this.$router.push({path（或name）:”路由路径”,name:”路由名“，query:{“<br>参数名”：值}})②使用时用<br>方法二(使用path时会忽略params)：this.$router.push({name:”路由名称”,name:”路由名“，params:{“<br>参数名”：值}})②使用时用 <br>（可以组合但是path和params组合不能一起使用）<br>三十三、路由嵌套：①创建二级路由页面：views文件夹下新建文件夹和vue文件②main.js中配置二级路由{path:”&#x2F;first”,component:First,children:[{path:”one”,component:One},]} (*注意二级路由路径中不加&#x2F;符) ③在一级页面中设置<router-link to=\"二级路由路径\">，再设置<router-view>标签显示二级路由页面<br>三十四、router-link激活的2个类型的区别（url上的hash值包含a标签href，就添加模糊匹配的类名，若url上的hash和导航的a标签完全匹配就添加精确匹配的类名）<br>三十五、路由守卫：（main.js中，在生成路由对象之后）router.beforeEach((to,from,next)&#x3D;&gt;{ 判断和处理 })  【其中to表示要去到的url，from表示从哪里跳转的，next()调用才能让路由正常的跳转切换，next(false)在原地停留，next(‘强制修改到另一个路由路径上’)，如果不调用next,则页面留在原地 】<br>三十六、Vant组件库【Vant是一个轻量、可靠的移动端Vue组件库，开箱即用】 （注意vue版本号和vant版本号的兼容性问题）<br>三十七、支持组件自定义，在组件使用时传值，子组件中使用props接受 ，:style&#x3D;“{使用绑定的值和属性}”<br>三十八、将axios挂载到vue原型上，方便全局使用 </p>\n<p>【总结】 </p>\n<p>}</p>\n<h2 id=\"分析总结：\"><a href=\"#分析总结：\" class=\"headerlink\" title=\"****分析总结：\"></a>****分析总结：</h2><p>一、**动态组件和vue-router<br>动态组件可以根据具体的条件和状态来灵活地切换和加载组件，这种切换是在同一个组件内部进行的，不涉及 URL 的变化和页面的跳转。可以用于组件复用，条件渲染，动态加载和替换部分组件（轻量灵活，不需要路由跳转和重新渲染，组件复用减少代码重复）<br>二、编程式导航和路由式导航<br>①声明式导航（路由式导航）：</p>\n<p>声明式导航是通过在模板中使用指令（如 <router-link>）或组件（如 <router-view>）来定义和触发路由跳转的方式。</p>\n<p>它基于 Vue Router 提供的组件和指令，使得在模板中进行页面导航更加简洁和直观。</p>\n<p>②声明式导航适用于那些在模板中静态定义的导航链接，例如菜单、导航栏等。通过声明式导航，你可以直接在模板中定义导航链接，点击链接时自动触发路由跳转。<br>编程式导航：</p>\n<p>编程式导航是通过在代码中以编程方式触发路由跳转的方式。</p>\n<p>它使用路由实例的方法来进行导航，例如使用 router.push 方法进行页面跳转。</p>\n<p>编程式导航适用于那些需要根据特定条件或用户操作来触发页面跳转的场景。通过编程式导航，你可以在任何地方、任何时候根据需要进行页面的跳转。</p>\n<p>}<br>*<em><strong>注意</strong><br>&#x2F;</em> css中禁止双击选中文本 *&#x2F;<br>.element {<br>  user-select: none;<br>}</p>\n<p>原始类型的值不能直接取反，（true&amp;&amp;false）,可以使用Obj.true进行取反<br>当父亲组件给子组件传值，需要通过对象的项目引用的关系来影响对象里面的值时，需要使用props的对象方法，而不能用数组方法<br>element-ui适用于vue2项目，vue3项目需要使用element-plus<br>v-bind:“ ” ，里面是属性时直接写，里面不是属性时要加括号<br>v-for遍历对象时，加上key属性，有id绑定id，没有id绑定index<br>过滤器使用场景：①在插值语法中使用②在v-bind中value | 过滤器1 | 过滤器2<br>过滤器使用于差值表达式和动态绑定中：管道符前面是过滤器的第一个·参数，过滤器的第二个参数写在其()里面<br>计算属性：相比于函数带有缓存，减少了函数的执行<br>侦听器：①侦听值：watch:{变量名（newVal,oldVal）{改变时发生的事件}}<br>②侦听对象：watch:{“侦听的名称”：{immediate:true,deep:true,handler(newVal,oldVal){侦听值改变时的操作} }}<br>ajax ：异步请求后端的技术,基于原生ajax+Promise技术封装通用于前后端的请求库（原理是XMLHttpRequest）<br>@是vue中src的绝对路径（webpack）,#是当前页面的路径<br>props类型校验：props:{name:String,color:{type:String,required:true,default:red}} 其中有自定义校验规则(验证器validator)：validator(value){校验函数体}<br>v-model绑定input值时，只能使用简易的没有歧义的js语法，若要使用较难的js语法需要使用watch进行监听（监听对象时，需要用深度监听）<br>计算属性的get方法在访问这个计算属性时触发，当模板首次渲染，或者当计算属性所依赖的响应式数据发生变化时重新触发<br>arr.reduce((sum,obj)&#x3D;&gt;{函数体},0)  返回累加和sum，sum的初始值为0（自定义）</p>\n<h2 id=\"代码部分\"><a href=\"#代码部分\" class=\"headerlink\" title=\"代码部分\"></a>代码部分</h2><p>——————————————————————————————————————————【*】路由导航中代码：(main.js)</p>\n<p><code>import Vue from &#39;vue&#39;</code><br><code>import App from &#39;./App.vue&#39;</code><br><code>Vue.config.productionTip = false</code><br><code>// 引入</code><br><code>import VueRouter from &#39;vue-router&#39;</code><br><code>import First from &#39;@/views/First&#39;</code><br><code>import Second from &#39;@/views/Second&#39;</code><br><code>import Third from &#39;@/views/Third&#39;</code><br><code>import NotFound from &#39;@/views/NotFound&#39;</code><br><code>import ViewsOne from &#39;@/views/Second/ViewsOne&#39;</code><br><code>import ViewsTwo from &#39;@/views/Second/ViewsTwo&#39;</code><br><code>import ViewsThree from &#39;@/views/Second/ViewsThree&#39;</code></p>\n<p><code>// 注册全局组件</code><br><code>Vue.use(VueRouter)</code><br><code>// 规则数组</code><br><code>const routes = [</code><br>  <code>// 匹配默认hash值路径,重定向到页面，检测网页打开的默认路由</code><br>  <code>&#123;</code><br>    <code>path: &#39;/&#39;,</code><br>    <code>redirect: &quot;/second&quot;,</code><br>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/first&#39;,</code><br>    <code>component: First,</code><br>    <code>name: &quot;First&quot;,</code></p>\n<p>   &#96;&#96;meta:{title:”首页”}             &#x2F;&#x2F;meta元字符，用于传值，路由组件可以通过this.$route.mata.属性名 拿到&#96;</p>\n<p>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/second&#39;,</code><br>    <code>component: Second,</code><br>    <code>name: &#39;Second&#39;,</code><br>    <code>// 给页面配置二级路由</code><br>    <code>children: [</code><br>      <code>&#123;</code><br>        <code>path: &quot;viewsone&quot;,</code><br>        <code>component: ViewsOne</code><br>      <code>&#125;,</code><br>      <code>&#123;</code><br>        <code>path: &quot;viewstwo&quot;,</code><br>        <code>component: ViewsTwo</code><br>      <code>&#125;,</code><br>      <code>&#123;</code><br>        <code>path: &quot;viewsthree&quot;,</code><br>        <code>component: ViewsThree</code><br>      <code>&#125;,</code><br>    <code>]</code><br>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/third&#39;,</code><br>    <code>component: Third,</code><br>    <code>name: &quot;Third&quot;</code><br>  <code>&#125;,</code><br>  <code>// 绑定值给视图</code><br>  <code>&#123;</code><br>    <code>path: &#39;/first/:name&#39;,</code><br>    <code>component: First,</code><br>    <code>name: &#39;First&#39;</code><br>  <code>&#125;,</code><br>  <code>&#123;</code><br>    <code>path: &#39;/second/:name&#39;,</code><br>    <code>component: Second,</code><br>    <code>name: &quot;Second&quot;,</code><br>  <code>&#125;, &#123;</code><br>    <code>path: &#39;/third/:name&#39;,</code><br>    <code>component: Third,</code><br>    <code>name: &quot;Third&quot;</code><br>  <code>&#125;,</code><br>  <code>// 404一定在配置在规则数组最后</code><br>  <code>&#123;</code><br>    <code>path: &quot;*&quot;,</code><br>    <code>component: NotFound</code><br>    <code>, name: &quot;NotFound&quot;</code><br>  <code>&#125;</code></p>\n<p><code>]</code><br><code>// 生成路由对象</code><br><code>const router = new VueRouter(&#123;</code><br>  <code>// routes是固定的key，传入规则数组</code><br>  <code>routes,</code><br>  <code>// 默认不写是hash值</code><br>  <code>mode: &quot;history&quot;</code><br><code>&#125;)</code><br><code>// 路由守卫，根据路由做出判断</code><br><code>const isLogin = false</code><br><code>router.beforeEach((to, from, next) =&gt; &#123;</code><br>  <code>if (to.path === &#39;/first&#39; &amp;&amp; isLogin === false) &#123;</code><br>    <code>alert(&#39;请登录&#39;)</code><br>    <code>next(false)  //阻止路由跳转</code><br>  <code>&#125; else &#123;</code><br>    <code>next()  //正常放行</code><br>  <code>&#125;</code><br><code>&#125;)</code><br><code>new Vue(&#123;</code><br>  <code>router,</code><br>  <code>render: h =&gt; h(App),</code><br><code>&#125;).$mount(&#39;#app&#39;)</code></p>\n<h1 id=\"Vue项目工具\"><a href=\"#Vue项目工具\" class=\"headerlink\" title=\"Vue项目工具\"></a>Vue项目工具</h1><h6 id=\"1、vant组件库（移动端vue组件库）\"><a href=\"#1、vant组件库（移动端vue组件库）\" class=\"headerlink\" title=\"1、vant组件库（移动端vue组件库）\"></a>1、vant组件库（移动端vue组件库）</h6><p>一、下载安装（根据vue版本）、引入(import)和全局注册(Vue.use)（main.js中）、直接使用Vant组件名<br>二、按需引入：安装（<code>yarn add @vant/auto-import-resolver unplugin-vue-components -D</code>）、配置、使用、引入</p>\n<h6 id=\"2、element-ui（PC端vue组件库）\"><a href=\"#2、element-ui（PC端vue组件库）\" class=\"headerlink\" title=\"2、element-ui（PC端vue组件库）\"></a>2、element-ui（PC端vue组件库）</h6><h6 id=\"3、postcss-（vue项目插件，配合webpack翻译css代码）\"><a href=\"#3、postcss-（vue项目插件，配合webpack翻译css代码）\" class=\"headerlink\" title=\"3、postcss  （vue项目插件，配合webpack翻译css代码）\"></a>3、postcss  （vue项目插件，配合webpack翻译css代码）</h6><p>postcss-pxtorem （ 配合webpack , 自动将 px 转成 rem ）</p>\n<p>一、下载 postcss    和    postcss-pxtorem</p>\n<p><code>yarn  add  postcss  postcss-pxtorem</code></p>\n<p>&#96;二、文件夹 src下新建postcss.config.js</p>\n<p><code>module.exports = &#123;</code></p>\n<p><code>plugins:&#123;</code></p>\n<p><code>&#39;postcss-pxtorem&#39;:&#123;</code></p>\n<p><code>//能够将所有元素的px单位转成rem</code></p>\n<p><code>//rootValue：转换px的基准值。</code></p>\n<p><code>//例如一个元素宽是75px，转换成rem之后就是2rem 。</code></p>\n<p><code>rootValue:37.5 ,</code></p>\n<p><code>propList:[&#39;*&#39;]</code></p>\n<p><code>&#125;&#125;&#125;</code></p>\n<h1 id=\"Vuex介绍\"><a href=\"#Vuex介绍\" class=\"headerlink\" title=\"Vuex介绍\"></a>Vuex介绍</h1><pre><code class=\"javascript\">npm  install vuex --save\nimport  Vuex from  &#39;vuex&#39;\nVue.use(Vuex)\nconst store = new Vuex.Store(&#123; state:&#123;count:0&#125; &#125;) \nnew Vue(&#123; el:&#39;#app&#39;, render:h =&gt; h(app) , router , store &#125;)\n</code></pre>\n<h3 id=\"Vuex基础\"><a href=\"#Vuex基础\" class=\"headerlink\" title=\"Vuex基础\"></a>Vuex基础</h3><p>一、Vuex的介绍（创建store仓库，项目中大范围进行数据共享）<br>1、简介：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。<br>它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension (opens new window)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n<p>Vuex就是用来存放全局变量的，供所有组件使用</p>\n<p>2、通俗理解<br>Vuex相当于一个仓库，仓库中可以存全局变量，方法。一个项目一个仓库，Vuex充当项目的存储模块</p>\n<h4 id=\"Vuex的模块\"><a href=\"#Vuex的模块\" class=\"headerlink\" title=\"Vuex的模块\"></a>Vuex的模块</h4><h4 id=\"（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（-this-store-commit（’子模块名-x2F-键名‘））\"><a href=\"#（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（-this-store-commit（’子模块名-x2F-键名‘））\" class=\"headerlink\" title=\"（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（ this.$store.commit（’子模块名&#x2F;键名‘））\"></a>（store中：state、mutations（commit）、actions（dispatch）、getters（getters）、Module（ this.$store.commit（’子模块名&#x2F;键名‘））</h4><p>三大模块中  辅助函数  使用时导入：（使用辅助函数形式时，传参需要在事件发生处传值）     子组件中：</p>\n<pre><code class=\"javascript\">import &#123; mapState ,mapMutations,mapActions&#125; from &#39;vuex&#39;  //导入辅助函数\ncomputed:&#123;\n    ...mapState([&#39;键值&#39;])       //计算属性中使用state中的值\n    //直接使用\n&#125;\nmethods：&#123;\n    ...mapMutations([&#39;函数1&#39;，&#39;函数2&#39;])       //methods中使用Mutations中的函数\n    ...mapActions([&#39;函数1&#39;，&#39;函数2&#39;])        //methods中使用Actions中的异步函数\n    //直接使用\n&#125;\n</code></pre>\n<p>（模块中定义函数时，第一个参数为state，方便拿到其中的数据，通过state.数据名）</p>\n<h6 id=\"【1】state数据\"><a href=\"#【1】state数据\" class=\"headerlink\" title=\"【1】state数据\"></a>【1】<code>state</code>数据</h6><p>【】     共享状态数据，存数据</p>\n<p>（1）定义 （在main.js中Vuex.Store中：）</p>\n<p>（2）组件获得数据的方式：</p>\n<p>①组件通过$store.键名  获得数据</p>\n<p>②从vuex中按需导入mapState函数，将全局数据，映射为当前组件的计算属性（子组件中）</p>\n<pre><code class=\"javascript\">import  &#123; mapState &#125;  from  &#39;vuex&#39;\ncomputed:&#123; ...mapState([&#39;键名&#39;])  &#125;\n</code></pre>\n<h6 id=\"【2】mutaitions修改（函数）\"><a href=\"#【2】mutaitions修改（函数）\" class=\"headerlink\" title=\"【2】mutaitions修改（函数）\"></a>【2】<code>mutaitions</code>修改（函数）</h6><p>【】   修改state<strong>必须</strong>通过mutations，但其只能执行同步代码，改数据</p>\n<p>（1）定义函数，传参state，通过state.名得到state中的数据进行修改 （在main.js中Vuex.Store中：）</p>\n<p>（2）组件在组件函数中，通过如下，调用state中的函数并传参</p>\n<pre><code class=\"javascript\">this.$store.commit（&#39;函数名&#39;，形参）\n//main.js中：\nmutations:&#123;函数名：&#125;\n</code></pre>\n<p>（3）<code>...mapMutations([&#39;函数名&#39;,’函数名2‘])  辅助函数</code>（***需要导入），组件函数中使用，子组件函数名与mutations中函数名保持一致，</p>\n<p>传参在事件发生处（@click&#x3D;’fn(参数)’）</p>\n<pre><code>子组件中import  &#123; mapMutations ..等 &#125;  from  &#39;vuex&#39;\nmethods中：&#123;...mapMutations([&#39;键名1，键名2&#39;]) ,\n 函数()里通过  this.键名() 调用\n</code></pre>\n<h6 id=\"【3】actions-异步\"><a href=\"#【3】actions-异步\" class=\"headerlink\" title=\"【3】actions   异步\"></a>【3】<code>actions</code>   异步</h6><p>【】执行异步操作，数据提交给<strong>mutations</strong>进行修改，从后端获取数据，更新到state中的count中（main.js中）</p>\n<p>【】注意在action中，不能直接修改state中的数据，必须通过<strong>context.commit（）函数</strong>触发某个mutation才行（main.js中）</p>\n<p>（1）在actions中定义函数并传参 （在main.js中Vuex.Store中：）</p>\n<p>（2）actions方法参数：</p>\n<p>①<code>context</code>，相当于组件中的this.$store，即获得store中的值</p>\n<p>②形参，用于传值</p>\n<p>（3）组件中调用actions（传参时，在定义actions函数时要接收）</p>\n<p>①原始形式调用：<code>this.$store.dispatch(&quot;函数名&quot;，形参)</code></p>\n<p>②辅助函数形式调用（***需要导入）：</p>\n<p>子组件中导入，methods方法中使用：</p>\n<pre><code class=\"javascript\">...mapActions([&#39;函数名&#39;,&#39;函数名2&#39;]，)\n//子组件函数中调用（如下）  或者直接在子组件触发事件上使用函数 @click=&quot;函数名(形参)&quot;\n子组件函数()&#123;\nthis.函数名（形参）\nthis.函数名2(形参)  &#125;\n</code></pre>\n<h6 id=\"【4】getters计算（包装数据）\"><a href=\"#【4】getters计算（包装数据）\" class=\"headerlink\" title=\"【4】getters计算（包装数据）\"></a>【4】<code>getters</code>计算（包装数据）</h6><p>【】从state中派生出一些状态，这些状态是依赖state的（相当于计算属性，二次处理数据），此时会用到getters</p>\n<p>（1）定义getters，并传参（在main.js中Vuex.Store中：）</p>\n<p>（2）组件中调用getters  </p>\n<p>①原始形式调用：<code>this.$store.getters.函数名</code>,  接着直接在页面使用： </p>\n<p>②辅助函数调用：（***需要引入）: …mapGetters([‘函数名’，’函数名2‘])    导入到computed计算属性中，页面中    使用</p>\n<h6 id=\"【5】Module模块化\"><a href=\"#【5】Module模块化\" class=\"headerlink\" title=\"【5】Module模块化\"></a>【5】<code>Module</code>模块化</h6><p>【】所有的数据、更新、操作都在一起，项目越大，越难维护，因此推出Vuex模块化（子模块中使用）</p>\n<p>（1）定义子模块Modules （在main.js中Vuex.Store中：）</p>\n<pre><code class=\"javascript\">modules:&#123;  子模块name1:&#123;state:&#123; 键：值 &#125;&#125; ， 子模块name2:&#123;state:&#123; 键：值 &#125;&#125;  &#125; \n</code></pre>\n<p>（2）组件中使用</p>\n<pre><code class=\"javascript\">$store.state.子模块name.子模块键\n</code></pre>\n<p>（3）快捷使用</p>\n<p>在getters中定义，之后直接使用自定义的名称（①引入mapGetters，②在computed中扩展 ：…mapGetters([‘自定义名1’，’名2’])）</p>\n<pre><code class=\"javascript\">getters:&#123;  自定义名  : state =&gt; state.子模块名.子模块键 ，    &#125;\n</code></pre>\n<h6 id=\"【6】模块化中的namespaced命名空间\"><a href=\"#【6】模块化中的namespaced命名空间\" class=\"headerlink\" title=\"【6】模块化中的namespaced命名空间\"></a>【6】模块化中的<code>namespaced</code>命名空间</h6><p>【】默认情况下，模块内部的action、mutation和getter是注册在全局命名空间的，这样使得多个模块能够对同一mutation或者action做出响应</p>\n<p>（各模块中函数中state表示子模块中的state），此时可以通过namespaced命名空间 对模块进行封锁</p>\n<p>（1）使用命名空间：</p>\n<pre><code class=\"javascript\">modules:&#123;  子模块名1： namespaced:true   ,state:&#123;....&#125;,.....   &#125;\n</code></pre>\n<p>（2）调用数据的方法:</p>\n<p>开启命名空间后，组件中读取state数据：<br>①&#x2F;&#x2F;方式一：自己直接读取</p>\n<pre><code>this.$store.state.personAbout.list\n</code></pre>\n<p>②&#x2F;&#x2F;方式二：借助mapState读取：</p>\n<pre><code>...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n</code></pre>\n<p>开启命名空间后，组件中读取getters数据：<br>&#x2F;&#x2F;方式一：自己直接读取<br>![</p>\n<pre><code>this.$store.getters[&#39;personAbout/firstPersonName&#39;]\n</code></pre>\n<p>]()</p>\n<p>&#x2F;&#x2F;方式二：借助mapGetters读取：</p>\n<pre><code>...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])\n</code></pre>\n<ol start=\"5\">\n<li>开启命名空间后，组件中调用dispatch<br> &#x2F;&#x2F;方式一：自己直接dispatch</li>\n</ol>\n<pre><code>this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)\n</code></pre>\n<p>&#x2F;&#x2F;方式二：借助mapActions：</p>\n<pre><code>...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\n</code></pre>\n<p>开启命名空间后，组件中调用commit<br>&#x2F;&#x2F;方式一：自己直接commit</p>\n<pre><code>this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)\n</code></pre>\n<p>&#x2F;&#x2F;方式二：借助mapMutations：</p>\n<pre><code>...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\n</code></pre>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"使用、配置Vuex\"><a href=\"#使用、配置Vuex\" class=\"headerlink\" title=\"使用、配置Vuex\"></a>使用、配置Vuex</h3><h4 id=\"main-js中配置，组件通过this-store获得\"><a href=\"#main-js中配置，组件通过this-store获得\" class=\"headerlink\" title=\"(main.js中配置，组件通过this.$store获得 )\"></a>(main.js中配置，组件通过this.$store获得 )</h4><p>1、安装：进入项目终端，输入<br>npm install vuex@3</p>\n<p>2、引入</p>\n<p>1）终端启动项目</p>\n<p>npm run serve<br>（2）在mian.js文件引入vuex，使用Vuex</p>\n<pre><code class=\"javascript\">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport Vuex from &#39;vuex&#39;    //引入\n\nVue.config.productionTip = false\n\nVue.use(Vuex)    //使用\n\nnew Vue(&#123;\n  router,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p>3、创建使用实例</p>\n<pre><code class=\"javascript\">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport Vuex from &#39;vuex&#39;//引入\n\nVue.config.productionTip = false\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store(&#123;&#125;)    //创建实例，注意Vuex.Store的大小写\n\nnew Vue(&#123;\n  router,\n  store,    //使用\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p>4、代码例子</p>\n<pre><code class=\"javascript\">import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport Vuex from &#39;vuex&#39;//引入\n\nVue.config.productionTip = false\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store(&#123;\n  state:&#123;\n    count:0,\n  &#125;,\n&#125;)\n\nnew Vue(&#123;\n  router,\n  store,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p> 去任意页面获取显示count数据</p>\n<template>\n  <div class=\"home\">\n    <h1>这是count：</h1>\n  </div>\n</template>\n","categories":["Vue"],"tags":["Vue"]},{"title":"Docker","url":"/2024/07/08/docker/","content":"<p><img data-src=\"https://dmqweb.cn/images/Docker.pdf\" alt=\"Docker\"><br><img data-src=\"https://dmqweb.cn/images/Docker%E6%96%87%E6%A1%A3.pdf\" alt=\"Docker文档\"><br><img data-src=\"https://dmqweb.cn/images/Docker%E5%A4%A7%E7%BA%B2.pdf\" alt=\"Docker大纲\"></p>\n<h1 id=\"虚拟化技术\"><a href=\"#虚拟化技术\" class=\"headerlink\" title=\"虚拟化技术\"></a>虚拟化技术</h1><blockquote>\n<p>虚拟化是一种计算机资源管理的技术,是将计算机的各种硬件资源,比如服务器、网络、CPU、内存、以及存储等,通过抽象和转换后呈现出的一套新的硬件资源环境,在这套资源环境中可以按照操作系统 , 部署应用环境等<br>虚拟化技术打破了计算机硬件资源不可切割的障碍,提高了计算机硬件资源的利用率</p>\n</blockquote>\n<h1 id=\"虚拟机-硬件级虚拟化技术\"><a href=\"#虚拟机-硬件级虚拟化技术\" class=\"headerlink\" title=\"虚拟机(硬件级虚拟化技术)\"></a>虚拟机(硬件级虚拟化技术)</h1><blockquote>\n<p>虚拟机是使用虚拟化的技术，使用抽象逻辑对物理计算机的模拟，包含整个操作系统和其中的应用程式。</p>\n</blockquote>\n<ul>\n<li>缺点是：启动慢、使用空间很大、性能通常不高，无法完全使用计算机的性能。</li>\n</ul>\n<h1 id=\"容器-操作系统级虚拟化技术\"><a href=\"#容器-操作系统级虚拟化技术\" class=\"headerlink\" title=\"容器(操作系统级虚拟化技术)\"></a>容器(操作系统级虚拟化技术)</h1><blockquote>\n<p>容器是包含在任何环境中的运行所需的所有元素的软件包，这样容器就可以模拟化应用程序，并可以在任何地方运行。它直接调用原操作系统的能力，并屏蔽了操作系统之间的差异。</p>\n</blockquote>\n<h1 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h1><blockquote>\n<p>docker 是一个用于构建、运行和传送应用程序的平台，docker 是容器的一种实现方式。<br>docker 和虚拟机的区别在于：是否模拟构建整个操作系统的能力。</p>\n</blockquote>\n<h2 id=\"image-镜像\"><a href=\"#image-镜像\" class=\"headerlink\" title=\"image 镜像\"></a>image 镜像</h2><blockquote>\n<p>image 镜像就相当于是一个菜谱，对应用程序的执行进行模板化。参照同一个 image 镜像运行的应用程序是相同的。它包含了运行容器所需的所有那日容（代码、运行时、库、环境变量和配置文件）<br>image 镜像打包了：</p>\n</blockquote>\n<ul>\n<li>配置文件、启动命令</li>\n<li>应用程序、环境变量</li>\n<li>第三方软件库和依赖包</li>\n<li>运行时环境</li>\n<li>操作系统</li>\n</ul>\n<h2 id=\"docker-容器\"><a href=\"#docker-容器\" class=\"headerlink\" title=\"docker 容器\"></a>docker 容器</h2><blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sYWJzLnBsYXktd2l0aC1kb2NrZXIuY29tLw==\">https://labs.play-with-docker.com/</span> ,在线运行各种 docker 容器<br>docker 容器就相当于是一个根据 image 镜像创建的运行实例，在 docker 容器中包含了运行时的全部环境，它屏蔽了操作系统之间的差异，使得应用程序的可移植性非常强。</p>\n</blockquote>\n<h1 id=\"docker-的优势\"><a href=\"#docker-的优势\" class=\"headerlink\" title=\"docker 的优势\"></a>docker 的优势</h1><blockquote>\n<p>如果不使用 docker，在开发环境和测试环境中都需要对应用程序的运行环境进行配置。尤其是当应用程序十分复杂时，配置运行环境的工作就十分复杂，使用 docker 之后就相当于封装了应用程序及其对应的运行环境，并且屏蔽了操作系统之间的差异，它直接调用主机操作系统的能力运行 docker 容器。<br>例如：使用 docker 之后，我们开发环境配置好运行环境，打包成镜像之后，测试环境中直接使用镜像构建 docker 容器，运行应用程序即可，无需重新配置环境。</p>\n</blockquote>\n<h1 id=\"docker-命令\"><a href=\"#docker-命令\" class=\"headerlink\" title=\"docker 命令\"></a>docker 命令</h1><blockquote>\n<p>安装 docker 之后，就可以使用 docker 对应的命令（windows 安装后需要开启 Hyper 选项），命令行中输入对应的命令之后会交给内部的 docker daemon 进行执行，docker daemon 会将执行结果返回给命令行。</p>\n</blockquote>\n<pre><code class=\"bash\"># docker run：运行一个新的容器实例。\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n# docker start：启动一个或多个已经停止运行的容器。\ndocker start [CONTAINER...]\n# docker stop：停止一个或多个正在运行的容器。\ndocker stop [CONTAINER...]\n# docker pause：暂停容器内的所有进程。\ndocker pause [CONTAINER...]\n# docker unpause：恢复之前被暂停的容器。\ndocker unpause [CONTAINER...]\n# docker restart：重启容器。\ndocker restart [CONTAINER...]\n# docker rm：删除一个或多个容器。\ndocker rm [CONTAINER...]\n# docker rmi：删除一个或多个镜像。\ndocker rmi [OPTIONS] IMAGE [IMAGE...]\n# docker ps：列出当前正在运行的容器。\ndocker ps [OPTIONS]\n# docker images：列出本地的镜像。\ndocker images [OPTIONS] [REPOSITORY[:TAG]]\n# docker build：根据 Dockerfile 构建镜像。\ndocker build [OPTIONS] PATH | URL | -\n# docker pull：从远程仓库拉取镜像或仓库到本地。\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]\n# docker push：将本地的镜像或仓库推送到远程仓库。\ndocker push [OPTIONS] NAME[:TAG]\n# docker login：登录到一个 Docker 远程仓库。\ndocker login [OPTIONS] [SERVER] USERNAME\n# docker logout：从 Docker 远程仓库登出。\ndocker logout [SERVER]\n# docker exec：在运行的容器中执行命令。\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n# docker logs：获取容器的日志。\ndocker logs [OPTIONS] CONTAINER\n# docker network：管理 Docker 网络设置。\ndocker network [OPTIONS]\n# docker volume：管理 Docker 数据卷。\ndocker volume [OPTIONS]\n# docker inspect：获取容器、镜像、网络或数据卷的详细信息。\ndocker inspect [OPTIONS] NAME|ID [NAME|ID...]\n# docker prune：删除未使用的 Docker 对象，如容器、镜像、网络、数据卷。\ndocker prune [OPTIONS]\n# docker stats：实时显示容器的资源使用情况。\ndocker stats [OPTIONS] [CONTAINER...]\n# docker-compose：使用 Docker Compose 工具管理多容器 Docker 应用程序。\ndocker-compose [OPTIONS] [COMMAND] [ARGS...]\n</code></pre>\n<h1 id=\"容器化\"><a href=\"#容器化\" class=\"headerlink\" title=\"容器化\"></a>容器化</h1><blockquote>\n<p>如何将应用程序和运行时的环境打包成一个镜像呢（）容器化？这时候就需要配置 dockerfile 定义容器的构建过程,构建镜像。最后使用 docker 命令镜像创建和运行容器（docker build -t app-name . 和 docker run -p 8080:8080 app-name）</p>\n</blockquote>\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><blockquote>\n<p>dockerfile 文件用于定义软件依赖的构建过程，确保应用程序的依赖项得到满足。alpine 是一个轻量的 linx 发行版。</p>\n</blockquote>\n<pre><code class=\"dockerfile\"># Docker镜像是一层一层进行构建的\n# 指定对应的操作系统和版本，alpine是linx轻量级的发行版\nFROM node:14-alpine\n# 使用COPY命令，将文件复制到镜像中\nCOPY index.js /index.js\n# 运行应用程序\n# CMD [&quot;node&quot;,&quot;/index.js&quot;] 或者\nCMD node /index.js\n# 此时使用docker build -t docker-name:版本号 . 就可以构建docker镜像，不指定版本号默认是latest\n# 使用docker image ls 可以查看所有的镜像\n# 使用docker run docker-name 运行镜像\n# 将容器推送到远程镜像仓库：docker push your-dockerhub-username/your-app-name:tag\n# 如果想要根据这个镜像创建docker容器，只需要拿到Dockerfile文件，运行上述命令即可\n# 通常将应用程序上传到docker hub中，后面通过docker pull docker-name 进行拉取\n</code></pre>\n<h1 id=\"volumes-逻辑卷\"><a href=\"#volumes-逻辑卷\" class=\"headerlink\" title=\"volumes 逻辑卷\"></a>volumes 逻辑卷</h1><blockquote>\n<p>volumes 逻辑卷是 Docker 中用于存储数据的，因为 docker 中的数据是不会进行持久化的。它通常以一个干净的文件开始，容器启动之后，可以在容器中创建文件和修改文件，但是当容器停止之后，数据并不会持久化，从而丢失，这时候就要在 Docker Compose 中使用 volumes 逻辑卷<br>volumes 逻辑卷可以将容器中的目录或者指定路径映射到宿主机的某一个目录或者位置上，从而实现数据的持久化。</p>\n</blockquote>\n<h1 id=\"Dev-Environments\"><a href=\"#Dev-Environments\" class=\"headerlink\" title=\"Dev Environments\"></a>Dev Environments</h1><blockquote>\n<p>docker desktop 中的一个功能，可以将自己当前环境分享给其他人，从而共享开发环境。</p>\n</blockquote>\n<h1 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h1><p>容器编排工具</p>\n<blockquote>\n<p>一个项目中需要的应用程序和应用程序（容器）间的逻辑是十分复杂的，统一管理他们的启动和停止非常麻烦，Docker Compose 用一个 YAML 文件，定义和运行多容器 Docker 应用程序，其中可以配置多个容器、网络和数据卷等，以便在隔离的环境中快速启动和停止整个应用程序。</p>\n</blockquote>\n<p><strong>Docker Compose 的作用：</strong></p>\n<ul>\n<li>多容器管理：Docker Compose 允许你在一个文件中定义多个容器，统一管理它们的启动和停止。</li>\n<li>环境一致性：通过使用 Compose，你可以在不同的机器和环境中保持应用程序的一致性，因为它定义了应用程序的完整运行环境。</li>\n<li>配置简化：Compose 使用 YAML 格式，使得配置更加简洁和易于理解。</li>\n<li>服务依赖管理：Compose 可以处理容器之间的依赖关系，确保在启动和停止时按正确的顺序操作。</li>\n<li>网络配置：Compose 允许定义自定义网络，使容器之间能够相互发现和通信。</li>\n<li>数据卷管理：可以配置数据卷，以便在容器之间共享数据或持久化数据。</li>\n<li>扩展性：Compose 支持扩展服务，允许你指定服务运行的容器数量。</li>\n<li>自动化：通过简单的命令，Compose 可以自动构建、启动或停止整个应用程序。</li>\n</ul>\n<p><strong>docker-compose.yml</strong></p>\n<pre><code class=\"yaml\">version: &quot;3.8&quot; # 指定 docker-compose 的版本\n\nservices:\n  web:\n    image: nginx:alpine # 使用官方的 nginx 镜像（基于 Alpine 版本）\n    ports:\n      - &quot;80:80&quot; # 将容器的 80 端口映射到宿主机的 80 端口\n    volumes:\n      - ./src:/usr/share/nginx/html # 挂载当前目录下的 src 文件夹到容器的 nginx HTML 目录\n    depends_on:\n      - app # 表示 web 服务依赖于 app 服务\n\n  app:\n    build: ./app # 构建当前目录下 app 文件夹中的 Dockerfile\n    expose:\n      - &quot;9000&quot; # 暴露容器内部的 9000 端口，供其他服务访问，但不映射到宿主机\n    environment:\n      - APP_ENV=production # 设置环境变量\n    volumes:\n      - ./app:/var/www # 挂载当前目录下的 app 文件夹到容器的 /var/www 目录\n\n  db:\n    image: mysql:5.7 # 使用官方的 MySQL 5.7 镜像\n    volumes:\n      - db-data:/var/lib/mysql # 挂载卷 db-data 到容器的 MySQL 数据目录\n    environment:\n      - MYSQL_ROOT_PASSWORD=rootpassword # 设置 MySQL root 用户的密码\n      - MYSQL_DATABASE=myappdb # 创建并使用名为 myappdb 的数据库\n\nvolumes:\n  db-data: # 定义一个名为 db-data 的卷，用于持久化 MySQL 数据\n</code></pre>\n<p><code>docker-compose.yml</code>文件将一组互相关联的容器组合在一起，然后使用<code>docker compose up</code>命令（包含 docker-compose.yml 的文件中执行）即可启动整个应用程序。</p>\n<p>docker-compose.yml 可以结合 CI&#x2F;CD 工具，集成到自动化工作流中，实现从开发到部署的自动化。</p>\n<h1 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h1><p>Kubernetes 和 Docker Compose 类似，是一种容器编排工具，用于管理和部署容器化应用程序。但是 Kubernetes 相比之下更适合大规模的生产环境和复杂的容器编排需求。</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>k8s 和 Docker Compose 的区别</p>\n<ol>\n<li>功能和规模：<ul>\n<li>Docker Compose 是一个简单的工具，用于定义和运行多个 Docker 容器组成的应用程序。它适用于单机或简单的多机环境，并提供了一种简化的方式来定义容器之间的依赖关系和配置。</li>\n<li>Kubernetes 是一个更强大和复杂的容器编排平台，用于管理大规模的容器集群。它可以自动化容器的部署、扩展、负载均衡、故障恢复等操作，并提供了更丰富的功能和管理能力。</li>\n</ul>\n</li>\n<li>架构和部署方式：<ul>\n<li>Docker Compose 使用单个 YAML 文件来定义整个应用程序的配置和服务之间的关系。它可以在单个主机上使用<code>docker-compose</code>命令进行部署和管理。</li>\n<li>Kubernetes 使用一组 YAML 文件来定义应用程序的各个组件和资源，并通过 Kubernetes API 进行管理。它需要一个 Kubernetes 集群来部署和运行应用程序。</li>\n</ul>\n</li>\n<li>可扩展性和弹性：<ul>\n<li>Docker Compose 适用于小型应用程序或开发&#x2F;测试环境，它的扩展性和弹性有限。它可以在单个主机上运行多个容器，但无法自动进行水平扩展或故障恢复。</li>\n<li>Kubernetes 设计用于大规模的生产环境，具有强大的扩展性和弹性。它可以自动进行容器的水平扩展、负载均衡和故障恢复，以确保应用程序的高可用性和性能。</li>\n</ul>\n</li>\n<li>社区和生态系统：<ul>\n<li>Docker Compose 是 Docker 官方提供的工具，拥有庞大的用户社区和丰富的生态系统。它与 Docker Engine 紧密集成，并且易于上手和使用。</li>\n<li>Kubernetes 是由 Google 开源并托管在 Cloud Native Computing Foundation（CNCF）下的项目，也拥有庞大的用户社区和活跃的开发者社区。它有许多第三方工具和插件，可以扩展其功能和集成其他系统。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，Docker Compose 适用于简单的应用程序部署和开发&#x2F;测试环境，而 Kubernetes 适用于大规模的生产环境和复杂的容器编排需求。根据实际需求和规模选择合适的工具</p>\n","categories":["Docker"],"tags":["Docker"]},{"title":"ajax","url":"/2023/01/08/ajax/","content":"<h1 id=\"HTTP协议请求报文、响应\"><a href=\"#HTTP协议请求报文、响应\" class=\"headerlink\" title=\"HTTP协议请求报文、响应\"></a>HTTP协议请求报文、响应</h1><p>一个HTTP请求报文可以由请求行、请求头、空行和请求体4个部分组成。<br>一个HTTP响应报文是由响应行、响应头、空行和响应体4个部分组成。<br>（报文(message)是网络中交换与传输的数据单元）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzMyODQwMzU=\">https://zhuanlan.zhihu.com/p/533284035</span>  （超详细的HTTP协议请求报文、响应报文教程）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h1><h2 id=\"什么是json\"><a href=\"#什么是json\" class=\"headerlink\" title=\"什么是json\"></a>什么是json</h2><p> JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据</p>\n<p>JSON本质上是一个带有特定格式的字符串</p>\n<p>主要功能：json就是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互. 类似于：<br>国际通用语言-英语<br>中国56个民族不同地区的通用语言-普通话</p>\n<h2 id=\"json有什么用\"><a href=\"#json有什么用\" class=\"headerlink\" title=\"json有什么用\"></a>json有什么用</h2><p>各种编程语言存储数据的容器不尽相同,在Python中有字典dict这样的数据类型, 而其它语言可能没有对应的字典。<br>为了让不同的语言都能够相互通用的互相传递数据，JSON就是一种非常良好的中转数据格式。</p>\n<h2 id=\"json格式数据转化\"><a href=\"#json格式数据转化\" class=\"headerlink\" title=\"json格式数据转化\"></a>json格式数据转化</h2><pre><code class=\"json\"># json数据的格式可以是： \n&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;  是&#123;&#125;括起来的键值对\n# 也可以是：  \n[&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;root&quot;,&quot;age&quot;:16&#125;,&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125;] \n是[]括起来的元素\n可以嵌套\n</code></pre>\n<pre><code class=\"java\">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;2.0.39&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Java中：java转json字符串</p>\n<pre><code class=\"java\">String jsonStr = JSON.toJSONString(objs);\n</code></pre>\n<p>JS中：json字符串转JavaScript对象</p>\n<pre><code class=\"java\">  JSON.parse(this.responseText)\n</code></pre>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h1><p>Ajax（Asynchronous JavaScript And XML）即异步 JavaScript 和 XML，是一组用于在网页上进行异步数据交换的Web开发技术，可以在不刷新整个页面的情况下向服务器发起请求并获取数据，然后将数据插入到网页中的某个位置。这种技术能够实现增量式更新页面，提高用户交互体验，减少响应时间和带宽的消耗。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>提升用户体验（通过减少页面的重载和刷新，使得网站变得更加灵活和的动态）</li>\n<li>减轻服务器压力（通过Ajax可以有效减少服务器接收到的请求次数和需要响应的数据量）</li>\n<li>提高响应速度（异步获得数据并更新页面）</li>\n<li>增加交互性（页面变得动态性和交互性）</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>Ajax对SEO（搜索引擎优化不友好）</li>\n<li>使用Ajax时，需要考虑数据安全性和网络安全性，并采取相应的措施防范</li>\n</ul>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h1><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用 <code>XMLHttpRequest</code> 可以通过 JavaScript 发起HTTP请求，接收来自服务器的响应，并动态地更新网页中的内容。这种异步通信方式不会阻塞用户界面，有利于增强用户体验。</p>\n<pre><code class=\"javascript\">// 发送get请求\nconst xhr = new XMLHttpRequest();\nxhr.open(&#39;GET&#39;, &#39;http://localhost:3000/api/txt&#39;)\nxhr.onload = function() &#123;\n  if (xhr.status === 200) &#123;\n        document.querySelector(&#39;#result&#39;).innerText = xhr.responseText;\n    &#125;\n    else &#123;\n       console.log(&#39;Request failed.  Returned status of &#39; + xhr.status);\n   &#125;\n&#125;;\nxhr.send(null);\n// 发送post请求\nconst xhr = new XMLHttpRequest();\nxhr.open(&#39;POST&#39;, &#39;http://localhost:3000/api/post&#39;)\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);\nxhr.onload = function() &#123;\n  if (xhr.status === 200) &#123;\n        document.querySelector(&#39;#result&#39;).innerText = xhr.responseText;\n    &#125;\n    else &#123;\n       console.log(&#39;Request failed.  Returned status of &#39; + xhr.status);\n   &#125;\n&#125;;\nxhr.send(JSON.stringify(&#123;name: &#39;zhangsan&#39;, age: 18&#125;));\n</code></pre>\n<h3 id=\"中断请求\"><a href=\"#中断请求\" class=\"headerlink\" title=\"中断请求\"></a>中断请求</h3><p>xhr通过addEventListener事件监听的机制来进行请求的中断和超时处理。</p>\n<pre><code class=\"javascript\">xhr.addEventListener(&#39;abort&#39;, function (event) &#123;\n    console.log(&#39;我被中断了&#39;);\n&#125;);\n</code></pre>\n<h3 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h3><pre><code class=\"javascript\">xhr.addEventListener(&#39;timeout&#39;, function (event) &#123;\n     console.log(&#39;超时啦&#39;);\n&#125;);\n</code></pre>\n<h3 id=\"监听进度\"><a href=\"#监听进度\" class=\"headerlink\" title=\"监听进度\"></a>监听进度</h3><p>xhr中的监听进度可以获得全过程的进行进度，这是fetch这个api所没有的</p>\n<pre><code class=\"javascript\">xhr.addEventListener(&#39;progress&#39;, function (event) &#123;\ndocument.querySelector(&#39;#progress&#39;).innerText = `$&#123;(event.loaded / event.total * 100).toFixed(2)&#125;%`;\n&#125;);\n</code></pre>\n<h1 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h1><h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p><strong>fetch返回格式：</strong></p>\n<ul>\n<li><p>text(): 将响应体解析为纯文本字符串并返回。</p>\n</li>\n<li><p>json(): 将响应体解析为JSON格式并返回一个JavaScript对象。</p>\n</li>\n<li><p>blob(): 将响应体解析为二进制数据并返回一个Blob对象。</p>\n</li>\n<li><p>arrayBuffer(): 将响应体解析为二进制数据并返回一个ArrayBuffer对象。</p>\n</li>\n<li><p>formData(): 将响应体解析为FormData对象。</p>\n</li>\n</ul>\n<pre><code class=\"javascript\">// get请求\nfetch(&#39;http://localhost:3000/api/txt&#39;).then(res =&gt; &#123;\n    console.log(res);\n    return res.text()\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n&#125;)\n// post请求\nfetch(&#39;http://localhost:3000/api/post&#39;,&#123;\n    method:&#39;POST&#39;,\n    headers:&#123;\n        &#39;Content-Type&#39;:&#39;application/json&#39;\n    &#125;,\n    body:JSON.stringify(&#123;\n        name:&#39;zhangsan&#39;,\n        age:18\n    &#125;)\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n    return res.json()\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n&#125;)\n</code></pre>\n<h3 id=\"中断请求-1\"><a href=\"#中断请求-1\" class=\"headerlink\" title=\"中断请求\"></a>中断请求</h3><p>使用 <code>AbortController</code> 的 <code>abort</code>方法中断</p>\n<pre><code class=\"javascript\">const abort = new AbortController()\nfetch(&#39;http://localhost:3000/api/post&#39;,&#123;\n    method:&#39;POST&#39;,\n    headers:&#123;\n        &#39;Content-Type&#39;:&#39;application/json&#39;\n    &#125;,\n    signal:abort.signal,\n    body:JSON.stringify(&#123;\n        name:&#39;zhangsan&#39;,\n        age:18\n    &#125;)\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n    return res.json()\n&#125;).then(res =&gt; &#123;\n    console.log(res);\n&#125;)\n\ndocument.querySelector(&#39;#stop&#39;).addEventListener(&#39;click&#39;, () =&gt; &#123;\n        console.log(&#39;stop&#39;);\n        abort.abort()\n&#125;)\n</code></pre>\n<h3 id=\"获取进度\"><a href=\"#获取进度\" class=\"headerlink\" title=\"获取进度\"></a>获取进度</h3><p>使用data.clone()方法复制了响应对象data，然后使用getReader()方法获取数据流中的reader对象，接着通过读取数据流并计算已加载字节数，实现了一个基于原生JavaScript的进度条功能。</p>\n<pre><code class=\"javascript\">const btn = document.querySelector(&#39;#send&#39;)\nconst sendFetch = async () =&gt; &#123;\n    const data = await fetch(&#39;http://localhost:3000/api/txt&#39;,&#123;\n        signal:abort.signal\n    &#125;)\n    //fetch 实现进度条\n    const response = data.clone()\n    const reader = data.body.getReader()\n    const contentLength = data.headers.get(&#39;Content-Length&#39;)\n    let loaded = 0\n    while (true) &#123;\n        const &#123; done, value &#125; = await reader.read()\n        if (done) &#123;\n            break\n        &#125;\n        loaded += value?.length || 0;\n        const progress = document.querySelector(&#39;#progress&#39;)\n        progress.innerHTML = (loaded / contentLength * 100).toFixed(2) + &#39;%&#39;\n    &#125;\n    const text = await response.text()\n    console.log(text);\n&#125;\nbtn.addEventListener(&#39;click&#39;, sendFetch)\n</code></pre>\n<h3 id=\"携带cookie\"><a href=\"#携带cookie\" class=\"headerlink\" title=\"携带cookie\"></a>携带cookie</h3><pre><code class=\"javascript\">const data = await fetch(&#39;http://localhost:3000/api/txt&#39;,&#123;\n    signal:abort.signal,\n    //cookie\n    credentials:&#39;include&#39;,\n&#125;)\n</code></pre>\n<h1 id=\"Fetch和XMLHTTPRequest对比\"><a href=\"#Fetch和XMLHTTPRequest对比\" class=\"headerlink\" title=\"Fetch和XMLHTTPRequest对比\"></a>Fetch和XMLHTTPRequest对比</h1><p><code>fetch</code> 和 <code>XMLHttpRequest</code>（XHR）都是前端与服务器进行数据交互的常用方式，它们各有优缺点，下面是它们的比较：</p>\n<ul>\n<li>API 设计和使用方式</li>\n</ul>\n<p><code>fetch</code> 的 API 设计更加现代化、简洁和易于使用，使用起来更加直观和方便。相比之下，XHR 的 API 设计比较繁琐，需要进行多个参数的配置和回调函数的处理。</p>\n<ul>\n<li>支持的请求方法</li>\n</ul>\n<p><code>fetch</code> API 默认只支持 GET 和 POST 请求方法，而 XHR 则支持所有标准的 HTTP 请求方法。</p>\n<ul>\n<li>请求头部</li>\n</ul>\n<p>在 <code>fetch</code> 中设置请求头部的方式更加清晰和直接，可以通过 <code>Headers</code> 对象进行设置，而 XHR 的方式相对较为繁琐。</p>\n<ul>\n<li>请求体</li>\n</ul>\n<p>在发送 POST 请求时，<code>fetch</code> API 要求将请求体数据作为参数传递给 <code>fetch</code> 方法中的 <code>options</code> 对象，而 XHR 可以直接在 <code>send()</code> 方法中设置请求体数据。</p>\n<ul>\n<li>支持的数据类型</li>\n</ul>\n<p>在解析响应数据时，<code>fetch</code> API 提供了多种方法，包括 <code>.json()</code>, <code>.blob()</code>, <code>.arrayBuffer()</code> 等，而 XHR 只支持文本和二进制数据两种数据类型。</p>\n<ul>\n<li>跨域请求</li>\n</ul>\n<p>在进行跨域请求时，<code>fetch</code> API 提供了一种简单而强大的解决方案——使用 CORS（跨域资源共享）头部实现跨域请求，而 XHR 则使用了一个叫做 <code>XMLHttpRequest Level 2</code> 的规范，在代码编写上相对较为繁琐。</p>\n<p>总的来说，<code>fetch</code> API 与 XHR 各有优缺点，具体选择哪种方式还需要根据具体情况进行考虑。平时开发中使用较多的是 <code>fetch</code> ，因为它使用方便、API 简洁、语法清晰，同时也支持了大多数常用的功能，可以有效地简化前端开发流程。</p>\n<h1 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h1><p>专注与网络请求的库<br>相比于原生的XMLHttpRequest对象，axios简单易用<br>相比与jQuery，axios更加轻量化，只专注与网络数据请求</p>\n<h2 id=\"axios发起GET请求：\"><a href=\"#axios发起GET请求：\" class=\"headerlink\" title=\"axios发起GET请求：\"></a><strong>axios发起GET请求：</strong></h2><pre><code class=\"javascript\">var url=&#39;&#39;\nvar paramsObj=&#123;name:&#39;zs&#39;,age:20&#125;\naxios.get(url,&#123;params:paramsObj&#125;)\n    .then(function(res)&#123;\n        console.log(res)\n        //res.data 服务器响应的数据\n        console.log(res.data)\n    &#125;)\n</code></pre>\n<h2 id=\"axios发起POST请求：\"><a href=\"#axios发起POST请求：\" class=\"headerlink\" title=\"axios发起POST请求：\"></a><strong>axios发起POST请求：</strong></h2><pre><code class=\"javascript\">var url=&#39;http://&#39;\nvar dataObj=&#123;location:&#39;Beijing&#39;,address:&#39;haidian&#39;&#125;\naxios.post(url,dataObj)\n    .then(function(res)&#123;\n        console.log(res)\n        //res.data 服务器响应的数据\n        console.log(res.data)\n    &#125;)\n</code></pre>\n<h2 id=\"直接使用axios发起请求：\"><a href=\"#直接使用axios发起请求：\" class=\"headerlink\" title=\"直接使用axios发起请求：\"></a><strong>直接使用axios发起请求：</strong></h2><p>axios页提供了类似于jQuery中的$.ajax()的函数，语法如下：</p>\n<pre><code class=\"javascript\">axios(&#123;\n    method:&#39;GET&#39;\n    url:&#39;&#39;\n    //GET参数要通过params属性提供\n    params:&#123;name:&#39;zs&#39;,age:20&#125;\n&#125;)\n    .then(function(res)&#123;\n        console.log(res.data)\n    &#125;)\n-------------------------------------\naxios(&#123;\n    method:&#39;POST&#39;\n    url:&#39;&#39;\n    //POST参数要通过data属性提供\n    data:&#123;bookname:&#39;thinking java&#39;,price:20&#125;\n&#125;)\n    .then(function(res)&#123;\n        console.log(res.data)\n    &#125;)\n</code></pre>\n<h1 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"navigator-sendBeacon\"><a href=\"#navigator-sendBeacon\" class=\"headerlink\" title=\"navigator.sendBeacon\"></a>navigator.sendBeacon</h1><pre><code class=\"javascript\">//性能中继器，使用不同指标来衡量和分析应用程序的性能\n//当页面上任何指标值完成计算时，将传递计算出的结果并触发这个函数\n//可以使用它将结果记录到控制台或者发送到特定端点\nfunction sendTo(metric)&#123;\n    const content = JSON.stringify(metric);\n    if(navigator.sendBeacon)&#123;\n        navigator.sendBeacon(&#39;http://test&#39;,content); //navigator.sendBeacon的作用是\n    &#125;else&#123;\n        fetch(&#39;http://test.com&#39;,&#123;\n        content,\n        method:&#39;POST&#39;,\n        keepAlive:true //fetch中的keepAlice保证了即使页面刷新或者关闭，发出的请求仍然存在并进行，而不是进行到一半的请求突然停止\n    &#125;).then(()=&gt;&#123;\n    console.log(&#39;发送成功&#39;);\n    &#125;).catch((e)=&gt;&#123;\n        console.error(e);\n    &#125;)\n    &#125;\n&#125;\nreportWebVitals(sendTo); //每一次得到计算结果都会执行一次\n</code></pre>\n<h3 id=\"对比-Ajax-fetch\"><a href=\"#对比-Ajax-fetch\" class=\"headerlink\" title=\"对比 Ajax fetch\"></a>对比 Ajax fetch</h3><h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li><strong>不受页面卸载过程的影响，确保数据可靠发送</strong>。</li>\n<li><strong>异步执行，不阻塞页面关闭或跳转</strong>。</li>\n<li><strong>能够发送跨域请求</strong>。</li>\n</ol>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>fetch 和 ajax 都可以发送任意请求 而 sendBeacon <strong>只能发送POST</strong></li>\n<li>fetch 和 ajax 可以传输任意字节数据 而 <strong>sendBeacon 只能传送少量数据</strong>（64KB 以内）</li>\n<li>fetch 和 ajax 可以定义任意请求头 而  <strong>sendBeacon 无法自定义请求头</strong></li>\n<li>sendBeacon 只能传输 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>ArrayBufferView</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\"><code>Blob</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>DOMString</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\"><code>FormData</code></a> 或 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\"><code>URLSearchParams</code></a> 类型的数据</li>\n<li><code>如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效</code></li>\n</ol>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ol>\n<li>发送心跳包：可以使用 <code>navigator.sendBeacon</code> 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。</li>\n<li>埋点：可以使用 <code>navigator.sendBeacon</code> 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。</li>\n<li>发送用户反馈：可以使用 <code>navigator.sendBeacon</code> 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进</li>\n</ol>\n","categories":["ajax"],"tags":["ajax"]},{"title":"Travis和Docker的持续集成","url":"/2023/12/02/Travis%20CI%E5%92%8CDocker%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/","content":"<h2 id=\"所使用的基础组件\"><a href=\"#所使用的基础组件\" class=\"headerlink\" title=\"所使用的基础组件\"></a>所使用的基础组件</h2><p>代码托管在Github上，使用github集成的Travis CI自动触发CI流程。在CI中自动build新的image上传到Docker Hub。然后通过sshpass远程登录server触发部署脚本。部署脚本pull新的image然后部署。</p>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><p>由于项目都是基于python的，所以dockerfile比较简单：</p>\n<pre><code class=\"dockerfile\">FROM ubuntu:latest\nMAINTAINER Shaobo Liu &lt;shaobo@mkdef.com&gt;\nLABEL Description=&quot;This image is used to flask-kraken&quot;\nRUN apt-get update -y\nRUN apt-get install -y python3-pip python3-dev build-essential\nCOPY src /app\nCOPY requirements.txt /app\nWORKDIR /app\nRUN pip3 install -r requirements.txt\nENTRYPOINT [&quot;python3&quot;]\nCMD [&quot;app.py&quot;]\n</code></pre>\n<p>分解一下：</p>\n<pre><code class=\"dockerfile\">FROM ubuntu:latest\nMAINTAINER Shaobo Liu &lt;shaobo@mkdef.com&gt;\nLABEL Description=&quot;This image is used to flask-kraken&quot;\n</code></pre>\n<p>首先申明使用的基础镜像，然后写上大名表示我是维护这个镜像的作者和这个镜像的用途。</p>\n<pre><code class=\"dockerfile\">RUN apt-get update -y\nRUN apt-get install -y python3-pip python3-dev build-essential\n</code></pre>\n<p>安装python3，如果有其他的工具或者lib，也要写在这里。</p>\n<pre><code class=\"dockerfile\">COPY src /app\nCOPY requirements.txt /app\nWORKDIR /app\nRUN pip3 install -r requirements.txt\n</code></pre>\n<p>复制源代码到docker里，然后切换工作目录，安装三方依赖。 有时候这里需要安装一些系统级的依赖，比如lxml或者psycopg2之类的，就需要加到前面<code>apt-get install</code>里去。</p>\n<pre><code class=\"dockerfile\">ENTRYPOINT [&quot;python3&quot;]\nCMD [&quot;app.py&quot;]\n</code></pre>\n<p>最后是需要执行的命令。根据docker的userguide，一个image最好只干一件事。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p>在项目根目录添加<code>.travis.yml</code>来定义CI流程</p>\n<pre><code class=\"dockerfile\">sudo: required\n\nlanguage: python\n\nservices:\n  - docker\n\npython:\n    - &quot;3.5&quot;\n\nbefore_install:\n  - sudo apt-get update\n  - sudo apt-get install sshpass\n\ninstall: &quot;pip install -r requirements.txt&quot;\n\nscript: \n  - python --version\n\nafter_success:\n  - docker login -u=&quot;$DOCKER_USERNAME&quot; -p=&quot;$DOCKER_PASSWORD&quot;\n  - docker build -t shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID . \n  - docker push shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID;\n  - sshpass -p $VPS_PASSWORD ssh -o stricthostkeychecking=no root@45.32.137.234 &quot;sudo /home/saukymo/kraken/deploy.sh $TRAVIS_BRANCH-$TRAVIS_BUILD_ID&quot;\n</code></pre>\n<p>这里就不一一分解了，具体可以参考Travis的官方文档。</p>\n<p>主要介绍一下这个部分和其他部分是怎么联动的。首先Travis和Github是有集成服务的，在<code>Setting -&gt; integrations &amp; services</code>里选择添加Travis就可以了。然后在Travis上就可以设置相应的CI流程了，默认是master有新的commit就会自动触发一次CI。</p>\n<p>每次CI结束后的结果可以通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kub3JnL3NhdWt5bW8vb2Rlcy5zdmc/YnJhbmNoPW1hc3Rlcg==\">badge</span>查看。</p>\n<p>重点在于测试完成后build和push docker image的过程</p>\n<pre><code class=\"dockerfile\">after_success:\n  - docker login -u=&quot;$DOCKER_USERNAME&quot; -p=&quot;$DOCKER_PASSWORD&quot;\n  - docker build -t shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID . \n  - docker push shaobol/kraken:$TRAVIS_BRANCH-$TRAVIS_BUILD_ID;\n</code></pre>\n<p>敏感信息这里全部通过Travis的Environment Variables。这样可以避免因为公开而泄露。</p>\n<p>如果需要将一些敏感信息传递到image里面去，可以通过<code>--build-arg</code>参数传递进去，然后保存为环境变量，参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLyNsYWJlbA==\">reference</span></p>\n<p>最后通过<code>sshpass</code>执行部署脚本，这一步也可以使用<code>ansible</code>代替。</p>\n<h2 id=\"docker-部署脚本\"><a href=\"#docker-部署脚本\" class=\"headerlink\" title=\"docker 部署脚本\"></a>docker 部署脚本</h2><pre><code class=\"dockerfile\">#!/bin/bash\n\ndocker pull shaobol/odes:$1\n\nif docker ps -a | grep -q odes; then\n    docker rm -f odes\nfi\n\ndocker run -d --name odes -p 9000:9000 --link postgres:postgres shaobol/odes:$1\n</code></pre>\n<p>脚本很简单，接收CI传过来的参数(image tag)，pull新的image，然后干掉之前的container，run一个新的。这样就完成了update整个过程。</p>\n","categories":["Travis和Docker"],"tags":["Docker","Travis"]},{"title":"esbuild","url":"/2024/05/17/esbuild/","content":"<p>关于打包工具：esbuild、webpack和rollup三者的介绍推荐<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjI0MDk4NDIyOTM5MjU0ODIx\">这里</span>：</p>\n<p>简单来说就是esbuild打包更快；rollup打包产物更纯净、体积更小，但不支持热更新；webpack功能更全，生态更完善，支持文件类型更多。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>Esbuild是一个类webpack的打包工具，速度是webpack的几十倍。其底层基于go语言进行编写，不使用AST，优化了构建流程。js是单线程串行，esbuild是新开了一个进程，使用多线程并行，充分发挥了多核的优势。</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>esbuild最显著的作用就是：快。它也是vite和snowpack底层的打包工具。同时也可以将esbuild打包工具集成到webpack中（使用plugin）。之所以esbuild没有流行起来是因为它绕过了AST，而直接进行构建，使没有很好的过渡到基于babel-loader这样通过AST进行打包的上层工具中。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><pre><code class=\"javascript\">const esbuild = require(&#39;esbuild&#39;);\n/**\n * 利用esbuild生成文件\n */\nesbuild.buildSync(&#123;\n    entryPoints:[&#39;vite.config.js&#39;],\n    outfile: &#39;out.js&#39;\n&#125;)\n/**\n * 利用esbuild处理jsx语法\n */\nconsole.log(\n    esbuild.transformSync(&#39;&lt;div&gt;利用esbuild处理jsx语法&lt;/div&gt;&#39;,&#123;\n        jsxFragment:&#39;Fragment&#39;,\n        loader:&#39;jsx&#39;\n    &#125;)\n);\n/**\n * 利用esbuld压缩代码体积\n */\nconsole.log(\n    esbuild.transformSync(&#39;const a = &quot;你好世界&quot;&#39;,&#123;\n        minify: true\n    &#125;)\n);\n/**\n * esbuild内置了一些loader，使用时会根据文件后缀自动执行loader，也可以手动确定loader\n * 支持：js,jsx,ts,tsx,css,text,binary,dataurl,file\n */\nconsole.log(\n    esbuild.buildSync(&#123;\n        entryPoints: [&#39;vite.config.js&#39;],\n        bundle:true,\n        loader: &#123;&#39;.js&#39;:&#39;jsx&#39;&#125;, //默认使用js loader，手动改为jsx-loader\n        outfile: &#39;out.js&#39;,\n    &#125;)\n);\n/**\n * 使用esbuild启动一个web server用于调试（热更新）\n */\nesbuild.serve(&#123;&#125;,&#123;\n    entryPoints: [&#39;vite.config.js&#39;],\n    bundle: true,\n    outfile: &#39;bundle.js&#39;,\n&#125;).then(serve=&gt;&#123;\n    serve.stop();\n&#125;)\n</code></pre>\n","categories":["esbuild"],"tags":["esbuild","打包工具"]},{"title":"electron","url":"/2024/05/21/electron/","content":"<p><strong>Electron中preload模块最为重要，它的源码逻辑如下：</strong></p>\n<ul>\n<li>首先electron中封装了c++模块对接node.js的addon模块,方法是：在头文件中标注了：#include &lt;node&#x2F;addon.h&gt;</li>\n<li>此c++模块将app实例绑定(linkedBinding)到process上，app实例中有<code>exposeAPIInWorld</code>方法</li>\n<li>接着<code>contextBridge</code>中的<code>expostInMainWorld</code>方法返回的是<code>process.linkedBinding.exposeAPIInWorld</code>方法。<br><img data-src=\"https://dmqweb.cn/images/Electron.pdf\" alt=\"Electron.pdf\"><br><a href=\"https://dmqweb.cn/images/Electron.pdf\">Electron pdf笔记</a></li>\n</ul>\n<h1 id=\"最近有些忙，未完待续哈\"><a href=\"#最近有些忙，未完待续哈\" class=\"headerlink\" title=\"最近有些忙，未完待续哈\"></a>最近有些忙，未完待续哈</h1>","categories":["electron"],"tags":["electron"]},{"title":"eslint源码","url":"/2024/05/17/eslint%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","content":"<h1 id=\"eslint知识点\"><a href=\"#eslint知识点\" class=\"headerlink\" title=\"eslint知识点\"></a>eslint知识点</h1><h3 id=\"extends与plugins\"><a href=\"#extends与plugins\" class=\"headerlink\" title=\"extends与plugins\"></a>extends与plugins</h3><ol>\n<li>plugins本质是为了加强eslint的扩展性，使我们可以直接使用别人写好的eslint规则，方便快速用于项目中。</li>\n<li>官方规定npm包的扩展必须以eslint-config-开头，插件以eslint-plugin-开头，在使用过程中可以省略这个开头。</li>\n<li>eslint-config-文件是我们共享的一些配置文件，里面就是一个JS对象，其中包含一些配置信息，而eslint-plugin-文件是我们自定义的集合规则，可以导入和使用。</li>\n<li>一个插件能带来：<ul>\n<li>额外的规则，如<code>&#123;&quot;rules&quot;: &#123;&quot;react/boolean-prop-naming&quot;: &quot;warning&quot;&#125;&#125;</code>。</li>\n<li>环境，如<code>&#123;&quot;env&quot;: &#123;&quot;jest/global&quot;: true&#125;&#125;</code>。</li>\n<li>配置，如<code>&#123;&quot;extends&quot;: [&quot;plugin:react/recommended&quot;]&#125;</code>。</li>\n<li>预处理器，如<code>&#123;&quot;process&quot;: &quot;a-plugin/a-processor&quot;&#125;</code>。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"eslint配置大全\"><a href=\"#eslint配置大全\" class=\"headerlink\" title=\"eslint配置大全\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODU5NDg4MjkyODcx\">eslint配置大全</span></h1><h1 id=\"eslint源码分析\"><a href=\"#eslint源码分析\" class=\"headerlink\" title=\"eslint源码分析\"></a>eslint源码分析</h1>","categories":["eslint"],"tags":["eslint","源码"]},{"title":"forEach","url":"/2023/07/02/forEach/","content":"<p>手动实现一个类似forEach的效果:<br>前端开发过程中经常会遇到使用forEach的场景,那么它的原理究竟是什么呢?下面我手动写了一个类似的效果,不同的是函数可能会改变原始值.</p>\n<p>代码如下:</p>\n<pre><code class=\"javascript\">function myEach(obj,fn,context=window)&#123;\n    //类型判断\n    if(typeof obj !== &#39;object&#39;)&#123;\n        throw (&#39;必须要是对象&#39;)\n    &#125;\n    if(obj === null)&#123;\n        throw (&#39;必要不为空对象&#39;)\n    &#125;\n    if(typeof fn !== &#39;function&#39;)&#123;\n        throw (&#39;第二个参数，必须要是函数&#39;)\n    &#125;\n    //如果是数组\n    if(isArrayLike(obj))&#123;\n        for(let i=0;i&lt;obj.length;i++)&#123;\n            let res = fn.call(context,obj[i],i);\n            //res为什么会为false（如果函数内部return了，那么这里就需要跳出循环）\n            if(res===false)&#123;\n                break;\n            &#125;\n            //如果返回值不是undefined,有返回值,就替换掉这一项\n            if(res !== undefined)&#123;\n                obj[i] = res;                \n            &#125;\n        &#125;\n    &#125;else&#123;\n        //如果是对象\n        for(let key in obj)&#123;\n            if(!obj.hasOwnProperty(key)) break;\n            const res = fn.call(context,obj[key],key);\n            if(res ===false)&#123;\n                break;\n            &#125;\n            if(res !==undefined)&#123;\n                obj[key] = res;\n            &#125;\n        &#125;\n    &#125;\n    return obj;\n&#125;\n</code></pre>\n","categories":["JS"],"tags":["JS","forEach"]},{"title":"gitlab cicd","url":"/2024/07/07/gitlab-cicd/","content":"<h1 id=\"CICD\"><a href=\"#CICD\" class=\"headerlink\" title=\"CICD\"></a>CICD</h1><p>CI：持续集成</p>\n<p>CD：持续交付</p>\n<p>CD：持续部署</p>\n<h3 id=\"上线流程\"><a href=\"#上线流程\" class=\"headerlink\" title=\"上线流程\"></a>上线流程</h3><blockquote>\n<p>发布上线流程举例：git 上传，开始跑测试，进行打包，使用 docker 容器化镜像打包，推送到 dev 开发环境，部署到 staging 测试环境，最后部署到 production 生产环境</p>\n</blockquote>\n<h3 id=\"pipeline\"><a href=\"#pipeline\" class=\"headerlink\" title=\"pipeline\"></a>pipeline</h3><blockquote>\n<p>一次 pipeline 就相当于一次构建任务，里面可以包含多个流程，如：安装依赖，跑测试代码，eslint 校验，编译，部署测试服务器，部署生产服务器等流程，任何提交或者 Merge Request 的合并都可以触发 Pipeline。</p>\n</blockquote>\n<h3 id=\"runner\"><a href=\"#runner\" class=\"headerlink\" title=\"runner\"></a>runner</h3><blockquote>\n<p>一个 runner 就相当于一个打工仔，可以下载 gitlab runner 之后注册多个 runner，并且指定对应的 runner 执行任务。</p>\n</blockquote>\n<h1 id=\"gitlab-ci-yml-文件\"><a href=\"#gitlab-ci-yml-文件\" class=\"headerlink\" title=\".gitlab-ci.yml 文件\"></a>.gitlab-ci.yml 文件</h1><pre><code class=\"yaml\"># 一项代表一个pipeline作业\nhelloworld:\n  stage: linter\n  script:\n    - echo &quot;hello world,Gitlab!&quot;\n    - chmod +x ./run.sh # 将run.sh文件添加可执行权限\n    - ./run.sh # 将执行过程提取成可执行文件进行执行\n\n# 私密使用（不想暴露到代码中）的环境变量，可以在平台上进行设置\nvariables: # 全局的环境变量，还有一些内置的环境变量，例如：$CI_PIPELINE_SOURCE 详见文档\n  my_password: &quot;全局的配置变量&quot;\n\nrun_unit_tests:\n  variables: # 任务中配置变量，使用时加上$符号\n    my_password: &quot;iamsomepassword...&quot;\n  stage: testing\n  script:\n    - echo &quot;执行单元测试&quot;\n\n# 配置运行的容器镜像\nimage: alpine:latest\n\nbefore_script:\n  image: node:3.1.2-alpine3.16 # 配置单项作业运行的容器镜像\n  stage: build\n  needs: # 同一个stage中，通过needs来指定工作的相依性\n    - bad_job\n  script:\n    - echo &quot;安装套件&quot;\n    - echo &quot;设定资料链接&quot;\n\nworkflow: # 配置工作流\n  rules: # 当main分支commit时，才启动工作流程\n    - if: $CI_COMMIT_BRANCH == &quot;main&quot; # $CI_COMMIT_BRANCH是内置的环境变量\n      when: always\n    - when: never\n\nafter_script:\n  stage: deplpy\n  script:\n    - echo &quot;删除不必要的文件&quot;\n\nbuild_docker_image:\n  only: # 指定只有推送到main分支上才会执行，指定哪些分支不执行使用：except\n    - main\n  state: build\n  script:\n    - echo &quot;building docker image&quot;\n\nbad_job: # 假设错误的任务，则会中断当前工作的执行，每个工作独立执行\n  tags: # 指定runner(打工仔)进行执行，在注册runner时会创建一个tags\n    - runner_tags\n    - uname # 验证当前在runner中执行\n  stage: build\n  script: script:no_script\n\n# 建立舞台，使得工作按照指定先后顺序执行\nstages:\n  - linter\n  - testing\n  - build\n  - deploy\n# 服务端去官网安装gitlab runner，使用runner（打工仔）分配工作\n# 接着启动服务\n# 然后将这个服务进行注册（配置在gitlab runner的配置中）\n# runner分为：shared runner、 group runners和specific runners三种\n# 可以为某个群组设置runner，例如在群组中设置runner配置，服务中注册一个runner进行配置\n</code></pre>\n","categories":["gitlab cicd"],"tags":["gitlab cicd"]},{"title":"git与github","url":"/2023/04/02/git%E5%92%8Cgithub/","content":"<h1 id=\"———————————–git\"><a href=\"#———————————–git\" class=\"headerlink\" title=\"———————————–git\"></a>———————————–git</h1><h2 id=\"https-zhuanlan-zhihu-com-p-389814854\"><a href=\"#https-zhuanlan-zhihu-com-p-389814854\" class=\"headerlink\" title=\"https://zhuanlan.zhihu.com/p/389814854\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODk4MTQ4NTQ=\">https://zhuanlan.zhihu.com/p/389814854</span></h2><p>网址：git命令大全</p>\n<h4 id=\"git全局配置文件，配置一次即可生效\"><a href=\"#git全局配置文件，配置一次即可生效\" class=\"headerlink\" title=\"git全局配置文件，配置一次即可生效\"></a>git全局配置文件，配置一次即可生效</h4><p>（C:user&#x2F;用户名文件夹&#x2F;.gitconfig）</p>\n<h3 id=\"一、git-init\"><a href=\"#一、git-init\" class=\"headerlink\" title=\"一、git init\"></a>一、<code>git init</code></h3><h4 id=\"（初始化，创建本地仓库）\"><a href=\"#（初始化，创建本地仓库）\" class=\"headerlink\" title=\"（初始化，创建本地仓库）\"></a>（初始化，创建本地仓库）</h4><h3 id=\"二、git-add\"><a href=\"#二、git-add\" class=\"headerlink\" title=\"二、git add\"></a>二、<code>git add</code></h3><h4 id=\"（添加到本地仓库）\"><a href=\"#（添加到本地仓库）\" class=\"headerlink\" title=\"（添加到本地仓库）\"></a>（添加到本地仓库）</h4><h3 id=\"三、git-commit-m-“注释”\"><a href=\"#三、git-commit-m-“注释”\" class=\"headerlink\" title=\"三、git commit -m “注释”\"></a>三、<code>git commit -m</code> “注释”</h3><h4 id=\"（添加注释）\"><a href=\"#（添加注释）\" class=\"headerlink\" title=\"（添加注释）\"></a>（添加注释）</h4><h3 id=\"四、git-remote-add-origin-仓库地址\"><a href=\"#四、git-remote-add-origin-仓库地址\" class=\"headerlink\" title=\"四、git remote add origin 仓库地址\"></a>四、<code>git remote add origin</code> 仓库地址</h3><h4 id=\"（连接远程仓库）\"><a href=\"#（连接远程仓库）\" class=\"headerlink\" title=\"（连接远程仓库）\"></a>（连接远程仓库）</h4><h3 id=\"五、git-pull-rebase-origin-master\"><a href=\"#五、git-pull-rebase-origin-master\" class=\"headerlink\" title=\"五、git pull --rebase origin master\"></a>五、<code>git pull --rebase origin master</code></h3><h4 id=\"仓库地址（同步仓库内容）\"><a href=\"#仓库地址（同步仓库内容）\" class=\"headerlink\" title=\"仓库地址（同步仓库内容）\"></a>仓库地址（同步仓库内容）</h4><h3 id=\"六、git-push-u-origin-master\"><a href=\"#六、git-push-u-origin-master\" class=\"headerlink\" title=\"六、git push -u origin master\"></a>六、<code>git push -u origin master</code></h3><h4 id=\"（上传到远程仓库）\"><a href=\"#（上传到远程仓库）\" class=\"headerlink\" title=\"（上传到远程仓库）\"></a>（上传到远程仓库）</h4><h3 id=\"①获得git帮助命令（浏览器中）\"><a href=\"#①获得git帮助命令（浏览器中）\" class=\"headerlink\" title=\"①获得git帮助命令（浏览器中）\"></a>①获得git帮助命令（浏览器中）</h3><p><code>git help config</code>（获取参考）<br><code>git config -h</code>（获取更简明的快速参考）</p>\n<h3 id=\"②获得git配置信息\"><a href=\"#②获得git配置信息\" class=\"headerlink\" title=\"②获得git配置信息\"></a>②获得git配置信息</h3><p> <code>git config --list --global</code>（查看全局配置项）<br><code>git config user.name</code>(查看某一项)</p>\n<h3 id=\"③配置用户信息\"><a href=\"#③配置用户信息\" class=\"headerlink\" title=\"③配置用户信息\"></a>③配置用户信息</h3><p><code>git config --global user.name &#39;name&#39;</code><br><code>git config --global user.email &#39;email&#39;</code><br>（使用了–global选项，那么该命令只需要运行一次即可永久生效）</p>\n<h3 id=\"④获取帮助信息\"><a href=\"#④获取帮助信息\" class=\"headerlink\" title=\"④获取帮助信息\"></a>④获取帮助信息</h3><p>git help <verb>(获取某个命令的帮助手册)</p>\n<h3 id=\"⑤将目录转换成Git仓库（项目的git-Bash中使用git-init）\"><a href=\"#⑤将目录转换成Git仓库（项目的git-Bash中使用git-init）\" class=\"headerlink\" title=\"⑤将目录转换成Git仓库（项目的git Bash中使用git init）\"></a>⑤将目录转换成Git仓库（项目的git Bash中使用git init）</h3><h3 id=\"⑥从其他服务器上克隆一个仓库\"><a href=\"#⑥从其他服务器上克隆一个仓库\" class=\"headerlink\" title=\"⑥从其他服务器上克隆一个仓库\"></a>⑥从其他服务器上克隆一个仓库</h3><h3 id=\"⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）\"><a href=\"#⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）\" class=\"headerlink\" title=\"⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）\"></a>⑦四种状态：：工作区（未修改），暂存区（已修改），仓库（已暂存）</h3><h3 id=\"⑧git目标：将工作区的文件都处于未修改的状态\"><a href=\"#⑧git目标：将工作区的文件都处于未修改的状态\" class=\"headerlink\" title=\"⑧git目标：将工作区的文件都处于未修改的状态\"></a>⑧git目标：将工作区的文件都处于未修改的状态</h3><h3 id=\"⑨查看文件出于什么状态：（git-status命令（git-status-s-精简显示），查看那些文件被跟踪，哪些没有）\"><a href=\"#⑨查看文件出于什么状态：（git-status命令（git-status-s-精简显示），查看那些文件被跟踪，哪些没有）\" class=\"headerlink\" title=\"⑨查看文件出于什么状态：（git status命令（git status -s 精简显示），查看那些文件被跟踪，哪些没有）\"></a>⑨查看文件出于什么状态：（git status命令（git status -s 精简显示），查看那些文件被跟踪，哪些没有）</h3><p>??：未被 Git 跟踪的新文件。<br>A：新增文件。<br>M：文件已被修改。<br>D：文件已被删除。<br>R：文件已被重命名。<br>C：文件已被拷贝。<br>X：文件状态没有更改。<br>M：文件被修改并且已经暂存。<br>A：文件已经添加到 Git 并且还没有被暂存。<br>D：文件被删除了。<br>R：文件被重命名了。<br>C：文件被拷贝（复制）了。</p>\n<h3 id=\"⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git-add-文件名-）\"><a href=\"#⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git-add-文件名-）\" class=\"headerlink\" title=\"⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git add 文件名 ）\"></a>⑩跟踪文件，跟踪后Git会记录文件的所有变化，并管理和恢复（git add 文件名 ）</h3><p>取消跟踪文件：<code>git rm --cached &lt;file&gt;</code>  （需要执行一次提交才生效）</p>\n<h3 id=\"十一、提交到git仓库中\"><a href=\"#十一、提交到git仓库中\" class=\"headerlink\" title=\"十一、提交到git仓库中\"></a>十一、提交到git仓库中</h3><p>（<code>git commit -m</code> ‘描述信息’）</p>\n<h3 id=\"十二、修改已提交的文件，其状态为红色M\"><a href=\"#十二、修改已提交的文件，其状态为红色M\" class=\"headerlink\" title=\"十二、修改已提交的文件，其状态为红色M\"></a>十二、修改已提交的文件，其状态为红色M</h3><h3 id=\"十三、git-add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态\"><a href=\"#十三、git-add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态\" class=\"headerlink\" title=\"十三、git add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态\"></a>十三、git add命令的三个功能：①跟踪新文件②将已跟踪且修改的文件放到暂存区③将有冲突的文件标记为以解决状态</h3><h3 id=\"十四、撤销对文件的修改谨慎操作\"><a href=\"#十四、撤销对文件的修改谨慎操作\" class=\"headerlink\" title=\"十四、撤销对文件的修改谨慎操作\"></a>十四、撤销对文件的修改<em>谨慎操作</em></h3><p>*（<code>git checkout -- 文件名</code>），本质是Git仓库中保存的文件，覆盖工作区中指定的文件</p>\n<h3 id=\"十五、向暂存区中一次性添加目录下所有文件\"><a href=\"#十五、向暂存区中一次性添加目录下所有文件\" class=\"headerlink\" title=\"十五、向暂存区中一次性添加目录下所有文件\"></a>十五、向暂存区中一次性添加目录下所有文件</h3><p>*（<code>git add .</code>）</p>\n<h3 id=\"十六、从暂存区移除暂存的文件\"><a href=\"#十六、从暂存区移除暂存的文件\" class=\"headerlink\" title=\"十六、从暂存区移除暂存的文件\"></a>十六、从暂存区移除暂存的文件</h3><p>*（<code>git reset HEAD 文件名</code>）文件名为 .号表明移除全部</p>\n<h3 id=\"十七、Git工作流程：工作区—-暂存区—-Git仓库\"><a href=\"#十七、Git工作流程：工作区—-暂存区—-Git仓库\" class=\"headerlink\" title=\"十七、Git工作流程：工作区—-暂存区—-Git仓库\"></a>十七、Git工作流程：工作区—-暂存区—-Git仓库</h3><h3 id=\"十八、跳过使用暂存区\"><a href=\"#十八、跳过使用暂存区\" class=\"headerlink\" title=\"十八、跳过使用暂存区\"></a>十八、跳过使用暂存区</h3><p>*（<code>git commit -a -m</code> “描述消息”）</p>\n<h3 id=\"十九、从Git仓库中移除文件\"><a href=\"#十九、从Git仓库中移除文件\" class=\"headerlink\" title=\"十九、从Git仓库中移除文件\"></a>十九、从Git仓库中移除文件</h3><p>*（<code>git rm -f</code> 文件名   ，从Git仓库和工作区中同时移除index.js文件②git rm –cached 文件名  ， 只从Git仓库中移除文件，用于不用更改的固定文件不用记录）</p>\n<h3 id=\"二十、忽略文件\"><a href=\"#二十、忽略文件\" class=\"headerlink\" title=\"二十、忽略文件\"></a>二十、忽略文件</h3><p>*（新建一个名为.gitignore配置文件，列出要忽略的文件的匹配模式）①以#开头的是注释②以&#x2F;结尾的是目录③以&#x2F;开头防止递归④以！开头表示取反⑤可以使用glob模式进行文件和文件夹的匹配（glob指简化了的正则表达式）</p>\n<h3 id=\"二十一、glob模式：\"><a href=\"#二十一、glob模式：\" class=\"headerlink\" title=\"二十一、glob模式：\"></a>二十一、glob模式：</h3><p><em>①</em>:匹配零个或多个任意字符</p>\n<p>②[abc]匹配任何一个列在方括号中的字符</p>\n<p>③？：匹配一个任意字符</p>\n<p>④[0-9]匹配所有0到9的数字</p>\n<p>⑤**表示匹配任意中间目录</p>\n<h3 id=\"二十二、输出Git提交日志\"><a href=\"#二十二、输出Git提交日志\" class=\"headerlink\" title=\"二十二、输出Git提交日志\"></a>二十二、输出Git提交日志</h3><p><code>（git log）git log -n</code>提交最近n条历史信息</p>\n<h3 id=\"二十三、回退指定版本：\"><a href=\"#二十三、回退指定版本：\" class=\"headerlink\" title=\"二十三、回退指定版本：\"></a>二十三、回退指定版本：</h3><p>（<code>git log --pretty=onlin</code>查看提交历史，获得对应标识id 、</p>\n<p> <code>git reset --hard &lt;CommitID&gt;</code>根据指定的提交ID回退到指定版本 、</p>\n<p><code>git reflog --pretty=online</code>旧版本中使用，查看命令操作的历史 、</p>\n<p> <code>git reset --hard &lt;CommitID&gt;</code>再次根据最新的提交ID，跳转到最新的版本）</p>\n<h1 id=\"—————————————-github\"><a href=\"#—————————————-github\" class=\"headerlink\" title=\"—————————————-github\"></a>—————————————-github</h1><h2 id=\"一、远程仓库使用\"><a href=\"#一、远程仓库使用\" class=\"headerlink\" title=\"一、远程仓库使用\"></a>一、远程仓库使用</h2><p>HTTPS:零配置，每次范围问需要重新输入密码</p>\n<p>SSH:需要额外配置,配置后不必重复输入密码（推荐使用）</p>\n<h2 id=\"二、基于HTTPS、SSH将本地仓库上传到Github\"><a href=\"#二、基于HTTPS、SSH将本地仓库上传到Github\" class=\"headerlink\" title=\"二、基于HTTPS、SSH将本地仓库上传到Github\"></a>二、基于HTTPS、SSH将本地仓库上传到Github</h2><p><code>echo &quot;# project 02&quot; &gt;&gt; README.md</code>       使用终端创建内容为#project 02的md文件</p>\n<p><code>git init</code>初始化本地仓库（git打开）</p>\n<p><code>git add README.md</code></p>\n<p><code>git commit -m &quot;first commit&quot;</code> 文件修改并提交到本地仓库</p>\n<p><code>git remote add </code> 仓库地址（HTTP或SSH） 链接远程仓库</p>\n<p><code>git push -u 仓库地址 master</code> 将本地仓库推送到远程仓库（第一次推送 以后直接<code>git push</code>）</p>\n<h2 id=\"三、生成SSH-key\"><a href=\"#三、生成SSH-key\" class=\"headerlink\" title=\"三、生成SSH key\"></a>三、生成SSH key</h2><p>git Bash中 使用： <code>ssh-keygen -t rsa -b 4096  -C &quot;邮箱地址&quot;</code></p>\n<p>连续三次回车，即可在C:\\Users\\dmq \\ .ssh目录中生成id_rsa 和 id_rsa.pub两个文件</p>\n<h4 id=\"SSH-key的好处\"><a href=\"#SSH-key的好处\" class=\"headerlink\" title=\"SSH key的好处\"></a>SSH key的好处</h4><p>实现本地仓库和Github之间免登录的加密数据传输</p>\n<h4 id=\"SSH-key两部分\"><a href=\"#SSH-key两部分\" class=\"headerlink\" title=\"SSH key两部分\"></a>SSH key两部分</h4><p>①id_rsa(私钥文件，存放于客户端的电脑中)</p>\n<p>②id_rsa.pub(公钥文件，需要配置到Github中)</p>\n<h4 id=\"配置SSH-key\"><a href=\"#配置SSH-key\" class=\"headerlink\" title=\"配置SSH key\"></a>配置SSH key</h4><p>①记事本打开id_rsa.pub 文件，复制里面的内容</p>\n<p>②在浏览器中登录Github，点击头像 -&gt;Settings -&gt;SSH and GPG Keys -&gt; New SSH key</p>\n<p>③将id_rsa.pub文件中的内容，粘贴到Key对应的文本框中</p>\n<p>④在Title文本框中任意填写一个名称，来标识这个Key从何而来</p>\n<h4 id=\"检测远程仓库中SSH是否配置成功\"><a href=\"#检测远程仓库中SSH是否配置成功\" class=\"headerlink\" title=\"检测远程仓库中SSH是否配置成功\"></a>检测远程仓库中SSH是否配置成功</h4><p>Git Bash中：</p>\n<p> <code>ssh -T git@github.com </code>(github)</p>\n<p><code>ssh -T git@gitee.com</code> (gitee)</p>\n<p>输入yes</p>\n<h2 id=\"四、将远程仓库克隆到本地\"><a href=\"#四、将远程仓库克隆到本地\" class=\"headerlink\" title=\"四、将远程仓库克隆到本地\"></a>四、将远程仓库克隆到本地</h2><p>Git Bash 中输入 <code>git clone  远程仓库地址</code></p>\n","categories":["git"],"tags":["git","github"]},{"title":"jest","url":"/2024/03/30/jest/","content":"<h1 id=\"jest测试\"><a href=\"#jest测试\" class=\"headerlink\" title=\"jest测试\"></a>jest测试</h1><p>市面上有很多测试框架，例如：mocha 、jasmine、vue test utils、vitest、react testing library和testing frameworks for jacascript等，但语法和思想大致相同，现在依jest框架进行简单的使用</p>\n<pre><code class=\"javascript\">/**\n * jest简单的语法\n * expect  toBe 语法\n */\ntest(&#39;tow plus to 4&#39;,()=&gt;&#123;\n    expect(2+2).toBe(4);\n&#125;)\n/**\n * toEqual语法，递归检查对象或数组的每个字段\n */\ntest(&#39;object assignment&#39;,()=&gt;&#123;\n    const data = &#123;name:&quot;张三&quot;&#125;;\n    data[&#39;age&#39;] = 18;\n    expect(data).toEqual(&#123;name:&quot;张三&quot;,age:18&#125;)\n&#125;)\n/**\n * expect  not  toBe\n */\ntest(&#39;adding is not 0&#39;,()=&gt;&#123;\n    for(let i=0;i&lt;10;i++)&#123;\n        for(let j=0;j&lt;5;j++)&#123;\n            expect(i + j).not.toBe(-1);\n        &#125;\n    &#125;\n&#125;)\n/**\n * 检查指定空类型（null,undefined,defined，true和false）\n */\ntest(&#39;toBe null&#39;,()=&gt;&#123;\n    const n = null;\n    expect(n).toBeNull();\n&#125;)\ntest(&#39;toBe defined&#39;,()=&gt;&#123;\n    const n = 1;\n    expect(n).toBeDefined();\n&#125;)\ntest(&#39;toBe Undefined&#39;,()=&gt;&#123;\n    let n;\n    expect(n).toBeUndefined();\n&#125;)\ntest(&#39;toBe Truthy&#39;,()=&gt;&#123;\n    const n = 1;\n    const m = true;\n    expect(n &amp;&amp; m).toBeTruthy();\n&#125;)\ntest(&#39;toBe falsy&#39;,()=&gt;&#123;\n    const n = 0;\n    const m = false;\n    expect(n &amp;&amp; m).toBeFalsy();\n&#125;)\n/**\n * jest对0进行精确测试的结果\n */\ntest(&#39;zero&#39;, () =&gt; &#123;\n    const z = 0;\n    expect(z).not.toBeNull(); //非null\n    expect(z).toBeDefined(); //defined\n    expect(z).not.toBeUndefined(); \n    expect(z).not.toBeTruthy(); //非true\n    expect(z).toBeFalsy(); //false\n  &#125;);\n/**\n * jest测试数字\n */\ntest(&#39;two and two&#39;,()=&gt;&#123;\n    const value = 2 + 2;\n    expect(value).toBeGreaterThan(3);\n    expect(value).toBeGreaterThanOrEqual(4)\n    expect(value).toBeLessThanOrEqual(4.5)\n    expect(value).toBeLessThanOrEqual(4)\n    expect(value).toBe(4)\n    expect(value).toEqual(4)\n&#125;)\n/**\n * toBeCloseTo检查浮点数相等\n */\ntest(&#39;test float number&#39;,()=&gt;&#123;\n    const value = 0.1 + 0.2;\n    // expect(value).toBe(0.3)  报错，因为计算机精度的原因\n    expect(value).toBeCloseTo(0.3)\n&#125;)\n/**\n * toMatch根据正则表达式检查字符串\n */\ntest(&#39;test reg&#39;,()=&gt;&#123;\n    expect(&#39;team&#39;).not.toMatch(/I/)\n    expect(&#39;Christoph&#39;).toMatch(/stop/)\n    expect(&#39;hello world&#39;).toMatch(&#39;lo w&#39;)\n&#125;)\n/**\n * toContain测试数组和可迭代对象\n */\nconst List = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];\ntest(&#39;list to be&#39;,()=&gt;&#123;\n    expect(List).toContain(&#39;c&#39;);\n    expect(List).not.toContain(1);\n&#125;)\n/**\n * 测试异步代码\n */\nconst testPromise = Promise.resolve(&#39;hello&#39;);\n//1 使用return\ntest(&#39;return异步代码&#39;,()=&gt;&#123;\n    return testPromise.then(data=&gt;&#123;\n        expect(data).toBe(&#39;hello&#39;)\n    &#125;)\n&#125;)\n//2 使用async和await语法\nfunction fetchMessage() &#123;\n    return new Promise((resolve) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(&#39;hello&#39;);\n        &#125;, 1000);\n    &#125;);\n&#125;\ntest(&#39;async and await&#39;, async () =&gt; &#123;\n    const result = await fetchMessage();\n    expect(result).toBe(&#39;hello&#39;);\n&#125;);\n//expect.assertions验证是否调用了一定数量的断言，确保兑现的承若通过测试\n//catch捕捉（确保Promise不会被兑现）\n// test(&#39;catch fails with errors&#39;,()=&gt;&#123;\n//     return fetchData2().catch(e=&gt;expect(e).toMatch(&#39;error&#39;))\n// &#125;)\n\n// 3 使用回调函数done\ntest(&#39;done to async&#39;,(done)=&gt;&#123;\n    testPromise.then(res=&gt;&#123;\n        expect(res).toBe(&#39;hello&#39;);\n    &#125;)\n    done();\n&#125;)\n// 4 .resolves匹配器等待Promise解析（reject则失败）\ntest(&#39;.resolves匹配器&#39;,()=&gt;&#123;\n    expect(testPromise).resolves.toBe(&#39;hello&#39;)\n&#125;)\n/**\n * beforeEach和afterEach钩子函数\n * 当每一个测试之前或之后都需要调用相同的方法就可以使用这两个钩子函数\n */\n\n/**\n * describe块\n */\n\n/**\n * test.only只运行一个测试\n */\ntest.only(&#39;test only&#39;,()=&gt;&#123;\n    expect(&#39;test only&#39;).toMatch(&#39;t o&#39;)\n&#125;)\n</code></pre>\n","categories":["TDD"],"tags":["jest"]},{"title":"json-server","url":"/2023/01/09/json-server%E6%95%99%E7%A8%8B/","content":"<h4 id=\"0-json-server-搭建本地接口\"><a href=\"#0-json-server-搭建本地接口\" class=\"headerlink\" title=\"0. json-server 搭建本地接口\"></a>0. json-server 搭建本地接口</h4><h5 id=\"0-1-安装-json-server\"><a href=\"#0-1-安装-json-server\" class=\"headerlink\" title=\"0.1 安装 json-server\"></a>0.1 安装 json-server</h5><ul>\n<li><p>使用 <strong>npm</strong> &#x3D;&#x3D;全局&#x3D;&#x3D;安装 <strong>json-server</strong></p>\n<pre><code class=\"bash\">npm install -g json-server\n</code></pre>\n</li>\n<li><p>检测是否安装成功</p>\n<pre><code class=\"bash\">json-server -v\n</code></pre>\n</li>\n</ul>\n<h5 id=\"0-2-准备数据文件（已准备好，这两步不用自己做）\"><a href=\"#0-2-准备数据文件（已准备好，这两步不用自己做）\" class=\"headerlink\" title=\"0.2 准备数据文件（已准备好，这两步不用自己做）\"></a>0.2 准备数据文件（已准备好，这两步不用自己做）</h5><ol>\n<li><p>电脑方便找到的任意位置创建一个&#x3D;&#x3D;文件夹&#x3D;&#x3D;，进入到该文件夹里面，创建一个&#x3D;&#x3D;JSON文件&#x3D;&#x3D;</p>\n<ul>\n<li><p>文件夹和JSON文件的名字可以任意设计，但是&#x3D;&#x3D;不能出现中文&#x3D;&#x3D;</p>\n</li>\n<li><p>比如：文件夹名字：<code>service/</code>；JSON文件名字：<code>db.json</code></p>\n</li>\n</ul>\n</li>\n<li><p>在<code>db.json</code>文件中，准备&#x3D;&#x3D;JSON格式的数据&#x3D;&#x3D;</p>\n<pre><code class=\"javascripton\">&#123;\n  &quot;address&quot;: [\n    &#123;\n      &quot;id&quot;: 101,\n      &quot;receiver&quot;: &quot;李白姓白&quot;,\n      &quot;mobile&quot;: &quot;13800000101&quot;,\n      &quot;province&quot;: &quot;浙江省&quot;,\n      &quot;city&quot;: &quot;杭州市&quot;,\n      &quot;area&quot;: &quot;西湖区&quot;,\n      &quot;location&quot;: &quot;西湖大道101号&quot;,\n      &quot;state&quot;: 1\n    &#125;,\n    &#123;\n      &quot;id&quot;: 102,\n      &quot;receiver&quot;: &quot;苏轼&quot;,\n      &quot;mobile&quot;: &quot;13800000102&quot;,\n      &quot;province&quot;: &quot;北京市&quot;,\n      &quot;city&quot;: &quot;北京市&quot;,\n      &quot;area&quot;: &quot;昌平区&quot;,\n      &quot;location&quot;: &quot;西湖大道102号&quot;,\n      &quot;state&quot;: 0\n    &#125;,\n    &#123;\n      &quot;receiver&quot;: &quot;韩愈&quot;,\n      &quot;mobile&quot;: &quot;13800000103&quot;,\n      &quot;province&quot;: &quot;浙江省&quot;,\n      &quot;city&quot;: &quot;杭州市&quot;,\n      &quot;area&quot;: &quot;西湖区&quot;,\n      &quot;location&quot;: &quot;西湖大道103号&quot;,\n      &quot;state&quot;: 1,\n      &quot;id&quot;: 103\n    &#125;\n  ]\n&#125;\n</code></pre>\n</li>\n</ol>\n<h5 id=\"0-3-启动-json-server-本地服务\"><a href=\"#0-3-启动-json-server-本地服务\" class=\"headerlink\" title=\"0.3 启动 json-server 本地服务\"></a>0.3 启动 json-server 本地服务</h5><ul>\n<li><p>在<code>service/</code>文件夹下，进入终端，执行启动 json-server 命令</p>\n</li>\n<li><p>&#x3D;&#x3D;第一种&#x3D;&#x3D;：<strong>默认启动方式</strong>，&#x3D;&#x3D;只能在自己的计算机中访问自己的数据，其他计算机无法访问你的数据&#x3D;&#x3D;</p>\n<pre><code class=\"bash\">json-server --watch db.json\n</code></pre>\n<blockquote>\n<p>测试访问：<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDozMDAwL2FkZHJlc3M=\">http://localhost:3000/address</span></p>\n</blockquote>\n</li>\n<li><p>&#x3D;&#x3D;第二种&#x3D;&#x3D;：<strong>自定义启动方式</strong>，在局域环境内，&#x3D;&#x3D;其他计算机也可以访问你计算机中的数据&#x3D;&#x3D;</p>\n<ul>\n<li><p>命令规范：<code>json-server --host 本机IP地址 db.json --port 端口号</code></p>\n<pre><code class=\"bash\">json-server --host 192.168.28.95 db.json --port 5000\n</code></pre>\n<blockquote>\n<p>测试访问：<span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguMjguOTU6NTAwMC9hZGRyZXNz\">http://192.168.28.95:5000/address</span></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["json-server"],"tags":["json-server"]},{"title":"git笔记","url":"/2023/05/02/git%20github%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89/","content":"<!--Ctrl+[ 提升列表等级；Ctrl+1 一级标题-->\n\n\n\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003049.png\" alt=\"/images/image-20220202212355012\"></p>\n<h1 id=\"一、用于版本控制\"><a href=\"#一、用于版本控制\" class=\"headerlink\" title=\"一、用于版本控制\"></a>一、用于版本控制</h1><ol>\n<li><p>版本控制工具需要的功能</p>\n<p>协同修改、数据备份、版本管理、权限控制、历史记录、分支管理</p>\n<p><img data-src=\"D:\\AMYCode\\220202testGithub\\images\\image-20220130110013784.png\" alt=\"/images/image-20220130110013784\"></p>\n</li>\n<li><p>分布式版本控制 vs 集中式版本控制</p>\n<p>集中式版本控制需联网才能需要</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003434.png\"></p>\n</li>\n</ol>\n<h1 id=\"二、Git简介\"><a href=\"#二、Git简介\" class=\"headerlink\" title=\"二、Git简介\"></a>二、Git简介</h1><ol>\n<li><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003455.png\" alt=\"/images/image-20220130112357773\"></p>\n</li>\n<li><p>本地库和远程库</p>\n<ul>\n<li><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003509.png\"></p>\n<p>团队内成员操作</p>\n</li>\n<li><p>想找不是团队内的成员 东方不败 来帮忙，那就需要他fork一下，这样对于修改可以进行pull request，经过审核后可以merge到原来的远程仓库</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003535.png\" alt=\"/images/image-20220130113228007\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"三、Git命令行操作\"><a href=\"#三、Git命令行操作\" class=\"headerlink\" title=\"三、Git命令行操作\"></a>三、Git命令行操作</h1><p>主体内容：<img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003525.png\" alt=\"/images/image-20220130120329440\"></p>\n<h2 id=\"本地库初始化\"><a href=\"#本地库初始化\" class=\"headerlink\" title=\"本地库初始化\"></a>本地库初始化</h2><ul>\n<li><p>git init</p>\n</li>\n<li><p>初始化后效果：会生成一个.git隐藏文件。使用ll .git&#x2F;可以查看</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003546.png\" alt=\"/images/image-20220130120928612\"></p>\n</li>\n<li><p>注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不能胡乱修改</p>\n</li>\n</ul>\n<h2 id=\"设置签名\"><a href=\"#设置签名\" class=\"headerlink\" title=\"设置签名\"></a>设置签名</h2><ul>\n<li><p>形式  例如：</p>\n<p>用户名：tom</p>\n<p>Email地址：<span class=\"exturl\" data-url=\"bWFpbHRvOiYjMTAzOyYjeDY5OyYjMTE2OyYjNjQ7JiM5ODsmIzk3OyYjeDZjOyYjOTc7JiN4MmU7JiN4NjM7JiMxMTE7JiMxMDk7\">&#103;&#x69;&#116;&#64;&#98;&#97;&#x6c;&#97;&#x2e;&#x63;&#111;&#109;</span></p>\n</li>\n<li><p>作用：区分不同开发人员的身份</p>\n</li>\n<li><p>辨析：这里设置的签名和登录远程库（代码托管中心）的账户、密码没有任何关系</p>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>项目级别&#x2F;仓库级别：仅在当前本地库范围内有效</p>\n<ul>\n<li><p>git config user.name tom</p>\n</li>\n<li><p>git config user.email <span class=\"exturl\" data-url=\"bWFpbHRvOiYjeDc0OyYjeDZmOyYjMTA5OyYjNjQ7JiM5ODsmI3g2MTsmI3g2YzsmI3g2MTsmI3gyZTsmIzk5OyYjMTExOyYjMTA5Ow==\">&#x74;&#x6f;&#109;&#64;&#98;&#x61;&#x6c;&#x61;&#x2e;&#99;&#111;&#109;</span></p>\n</li>\n<li><p>设置后，信息会保存到 .git&#x2F;config [下面用cat命令查看这个文件]</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003600.png\" alt=\"/images/image-20220130123501964\"></p>\n</li>\n</ul>\n</li>\n<li><p>系统用户级别：登录当前操作系统的用户范围</p>\n<ul>\n<li>git config –global user.name tom</li>\n<li>git config –global user.email <span class=\"exturl\" data-url=\"bWFpbHRvOiYjeDc0OyYjeDZmOyYjMTA5OyYjeDQwOyYjeDYyOyYjeDYxOyYjMTA4OyYjOTc7JiN4MmU7JiN4NjM7JiMxMTE7JiMxMDk7\">&#x74;&#x6f;&#109;&#x40;&#x62;&#x61;&#108;&#97;&#x2e;&#x63;&#111;&#109;</span></li>\n<li>信息保存位置：.&#x2F;.git&#x2F;config 文件</li>\n</ul>\n</li>\n<li><p>级别优先级</p>\n<ul>\n<li>就近原则：项目级别优先于用户级别，二者都有时采用项目级别的签名</li>\n<li>如果只有系统用户级别的签名，就以系统用户级别的签名为准</li>\n<li>二者都没有不允许</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作命令\"><a href=\"#操作命令\" class=\"headerlink\" title=\"操作命令\"></a>操作命令</h2><ol>\n<li><p>状态查看操作 <strong>git</strong> <strong>status</strong> 【该命令特别常用】</p>\n</li>\n<li><p>添加操作 <strong>git add 文件名</strong>   </p>\n<p>把untrack的文件加入到暂存区。将工作区的“新建&#x2F;修改”添加到暂存区</p>\n</li>\n<li><p>提交操作 <strong>git commit 文件名</strong></p>\n</li>\n</ol>\n<ul>\n<li><p>把文件从暂存区提交到本地库</p>\n</li>\n<li><p>执行该命令后需要输入 commit message，即这次commit的相关注释。</p>\n<p>因为使用的是vim编辑器，可以i键进入编辑模式，ESC进入命令模式，命令模式下输入：wq进行保存并退出</p>\n</li>\n</ul>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003720.png\" alt=\"/images/image-20220130125343078\"></p>\n<p> 图片展示中的2 insertions代表两行，新加的good.txt文件确实里边只有两行文字。</p>\n<ul>\n<li>执行git commit命令后会进入vim文本编辑器，需要输注释。下面是一种更简单的方法</li>\n</ul>\n<p>  <code>git commit -m &quot;这里写注释&quot; goood.txt</code></p>\n<ol start=\"4\">\n<li><p>查看历史记录操作</p>\n<p><code>git log</code> </p>\n<ul>\n<li><p>查看历史操作<img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003738.png\" alt=\"/images/image-20220130131345836\"></p>\n</li>\n<li><p>如果提交次数特别多，历史记录会一屏放不下。多屏显示控制方式</p>\n<p>空格向下翻页；b向上翻页；q退出</p>\n</li>\n<li><p>可以使用–pretty增加参数</p>\n<p><code>git log --pretty=oneline</code> 显示一行</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003846.png\" alt=\"/images/image-20220130132306271\"></p>\n</li>\n<li><p><code>git log --oneline</code> 也是每次提交仅显示一行，与上面的命令相比，hash值会变短</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003854.png\" alt=\"/images/image-20220130132333516\"></p>\n</li>\n<li><p><code>git reflog</code> 可以增加显示要移动几次指针来回复到对应版本</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003822.png\" alt=\"/images/image-20220130132048569\"></p>\n</li>\n</ul>\n</li>\n<li><p>版本前进和后退</p>\n<ul>\n<li><p>基于索引值操作（推荐）</p>\n<p><code>git reset --hard 索引值</code>【索引值可以通过git reflog获得，选中索引，然后粘贴】</p>\n</li>\n<li><p>使用^符号</p>\n<ul>\n<li><p>该命令只能后退</p>\n</li>\n<li><p><code>git reset --hard HEAD^^</code> 几个<strong>^</strong>代表退几步</p>\n</li>\n</ul>\n</li>\n<li><p>使用~符号</p>\n<p>该命令也只能后退</p>\n<ul>\n<li><p><code>git reset --hard HEAD~n</code> </p>\n</li>\n<li><p>n代表后退n步</p>\n</li>\n</ul>\n</li>\n<li><p>reset命令的三个参数对比</p>\n<ul>\n<li><p>–soft 参数  仅仅在本地库移动HEAD指针</p>\n</li>\n<li><p>–mixed参数 在本地库移动HEAD指针；重置暂存区</p>\n</li>\n<li><p>–hard参数   在本地库移动HEAD指针；重置暂存区；重置工作区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>git help 命令</code></p>\n</li>\n<li><p>永久删除文件后找回</p>\n<p>在工作区删除后，提交到本地库，可以通过reset回到之前的版本，之前版本还保留该文件</p>\n<ul>\n<li>前提：删除前，文件存在时的状态提交到本地库</li>\n<li>操作：git reset –hard [指针位置]<ul>\n<li>删除操作已经提交到本地库，则指针位置指向历史记录</li>\n<li>删除操作没有提交到本地库，指针使用head</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>比较文件差异</p>\n<ul>\n<li>git diff [文件名]<ul>\n<li>将工作区中的文件和暂存区进行比较</li>\n</ul>\n</li>\n<li>git diff [本地库中的历史版本] [文件名]<ul>\n<li>将工作区中的文件和本地库历史记录比较</li>\n</ul>\n</li>\n<li>不带文件名则可以比较多个文件</li>\n</ul>\n</li>\n<li><p>分支管理</p>\n<ol>\n<li><p>分支：在版本控制过程中，使用多条线同时推进多个任务</p>\n</li>\n<li><p>分支的好处：</p>\n<ul>\n<li>同时并行推进多个功能的开发，提高开发效率</li>\n<li>如果发现某个分支有问题，可以删除该分支不影响主干</li>\n</ul>\n</li>\n<li><p>如何查看分支</p>\n<p><code>git branch -v</code></p>\n</li>\n<li><p>如何创建分支</p>\n<p><code>git branch [新的分支名字]</code></p>\n</li>\n<li><p>切换分支</p>\n<p><code>git checkout [分支名字]</code>  切换到某个分支</p>\n</li>\n<li><p>合并分支</p>\n<p><code>git branch -v</code> </p>\n<ul>\n<li><p>第一步，切换到接受修改的分支（被合并，增加新内容）上</p>\n<p><code>git checkout master</code> 到接受修改的分支，比如合并到主分支</p>\n</li>\n<li><p>第二步，执行merge</p>\n<p><code>git merge [被合并的分支名]</code></p>\n</li>\n</ul>\n</li>\n<li><p>解决冲突</p>\n<ul>\n<li><p>冲突的表现</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003919.png\" alt=\"/images/image-20220202183828366\"></p>\n</li>\n<li><p>冲突的解决</p>\n<ul>\n<li>第一步：编辑文件，删除特殊符号</li>\n<li>第二步：把文件修改到满意的程度，保存退出</li>\n<li>第三步：git add[文件名]</li>\n<li>第四步：git commit -m “日志信息”<ul>\n<li>注意：此时commit 一定不能带具体文件名</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"四、Git基本原理\"><a href=\"#四、Git基本原理\" class=\"headerlink\" title=\"四、Git基本原理\"></a>四、Git基本原理</h1><ol>\n<li><p>Hash</p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003934.png\" alt=\"/images/image-20220202184334597\"></p>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003941.png\" alt=\"/images/image-20220202184638546\"></p>\n</li>\n</ol>\n<p>2.创建分支—&gt;创建指针；</p>\n<p>切换分支—&gt;切换指针；</p>\n<h1 id=\"五、Github\"><a href=\"#五、Github\" class=\"headerlink\" title=\"五、Github\"></a>五、Github</h1><ol>\n<li><p>首先创建一个Github账号，然后创建一个repository。复制这个仓库对应的地址，然后在本地添加一下这个地址（这样就不用每次都写它了）</p>\n<ul>\n<li>这里初始化仓库 <code>git init</code></li>\n<li>添加远程仓库，&#96;之后可以使用别名origin指代该仓库</li>\n</ul>\n<p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003953.png\" alt=\"/images/image-20220202192116825\"></p>\n<ul>\n<li>向该仓库推送  <code>git push origin master</code> 格式：git push 仓库地址（名） 分支名</li>\n</ul>\n</li>\n</ol>\n<p><code>git remote add  地址别名  地址</code></p>\n<p><code>git push 地址别名  分支名</code></p>\n</li>\n<li><p>克隆</p>\n<ul>\n<li>直接使用命令<code>git  clone [远程地址]</code></li>\n<li>效果<ul>\n<li>完整地把远程库下载到本地</li>\n<li>创建origin远程地址别名</li>\n<li>初始化本地库</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拉取</p>\n<ul>\n<li>pull &#x3D; fetch+merge</li>\n<li>git fetch 【远程库地址别名】【远程分支名】</li>\n<li>git merge 【远程库地址别名&#x2F;远程分支名】</li>\n<li>git pull 【远程库地址别名】【远程分支名】</li>\n</ul>\n<p>如果没冲突，就直接从远程pull；如果不确定，可以先fetch下来看看，再决定merge</p>\n</li>\n<li><p>协同开发时冲突的解决</p>\n<ul>\n<li>要点<ul>\n<li>如果不是基于Github远程库的最新版所作的修改，不能推送，必须先拉取。</li>\n<li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>跨团队协作</p>\n</li>\n</ol>\n<ul>\n<li>Fork</li>\n<li>pull requestes</li>\n</ul>\n<ol start=\"6\">\n<li><p>Eclipse 中Git使用 </p>\n<p>介绍了在Eclipse使用Git 。 应该pycharm或者VSCode也可以？</p>\n</li>\n</ol>\n<h1 id=\"六、Git工作流\"><a href=\"#六、Git工作流\" class=\"headerlink\" title=\"六、Git工作流\"></a>六、Git工作流</h1><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003050.png\" alt=\"/images/image-20220202210632324\"></p>\n<p>这里安装Gitlab为啥？？？？</p>\n<h1 id=\"七、Gitee\"><a href=\"#七、Gitee\" class=\"headerlink\" title=\"七、Gitee\"></a>七、Gitee</h1><p><img data-src=\"https://gitee.com/meng-xuemeng/git-and---github-notes/raw/master/img/20220203003051.png\" alt=\"/images/image-20220203000544636\"></p>\n","categories":["git"],"tags":["git","github"]},{"title":"jQuery","url":"/2023/01/02/jQuery%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8/","content":"<h1 id=\"jQuery基本概念\"><a href=\"#jQuery基本概念\" class=\"headerlink\" title=\"jQuery基本概念\"></a>jQuery基本概念</h1><blockquote>\n<p>学习目标：学会如何使用jQuery，掌握jQuery的常用api，能够使用jQuery实现常见的效果。</p>\n</blockquote>\n<h6 id=\"为什么要学习jQuery？\"><a href=\"#为什么要学习jQuery？\" class=\"headerlink\" title=\"为什么要学习jQuery？\"></a>为什么要学习jQuery？</h6><p>【01-让div显示与设置内容.html】</p>\n<p>使用javascript开发过程中，有许多的缺点：</p>\n<pre><code class=\"javascript\">1. 查找元素的方法太少，麻烦。\n2. 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。\n3. 有兼容性问题。\n4. 想要实现简单的动画效果，也很麻烦\n5. 代码冗余。\n</code></pre>\n<h6 id=\"jQuery初体验\"><a href=\"#jQuery初体验\" class=\"headerlink\" title=\"jQuery初体验\"></a>jQuery初体验</h6><p>优点总结：</p>\n<pre><code class=\"javascript\">1. 查找元素的方法多种多样，非常灵活\n2. 拥有隐式迭代特性，因此不再需要手写for循环了。\n3. 完全没有兼容性问题。\n4. 实现动画非常简单，而且功能更加的强大。\n5. 代码简单、粗暴。\n</code></pre>\n<h6 id=\"什么是jQuery\"><a href=\"#什么是jQuery\" class=\"headerlink\" title=\"什么是jQuery?\"></a>什么是jQuery?</h6><blockquote>\n<p>jQuery的官网 <span class=\"exturl\" data-url=\"aHR0cDovL2pxdWVyeS5jb20v\">http://jquery.com/</span><br>jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。</p>\n</blockquote>\n<p>js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js）</p>\n<p>我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。</p>\n<h6 id=\"jQuery的版本\"><a href=\"#jQuery的版本\" class=\"headerlink\" title=\"jQuery的版本\"></a>jQuery的版本</h6><blockquote>\n<p>官网下载地址：<span class=\"exturl\" data-url=\"aHR0cDovL2pxdWVyeS5jb20vZG93bmxvYWQv\">http://jquery.com/download/</span><br>jQuery版本有很多，分为1.x 2.x 3.x</p>\n</blockquote>\n<h6 id=\"jQuery的入口函数\"><a href=\"#jQuery的入口函数\" class=\"headerlink\" title=\"jQuery的入口函数\"></a>jQuery的入口函数</h6><p>使用jQuery的三个步骤：</p>\n<pre><code class=\"javascript\">1. 引入jQuery文件\n2. 入口函数\n3. 功能实现\n</code></pre>\n<p>关于jQuery的入口函数：</p>\n<pre><code class=\"javascript\">//第一种写法\n$(document).ready(function() &#123;\n    \n&#125;);\n//第二种写法\n$(function() &#123;\n    \n&#125;);\n</code></pre>\n<p>jQuery入口函数与js入口函数的对比</p>\n<pre><code class=\"javascript\">1.\tJavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。\n2.\tjQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。\n</code></pre>\n<h6 id=\"jQuery对象与DOM对象的区别（重点）\"><a href=\"#jQuery对象与DOM对象的区别（重点）\" class=\"headerlink\" title=\"jQuery对象与DOM对象的区别（重点）\"></a>jQuery对象与DOM对象的区别（重点）</h6><pre><code class=\"javascript\">1. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。\n2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。\n3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））\n4. DOM对象与jQuery对象的方法不能混用。\n</code></pre>\n<p>DOM对象转换成jQuery对象：【联想记忆：花钱】</p>\n<pre><code class=\"javascript\">var $obj = $(domObj);\n// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象\n</code></pre>\n<p>jQuery对象转换成DOM对象：</p>\n<pre><code class=\"javascript\">var $li = $(“li”);\n//第一种方法（推荐使用）\n$li[0]\n//第二种方法\n$li.get(0)\n</code></pre>\n<h1 id=\"jQuery框架应用\"><a href=\"#jQuery框架应用\" class=\"headerlink\" title=\"jQuery框架应用\"></a>jQuery框架应用</h1><p>jQuery是一个快速的、简洁的JavaScript框架（库），它的宗旨“ write less Do more ” 即写更少的代码做更多的事情，它会封装很多JavaScript中常用的功能代码，提供了一个简洁的JS设计模式</p>\n<ul>\n<li>优化HTML文档操作（优化DOM操作）</li>\n<li>事件处理</li>\n<li>动画设计（动画存在bug）</li>\n<li>Ajax</li>\n</ul>\n<p>要使用JQ我们需要引入对应的库文件做支持</p>\n<pre><code class=\"html\">&lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<h2 id=\"jQuery基础语法\"><a href=\"#jQuery基础语法\" class=\"headerlink\" title=\"jQuery基础语法\"></a>jQuery基础语法</h2><p>由三个部分组成</p>\n<p>1、启动符：$ ，如果该符号在语言中已经作为关键字或者预留字使用，可以替换成 jQuery</p>\n<p>2、选择器【用来选择需要操作的JQ元素】</p>\n<p>3、方法【对元素进行操作】</p>\n<h2 id=\"jQuery选择器\"><a href=\"#jQuery选择器\" class=\"headerlink\" title=\"jQuery选择器\"></a>jQuery选择器</h2><pre><code class=\"javascript\">$(&quot;h1&quot;)   //document.querySelectorAll()\n$(&quot;.tit&quot;)\n</code></pre>\n<h3 id=\"什么是jQuery选择器\"><a href=\"#什么是jQuery选择器\" class=\"headerlink\" title=\"什么是jQuery选择器\"></a>什么是jQuery选择器</h3><p>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。</p>\n<p>jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】</p>\n<p>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。</p>\n<h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><p>选择器选取到的是一个jQuery对象</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID选择器</td>\n<td>$(“#id”);</td>\n<td align=\"left\">获取指定ID的元素</td>\n</tr>\n<tr>\n<td>类选择器</td>\n<td>$(“.class”);</td>\n<td align=\"left\">获取同一类class的元素</td>\n</tr>\n<tr>\n<td>标签选择器</td>\n<td>$(“div”);</td>\n<td align=\"left\">获取同一类标签的所有元素</td>\n</tr>\n<tr>\n<td>并集选择器</td>\n<td>$(“div,p,li”);</td>\n<td align=\"left\">使用逗号分隔，只要符合条件之一就可。</td>\n</tr>\n<tr>\n<td>交集选择器</td>\n<td>$(“div.redClass”);</td>\n<td align=\"left\">获取class为redClass的div元素</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>总结：跟css的选择器用法一模一样。</p>\n</blockquote>\n<h3 id=\"层级选择器\"><a href=\"#层级选择器\" class=\"headerlink\" title=\"层级选择器\"></a>层级选择器</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>子代选择器</td>\n<td>$(“ul&gt;li”);</td>\n<td align=\"left\">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td>\n</tr>\n<tr>\n<td>后代选择器</td>\n<td>$(“ul li”);</td>\n<td align=\"left\">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>跟CSS的选择器一模一样。</p>\n</blockquote>\n<h3 id=\"过滤选择器\"><a href=\"#过滤选择器\" class=\"headerlink\" title=\"过滤选择器\"></a>过滤选择器</h3><blockquote>\n<p>这类选择器都带冒号:</p>\n<p>获取到的为数组，并且只匹配一次，成功后就停止匹配</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:eq（index）</td>\n<td>$(“li:eq(2)”).css(“color”, ”red”);</td>\n<td align=\"left\">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td>\n</tr>\n<tr>\n<td>:odd</td>\n<td>$(“li:odd”).css(“color”, ”red”);</td>\n<td align=\"left\">获取到的li元素中，选择索引号为奇数的元素</td>\n</tr>\n<tr>\n<td>:even</td>\n<td>$(“li:even”).css(“color”, ”red”);</td>\n<td align=\"left\">获取到的li元素中，选择索引号为偶数的元素</td>\n</tr>\n</tbody></table>\n<p>【案例：隔行变色】</p>\n<h3 id=\"筛选选择器-方法\"><a href=\"#筛选选择器-方法\" class=\"headerlink\" title=\"筛选选择器(方法)\"></a>筛选选择器(方法)</h3><blockquote>\n<p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>用法</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>children(selector)</td>\n<td>$(“ul”).children(“li”)</td>\n<td align=\"left\">相当于$(“ul&gt;li”)，子类选择器，可以不指明selector</td>\n</tr>\n<tr>\n<td>find(selector)</td>\n<td>$(“ul”).find(“li”);</td>\n<td align=\"left\">相当于$(“ul li”),后代选择器，必须要指明selector</td>\n</tr>\n<tr>\n<td>siblings(selector)</td>\n<td>$(“#first”).siblings(“li”);</td>\n<td align=\"left\">查找所有兄弟节点，不包括自己本身，不指定selector时会包含script标签</td>\n</tr>\n<tr>\n<td>parent()</td>\n<td>$(“#first”).parent();</td>\n<td align=\"left\">查找父亲</td>\n</tr>\n<tr>\n<td>eq(index)</td>\n<td>$(“li”).eq(2);</td>\n<td align=\"left\">相当于$(“li:eq(2)”),index从0开始</td>\n</tr>\n<tr>\n<td>next()</td>\n<td>$(“li”).next()</td>\n<td align=\"left\">找下一个兄弟，包含其内容，返回的是数组</td>\n</tr>\n<tr>\n<td>prev()</td>\n<td>$(“li”).prev()</td>\n<td align=\"left\">找上一个兄弟，包含其内容，返回的是数组</td>\n</tr>\n</tbody></table>\n<pre><code class=\"javascript\">【案例：下拉菜单】this+children+mouseenter+mouseleave\n【案例：突出展示】siblings+find\n【案例：手风琴】next+parent\n【案例：淘宝精品】index+eq\n</code></pre>\n<h2 id=\"jQuery事件\"><a href=\"#jQuery事件\" class=\"headerlink\" title=\"jQuery事件\"></a>jQuery事件</h2><p>jQuery事件是把DOM当中常用的事件进行了一个封装，成了一个方法来调用</p>\n<pre><code class=\"javascript\">$(&quot;.tit&quot;).click(function()&#123;\n    //回调函数就是当你的事件触发的时候要执行的事情\n&#125;)\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>鼠标事件</th>\n<th>键盘事件</th>\n<th>表单事件</th>\n<th>文档&#x2F;窗口事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>click</td>\n<td>keypress</td>\n<td>submit</td>\n<td>load（窗口）</td>\n</tr>\n<tr>\n<td>dblclick</td>\n<td>keydown</td>\n<td>change</td>\n<td>resize（窗口）</td>\n</tr>\n<tr>\n<td>mouseenter</td>\n<td>keyup</td>\n<td>focus</td>\n<td>scroll（窗口）</td>\n</tr>\n<tr>\n<td>mouseleave</td>\n<td></td>\n<td>blur</td>\n<td>unload（窗口）</td>\n</tr>\n<tr>\n<td>hover</td>\n<td></td>\n<td></td>\n<td>ready（文档）</td>\n</tr>\n</tbody></table>\n<p>对于不常用的事件，jQ提供了一个on方法来实现绑定</p>\n<pre><code class=\"javascript\">$(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;呵呵呵呵&quot;)\n&#125;)\n</code></pre>\n<h2 id=\"jQuery事件委托\"><a href=\"#jQuery事件委托\" class=\"headerlink\" title=\"jQuery事件委托\"></a>jQuery事件委托</h2><p>jQuery事件委托通过on方法实现</p>\n<pre><code class=\"html\">&lt;ul class=&quot;ul1&quot;&gt;\n    &lt;li&gt;1&lt;/li&gt;\n    &lt;li class=&quot;active&quot;&gt;2&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n    &lt;li&gt;4&lt;/li&gt;\n    &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n    $(&quot;.ul1&quot;).on(&quot;click&quot;,&quot;li.active&quot;,function()&#123;\n        console.log(new Date());\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"jQuery事件移除\"><a href=\"#jQuery事件移除\" class=\"headerlink\" title=\"jQuery事件移除\"></a>jQuery事件移除</h2><p>jQuery使用off方法</p>\n<pre><code class=\"javascript\">$(&quot;css选择器&quot;).off(&quot;事件类型&quot;,函数名)\n//如果没有写函数名，就移除所有\n</code></pre>\n<h2 id=\"jQuery单次事件\"><a href=\"#jQuery单次事件\" class=\"headerlink\" title=\"jQuery单次事件\"></a>jQuery单次事件</h2><pre><code class=\"javascript\">//原生写法\ndocument.querySelector(&quot;#btn&quot;).addEventListener(&quot;click&quot;,function()&#123;\n    console.log(&quot;我被点了&quot;);\n    document.querySelector(&quot;#btn&quot;).removeEventListener(&quot;click&quot;,arguments.callee)\n&#125;)\n\n//jQ写法\n$(&quot;#btn&quot;).one(&quot;click&quot;,function()&#123;\n    console.log(&quot;我被点了&quot;)\n&#125;)\n</code></pre>\n<h2 id=\"jQuery动画方法\"><a href=\"#jQuery动画方法\" class=\"headerlink\" title=\"jQuery动画方法\"></a>jQuery动画方法</h2><p>1、show() &#x2F; hide() &#x2F; toggle() 执行元素的显示隐藏</p>\n<blockquote>\n<p>注意：toggle方法有版本兼容的问题，如果要使用toggle简易采用1.7.2一下的版本</p>\n</blockquote>\n<p>2、slideUp() &#x2F; slideDown() &#x2F; slideToggle() 元素执行上下滑动</p>\n<p>3、fadeIn() &#x2F; fadeOut() &#x2F; fadeTo(speed,opacity) &#x2F; fadeToggle()  渐隐渐显</p>\n<p>4、animate() 自定义动画方法</p>\n<pre><code class=\"javascript\">$(&quot;.switch&quot;).click(function()&#123;\n    $(&quot;.box&quot;).animate(&#123;\n        &quot;width&quot;:&quot;500px&quot;,\n        &quot;height&quot;:&quot;500px&quot;\n    &#125;,2000,function()&#123;\n        console.log(&quot;我完了&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<h2 id=\"jQuery-css方法（1）\"><a href=\"#jQuery-css方法（1）\" class=\"headerlink\" title=\"jQuery css方法（1）\"></a>jQuery css方法（1）</h2><p>1、addClass() 在选中的元素上添加一个类</p>\n<p>2、removeClass() 在选中的元素上删除一个类</p>\n<p>3、toggleClass（） 在选中的元素上替换一个类</p>\n<p>4、css() 这个方法可以在获取的元素中任意添加或者获取样式</p>\n<h4 id=\"获取样式\"><a href=\"#获取样式\" class=\"headerlink\" title=\"获取样式\"></a>获取样式</h4><pre><code class=\"javascript\">var a = $(&quot;.box&quot;).css(&quot;width&quot;);\n</code></pre>\n<h4 id=\"设置样式（hover时传入两个函数，移入移出事件）\"><a href=\"#设置样式（hover时传入两个函数，移入移出事件）\" class=\"headerlink\" title=\"设置样式（hover时传入两个函数，移入移出事件）\"></a>设置样式（hover时传入两个函数，移入移出事件）</h4><pre><code class=\"javascript\">\n$(&quot;.box&quot;).hover(function()&#123;\n    $(this).css(&#123;\n        width:&quot;500px&quot;,\n        height:&quot;500px&quot;\n    &#125;)\n&#125;,function()&#123;\n    $(this).css(&#123;\n        width:&quot;300px&quot;,\n        height:&quot;300px&quot;\n    &#125;)\n&#125;)\n</code></pre>\n<h2 id=\"css操作（2）\"><a href=\"#css操作（2）\" class=\"headerlink\" title=\"css操作（2）\"></a>css操作（2）</h2><pre><code class=\"js\">//name：需要设置的样式名称\n//value：对应的样式值\ncss(name, value);\n//使用案例\n$(&quot;#one&quot;).css(&quot;background&quot;,&quot;gray&quot;);//将背景色修改为灰色\n\n//参数是一个对象，对象中包含了需要设置的样式名和样式值\ncss(obj);\n//使用案例\n$(&quot;#one&quot;).css(&#123;\n    &quot;background&quot;:&quot;gray&quot;,\n    &quot;width&quot;:&quot;400px&quot;,\n    &quot;height&quot;:&quot;200px&quot;\n&#125;);\n\n//name:需要获取的样式名称\ncss(name);\n//案例\n$(&quot;div&quot;).css(&quot;background-color&quot;);\n</code></pre>\n<p>注意：获取样式操作只会返回第一个元素对应的样式值。<br>隐式迭代：<br>1.设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值<br>2.获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</p>\n<h2 id=\"class操作（2）\"><a href=\"#class操作（2）\" class=\"headerlink\" title=\"class操作（2）\"></a>class操作（2）</h2><pre><code class=\"javascript\">//name：需要添加的样式类名，注意参数不要带点.\naddClass(name);\n//例子,给所有的div添加one的样式。\n$(“div”).addClass(“one”);\n\n//name:需要移除的样式类名\nremoveClass(“name”);\n//例子，移除div中one的样式类名\n$(“div”).removeClass(“one”);\n\n//name:用于判断的样式类名，返回值为true false\nhasClass(name)\n//例子，判断第一个div是否有one的样式类\n$(“div”).hasClass(“one”);\n\n//name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。\ntoggleClass(name);\n//例子\n$(“div”).toggleClass(“one”);\n</code></pre>\n<p>、、、<br>mouseenter<br>$(“li”).mouseenter(function(){<br>    &#x2F;&#x2F;this:为当前的都dom对象， $(this)转换为jquery对象</p>\n<pre><code class=\"javascript\">console.log($(this).text());\n</code></pre>\n<h3 id=\"jQuery属性方法\"><a href=\"#jQuery属性方法\" class=\"headerlink\" title=\"jQuery属性方法\"></a>jQuery属性方法</h3><p>1、html() 等价原生DOM中的innerHTML属性</p>\n<pre><code class=\"javascript\">$(&quot;.box&quot;).html(&quot;&lt;h1&gt;哈哈&lt;/h1&gt;&quot;)  //传参表示赋值\n$(&quot;.box&quot;).html()   //取值\n</code></pre>\n<p>2、text() 等价原生DOM中的innerText属性</p>\n<p>3、val() 对表单的value属性进行操作</p>\n<blockquote>\n<p>以上三个传参就是赋值，不传参就是取值</p>\n</blockquote>\n<p>4、attr()  操作标签属性</p>\n<pre><code class=\"javascript\">$(&quot;input&quot;).attr(&quot;type&quot;);\n$(&quot;input&quot;).attr(&quot;type&quot;,&quot;password&quot;)   //注意低版本无法设置type属性\n</code></pre>\n<p>5、removeAttr() 移除一个属性</p>\n<p>6、prop() 对标签的单属性进行操作</p>\n<pre><code class=\"javascript\">$(&quot;input&quot;).prop(&quot;checked&quot;,false)\n</code></pre>\n<h3 id=\"jQuery的尺寸方法\"><a href=\"#jQuery的尺寸方法\" class=\"headerlink\" title=\"jQuery的尺寸方法\"></a>jQuery的尺寸方法</h3><p>1、width() &#x2F; height() 获取盒子的content大小</p>\n<p>2、innerWidth() &#x2F; innerHeight()  获取盒子的content+padding的大小</p>\n<p>3、outerWidth() &#x2F; outerHeight（）获取盒子的content+padding+border的大小</p>\n<p>5、outerWidth(true) &#x2F; outerHeight（true）获取盒子的content+padding+border+margin的大小</p>\n<h1 id=\"文档就绪函数\"><a href=\"#文档就绪函数\" class=\"headerlink\" title=\"文档就绪函数\"></a>文档就绪函数</h1><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            $(&quot;#btn&quot;).click(function()&#123;\n                console.log(&quot;haha&quot;)\n            &#125;)\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>代码分析：</p>\n<p>上面的代码当中，按钮是不会有事件触发的，因为它是先绑定的事件，再加载的DOM元素，再绑定事件的时候DOM元素还没有加载出来</p>\n</blockquote>\n<p>在原生JS中window中有一个事件onload，它代表所有元素已经加载完毕才会触发，所以我们可以使用这个事件</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            window.onload = function()&#123;\n                $(&quot;#btn&quot;).click(function()&#123;\n                    console.log(&quot;haha&quot;)\n                &#125;)\n            &#125;\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>代码分析：</p>\n<p>这些写其实不太好，因为它是将所有的元素加载完毕之后才会触发，如果一个页面上所有的元素已经加载好了，但是任然有一些大图片或者一些其他外部资源没有加载好，这个时候onload是不会触发的，这个从用户体验角度来讲不太好</p>\n</blockquote>\n<p>优化一下</p>\n<pre><code class=\"javascript\">document.addEventListener(&quot;DOMContentLoaded&quot;,function()&#123;\n    $(&quot;#btn&quot;).click(function()&#123;\n        console.log(&quot;haha&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<blockquote>\n<p>代码分析：</p>\n<p>上面的写法就更优化了，把对象改成document，通过触发事件DOMContentLoaded 从而不需要等待DOM以外的东西加载好就可以触发</p>\n</blockquote>\n<p>而上面这套写法，在JQ当中有一个专门函数叫做<strong>文档就绪函数</strong></p>\n<pre><code class=\"javascript\">$(document).ready(function()&#123;\n    $(&quot;#btn&quot;).click(function()&#123;\n        console.log(&quot;haha&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<p>进一步简化</p>\n<pre><code class=\"javascript\">$(function()&#123;\n    $(&quot;#btn&quot;).click(function()&#123;\n        console.log(&quot;haha&quot;)\n    &#125;)\n&#125;)\n</code></pre>\n<h1 id=\"Ajax方法\"><a href=\"#Ajax方法\" class=\"headerlink\" title=\"Ajax方法\"></a>Ajax方法</h1><p><strong>jquery封装的Ajax方法会自动将返回的json格式数据进行序列化。</strong></p>\n<p>我们自己封装过一套ajax请求，JQ也有自己封装的</p>\n<pre><code class=\"javascript\">$.ajax(&#123;\n    async:true,               //是否异步，默认false\n    type:&quot;get&quot;,               //请求方法，默认是get\n    url:&quot;&quot;,                   //请求地址\n    dataType:&quot;json&quot;,          //返回的数据类型，如果是json则自动反序列化\n    success:function(data)&#123;   \n        //请求成功时，执行的回调，data相当于xhr对象中的response\n    &#125;,\n    error:function(err)&#123;\n        //请求失败时执行的回调，err错误信息\n    &#125;\n&#125;) \n</code></pre>\n<p>JQ自己也觉得上面的写法很麻烦，所以由简化了一下</p>\n<pre><code class=\"javascript\">$.get(url,function(data)&#123;\n\n&#125;)\n或者\n$.post(url, data, function(response) &#123;\n  // 处理响应数据\n&#125;);\n</code></pre>\n<pre><code class=\"javascript\">$.extend  === Array.prototype.abc\n</code></pre>\n<p>ajax的封装方法中有xhr对象，此对象指向自己，施一公xhr.upload.onprogress方法创建一个函数，可以生成进度条样式（通过e.loaded和e.total，函数事件中内置的属性）</p>\n<pre><code class=\"javascript\">$.extend  === Array.prototype.abc\n</code></pre>\n<h1 id=\"JQuery的其他方法\"><a href=\"#JQuery的其他方法\" class=\"headerlink\" title=\"JQuery的其他方法\"></a>JQuery的其他方法</h1><p>1、<code>each()</code> 方法</p>\n<pre><code class=\"javascript\">$(&quot;.ul1&gt;li&quot;).each(function(index,ele)&#123;\n    console.log(index,ele);\n&#125;)\n</code></pre>\n<p>选取元素之后，可以直接进行遍历，回调函数里面的第一个参数代表索引，第二个参数表单当前遍历的元素</p>\n<pre><code class=\"javascript\">var result = $(&quot;.ul1&gt;li&quot;);\n$.each(result,function(index,ele)&#123;\n    console.log(index,ele);\n&#125;)\n</code></pre>\n<p>上面的调用 <code>$.each</code> 的时候，里面的result是一个类数组，所以我们可以用这个方法来进行遍历</p>\n<p>2、<code>toArray()</code>  可以把Jquery选择操作的对象转换成一个数组</p>\n<pre><code class=\"javascript\">$(&quot;.ul1&gt;li&quot;).toArray();   //这个时候就变成了一个数组\n</code></pre>\n<p>刚刚上面的<code>toArray()</code> 是可以将JQuery的选择结果转化昵称真正的数组，但是这个结束是不是 JQuery选取的？</p>\n<p>3、<code>makeArray()</code> 可以将任何类数组转换成数组</p>\n<pre><code class=\"javascript\">var lis = document.querySeletorAll(&quot;.ul1&gt;li&quot;)    //得到是一个NodeList类型的类数组\n</code></pre>\n<p>把上面的NodeList，我们通过已经学过的方法转成数组</p>\n<p><strong>第一种</strong></p>\n<pre><code class=\"javascript\">var arr = Array.prototype.slice.call(lis);\n</code></pre>\n<p><strong>第二种</strong></p>\n<pre><code class=\"javascript\">var arr = $(lis).toArray();\n</code></pre>\n<p><strong>第三种</strong></p>\n<pre><code class=\"javascript\">var arr = $.makeArray(lis);\n</code></pre>\n<h3 id=\"JQuery的扩展\"><a href=\"#JQuery的扩展\" class=\"headerlink\" title=\"JQuery的扩展\"></a>JQuery的扩展</h3><p>on的使用</p>\n<p><strong>第一种方式</strong></p>\n<pre><code class=\"javascript\">$(&quot;#btn1&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;单击事件&quot;)\n&#125;)\n\n$(&quot;#btn1&quot;).on(&quot;mousedown&quot;,function()&#123;\n    console.log(&quot;鼠标按下事件&quot;)\n&#125;)\n\n$(&quot;#btn1&quot;).on(&quot;mouseup&quot;,function()&#123;\n    console.log(&quot;鼠标松开事件&quot;)\n&#125;)\n</code></pre>\n<p><strong>第二种写法</strong></p>\n<pre><code class=\"javascript\">$(&quot;#btn1&quot;).on(&#123;\n    click: function()&#123;\n        console.log(&quot;单击事件&quot;)\n    &#125;,\n    mousedown: function()&#123;\n        console.log(&quot;鼠标按下事件&quot;)\n    &#125;,\n    mouseup: function()&#123;\n        console.log(&quot;鼠标松开事件&quot;)\n    &#125;\n&#125;)\n</code></pre>\n<p><strong>第三种：链式语法</strong></p>\n<h3 id=\"DOM的attribute和property\"><a href=\"#DOM的attribute和property\" class=\"headerlink\" title=\"DOM的attribute和property\"></a>DOM的attribute和property</h3><p>attribute：在web前端中指的是HTML的属性</p>\n<p>property：在web前端中指的是对象的属性</p>\n<pre><code class=\"javascript\">$(&quot;#input1&quot;).attr(&quot;type&quot;);\n$(&quot;#input1&quot;).prop(&quot;checked&quot;,false);\n</code></pre>\n<h4 id=\"JQuery对象于普通DOM对象的转换\"><a href=\"#JQuery对象于普通DOM对象的转换\" class=\"headerlink\" title=\"JQuery对象于普通DOM对象的转换\"></a>JQuery对象于普通DOM对象的转换</h4><pre><code class=\"html\">&lt;body&gt;\n    &lt;button type=&quot;button&quot; id=&quot;btn1&quot;&gt;按钮&lt;/button&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    var btn1 = document.querySelector(&quot;#btn1&quot;);   //btn是一个原生的DOM对象\n\n    var btn2 = $(&quot;#btn1&quot;);    //JQuery的初始化操作对象，jQuery.fn.init\n&lt;/script&gt;\n</code></pre>\n<p>首先我们要知道一点，$(选择器)它返回的是一个JQuery对象，是一个类数组形式</p>\n<p><strong>JQuery对象转换成DOM</strong></p>\n<pre><code class=\"javascript\">btn2[0];\n$(&quot;#btn1&quot;)[0];   //这样就得到了原生的DOM对象\n//接下来就可以操作对应的原生的js方法\n</code></pre>\n<p><strong>普通DOM对象转成JQuery对象</strong></p>\n<pre><code class=\"javascript\">$(btn1);   //这样就得到了JQuery的操作对象\n//只要得到了就可以使用JQ方法进行操作\n$(btn1).text();\n</code></pre>\n<h3 id=\"JQ里面的事件对象\"><a href=\"#JQ里面的事件对象\" class=\"headerlink\" title=\"JQ里面的事件对象\"></a>JQ里面的事件对象</h3><p>JQuery的事件全部都是二级事件，并且它默认执行的是事件冒泡</p>\n<p>JQuery当中的事件对象并不是原生的事件对象，而是经过JQuery自己的封装的一个对象，正是因为它是自己封装的对象，所以JQuery事件对象肯定是与原生有一些不一样的</p>\n<p>1、JQuery的事件对象不需要做兼容性的处理，因为在框架内部就已经了处理了</p>\n<pre><code class=\"javascript\">//原生的DOM事件对象\nevent = event || window.event;\n//而JQuery里面，直接使用event就好了\n</code></pre>\n<p>2、JQuery事件对象上面的 <code>stopPropagtion()</code> 它自己封装的方法，它不是原生的事件对象的方法，所以在停止事件冒泡与取消事件传播的时候，直接调用这一个方法就行了</p>\n<pre><code class=\"javascript\">//原生DOM的事件里面，取消事件传播与冒泡\nevent.cancelBubble = true；    //IE\nevent.stopPropagtion();       //W3c\n\n//在JQuery中，直接调用方法即可\nevent.stopPropagtion();\n</code></pre>\n<p>3、JQuery事件对象里面，如果要阻止事件的默认行为也是 <code>event.preventDefault()</code> ,而在原生DOM对象里面，0级使用 <code>return false</code> 2级事件使用 <code>event.preventDefault()</code></p>\n<pre><code class=\"javascript\">//原生DOM\n//0级事件\n//在事件方法的最后添加\nreturn false\n\n//JQuery当中，直接调用\nevent.preventDefault()\n</code></pre>\n<p>4、JQuery事件里面的 <code>return false</code> 会同时停止事件冒泡与阻止事件默认行为，相当于把 <code>stopPropagtion()</code> 与 <code>preventDefault() </code>都干了</p>\n<p>5、jQuery当中的事件对象是框架自己封装的对象，如果要找原生的事件对象可以使用 <code>originalEvent</code>这个属性</p>\n<p>6、JQuery的事件对象中 <code>which</code>属性代表鼠标的键，1代表左键，2代表中键，3代表右键</p>\n<p>7、因为JQuery事件是2级事件可以实现多次监听，这样在触发的时候会同时调用所有监听的方法，这时候会形成事件链，在JQuery当中提供了一个排他的特性，它是 <code>event.stopImmediatePropagation()</code></p>\n<pre><code class=\"javascript\">$(&quot;#btn1&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;我是第一次&quot;)\n&#125;).on(&quot;click&quot;,function(event)&#123;\n    console.log(&quot;第二次&quot;);\n    event.stopImmediatePropagation();  //事件链到这里就断掉了，后面的事件方法不执行\n&#125;).on(&quot;click&quot;,function()&#123;\n    console.log(&quot;第三次&quot;);\n&#125;)\n</code></pre>\n<h4 id=\"JQuery事件委托拓展\"><a href=\"#JQuery事件委托拓展\" class=\"headerlink\" title=\"JQuery事件委托拓展\"></a>JQuery事件委托拓展</h4><p>在JQ里面事件委托和原生DOM里面实现的事件委托有点不一样</p>\n<p><strong>原生DOM里面</strong></p>\n<ul>\n<li><code>event.target</code> 代表事件的触发者</li>\n<li><code>event.currentTarget</code> 代表事件的绑定者</li>\n</ul>\n<p><strong>JQuery框架里面</strong></p>\n<ul>\n<li><code>event.target</code> 代表事件的触发者</li>\n<li><code>event.currentTarget</code> 代表事件的绑定者</li>\n<li><code>event.delegateTarget</code> 代表事件的委托者</li>\n</ul>\n<pre><code class=\"html\">&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;\n        &lt;div class=&quot;small-box&quot;&gt;\n            &lt;button type=&quot;button&quot; class=&quot;btn1&quot;&gt;按钮&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $(&quot;.box&quot;).on(&quot;click&quot;,&quot;.small-box&quot;,function()&#123;\n        console.log(&quot;我触发了事件&quot;,event);\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<p>当我们点击按钮的时候，会触发click事件，这个时候我们来分析下这个事件对象</p>\n<p>1、我们把事件绑定在了 <code>box</code> 身上，但是 <code>box</code> 又把事件委托给了 <code>small-box</code> 所以我们认为，事件现在实际上是在 <code>small-box</code> 身上</p>\n<p>2、当我们点击按钮按钮的时候，会触发按钮身上的click事件，但是按钮本身并没有事件方法需要执行，所以按钮本身并不会又任何的事情发生，但是事件传播的行为任然是会发生的，所以按钮的点击事件传播到了外面的small-box身上，正好触发了small-box身上委托的事件方法</p>\n<ul>\n<li><code>delegateTarget</code>  是 <code>div.box</code> </li>\n<li><code>currentTarget</code> 是 <code>div.small-box</code></li>\n<li><code>target</code> 是 <code>button.btn1</code></li>\n</ul>\n<p>总的来说，它的格式因该是如下</p>\n<pre><code class=\"javascript\">$(委托者).on(事件类型，事件绑定者,function()&#123;\n    //这里面可以找到真正的target触发者\n&#125;)\n</code></pre>\n<h4 id=\"JQuery-方法中的this\"><a href=\"#JQuery-方法中的this\" class=\"headerlink\" title=\"JQuery 方法中的this\"></a>JQuery 方法中的this</h4><pre><code class=\"javascript\">$(&quot;.box&quot;).on(&quot;click&quot;,&quot;.small-box&quot;,function()&#123;\n    console.log(this);          //small-box\n&#125;)\n    \n$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;\n    console.log(this);          //box\n&#125;)\n</code></pre>\n<p>JQuery里面的事件当中的this永远指向谁事件的绑定者  <code>event.currentTarget</code></p>\n<p>Jquery当中的this的一种特殊用法，它可以直接通过选择器选取以后再操作</p>\n<pre><code class=\"javascript\">$(this)   //这就相当于对当前元素选取之后再操作\n</code></pre>\n<h3 id=\"JQuery的扩展方法\"><a href=\"#JQuery的扩展方法\" class=\"headerlink\" title=\"JQuery的扩展方法\"></a>JQuery的扩展方法</h3><p>在JQuery当中，它为我们提供了很多的方法，同时也可以让我们自己来实现自定义的方法，这些自定义的方法，我们叫做jQuery的扩展方法</p>\n<p>jQuery的扩展方法有两种形式存在</p>\n<p>1、<code>$.extend()</code> ，这种情况直接在 $ 对象身上扩展方法</p>\n<p>2、<code>$.fn.extend()</code> ，这种情况是在JQuery选取的元素上面扩展方法</p>\n<pre><code class=\"html\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $.extend(&#123;\n        aaa:function()&#123;\n            console.log(&quot;我是JQuery对象上面扩展的aaa方法&quot;);\n        &#125;\n    &#125;)\n\n    $.aaa();\n\n    $.fn.extend(&#123;\n        bbb:function()&#123;\n            console.log(&quot;我是JQuery操作对象上面扩展的bbb方法&quot;)\n        &#125;\n    &#125;)\n    $(&quot;#div1&quot;).bbb();\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"JQuery扩展方法实现插件制作\"><a href=\"#JQuery扩展方法实现插件制作\" class=\"headerlink\" title=\"JQuery扩展方法实现插件制作\"></a>JQuery扩展方法实现插件制作</h4><p>index.html部分</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/context-menu-box.css&quot;&gt;\n        \n        &lt;style&gt;\n            .box&#123;\n                width:400px;\n                height:400px;\n                border:solid 1px #f00;\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=&quot;box&quot;&gt;\n            &lt;!-- &lt;ul class=&quot;context-menu-box&quot;&gt;\n                &lt;li&gt;haha&lt;/li&gt;\n                &lt;li&gt;haha&lt;/li&gt;\n                &lt;li&gt;haha&lt;/li&gt;\n            &lt;/ul&gt; --&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;script src=&quot;js/jquery-1.7.2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;js/jQuery.contextmenu.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n        var menuList = [\n            &#123;\n                text: &quot;退回&quot;,\n                click: function()&#123;\n                    console.log(&quot;你要退回么?&quot;)\n                &#125;\n            &#125;,\n            &#123;\n                text: &quot;提交&quot;,\n                click: function()&#123;\n                    console.log(&quot;你正在提交&quot;)\n                &#125;\n            &#125;,\n            &#123;\n                text: &quot;登录&quot;,\n                click: function()&#123;\n                    console.log(&quot;你在登录&quot;)\n                &#125;\n            &#125;\n        ]\n        $(&quot;.box&quot;).addContextMenu(menuList);\n    &lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<p>context-menu-box.css部分</p>\n<pre><code class=\"css\">*&#123;\n    padding:0;\n    margin:0;\n&#125;\nul,ol&#123;\n    list-style:none;\n&#125;\na&#123;\n    text-decoration: none;\n    color:#333;\n&#125;\n.context-menu-box&#123;\n    width:130px;\n    position: fixed;\n    left:0;\n    top:0;\n    background-color: #fff;\n    box-shadow:0 0 5px #000;\n    display:none;\n&#125;\n\n.context-menu-box&gt;li&#123;\n    line-height:35px;\n    border-bottom: solid 1px #ccc;\n    cursor: pointer;\n    text-align: center;\n&#125;\n.context-menu-box&gt;li:hover&#123;\n    font-weight: bold;\n&#125;\n</code></pre>\n<p>jQuery.contextmenu.js</p>\n<pre><code class=\"javascript\">(function($)&#123;\n    if(typeof $ == undefined)&#123;\n        throw new Error(&quot;jQuery is not defined&quot;);\n        return;\n    &#125;\n    $.fn.extend(&#123;\n        addContextMenu: function(menuList)&#123;\n            var menuUl = document.createElement(&quot;ul&quot;);\n            menuUl.classList.add(&quot;context-menu-box&quot;);\n            for(var i = 0;i &lt; menuList.length;i++)&#123;\n                var newli = document.createElement(&quot;li&quot;);\n                newli.innerText = menuList[i].text;\n                //判断一下是否有click事件\n                if(typeof menuList[i].click === &quot;function&quot;)&#123;\n                    $(newli).on(&quot;click&quot;,menuList[i].click);\n                &#125;\n                menuUl.appendChild(newli);\n            &#125;\n            document.body.appendChild(menuUl);\n            \n            //点击自己的时候，把自己隐藏掉\n            $(menuUl).click(function()&#123;\n                $(this).hide();\n            &#125;)\n            //绑定右键菜单事件\n            this.contextmenu(function(event)&#123;\n                event.preventDefault();\n                var x = event.clientX;\n                var y = event.clientY;\n                $(menuUl).css(&#123;\n                    left: x + &quot;px&quot;,\n                    top: y + &quot;px&quot;\n                &#125;).slideDown(&quot;fast&quot;);\n            &#125;)\n        &#125;\n    &#125;)\n&#125;)(jQuery)   \n/*\n$符号并不是jQuery独占的一个标识符，你有可以在实际的工作中\n会引入多个框架文件进行使用，有可以在其他的框架文件中也使用了$这个\n符号作为它自己的标识符使用，那么这个时候，两个框架文件之间就会\n产生冲突，jQuery在这个情况下，可以使用另外一个标识符来替代$的作用\n就是jQuery\n*/\n</code></pre>\n","categories":["jQuery"],"tags":["jQuery"]},{"title":"markdown","url":"/2023/02/10/md/","content":"<h1 id=\"diff-代码块\"><a href=\"#diff-代码块\" class=\"headerlink\" title=\"diff 代码块\"></a>diff 代码块</h1><pre><code class=\"diff\">const unique = (arr)=&gt;&#123;\n- return Array.from(new Set(arr))\n+ return [...new Set(arr)];\n&#125;\n</code></pre>\n<h1 id=\"待办-ctrl-shift-x\"><a href=\"#待办-ctrl-shift-x\" class=\"headerlink\" title=\"待办(ctrl+shift+x)\"></a>待办(ctrl+shift+x)</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> [ ]</li>\n</ul>\n<h1 id=\"折叠\"><a href=\"#折叠\" class=\"headerlink\" title=\"折叠\"></a>折叠</h1><pre><code>&lt;details&gt;\n&lt;summary&gt;展开查看规范&lt;/summary&gt;\n这是展开后的内容1\n&lt;/details&gt;\n</code></pre>\n<details> <summary>展开查看规范</summary> 这是展开后的内容1 </details>\n\n<h1 id=\"puml-画图（需要插件）\"><a href=\"#puml-画图（需要插件）\" class=\"headerlink\" title=\"puml 画图（需要插件）\"></a>puml 画图（需要插件）</h1><pre><code class=\"puml\">@startuml\ntank &lt;|-- PlayerTank\ntank &lt;|-- EnemyTank\n@enduml\n</code></pre>\n<h1 id=\"mermaid-流程图\"><a href=\"#mermaid-流程图\" class=\"headerlink\" title=\"mermaid 流程图\"></a>mermaid 流程图</h1><pre><code>sequenceDiagram\n    participant 老板L\n    participant 员工A\n\n    老板L -&gt;&gt; 员工A : “在这里我们是兄弟！”\n    老板L -x 员工A : 画个饼\n    员工A --&gt;&gt; 老板L : 怯怯地鼓掌\n</code></pre>\n<pre><code class=\"mermaid\">sequenceDiagram\n    participant 老板L\n    participant 员工A\n\n    老板L -&gt;&gt; 员工A : “在这里我们是兄弟！”\n    老板L -x 员工A : 画个饼\n    员工A --&gt;&gt; 老板L : 怯怯地鼓掌\n</code></pre>\n<pre><code class=\"mermaid\">sequenceDiagram\n    Note left of 老板L : 对脸不感兴趣\n    Note right of 老板M : 对钱不感兴趣\n    Note over 老板L,老板M : 对996感兴趣\n    loop 一天七次\n        网友 -&gt;&gt; + X宝 : 查看配送进度\n        X宝 --&gt;&gt; - 网友 : 配送中\n    end\n</code></pre>\n<pre><code class=\"mermaid\">    pie\n        title 今天晚上吃什么？\n        &quot;火锅&quot; : 8\n        &quot;外卖&quot; : 60\n        &quot;自己煮&quot; : 8\n        &quot;海底捞&quot; : 9\n        &quot;海鲜&quot; : 5\n        &quot;烧烤&quot; : 5\n        &quot;不吃&quot; : 5\n</code></pre>\n<pre><code class=\"mermaid\">graph RL\n\n        User((用户))--1.用户登录--&gt;Login(登录)\n        Login --2.查询--&gt;SERVER[服务器]\n subgraph 查询数据库\n        SERVER--3.查询数据--&gt;DB[(数据库)]\n        DB--4.返回结果--&gt;SERVER\n end\n        SERVER--5.校验数据--&gt;Condition&#123;判断&#125;\n        Condition --&gt;|校验成功| OK[登录成功]\n        Condition --&gt;|校验失败| ERR[登录失败]\n        OK--&gt;SYS[进入系统]\n\n        ERR --&gt;|返回登录页面,重新登录| Login\n</code></pre>\n<h1 id=\"flow流程图\"><a href=\"#flow流程图\" class=\"headerlink\" title=\"flow流程图\"></a>flow流程图</h1><pre><code class=\"flow\">\\```mermaid\nflowchat\nst=&gt;start: Start:&gt;http://www.google.com[blank]\ne=&gt;end:&gt;http://www.google.com\nop1=&gt;operation: My Operation\nsub1=&gt;subroutine: My Subroutine\ncond=&gt;condition: linear or polynomial :&gt;http://www.google.com\nio=&gt;inputoutput: catch something...\npara=&gt;parallel: 3 possibilities\n\nst-&gt;op1-&gt;cond\ncond(true)-&gt;io-&gt;e\ncond(false)-&gt;sub1(right)\nsub1(right)-&gt;para\npara(path1, top)-&gt;cond\npara(path2, right)-&gt;op1\npara(path3, bottom)-&gt;e\n\\```\n</code></pre>\n","categories":["markdown"],"tags":["markdown"]},{"title":"react笔记","url":"/2023/12/02/react/","content":"<h1 id=\"————————————\"><a href=\"#————————————\" class=\"headerlink\" title=\"————————————\"></a>————————————</h1><h1 id=\"react-官网笔记：\"><a href=\"#react-官网笔记：\" class=\"headerlink\" title=\"react 官网笔记：\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi95b3UtbWlnaHQtbm90LW5lZWQtYW4tZWZmZWN0\">react 官网笔记：</span></h1><h1 id=\"react-核心价值\"><a href=\"#react-核心价值\" class=\"headerlink\" title=\"react 核心价值\"></a>react 核心价值</h1><p>组件化 + 数据驱动视图<br>UI &#x3D; f( state )</p>\n<h1 id=\"react-快照-state\"><a href=\"#react-快照-state\" class=\"headerlink\" title=\"react 快照 state\"></a>react 快照 state</h1><p>state 就像每次渲染的快照，并且不会同步更新，react 中当 state 状态变化时，当前快照中是获取不到更新后的内容和状态的（因为 react 由于优化需要集中多个进行更新），此时想要操作快照更新之后的操作只能在快照更新之后添加钩子函数。</p>\n<ul>\n<li>使用 useEffect（快照更新之后自动执行钩子）</li>\n<li>类组件可以使用生命周期钩子</li>\n<li>使用条件渲染，根据条件进行不同的处理</li>\n</ul>\n<h1 id=\"组件透层级传递状态\"><a href=\"#组件透层级传递状态\" class=\"headerlink\" title=\"组件透层级传递状态\"></a>组件透层级传递状态</h1><p>使用 React 的 Context 功能，Context 让父组件可以为它下面的整个组件树提供数据，实现原理是通过发布订阅模式。</p>\n<ol>\n<li>使用 react 中 createContext 方法，创建一个 context 状态，传入状态初始值</li>\n<li>通过 react 的 useContent 方法，传入 context 名称进行状态的消费。</li>\n<li>前提是需要在需要使用到的标签外部包裹创建的 context 组件.Provider&lt;ContextName.Provider value&#x3D;{}&gt;&lt;&#x2F;ContextName.Provider&gt;</li>\n<li>这将导致在组件内部消费状态时，根据 Provider 的嵌套层级，使用最近的 Provider 的 context 内容。</li>\n</ol>\n<h1 id=\"react-状态管理\"><a href=\"#react-状态管理\" class=\"headerlink\" title=\"react 状态管理\"></a>react 状态管理</h1><h3 id=\"局部状态管理\"><a href=\"#局部状态管理\" class=\"headerlink\" title=\"局部状态管理\"></a>局部状态管理</h3><p>react 提供了两种状态管理的 hooks，useState 和 useReducer，两者使用场景为：简单的业务可以使用 useState 钩子完成即可，但是如果业务中状态繁琐，频繁使用 useState 就会导致太多状态难以阅读理解，表现和业务耦合在一起，这时使用 useReducer 更好。</p>\n<h3 id=\"全局状态管理\"><a href=\"#全局状态管理\" class=\"headerlink\" title=\"全局状态管理\"></a>全局状态管理</h3><p>react 中已经有了 useState 和 useReducer 两种状态管理方式，那为什么还要使用 redux 呢？其实只是用 useState 和 useReuder 只能实现局部的状态管理，redux 解决了：</p>\n<ul>\n<li>全局状态管理（多个组件共享状态）</li>\n<li>状态的可预测性（使得状态的变化更加清晰和易于追踪）</li>\n<li>结构化组织代码，提高可维护性</li>\n</ul>\n<h2 id=\"redux-对比-useReducer-Context\"><a href=\"#redux-对比-useReducer-Context\" class=\"headerlink\" title=\"redux 对比 useReducer+Context\"></a>redux 对比 useReducer+Context</h2><ul>\n<li>使用 useReducer 加上 Context 就可以实现一个简易的状态管理仓库了，可以使得子组件之间共享状态</li>\n<li>但是 redux 的好处在于可以集中管理状态，便于追踪</li>\n<li>此外 redux 插件可以帮助调试，redux 的分包管理使得逻辑更加清晰</li>\n</ul>\n<h1 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h1><p>useRef 返回一个普通的 javascript 对象，它和 state 一样，react 会在每次渲染之间保留 ref，但是设置 state 会重新渲染组件，更改 ref 不会。</p>\n<p>当一条信息用于渲染时，将他保存在 state 中，当一条信息用于仅仅被事件处理器需要，并且不参与渲染时，使用 ref 更加高效。</p>\n<h3 id=\"ref-和-state-差异\"><a href=\"#ref-和-state-差异\" class=\"headerlink\" title=\"ref 和 state 差异\"></a>ref 和 state 差异</h3><p><strong>useRef 是由 useState 函数进一步封装得到（只使用状态，不使用方法更新视图）：</strong></p>\n<pre><code class=\"javascript\">function useRef(initialValue) &#123;\n  const [ref, unused] = useState(&#123; current: initialValue &#125;);\n  return ref;\n&#125;\n</code></pre>\n<p>大多数情况下，建议使用 state。ref 是一种“脱围机制”，并不会经常用到它。 以下是 state 和 ref 的对比：</p>\n<table>\n<thead>\n<tr>\n<th>ref</th>\n<th>state</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>useRef(initialValue)</code>返回 <code>&#123; current: initialValue &#125;</code></td>\n<td><code>useState(initialValue)</code> 返回 state 变量的当前值和一个 state 设置函数 ( <code>[value, setValue]</code>)</td>\n</tr>\n<tr>\n<td>更改时不会触发重新渲染</td>\n<td>更改时触发重新渲染。</td>\n</tr>\n<tr>\n<td>可变 —— 你可以在渲染过程之外修改和更新 <code>current</code> 的值。</td>\n<td>“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。</td>\n</tr>\n<tr>\n<td>你不应在渲染期间读取（或写入） <code>current</code> 值。</td>\n<td>你可以随时读取 state。但是，每次渲染都有自己不变的 state <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi9zdGF0ZS1hcy1hLXNuYXBzaG90\">快照</span>。</td>\n</tr>\n</tbody></table>\n<p><strong>注意：ref 设值（同步）不同于 state 快照型设值（不同步）。</strong></p>\n<h3 id=\"ref-和-DOM\"><a href=\"#ref-和-DOM\" class=\"headerlink\" title=\"ref 和 DOM\"></a>ref 和 DOM</h3><p>ref 最常见的用法是访问 DOM 元素。比如 <code>&lt;div ref=&#123;myRef&#125;&gt;</code>，React 会将相应的 DOM 元素放入 <code>myRef.current</code> 中。当元素从 DOM 中删除时，React 会将 <code>myRef.current</code> 更新为 <code>null</code>。</p>\n<p><code>useRef</code> Hook 返回一个对象，该对象有一个名为 <code>current</code> 的属性。最初，<code>myRef.current</code> 是 <code>null</code>。当 React 为这个 <code>&lt;div&gt;</code> 创建一个 DOM 节点时，React 会把对该节点的引用放入 <code>myRef.current</code>。然后，你可以从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi9yZXNwb25kaW5nLXRvLWV2ZW50cw==\">事件处理器</span> 访问此 DOM 节点，并使用在其上定义的内置<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0VsZW1lbnQ=\">浏览器 API</span>。</p>\n<p>useRef 返回的 ref.current 中有一个 remove 方法，该方法执行后会将 ref 值为 null，这样以便于 ref 能够被垃圾回收机制进行回收。</p>\n<p><strong>注意：ref 只能使用浏览器自带的 DOM 元素上，而不能直接用在组件上（可以在组件内传递一下使用）。</strong></p>\n<h1 id=\"forwardRef\"><a href=\"#forwardRef\" class=\"headerlink\" title=\"forwardRef\"></a>forwardRef</h1><p>用于将一个组件的 <code>ref</code> 转发到该组件的子组件中。这在使用类组件或需要访问子组件的 DOM 元素时非常有用，尤其是当子组件是一个函数组件或类组件，且你希望保留对该子组件的引用时。</p>\n<h1 id=\"useImperativeHandle\"><a href=\"#useImperativeHandle\" class=\"headerlink\" title=\"useImperativeHandle\"></a>useImperativeHandle</h1><p><code>useImperativeHandle</code> 是 React 的一个钩子，它与 <code>forwardRef</code> 一起使用，用于在使用 refs 的场景中为组件提供一个<strong>可自定义的行为。</strong>当你想要在子组件中暴露给父组件一些方法或属性时，<code>useImperativeHandle</code> 就非常有用。</p>\n<p>两者可以结合使用（使用 forwardRef 转发 ref，使用 useImperativeHandle 设置 DOM 元素方法）：</p>\n<pre><code class=\"javascript\">const InputComponent = React.forwardRef((props, ref) =&gt; &#123;\n  useImperativeHandle(ref, () =&gt; (&#123;\n    focus: () =&gt; inputRef.current.focus(),\n  &#125;));\n  return &lt;input ref=&#123;inputRef&#125; &#123;...props&#125; /&gt;;\n&#125;);\n</code></pre>\n<h1 id=\"Effect-同步\"><a href=\"#Effect-同步\" class=\"headerlink\" title=\"Effect 同步\"></a>Effect 同步</h1><h3 id=\"React-中两种逻辑类型\"><a href=\"#React-中两种逻辑类型\" class=\"headerlink\" title=\"React 中两种逻辑类型\"></a>React 中两种逻辑类型</h3><ul>\n<li><strong>渲染逻辑代码</strong>，<strong>位于组件的顶层</strong>，在此处接受 props 和 state，并对他们进行转换，最终返回想在屏幕上看到的 JSX，渲染的代码必须是纯粹的，它只应该“计算”结果，而不做其他任何事情。</li>\n<li><strong>事件处理程序</strong>，<strong>是嵌套在组件内部的函数</strong>，而不仅仅是计算函数。事件处理程序可能会更新输入字段、提交 HTTP POST 请求以购买产品，或者将用户导航到另一个屏幕。事件处理程序包含由特定用户操作（例如按钮点击或键入）引起的“副作用”（它们改变了程序的状态）。</li>\n</ul>\n<h3 id=\"Effect-作用\"><a href=\"#Effect-作用\" class=\"headerlink\" title=\"Effect 作用\"></a>Effect 作用</h3><p>Effect 允许指定由渲染本身而不是特定事件引起的副作用。（利用无论是哪种交互导致组件执行渲染，effect 都会在屏幕更新后的提交阶段执行）</p>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ul>\n<li><p><strong>不要随意在你的组件中使用 Effect</strong>。记住，Effect 通常用于暂时“跳出” React 代码并与一些 <strong>外部</strong> 系统进行同步。这包括浏览器 API、第三方小部件，以及网络等等。如果你想用 Effect 仅根据其他状态调整某些状态，那么 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0LmRldi9sZWFybi95b3UtbWlnaHQtbm90LW5lZWQtYW4tZWZmZWN0\">你可能不需要 Effect</span>。</p>\n</li>\n<li><p>Effect 会在每次渲染之后执行，如下代码会造成死循环：</p>\n<pre><code>const [count,setCount] = useState();\nuseEffect(()=&gt;&#123;\n    setCount(count++);\n&#125;)\n</code></pre>\n</li>\n<li><p>useEffect 第二个参数不传代表<strong>每次渲染组件后都执行一次</strong>，传空数组代表<strong>只会在第一次挂载后执行</strong>，传依赖项代表在<strong>依赖项变化时执行。</strong></p>\n</li>\n<li><p>useEffect 依赖项中传入 ref 通常是无效的，因为 ref 相当于不使用渲染赋值的 state 状态，传递过去的 ref 引用始终相同（不随着快照的渲染而变化）。</p>\n</li>\n<li><p>某些逻辑不能放在 effect 中执行，因为 effect 的执行是和组件渲染强绑定的（例如不能在 effect 中写购买商品的逻辑，这样会导致组件以任何方式被渲染都会执行购买逻辑，这样是不对的）</p>\n</li>\n<li><p>effect 中 return 的函数会在下一次 effect 执行前被执行，常用于执行清理函数（清除定时器等）</p>\n</li>\n</ul>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li>与事件不同，Effect 是由渲染本身，而非特定交互引起的。</li>\n<li>Effect 允许你将组件与某些外部系统（第三方 API、网络等）同步。</li>\n<li>默认情况下，Effect 在每次渲染（包括初始渲染）后运行。</li>\n<li>如果 React 的所有依赖项都与上次渲染时的值相同，则将跳过本次 Effect。</li>\n<li>不能随意选择依赖项，它们是由 Effect 内部的代码决定的。</li>\n<li>空的依赖数组（<code>[]</code>）对应于组件“挂载”，即添加到屏幕上。</li>\n<li>仅在严格模式下的开发环境中，React 会挂载两次组件，以对 Effect 进行压力测试。</li>\n<li>如果 Effect 因为重新挂载而中断，那么需要实现一个清理函数。</li>\n<li>React 将在下次 Effect 运行之前以及卸载期间这两个时候调用清理函数</li>\n</ul>\n<h1 id=\"Effect-生命周期\"><a href=\"#Effect-生命周期\" class=\"headerlink\" title=\"Effect 生命周期\"></a>Effect 生命周期</h1><p>react 组件的生命周期：</p>\n<ul>\n<li>添加到屏幕（挂载）</li>\n<li>组件接收新的 props 或 state（更新）</li>\n<li>从屏幕移除（卸载）</li>\n</ul>\n<h1 id=\"effect-依赖项\"><a href=\"#effect-依赖项\" class=\"headerlink\" title=\"effect 依赖项\"></a>effect 依赖项</h1><ul>\n<li>effect 中的依赖项只能传入响应性的变量（组件 props 也是响应性的）</li>\n<li>组件 props 也是响应性的，类组件 props 变化会触发钩子重新执行，函数式组件 props 变化会重新执行</li>\n<li>组件内声明的变量可以是响应性的，每次会重新声明。</li>\n<li>effect 依赖项不能传入 ref.current，ref.current 本身不是响应性的，不会引起视图更新（ref.current 允许跟踪某些值而不触发重新渲染）</li>\n<li>effect 依赖项不能传入组件内定义的对象或者函数（由于每次定义都会改变）</li>\n<li>effect 依赖项不能传入可变值（包括全局变量），它不是响应性的。</li>\n</ul>\n<h1 id=\"自定义-Hook\"><a href=\"#自定义-Hook\" class=\"headerlink\" title=\"自定义 Hook\"></a>自定义 Hook</h1><ul>\n<li>use 开头</li>\n<li>代码检查工具会强制 use 命名公约，只有 Hook 和组件可以调用其他 Hook</li>\n<li>没有调用 Hook 的函数不需要变成 Hook（或以 use 开头）</li>\n<li>自定义 Hook 共享的是状态逻辑，而不是状态本身，对 Hook 的每一个调用完全独立于对同一个 Hook 的其他调用。</li>\n<li>当需要在多个组件之间共享 state 本身时，需要将变量提升并传递下去。</li>\n</ul>\n<h1 id=\"————————————-1\"><a href=\"#————————————-1\" class=\"headerlink\" title=\"————————————\"></a>————————————</h1><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"react-项目学习\"><a href=\"#react-项目学习\" class=\"headerlink\" title=\"react 项目学习\"></a><a href=\"\">react 项目学习</a></h1><h1 id=\"react-笔记\"><a href=\"#react-笔记\" class=\"headerlink\" title=\"react 笔记\"></a>react 笔记</h1><h1 id=\"状态管理工具\"><a href=\"#状态管理工具\" class=\"headerlink\" title=\"状态管理工具\"></a>状态管理工具</h1><h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h2><h3 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h3><p>将 store 实例进行订阅，则当 store 实例通过 dispatch 进行发布时，就触发订阅函数的执行。</p>\n<pre><code class=\"js\">  // 1. 定义reducer函数\n  // 作用: 根据不同的action对象，返回不同的新的state\n  // state: 管理的数据初始状态\n  // action: 对象 type 标记当前想要做什么样的修改\n  function reducer (state = &#123; count: 0 &#125;, action) &#123;\n    // 数据不可变：基于原始状态生成一个新的状态\n    if (action.type === &#39;INCREMENT&#39;) &#123;\n      return &#123; count: state.count + 1 &#125;\n    &#125;\n    if (action.type === &#39;DECREMENT&#39;) &#123;\n      return &#123; count: state.count - 1 &#125;\n    &#125;\n    return state\n  &#125;\n\n  // 2. 使用reducer函数生成store实例\n  const store = Redux.createStore(reducer)\n\n  // 3. 通过store实例的subscribe订阅数据变化\n  // 回调函数可以在每次state发生变化的时候自动执行\n  store.subscribe(() =&gt; &#123;\n    console.log(&#39;state变化了&#39;, store.getState())\n    document.getElementById(&#39;count&#39;).innerText = store.getState().count\n  &#125;)\n\n  // 4. 通过store实例的dispatch函数提交action更改状态\n  const inBtn = document.getElementById(&#39;increment&#39;)\n  inBtn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    // 增\n    store.dispatch(&#123;\n      type: &#39;INCREMENT&#39;\n    &#125;)\n  &#125;)\n\n  const dBtn = document.getElementById(&#39;decrement&#39;)\n  dBtn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    // 减\n    store.dispatch(&#123;\n      type: &#39;DECREMENT&#39;\n    &#125;)\n  &#125;)\n  // 5. 通过store实例的getState方法获取最新状态更新到视图中\n</code></pre>\n<h2 id=\"Mobx\"><a href=\"#Mobx\" class=\"headerlink\" title=\"Mobx\"></a>Mobx</h2><p>声明式的修改数据，类似于 Vue。</p>\n<h1 id=\"react-中-css-使用\"><a href=\"#react-中-css-使用\" class=\"headerlink\" title=\"react 中 css 使用\"></a>react 中 css 使用</h1><h3 id=\"出现问题\"><a href=\"#出现问题\" class=\"headerlink\" title=\"出现问题\"></a>出现问题</h3><p>react 组件中使用样式时，需要引入对应的 css 文件，但是如果两个 css 文件中有相同的 class 命名，这时就会造成样式冲突（相互影响）。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p><strong>CSS Module</strong></p>\n<ul>\n<li>每个 CSS 文件都当作单独的模块，命名 xxx.module.css</li>\n<li>引入时：<code>import styles from &#39;xxx.module.css&#39;</code></li>\n<li>使用时：<code>className = &#123;styles[&#39;test-style&#39;]&#125;</code></li>\n<li>这样使用后组件中对应的 class 就会被命名为组件名称和样式名称的拼接</li>\n</ul>\n<p>create-react-app 中内置了 CSS Module 功能，直接使用即可。</p>\n<h3 id=\"使用-sass\"><a href=\"#使用-sass\" class=\"headerlink\" title=\"使用 sass\"></a>使用 sass</h3><p>create-react-app 中内置了 cass 语法的支持，安装 sass 直接使用即可</p>\n<h2 id=\"CSS-in-JS\"><a href=\"#CSS-in-JS\" class=\"headerlink\" title=\"CSS-in-JS\"></a>CSS-in-JS</h2><h5 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h5><ul>\n<li>css-in-js 是一种解决方案，包含很多工具</li>\n<li>在 JS 中书写 CSS，带来极大的灵活性</li>\n<li>它和内联的 style 完全不同，也不会有内联 style 的问题</li>\n</ul>\n<h5 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h5><ul>\n<li>styled-components</li>\n<li>styled-js（ts 支持不友好）</li>\n<li>emotion</li>\n</ul>\n<h5 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h5><ul>\n<li>优点：使用 js 书写，有逻辑有变量，非常灵活</li>\n<li>缺点：JSX 和样式代码混在一起，代码较多，增加了编译成本</li>\n<li>使用场景：需要灵活变换样式</li>\n</ul>\n<h1 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h1><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><ul>\n<li>Web 系统需要多个页面</li>\n<li>多页面就需要用路由来管理</li>\n<li>PS：业务上的页面，技术上还是 react 组件</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>路由设计：网址和页面之间的关系</li>\n<li>增加页面和 Layout 模板</li>\n<li>使用<code>react-router</code>增加路由配置</li>\n</ul>\n<p>浏览器端使用<code>react-router-dom</code>工具，其中包含：</p>\n<ul>\n<li>Outlet 组件（父组件中嵌入子组件路由）</li>\n<li>Link 组件（用于路由跳转）</li>\n<li>useNavigate 钩子函数（用于路由跳转）</li>\n<li>useSearchParams 钩子函数（用于获取路由参数）</li>\n<li>useLocation 钩子函数（用于获取当前路由的信息）</li>\n</ul>\n<h1 id=\"—————\"><a href=\"#—————\" class=\"headerlink\" title=\"—————-\"></a>—————-</h1><h1 id=\"react-项目\"><a href=\"#react-项目\" class=\"headerlink\" title=\"react 项目\"></a>react 项目</h1><h1 id=\"React-核心价值\"><a href=\"#React-核心价值\" class=\"headerlink\" title=\"React 核心价值\"></a>React 核心价值</h1><p>这两个，也是所有现代前端框架的核心价值</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>什么是组件化</p>\n<ul>\n<li>拆分页面结构，易开发易维护，尤其对大型项目</li>\n<li>重复的结构，可通过组件化复用</li>\n</ul>\n<p>（画图表示）</p>\n<p>组件化并不是 React 独创的</p>\n<ul>\n<li>早年的 PHP ASP 等动态网页技术，就支持组件化</li>\n<li>HTML5 的 Web Component 也支持组件化</li>\n<li>React 正式把组件化发扬光大 （包括 ng Vue）</li>\n</ul>\n<h2 id=\"数据驱动视图\"><a href=\"#数据驱动视图\" class=\"headerlink\" title=\"数据驱动视图\"></a>数据驱动视图</h2><p>公式 <code>UI = f(state)</code> （开始可能不理解）</p>\n<p>例如，要增加一个 todo item （修改、删除，用 DOM 操作更麻烦）</p>\n<pre><code class=\"html\">&lt;ul&gt;\n  &lt;li&gt;吃饭&lt;/li&gt;\n  &lt;li&gt;睡觉&lt;/li&gt;\n&lt;/ul&gt;\n// 用 jQuery 的代码逻辑 - DOM 操作 const $li = $(&#39;\n&lt;li&gt;new todo&lt;/li&gt;\n&#39;) $ul.append($li)\n</code></pre>\n<p>用 React</p>\n<pre><code class=\"jsx\">&lt;ul&gt;\n  &#123;list.map((todo) =&gt; (\n    &lt;li&gt;&#123;todo&#125;&lt;/li&gt;\n  ))&#125;\n&lt;/ul&gt;;\n// 用 React 的代码逻辑 - JS 操作\nconst [list, setList] = useState([&quot;吃饭&quot;, &quot;睡觉&quot;]);\nsetList((l) =&gt; l.concat(&quot;new todo&quot;));\n</code></pre>\n<p>数据驱动视图的好处</p>\n<ul>\n<li>只关注业务数据，解放 DOM 操作，增加开发效率</li>\n<li>适合大型复杂的前端项目 （否则，光 DOM 操作也受不了）</li>\n</ul>\n<h1 id=\"CRA\"><a href=\"#CRA\" class=\"headerlink\" title=\"CRA\"></a>CRA</h1><p>Create React App 使用最多的脚手架，React 官方推荐</p>\n<p>官网 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmVhdGUtcmVhY3QtYXBwLmRldi8=\">https://create-react-app.dev/</span></p>\n<h2 id=\"脚手架\"><a href=\"#脚手架\" class=\"headerlink\" title=\"脚手架\"></a>脚手架</h2><p>脚手架的好处：傻瓜式操作，简单方便<br><br>如自己搭建，中间可能会出很多问题（版本问题 + 个人操作问题），可能会劝退很多人</p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p>PS：直接使用 typescript</p>\n<pre><code class=\"shell\">## 使用 npx\nnpx create-react-app my-app --template typescript\n\n## 使用 npm\nnpm init react-app my-app --template typescript\n\n## 使用 yarn\nyarn create react-app my-app --template typescript\n</code></pre>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>项目入口 <code>src/App.js</code></p>\n<p>其他文件先不管，以后再说</p>\n<h2 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h2><pre><code>npm start\n</code></pre>\n<h1 id=\"vite\"><a href=\"#vite\" class=\"headerlink\" title=\"vite\"></a>vite</h1><p>vite 是 Vue 作者发布的打包工具，启动速度快，近两年很火爆</p>\n<p>官网 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52aXRlanMuZGV2L2d1aWRlLw==\">https://cn.vitejs.dev/guide/</span></p>\n<h2 id=\"创建项目-1\"><a href=\"#创建项目-1\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><pre><code class=\"shell\">npm create vite@latest react-demo-vite --template react-ts\n\nyarn create vite react-demo-vite --template react-ts\n</code></pre>\n<p>其他创建方式，可参考官网</p>\n<h2 id=\"项目结构-1\"><a href=\"#项目结构-1\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>入口 <code>src/App.tsx</code></p>\n<p>其他文件，以后再说</p>\n<h2 id=\"启动项目-1\"><a href=\"#启动项目-1\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h2><pre><code>npm run dev\n</code></pre>\n<h1 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h1><p>高质量代码的特点</p>\n<ul>\n<li><strong>严格编码规范</strong>（靠工具、流程，而非自觉）</li>\n<li>合理、规范的注释</li>\n<li>代码合理拆分</li>\n</ul>\n<h2 id=\"两者区别\"><a href=\"#两者区别\" class=\"headerlink\" title=\"两者区别\"></a>两者区别</h2><p>eslint prettier</p>\n<ul>\n<li>eslint 编码规范，如变量未定义（语法语义）</li>\n<li>prettier 编码风格，如末尾是否用 <code>;</code></li>\n<li>eslint 也有编码风格的功能，两者可能会有冲突</li>\n</ul>\n<h2 id=\"eslint\"><a href=\"#eslint\" class=\"headerlink\" title=\"eslint\"></a>eslint</h2><p>安装插件</p>\n<pre><code class=\"shell\">npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -save-dev\n</code></pre>\n<p>初始化配置文件 <code>.eslint.js</code></p>\n<pre><code class=\"shell\">npx eslint --init    ## 然后根据引导一步一步走\n</code></pre>\n<p>解释：eslint <code>plugin</code> 与 <code>extend</code> 的区别：</p>\n<ul>\n<li><code>extend</code> 提供的是 eslint 现有规则的一系列预设</li>\n<li><code>plugin</code> 则提供了除预设之外的自定义规则，当你在 eslint 的规则里找不到合适的的时候就可以借用插件来实现了</li>\n</ul>\n<p>安装 vscode 插件 <code>eslint</code> ，此时就可以看到代码 <code>App.txs</code> 中的错误提示（如定义一个未使用的变量）</p>\n<p>在 <code>package.json</code> 中增加 scripts <code>&quot;lint&quot;: &quot; eslint &#39;src/**/*.+(js|ts|jsx|tsx)&#39; &quot;</code> <br><br>控制台运行 <code>npm run lint</code> 也可以看到错误提示。如果要自动修复，可以加 <code>--fix</code> 参数</p>\n<h2 id=\"prettier\"><a href=\"#prettier\" class=\"headerlink\" title=\"prettier\"></a>prettier</h2><pre><code>npm install prettier eslint-config-prettier eslint-plugin-prettier -save-dev\n</code></pre>\n<ul>\n<li><code>eslint-config-prettier</code> 禁用所有和 Prettier 产生<strong>冲突</strong>的规则</li>\n<li><code>eslint-plugin-prettier</code> 把 Prettier 应用到 Eslint，配合 rules <code>&quot;prettier/prettier&quot;: &quot;error&quot;</code> 实现 Eslint 提醒。</li>\n</ul>\n<p>在 eslint 配置文件的 <code>extends</code> <strong>最后</strong> 增加 <code>&#39;plugin:prettier/recommended&#39;</code></p>\n<p>安装 vscode 插件 <code>prettier</code> ，此时可以看到代码 <code>App.txs</code> 中的格式提示（如末尾是否使用 <code>;</code> ，或单引号、双引号）</p>\n<p>在 <code>package.json</code> 中增加 scripts <code>&quot;format&quot;: &quot; prettier --write &#39;src/**/*.+(js|ts|jsx|tsx)&#39; &quot;</code> <br><br>控制台运行 <code>npm run format</code> 可以修复所有的格式错误</p>\n<p>设置 vscode <code>.vscode/settings.json</code> 自动保存格式，可以在文件保存时，自动保留格式</p>\n<pre><code class=\"json\">&#123;\n  &quot;editor.codeActionsOnSave&quot;: &#123;\n    &quot;source.fixAll.eslint&quot;: true\n  &#125;\n&#125;\n</code></pre>\n<p>增加配置文件 <code>.prettierrc.js</code> 规定自己的编码格式，运行 <code>npm run format</code> 可以看到效果，保存文件也可以看到效果。<br><br>【注意】如果此处没效果，可以<strong>重启 vscode</strong> 再重试。</p>\n<hr>\n<p>一直搞不定，重启 vscode 就好了。<br>在 vscode 搜“prettier” 插件时，发现一个 “reload required” 的提示，于是就重启了</p>\n<p>CRA 创建的项目，配置文件是 <code>js</code> 格式<br>vite 创建的项目，配置文件是 <code>cjs</code> 格式</p>\n<h1 id=\"提交到-git-仓库\"><a href=\"#提交到-git-仓库\" class=\"headerlink\" title=\"提交到 git 仓库\"></a>提交到 git 仓库</h1><p>PS：git 不会从 0 讲起</p>\n<h2 id=\"选择平台\"><a href=\"#选择平台\" class=\"headerlink\" title=\"选择平台\"></a>选择平台</h2><ul>\n<li>工作中，按照公司规定，可能有内网 git 仓库</li>\n<li>正式的开源项目，需要积累 star ，可以考虑 github （但有时访问不稳定，不同网络环境不一样）</li>\n<li>个人学习项目，尽量选择国内平台，速度快</li>\n</ul>\n<p>我选择 coding.net</p>\n<h2 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h2><pre><code class=\"sh\">git remote add origin xxx\ngit push -u origin master\n</code></pre>\n<h2 id=\"husky\"><a href=\"#husky\" class=\"headerlink\" title=\"husky\"></a>husky</h2><p>git-hook</p>\n<p>安装依赖</p>\n<pre><code>npm install husky -save-dev\n</code></pre>\n<p>参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3R5cGljb2RlL2h1c2t5\">https://github.com/typicode/husky</span> 增加三个 <code>pre-commit</code> 命令</p>\n<pre><code class=\"shell\">npm run lint\nnpm run format\ngit add .\n</code></pre>\n<p>可以故意制造一个错误：定义一个未使用变量（eslint 配置文件 <code>rules</code> 增加 <code>&#39;no-unused-vars&#39;: &#39;error&#39;,</code>）<br><br>然后执行 <code>git commit</code> 试试</p>\n<h2 id=\"commit-lint\"><a href=\"#commit-lint\" class=\"headerlink\" title=\"commit-lint\"></a>commit-lint</h2><p>参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NvbnZlbnRpb25hbC1jaGFuZ2Vsb2cvY29tbWl0bGludCNnZXR0aW5nLXN0YXJ0ZWQ=\">https://github.com/conventional-changelog/commitlint#getting-started</span> 安装设置即可</p>\n<p>commit 规则查看 <code>node_modules/@commitlint/config-conventional</code> （在 <code>commitlint.config.js</code> 中有配置）</p>\n<p>尝试 <code>git commit -m &quot;test&quot;</code> 会失败，再尝试 <code>git commit -m &quot;chore: commit lint&quot;</code> 会成功</p>\n<h1 id=\"JSX-语法\"><a href=\"#JSX-语法\" class=\"headerlink\" title=\"JSX 语法\"></a>JSX 语法</h1><p>JSX - JS 语法扩展，可以在 JS 中写模板（类似 HTML 语法）<br><br>JSX 已经成为 ES 语法标准，也可用于其他框架，如 Vue3</p>\n<ul>\n<li>标签</li>\n<li>属性</li>\n<li>事件</li>\n<li>JS 表达式</li>\n<li>判断</li>\n<li>循环</li>\n</ul>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><ul>\n<li>首字母小写 - HTML tag</li>\n<li>首字母<strong>大写</strong> - 自定义组件</li>\n<li>如 <code>&lt;input/&gt;</code> 和 <code>&lt;Input/&gt;</code> 就不一样</li>\n</ul>\n<p>可以像 HTML 一样嵌套</p>\n<p>JSX 里的标签必须是闭合的，<code>&lt;input&gt;</code> <code>&lt;br&gt;</code> 这样写在 JSX 会报错（在 HTML 中不会报错），必须闭合 <code>&lt;input/&gt;</code></p>\n<p>每一段 JSX 只能有一个根节点，或者使用 <code>&lt;&gt;&lt;/&gt;</code> （ Fragment ）</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>和 HTML 属性基本一样，但有些和 JS 关键字冲突了</p>\n<ul>\n<li><code>class</code> 要改为 <code>className</code></li>\n<li><code>style</code> 要写成 JS 对象（不能是 string），key 采用<strong>驼峰写法</strong></li>\n<li><code>for</code> 要改为 <code>htmlFor</code></li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p><code>onXxx</code> 的形式</p>\n<p>注意 TS 的写法</p>\n<pre><code class=\"javascriptx\">function clickHandler(event: React.MouseEvent&lt;HTMLParagraphElement&gt;) &#123;\n  event.preventDefault();\n  console.log(&quot;clicked&quot;);\n&#125;\n\nreturn &lt;p onClick=&#123;clickHandler&#125;&gt;hello world&lt;/p&gt;;\n</code></pre>\n<p>如果要想<strong>传递参数</strong>，可以通过如下方式</p>\n<pre><code class=\"javascriptx\">function clickHandler(\n  event: React.MouseEvent&lt;HTMLParagraphElement&gt;,\n  x: string\n) &#123;\n  event.preventDefault();\n  console.log(&quot;clicked&quot;, x);\n&#125;\n\nreturn (\n  &lt;p\n    onClick=&#123;(e: React.MouseEvent&lt;HTMLParagraphElement&gt;) =&gt;\n      clickHandler(e, &quot;hello&quot;)\n    &#125;\n  &gt;\n    hello world\n  &lt;/p&gt;\n);\n</code></pre>\n<p>PS：Event handlers must be passed, <strong>not called!</strong> <code>onClick=&#123;handleClick&#125;</code>, not <code>onClick=&#123;handleClick()&#125;</code>.</p>\n<h2 id=\"JS-表达式\"><a href=\"#JS-表达式\" class=\"headerlink\" title=\"JS 表达式\"></a>JS 表达式</h2><p><code>&#123;xxx&#125;</code> 格式表示一个 JS 变量或表达式，可用于</p>\n<ul>\n<li>普通文本内容，或判断、循环</li>\n<li>属性值</li>\n<li>用于注释</li>\n</ul>\n<h2 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h2><p>JS 一般使用 <code>if...else</code> 做判断，但不能用于 JSX 的 <code>&#123;xxx&#125;</code> 中。</p>\n<p>所以，可以选择其他方式做判断</p>\n<ul>\n<li>运算符 <code>&amp;&amp;</code></li>\n<li>三元表达式 <code>a ? b : c</code></li>\n<li>用函数封装</li>\n</ul>\n<pre><code class=\"javascriptx\">const flag = true;\nreturn (\n  &lt;div&gt;\n    &#123;flag &amp;&amp; &lt;p&gt;hello&lt;/p&gt;&#125;\n    &#123;flag ? &lt;p&gt;你好&lt;/p&gt; : &lt;p&gt;再见&lt;/p&gt;&#125;\n  &lt;/div&gt;\n);\n</code></pre>\n<p>或者用函数封装</p>\n<pre><code class=\"javascript\">function Hello() &#123;\n  if (flag) return &lt;p&gt;你好&lt;/p&gt;;\n  else return &lt;p&gt;再见&lt;/p&gt;;\n&#125;\n\nreturn &lt;Hello&gt;&lt;/Hello&gt;;\n</code></pre>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>使用 <code>map</code> 做循环</p>\n<pre><code class=\"javascript\">const list = [\n  &#123; username: &quot;zhangsan&quot;, name: &quot;张三&quot; &#125;,\n  &#123; username: &quot;lisi&quot;, name: &quot;李四&quot; &#125;,\n  &#123; username: &quot;shuangyue&quot;, name: &quot;双越&quot; &#125;,\n];\n\nconst ul = (\n  &lt;ul&gt;\n    &#123;list.map((user) =&gt; &#123;\n      return &lt;li key=&#123;user.username&#125;&gt;&#123;user.name&#125;&lt;/li&gt;;\n    &#125;)&#125;\n  &lt;/ul&gt;\n);\n</code></pre>\n<p>JSX 循环必须有 <code>key</code> - 帮助 React 识别哪些元素改变了，比如被添加或删除。</p>\n<ul>\n<li>同级别 <code>key</code> 必须唯一</li>\n<li><code>key</code> 是不可改变的 —— 尽量不用 index ，要用业务 ID （也不要用随机数）</li>\n<li><code>key</code> 用于优化 VDOM diff 算法（后面再说）</li>\n</ul>\n<h2 id=\"显示-HTML-代码\"><a href=\"#显示-HTML-代码\" class=\"headerlink\" title=\"显示 HTML 代码\"></a>显示 HTML 代码</h2><p>JSX 防止注入攻击，否则用 <code>dangerouslySetInnerHTML=&#123;&#123; __html: 'xxx' &#125;&#125;</code></p>\n<h1 id=\"组件和-props\"><a href=\"#组件和-props\" class=\"headerlink\" title=\"组件和 props\"></a>组件和 props</h1><h2 id=\"React-一切皆组件\"><a href=\"#React-一切皆组件\" class=\"headerlink\" title=\"React 一切皆组件\"></a>React 一切皆组件</h2><p>React 应用是由组件组成的。组件是 UI(用户界面)的一部分，它有自己的逻辑和外观。组件可以小到一个按钮，也可以大到整个页面。</p>\n<p>组件可嵌套</p>\n<ul>\n<li>React 通过组件来构建 UI</li>\n<li>组件拆分也有利于代码组织和维护，尤其对于大型软件</li>\n<li>JSX 中，组件 tag 首字母要大写</li>\n</ul>\n<p>代码演示：从 index.tsx 开始，到 <code>&lt;App&gt;</code> 全都是组件。</p>\n<h2 id=\"组件就是一个函数\"><a href=\"#组件就是一个函数\" class=\"headerlink\" title=\"组件就是一个函数\"></a>组件就是一个函数</h2><ul>\n<li>React 之前是 class 组件</li>\n<li>现已被函数组件 FC 全面取代</li>\n<li>输入 props ，返回一段 JSX</li>\n</ul>\n<h2 id=\"实战：List-页面抽离组件\"><a href=\"#实战：List-页面抽离组件\" class=\"headerlink\" title=\"实战：List 页面抽离组件\"></a>实战：List 页面抽离组件</h2><p>代码参考 react-ts-demo 中 <code>components/QuestionCard1.tsx</code></p>\n<ul>\n<li>props 类型</li>\n<li>TS 泛型</li>\n</ul>\n<h2 id=\"进阶：type-还是-interface\"><a href=\"#进阶：type-还是-interface\" class=\"headerlink\" title=\"进阶：type 还是 interface\"></a>进阶：type 还是 interface</h2><p>都可以实现类型定义的功能 （具体代码演示），用哪个都可以</p>\n<hr>\n<p>PS：组件之间的数据传递不仅仅只有 props ，课程后面还会继续讲解其他形式。</p>\n<p>TS 语法如果一开始不熟练，就先记住当前的。随着课程深入，用多了也就熟练了。</p>\n<p>PS：函数也可以当做属性来传递</p>\n<h1 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h1><h2 id=\"让页面“动”起来\"><a href=\"#让页面“动”起来\" class=\"headerlink\" title=\"让页面“动”起来\"></a>让页面“动”起来</h2><p>例如实现一个 click 计数功能，普通变量无法实现。即：修改普通变量无法触发组件的更新 rerender</p>\n<p>通过 useState 即可实现。</p>\n<h2 id=\"state-是什么\"><a href=\"#state-是什么\" class=\"headerlink\" title=\"state 是什么\"></a>state 是什么</h2><p>State, A component’s memory —— 这个比喻非常好！</p>\n<ul>\n<li>props 父组件传递过来的信息</li>\n<li>state 组件自己内部的状态，不对外</li>\n</ul>\n<p>每次 state 变化，都会触发组件更新，从新渲染页面。</p>\n<p>代码演示，参考 react-ts-demo 中 <code>pages/StateDemo1.tsx</code></p>\n<h2 id=\"state-的特点\"><a href=\"#state-的特点\" class=\"headerlink\" title=\"state 的特点\"></a>state 的特点</h2><h3 id=\"异步更新\"><a href=\"#异步更新\" class=\"headerlink\" title=\"异步更新\"></a>异步更新</h3><p>代码演示</p>\n<p>PS：setState 传入函数，可同步更新</p>\n<h3 id=\"可能会被合并\"><a href=\"#可能会被合并\" class=\"headerlink\" title=\"可能会被合并\"></a>可能会被合并</h3><p>代码演示</p>\n<h3 id=\"不可变数据\"><a href=\"#不可变数据\" class=\"headerlink\" title=\"不可变数据\"></a>不可变数据</h3><p>state 可以是任意 JS 类型，不仅仅是值类型。<br><br>不可直接修改 state ，而要 setState 新值。</p>\n<p>代码演示</p>\n<p>PS：函数组件，每个更新函数从新执行，<strong>state 被重置，而不是被修改</strong>。state 可以理解为 readOnly</p>\n<h2 id=\"immer\"><a href=\"#immer\" class=\"headerlink\" title=\"immer\"></a>immer</h2><p>Immer 简化了不可变数据结构的处理。特别是对于 JS 语法没那么熟悉的人。</p>\n<p>代码演示，参考 react-ts-demo 中 <code>pages/ImmerDemo1.tsx</code></p>\n<h2 id=\"实战：List-页面使用-state\"><a href=\"#实战：List-页面使用-state\" class=\"headerlink\" title=\"实战：List 页面使用 state\"></a>实战：List 页面使用 state</h2><ul>\n<li>使用 state</li>\n<li>使用 immer<ul>\n<li>push</li>\n<li>修改 isPublish</li>\n</ul>\n</li>\n</ul>\n<p>代码参考 <code>pages/List2.tsx</code></p>\n<hr>\n<p>最重要的就是：不可变数据 —— 这是 React state 的核心</p>\n<h1 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h1><h2 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h2><p>函数组件：执行函数，返回 JSX</p>\n<ul>\n<li>初次渲染时</li>\n<li>state 更新时</li>\n</ul>\n<p>但有些场景需要如下功能</p>\n<ul>\n<li>当渲染完成时，做某些事情</li>\n<li>当某个 state 变化时，做某些事情</li>\n<li>如 ajax 加载数据（state 变化重新加载）</li>\n</ul>\n<p>如果只有 <code>执行函数，返回 JSX</code> 这个逻辑，无法满足上面的场景。</p>\n<p>所以需要 useEffect</p>\n<h2 id=\"组件渲染完成时\"><a href=\"#组件渲染完成时\" class=\"headerlink\" title=\"组件渲染完成时\"></a>组件渲染完成时</h2><p>代码演示：List2.tsx 使用 <code>useEffect</code> 模拟 ajax 请求</p>\n<h2 id=\"某些-state-更新时\"><a href=\"#某些-state-更新时\" class=\"headerlink\" title=\"某些 state 更新时\"></a>某些 state 更新时</h2><p>代码演示：QuestionCard 监听 <code>isPublished</code> 的更新</p>\n<h2 id=\"组件销毁时\"><a href=\"#组件销毁时\" class=\"headerlink\" title=\"组件销毁时\"></a>组件销毁时</h2><p>有创建就有销毁，有生就有死</p>\n<p>代码演示：增加 <code>isDeleted</code> 属性和 <code>delete</code> 事件，看 QuestionCard 组件的销毁</p>\n<p>【重要】如果有定时任务，或者 DOM 事件，组件销毁时一定要解绑</p>\n<h2 id=\"执行两次（销毁一次）\"><a href=\"#执行两次（销毁一次）\" class=\"headerlink\" title=\"执行两次（销毁一次）\"></a>执行两次（销毁一次）</h2><p>React18 开始，<code>useEffect</code> 在开发环境下执行两次 <br><br>模拟组件挂载、销毁、重新挂载的完整流程，及早发现后续的问题。如果只挂载一次，有可能卸载组件时有问题。<br><br>而且，实际项目中某些组件真的有可能会被挂载很多次（如重置 state），要及早模拟这种情况，避免出现重复挂载的问题（如弹窗重复、bindEvent 重复）</p>\n<p><strong>生产环境下，不会再执行两次</strong></p>\n<h1 id=\"其他-Hooks\"><a href=\"#其他-Hooks\" class=\"headerlink\" title=\"其他 Hooks\"></a>其他 Hooks</h1><h2 id=\"useRef-1\"><a href=\"#useRef-1\" class=\"headerlink\" title=\"useRef\"></a>useRef</h2><p>useRef 是基于 useState 疯转而来，区别在于没有向外暴露设置响应性数据的函数，一般用于操作 DOM 元素，也可以用来持久化缓存数据</p>\n<p>PS：useRef 也可以传入 JS 值，但更新时不会触发 rerender ，需替换为 useState</p>\n<h2 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h2><ul>\n<li>函数组件，默认，每次 state 变化都会重新执行</li>\n<li>useMemo 可以缓存某个数据，不用每次都重新生成</li>\n<li>可用于计算量比较大的数据场景</li>\n</ul>\n<p>代码参考 pages&#x2F;UseMemoAndCallback&#x2F;UseMemoDemo1.tsx</p>\n<p>注意文档中的这段话 “你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。” <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlbWVtbw==\">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</span><br><br>即，useMemo 的控制权在 React ，不一定保证每个都会缓存，但都是为了全局的性能最佳。</p>\n<h2 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h2><p>useCallback 就是 useMemo 的语法糖，和 useMemo 一样。用于缓存函数。</p>\n<h1 id=\"自定义-Hooks\"><a href=\"#自定义-Hooks\" class=\"headerlink\" title=\"自定义 Hooks\"></a>自定义 Hooks</h1><p>已学习了几个常用的内置 Hooks ，可以用于很多业务功能。</p>\n<h2 id=\"修改网页标题\"><a href=\"#修改网页标题\" class=\"headerlink\" title=\"修改网页标题\"></a>修改网页标题</h2><ul>\n<li>第一步，直接在组件内部写</li>\n<li>第二步，可以抽离一个函数</li>\n<li>第三步，可以直接抽离一个文件 src&#x2F;hooks&#x2F;useTitle.ts ，引用使用</li>\n</ul>\n<p>抽离自定义 Hook ，可用于很多组件，<strong>复用代码</strong></p>\n<h2 id=\"获取鼠标位置\"><a href=\"#获取鼠标位置\" class=\"headerlink\" title=\"获取鼠标位置\"></a>获取鼠标位置</h2><p>（刚才的没有返回值，这次有返回值）</p>\n<p>代码演示 src&#x2F;hooks&#x2F;useMousePosition.ts （直接在 App.tsx 中使用）</p>\n<h2 id=\"异步获取信息\"><a href=\"#异步获取信息\" class=\"headerlink\" title=\"异步获取信息\"></a>异步获取信息</h2><p>（再来个异步的）</p>\n<p>代码演示 src&#x2F;hooks&#x2F;useGetInfo.ts （直接在 App.tsx 中使用）</p>\n<h2 id=\"小节\"><a href=\"#小节\" class=\"headerlink\" title=\"小节\"></a>小节</h2><p>自定义 Hooks 可以抽离公共逻辑，复用到多个组件中 —— 这是 Hooks 设计的初衷</p>\n<p>在 Hooks 和函数组件之前，class 组件也有一些方法：mixin HOC render-prop 等，但都没有 Hooks 来的简单。</p>\n<h1 id=\"第三方-Hooks\"><a href=\"#第三方-Hooks\" class=\"headerlink\" title=\"第三方 Hooks\"></a>第三方 Hooks</h1><p>回顾上一节的“三步”，其实还有第四步：抽离为单独的模块，发布到 npm ，供所有开发者使用。</p>\n<p>例如，之前开发的 useTitle useMousePosition ，就现成的</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9haG9va3MuanMub3JnL3poLUNOL2hvb2tzL3VzZS10aXRsZQ==\">https://ahooks.js.org/zh-CN/hooks/use-title</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9haG9va3MuanMub3JnL3poLUNOL2hvb2tzL3VzZS1tb3VzZQ==\">https://ahooks.js.org/zh-CN/hooks/use-mouse</span></li>\n</ul>\n<h2 id=\"ahooks\"><a href=\"#ahooks\" class=\"headerlink\" title=\"ahooks\"></a>ahooks</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9haG9va3MuanMub3JnL3poLUNOLw==\">https://ahooks.js.org/zh-CN/</span></p>\n<p>ahooks 是国内流行的第三方 Hooks 库</p>\n<ul>\n<li>功能全面</li>\n<li>使用简单</li>\n<li>文档 demo 清晰易懂</li>\n</ul>\n<p>后面会再次用到 ahooks ，到时候再代码演示</p>\n<h2 id=\"react-use\"><a href=\"#react-use\" class=\"headerlink\" title=\"react-use\"></a>react-use</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0cmVhbWljaC9yZWFjdC11c2U=\">https://github.com/streamich/react-use</span></p>\n<p>react-use 是国外比较流行的，功能也很前面，但是英文文档。<br><br>先做了解吧，项目中不会使用。</p>\n<h1 id=\"Hooks-使用规则\"><a href=\"#Hooks-使用规则\" class=\"headerlink\" title=\"Hooks 使用规则\"></a>Hooks 使用规则</h1><h2 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h2><p>Hook 必须 <code>useXxx</code> 格式来命名。</p>\n<p>PS：这种命名规则也很易读，简单粗暴</p>\n<h2 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h2><p>Hook 或自定义 Hook ，只能在两个地方被调用</p>\n<ul>\n<li>组件内部</li>\n<li>其他 Hook 内部</li>\n</ul>\n<p>组件外部，或一个普通函数中，不能调用 Hook</p>\n<h2 id=\"顺序一致\"><a href=\"#顺序一致\" class=\"headerlink\" title=\"顺序一致\"></a>顺序一致</h2><p>Hook 在每次渲染时都按照相同的顺序被调用。</p>\n<ul>\n<li>Hook 必须是组件“第一层代码”</li>\n<li>Hook 不可放在 if 等条件语句中 （ 或者前面有 return ，也算是条件 ）</li>\n<li>Hook 不可放在 for 等循环语句中</li>\n</ul>\n<p>代码演示</p>\n<h2 id=\"闭包陷阱\"><a href=\"#闭包陷阱\" class=\"headerlink\" title=\"闭包陷阱\"></a>闭包陷阱</h2><p>当<strong>异步函数</strong>中获取 state 时，可能不是最新的 state 值。</p>\n<p>解决方案：替换为 <code>useRef</code> —— <strong>但 ref 变化不会触发 rerender</strong> ，所以得结合 state 一起</p>\n<h1 id=\"普通-CSS\"><a href=\"#普通-CSS\" class=\"headerlink\" title=\"普通 CSS\"></a>普通 CSS</h1><h2 id=\"内联-style\"><a href=\"#内联-style\" class=\"headerlink\" title=\"内联 style\"></a>内联 style</h2><ul>\n<li>和 HTML style 一样，元素的内联样式</li>\n<li>必须是 JS 对象形式，不可以是字符串</li>\n<li>样式名称用驼峰式写法，如 <code>fontSize</code></li>\n</ul>\n<p>代码演示</p>\n<h2 id=\"className\"><a href=\"#className\" class=\"headerlink\" title=\"className\"></a>className</h2><ul>\n<li>和 HTML class 一样，设置 CSS 样式名</li>\n<li>和 JS <code>class</code> 重复，所以改名 <code>className</code></li>\n<li>可用 <code>clsx</code> 或 <code>classnames</code> 条件判断</li>\n</ul>\n<p>代码演示</p>\n<p>链接</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xhc3NuYW1lcw==\">https://www.npmjs.com/package/classnames</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xzeA==\">https://www.npmjs.com/package/clsx</span></li>\n</ul>\n<h2 id=\"尽量不用内联-style\"><a href=\"#尽量不用内联-style\" class=\"headerlink\" title=\"尽量不用内联 style\"></a>尽量不用内联 style</h2><ul>\n<li>内联 style 代码量多，性能差</li>\n<li>外链样式（用 className）代码复用，性能好</li>\n<li>这和 React 无关，在学 HTML CSS 时就知道</li>\n</ul>\n<h1 id=\"CSS-Module\"><a href=\"#CSS-Module\" class=\"headerlink\" title=\"CSS Module\"></a>CSS Module</h1><h2 id=\"普通-CSS-的问题\"><a href=\"#普通-CSS-的问题\" class=\"headerlink\" title=\"普通 CSS 的问题\"></a>普通 CSS 的问题</h2><ul>\n<li>React 使用组件化</li>\n<li>多个组件，对应多个 CSS</li>\n<li>多个 CSS 就会造成命名重复，不好管理</li>\n</ul>\n<h2 id=\"CSS-Module-1\"><a href=\"#CSS-Module-1\" class=\"headerlink\" title=\"CSS Module\"></a>CSS Module</h2><ul>\n<li>每个 CSS 都是一个独立的模块，命名 <code>xxx.module.css</code></li>\n<li>每个模块中的 className 都不一样</li>\n<li>CRA 原生支持 CSS Module</li>\n</ul>\n<p>代码演示，参考 <code>components/Button2.tsx</code></p>\n<h2 id=\"使用-Sass\"><a href=\"#使用-Sass\" class=\"headerlink\" title=\"使用 Sass\"></a>使用 Sass</h2><ul>\n<li>CSS 写法比较原始</li>\n<li>一般使用 Sass less 等预处理语言</li>\n<li>CRA 支持 Sass Module ，把后缀改为 <code>.scss</code> 即可</li>\n</ul>\n<h1 id=\"CSS-in-js\"><a href=\"#CSS-in-js\" class=\"headerlink\" title=\"CSS-in-js\"></a>CSS-in-js</h1><ul>\n<li>在 JS 中（组件代码中）写 CSS</li>\n<li>不用担心 CSS class 重名的问题</li>\n<li>CSS-in-js 是一个解决方案，并不是一个工具的名称</li>\n</ul>\n<p>PS：CSS-in-js 并不是内联 style （重要！！！），它会经过工具的编译处理，生成 CSS class 的形式。</p>\n<h2 id=\"Styled-components\"><a href=\"#Styled-components\" class=\"headerlink\" title=\"Styled-components\"></a>Styled-components</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsZWQtY29tcG9uZW50cy5jb20v\">https://styled-components.com/</span></p>\n<p>代码演示，参考 <code>components/Button3.tsx</code></p>\n<h2 id=\"Styled-jsx\"><a href=\"#Styled-jsx\" class=\"headerlink\" title=\"Styled-jsx\"></a>Styled-jsx</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zdHlsZWQtanN4I2dldHRpbmctc3RhcnRlZA==\">https://github.com/vercel/styled-jsx#getting-started</span></p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>CSS-in-js 能更灵活的支持动态样式，直接在 JS 中完成计算和样式切换。这比 css-module 更好。</p>\n<p><strong># 使用 antd</strong></p>\n<p><strong>## 安装和使用</strong></p>\n<p>参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbnQuZGVzaWduL2RvY3MvcmVhY3QvdXNlLWluLXR5cGVzY3JpcHQtY24=\">https://ant.design/docs/react/use-in-typescript-cn</span></p>\n<p>测试 Button 组件</p>\n<p><strong>## antd 组件</strong></p>\n<p>根据官网 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbnQuZGVzaWduL2NvbXBvbmVudHMvb3ZlcnZpZXctY24v\">https://ant.design/components/overview-cn/</span> 浏览一遍 antd 所有的组件，有一个了解</p>\n<h1 id=\"Tailwind-CSS\"><a href=\"#Tailwind-CSS\" class=\"headerlink\" title=\"Tailwind CSS\"></a>Tailwind CSS</h1><p>特点：把常用的 CSS 样式都细分，自己自己随意搭配。</p>\n<p>例如</p>\n<ul>\n<li>字体大小 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy9mb250LXNpemU=\">https://www.tailwindcss.cn/docs/font-size</span></li>\n<li>间距 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy9wYWRkaW5n\">https://www.tailwindcss.cn/docs/padding</span></li>\n<li>宽度 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy93aWR0aA==\">https://www.tailwindcss.cn/docs/width</span></li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"html\">&lt;h1 className=&quot;text-3xl font-bold underline&quot;&gt;Use tailwind CSS&lt;/h1&gt;\n</code></pre>\n<p>安装参考文档 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGFpbHdpbmRjc3MuY24vZG9jcy9ndWlkZXMvY3JlYXRlLXJlYWN0LWFwcA==\">https://www.tailwindcss.cn/docs/guides/create-react-app</span></p>\n<h1 id=\"普通表单组件\"><a href=\"#普通表单组件\" class=\"headerlink\" title=\"普通表单组件\"></a>普通表单组件</h1><h2 id=\"input-组件\"><a href=\"#input-组件\" class=\"headerlink\" title=\"input 组件\"></a>input 组件</h2><pre><code class=\"tsx\">import React, &#123; FC, useState, ChangeEvent &#125; from &quot;react&quot;;\n\nconst Demo: FC = () =&gt; &#123;\n  const [text, setText] = useState(&quot;&quot;);\n  function handleChange(event: ChangeEvent&lt;HTMLInputElement&gt;) &#123;\n    setText(event.target.value);\n  &#125;\n\n  return &lt;input onChange=&#123;handleChange&#125; value=&#123;text&#125; /&gt;;\n&#125;;\n</code></pre>\n<h2 id=\"受控组件-vs-非受控组件\"><a href=\"#受控组件-vs-非受控组件\" class=\"headerlink\" title=\"受控组件 vs 非受控组件\"></a>受控组件 vs 非受控组件</h2><p>受控组件</p>\n<ul>\n<li>元素的值同步到 state</li>\n<li>使用 <code>value</code> 属性</li>\n</ul>\n<p>非受控组件</p>\n<ul>\n<li>元素的值，不同步到 state</li>\n<li>使用 <code>defaultValue</code> 属性</li>\n</ul>\n<p>React 推荐使用受控组件。看似麻烦，其实让设计更简单。</p>\n<h1 id=\"表单校验\"><a href=\"#表单校验\" class=\"headerlink\" title=\"表单校验\"></a>表单校验</h1><h2 id=\"antd-Form-rules\"><a href=\"#antd-Form-rules\" class=\"headerlink\" title=\"antd Form rules\"></a>antd Form rules</h2><p>参考登录、注册页</p>\n<p>PS：选择使用 antd ，顺带了解一下两个其他的 Form 验证工具</p>\n<h2 id=\"react-hook-form\"><a href=\"#react-hook-form\" class=\"headerlink\" title=\"react-hook-form\"></a>react-hook-form</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tLw==\">https://react-hook-form.com/</span></p>\n<h2 id=\"formi\"><a href=\"#formi\" class=\"headerlink\" title=\"formi\"></a>formi</h2><p>React 官网推荐的 f</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3JtaWsub3JnL2RvY3Mvb3ZlcnZpZXc=\">https://formik.org/docs/overview</span></p>\n<h1 id=\"mock-服务\"><a href=\"#mock-服务\" class=\"headerlink\" title=\"mock 服务\"></a>mock 服务</h1><h2 id=\"Mock-js\"><a href=\"#Mock-js\" class=\"headerlink\" title=\"Mock.js\"></a>Mock.js</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL21vY2tqcy5jb20v\">http://mockjs.com/</span></p>\n<ul>\n<li>前端引入 Mock.js</li>\n<li>定义路由</li>\n<li>Mock.js 劫持 ajax 请求</li>\n</ul>\n<p>代码演示</p>\n<ul>\n<li>安装 Mock.js 和 axios</li>\n<li>定义路由，参考 <code>_mock/index.ts</code></li>\n<li>App.js 测试 ajax</li>\n</ul>\n<pre><code class=\"ts\">import &quot;./_mock/index&quot;;\nimport axios from &quot;axios&quot;;\n\nuseEffect(() =&gt; &#123;\n  // fetch(&#39;/api/test&#39;)  // 不能用 fetch\n  //   .then(res =&gt; res.json())\n  //   .then(data =&gt; console.log(data))\n\n  axios.get(&quot;/api/test&quot;).then((res) =&gt; console.log(&quot;res&quot;, res.data));\n&#125;, []);\n</code></pre>\n<p>Mock.js 的强大之处：</p>\n<ul>\n<li>前端劫持 Ajax</li>\n<li>Random 的模拟能力</li>\n</ul>\n<p>注意</p>\n<ul>\n<li>Mock.js 只能劫持 XHR ，不能劫持 fetch ，所以不要用 fetch 请求。</li>\n<li>Mock.js 要在生产环境下去掉，否则上线会有问题 —— Mock.js 体积也很大</li>\n<li>结论：不建议直接在前端使用 Mock.js</li>\n</ul>\n<h2 id=\"nodejs-搭建-Mock-服务\"><a href=\"#nodejs-搭建-Mock-服务\" class=\"headerlink\" title=\"nodejs 搭建 Mock 服务\"></a>nodejs 搭建 Mock 服务</h2><p>代码参考 question-mock</p>\n<ul>\n<li>刻意延迟 1s ，模拟真实效果</li>\n<li>使用 Mock.js 的 <code>Random</code> 功能</li>\n<li>定义写 Mock 的格式，考虑扩展性</li>\n</ul>\n<p>前端修改 <code>devServer</code> ，参考 craco.config.js</p>\n<p>扩展 webpack 配置</p>\n<ul>\n<li>使用 craco <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RpbGFueC9jcmFjbw==\">https://github.com/dilanx/craco</span></li>\n<li>可参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGluZ2ppZS50ZWNoL2FydGljbGUvMjAyMS0wMS0wNC8yNw==\">https://www.lingjie.tech/article/2021-01-04/27</span></li>\n</ul>\n<h2 id=\"在线-Mock-平台\"><a href=\"#在线-Mock-平台\" class=\"headerlink\" title=\"在线 Mock 平台\"></a>在线 Mock 平台</h2><p>不稳定，可能不维护了。有数据泄漏风险（多人使用，难免会写敏感数据）</p>\n<ul>\n<li>fast-mock</li>\n<li>y-api</li>\n<li>swagger - 尽量不推荐用国外平台（可以用做工具，但别用作服务）</li>\n</ul>\n<h1 id=\"为何使用状态管理\"><a href=\"#为何使用状态管理\" class=\"headerlink\" title=\"为何使用状态管理\"></a>为何使用状态管理</h1><h2 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h2><ul>\n<li>一个复杂页面，要拆分 UI 组件</li>\n<li>但数据保存在顶级组件</li>\n<li>通过 props 传递到下级组件</li>\n</ul>\n<p>代码演示，参考 react-ts-demo 中 <code>pages/homePageDemo/demo3.tsx</code> —— 需要抽离 <code>&lt;form&gt;</code> 为单独的组件</p>\n<p>（画图表示）</p>\n<h2 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h2><p>但如果情况再复杂，例如问卷编辑器，光通过状态提升无法满足。需要状态管理 —— 数据放在一个集中的第三方。</p>\n<p>（画图表示）</p>\n<p>React 状态管理的方式</p>\n<ul>\n<li>自带的 Context useReducer</li>\n<li>Redux</li>\n<li>Mobx</li>\n</ul>\n<h1 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h1><p>介绍</p>\n<p>- 向下级组件，跨组件传递信息</p>\n<p>- 不用像 props 层层传递</p>\n<p>- 例如：切换语言、切换主题等</p>\n<p>Context 只适合统一设置、下发某些全局变量（语言，主题等），应用场景比较单一</p>\n<h1 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h1><h2 id=\"背景-1\"><a href=\"#背景-1\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>第一，是 <code>useState</code> 的代替方案。<br/><br>当数据简单时用 <code>useState</code> ，当数据结构较为复杂时，可以考虑用 <code>useReducer</code></p>\n<p>第二，参考了 redux （马上要学）的设计，一个简化了的 redux</p>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>简单 demo <code>pages/CountReducer.tsx</code></p>\n<p>todo list demo <code>pages/TodoReducer/index.tsx</code></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>state 或 store - 存储数据</li>\n<li>action - 动作，格式如 <code>&#123; type: &#39;xxx&#39;, ... &#125;</code></li>\n<li>reducer - 根据 action 生成新 state —— <strong>不可变数据</strong></li>\n<li>dispatch - 触发 action</li>\n</ul>\n<p>PS：在 React 环境下，永远不能忘记 <code>不可变数据</code></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>需结合 useContext 跨组件通讯</p>\n<p>另，state 和 dispatch 没有模块化，数据混在一起，也不适合复杂项目。</p>\n<p>但简单项目还是可以用的。</p>\n<h1 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h1><p>Redux 是 React 最出名的状态管理工具</p>\n<h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>redux 和 useReducer 的概念一样</p>\n<ul>\n<li>state 或 store - 存储数据</li>\n<li>action - 动作，格式如 <code>&#123; type: &#39;xxx&#39;, ... &#125;</code></li>\n<li>reducer - 根据 action 生成新 state —— <strong>不可变数据</strong></li>\n<li>dispatch - 触发 action</li>\n</ul>\n<p>但 redux 和 useReducer 有很多区别</p>\n<ul>\n<li>store 可拆分模块</li>\n<li>可通过 Hook 获取 state 和 dispatch</li>\n<li>开发者工具</li>\n</ul>\n<h2 id=\"代码演示-1\"><a href=\"#代码演示-1\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>代码参考 undo-redo-demo （忽略 undo redo 功能）。分两步：</p>\n<ul>\n<li>不使用 immer</li>\n<li>使用 immer</li>\n</ul>\n<h2 id=\"开发者工具\"><a href=\"#开发者工具\" class=\"headerlink\" title=\"开发者工具\"></a>开发者工具</h2><p>Chrome redux DevTools</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvcmVkdXgtZGV2dG9vbHMvbG1oa3BtYmVrY3Bta25rbGlvZWliZmtwbW1maWJsamQ/aGw9emgtQ04=\">https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=zh-CN</span></p>\n<p>可以看到每一步 dispatch 的 state 变化，开发调试很方便</p>\n<h2 id=\"redux-单项数据流模型\"><a href=\"#redux-单项数据流模型\" class=\"headerlink\" title=\"redux 单项数据流模型\"></a>redux 单项数据流模型</h2><p>参考这里的动<img data-src=\"https://cn.redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow/\" alt=\"Image\"></p>\n<h1 id=\"Mobx-1\"><a href=\"#Mobx-1\" class=\"headerlink\" title=\"Mobx\"></a>Mobx</h1><p>Mobx 可以通过<strong>声明式</strong>的方式来修改数据。像 Vue 。<br><br>不像 React 和 redux 那样，需要用纯函数和不可变值。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>主旨 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC5tb2J4LmpzLm9yZy90aGUtZ2lzdC1vZi1tb2J4Lmh0bWw=\">https://zh.mobx.js.org/the-gist-of-mobx.html</span></p>\n<ul>\n<li>state 数据</li>\n<li>action 动作</li>\n<li>derivation 派生<ul>\n<li>computed</li>\n<li><code>observer</code> 监听变化，包裹的 React 组件</li>\n<li><code>autorun</code> 监听变化，像 watch</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码演示-2\"><a href=\"#代码演示-2\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>简单 demo - mobx-demo&#x2F;src&#x2F;BasicDemo</p>\n<p>todo-list demo - mobx-demo&#x2F;src&#x2F;TodoDemo2</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>Mobx 使用单项数据流 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC5tb2J4LmpzLm9yZy90aGUtZ2lzdC1vZi1tb2J4Lmh0bWwjJUU1JThFJTlGJUU1JTg4JTk5\">https://zh.mobx.js.org/the-gist-of-mobx.html#%E5%8E%9F%E5%88%99</span></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>v6 已经默认去掉了<strong>装饰器</strong>语法，为了大部分的兼容性 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2J4LmpzLm9yZy9pbnN0YWxsYXRpb24uaHRtbCNtb2J4LWFuZC1kZWNvcmF0b3Jz\">https://mobx.js.org/installation.html#mobx-and-decorators</span></p>\n<p>尽量使用 <code>computed</code><br><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2J4LmpzLm9yZy90aGUtZ2lzdC1vZi1tb2J4Lmh0bWw=\">https://mobx.js.org/the-gist-of-mobx.html</span><br>When starting with MobX, people tend to overuse reactions. The golden rule is, always use computed if you want to create a value based on the current state.</p>\n<p>computed 必须是纯函数。而 action 可以修改 state （如 arr.push）<br><br>computed 采用惰性求值，会缓存其输出，并且只有当其依赖的可观察对象被改变时才会重新计算。 它们在不被任何值观察时会被暂时停用。</p>\n<h1 id=\"Redux-管理用户信息\"><a href=\"#Redux-管理用户信息\" class=\"headerlink\" title=\"Redux 管理用户信息\"></a>Redux 管理用户信息</h1><h2 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h2><p>创建 src&#x2F;store&#x2F;store.ts 和 src&#x2F;store&#x2F;userReducer.ts</p>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><p>Logo 组件，根据 username 判断链接地址<br><br>新建 hooks&#x2F;useGetUserInfo.ts</p>\n<p>hooks&#x2F;useLoadUserData.ts</p>\n<ul>\n<li>使用 <code>loginReducer</code></li>\n<li>useSelect - 根据 username 判断是否已经登录</li>\n<li>UserInfo 组件，去掉 service ，改用 useGetUserInfo</li>\n</ul>\n<p>UserInfo 组件</p>\n<ul>\n<li>使用 <code>logoutReducer</code></li>\n<li>useSelect - 显示用户信息或“登录”</li>\n</ul>\n<p>新建 <code>hooks/useNavPage</code> 执行跳转逻辑，用于 MainLayout QuestionLayout</p>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"————————————–\"><a href=\"#————————————–\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"功能开发\"><a href=\"#功能开发\" class=\"headerlink\" title=\"功能开发\"></a>功能开发</h1><h1 id=\"拖拽排序\"><a href=\"#拖拽排序\" class=\"headerlink\" title=\"拖拽排序\"></a>拖拽排序</h1><h1 id=\"拖拽排序-1\"><a href=\"#拖拽排序-1\" class=\"headerlink\" title=\"拖拽排序\"></a>拖拽排序</h1><p>拖拽排序是 Web 管理系统的常见功能，React 也有相应的第三方插件供我们选择。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>分析常见的第三方插件，并且选择一个合适的。</p>\n<ul>\n<li>看 github star ，看 npm 下载量 —— （不一定最高，但要有一定的数量规模）</li>\n<li>看 github 代码更新，和 npm 发布更新</li>\n<li>看文档和 demo ，是否易读易懂 —— （当年，Vue 能在国内打开，文档占了很大功劳）</li>\n</ul>\n<h3 id=\"react-dnd\"><a href=\"#react-dnd\" class=\"headerlink\" title=\"react-dnd\"></a>react-dnd</h3><ul>\n<li>github star 多，代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQ=\">https://github.com/react-dnd/react-dnd</span></li>\n<li>npm 下载量大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtZG5k\">https://www.npmjs.com/package/react-dnd</span></li>\n<li>但，文档不易懂，学习成本高 。如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9hYm91dA==\">首页</span> 的 demo ，代码就非常复杂，不易读</li>\n</ul>\n<p>PS：examples 太复杂 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvdHJlZS9tYWluL3BhY2thZ2VzL2V4YW1wbGVzL3NyYy8wNC1zb3J0YWJsZS9zaW1wbGU=\">https://github.com/react-dnd/react-dnd/tree/main/packages/examples/src/04-sortable/simple</span></p>\n<h3 id=\"react-beautiful-dnd\"><a href=\"#react-beautiful-dnd\" class=\"headerlink\" title=\"react-beautiful-dnd\"></a>react-beautiful-dnd</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5k\">https://github.com/atlassian/react-beautiful-dnd</span></p>\n<ul>\n<li>github star 多， 代码更新不频繁了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5k\">https://github.com/atlassian/react-beautiful-dnd</span></li>\n<li>npm 下载量高 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtYmVhdXRpZnVsLWRuZA==\">https://www.npmjs.com/package/react-beautiful-dnd</span></li>\n<li>文档比较好理解，可以直接在 github 上找到 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvYWJvdXQvZXhhbXBsZXMubWQ=\">examples</span></li>\n</ul>\n<p>但，<strong>不支持 React18 严格模式</strong>（代码好久没更新了）<br><br>去掉 <code>&lt;React.StrictMode&gt;</code> 就好了。但这样就丢失了严格模式的好处 <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3Mvc3RyaWN0LW1vZGUuaHRtbA==\">https://zh-hans.reactjs.org/docs/strict-mode.html</span></p>\n<p>有解决的 lib ，但 star 太少了，不可靠 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQ=\">https://github.com/hello-pangea/dnd</span></p>\n<p>PS：暂无精力更新，看 npm 首页的描述 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtYmVhdXRpZnVsLWRuZA==\">https://www.npmjs.com/package/react-beautiful-dnd</span></p>\n<h3 id=\"Sortablejs\"><a href=\"#Sortablejs\" class=\"headerlink\" title=\"Sortablejs\"></a>Sortablejs</h3><p>老牌的 js 排序 lib ，不依赖于 React 或 Vue 。</p>\n<p>官方提供的 React 版本的下载量还可以 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NvcnRhYmxlSlMvcmVhY3Qtc29ydGFibGVqcw==\">https://github.com/SortableJS/react-sortablejs</span></p>\n<p>但它有一个提示 <code>is not considered ready for production</code> ，不推荐用于生产环境</p>\n<h3 id=\"react-sortable-hoc\"><a href=\"#react-sortable-hoc\" class=\"headerlink\" title=\"react-sortable-hoc\"></a>react-sortable-hoc</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NsYXVkZXJpYy9yZWFjdC1zb3J0YWJsZS1ob2M=\">https://github.com/clauderic/react-sortable-hoc</span></p>\n<p>star 和下载量都不错，但已不再主动维护，推荐使用 <code>dnd-kit</code></p>\n<h3 id=\"dnd-kit\"><a href=\"#dnd-kit\" class=\"headerlink\" title=\"dnd-kit\"></a>dnd-kit</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRuZGtpdC5jb20vcHJlc2V0cy9zb3J0YWJsZQ==\">https://docs.dndkit.com/presets/sortable</span></p>\n<ul>\n<li>github star 数量还可以（不算高），代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NsYXVkZXJpYy9kbmQta2l0\">https://github.com/clauderic/dnd-kit</span></li>\n<li>npm 下载量还可以（不算高）<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGRuZC1raXQvY29yZQ==\">https://www.npmjs.com/package/@dnd-kit/core</span></li>\n<li>文档和 demo 通俗移动</li>\n</ul>\n<p>代码演示，参考 dnd-kit-and-sortablejs-demo</p>\n<h2 id=\"开发-1\"><a href=\"#开发-1\" class=\"headerlink\" title=\"开发\"></a>开发</h2><ul>\n<li>抽离组件 <code>SortableContainer</code> <code>SortableItem</code> —— 图层和画布都需要拖拽排序</li>\n<li>在画布和图层使用</li>\n</ul>\n<p>之前代码的改动</p>\n<ul>\n<li>App.css 增加 <code>div[role=&quot;button&quot;] &#123; outline: 0 &#125;</code></li>\n<li>键盘快捷键，修改 <code>isActiveElementValid</code> 函数内的逻辑</li>\n</ul>\n<p>工具栏：上移&#x2F;下移</p>\n<h1 id=\"撤销重做\"><a href=\"#撤销重做\" class=\"headerlink\" title=\"撤销重做\"></a>撤销重做</h1><h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p>（先介绍 stack）</p>\n<p>两个 stack ：undo-stack redo-stack</p>\n<ul>\n<li>输入：redo-stack 清空，undo-stack 入栈</li>\n<li>undo ：undo-stack 出栈，redo-stack 入栈</li>\n<li>redo ：redo-stack 出栈，undo-stack 入栈</li>\n</ul>\n<p>画图表示<br><br>代码演示</p>\n<h2 id=\"redux-撤销重做\"><a href=\"#redux-撤销重做\" class=\"headerlink\" title=\"redux 撤销重做\"></a>redux 撤销重做</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVkdXgtdW5kbw==\">https://www.npmjs.com/package/redux-undo</span></p>\n<p>代码演示，从之前的 redux todo-list demo 上进行</p>\n<ul>\n<li>store&#x2F;store.ts</li>\n<li>pages&#x2F;TodoList.ts</li>\n</ul>\n<h2 id=\"开发-2\"><a href=\"#开发-2\" class=\"headerlink\" title=\"开发\"></a>开发</h2><ul>\n<li>src&#x2F;store&#x2F;store.ts</li>\n<li>src&#x2F;hooks&#x2F;useGetComponentInfo.ts</li>\n<li>src&#x2F;pages&#x2F;question&#x2F;Edit&#x2F;EditToolbar.tsx</li>\n</ul>\n<p>PS：看 ctrl + z 等快捷键</p>\n<h1 id=\"Chat-图表\"><a href=\"#Chat-图表\" class=\"headerlink\" title=\"Chat 图表\"></a>Chat 图表</h1><h1 id=\"chart-lib-选型\"><a href=\"#chart-lib-选型\" class=\"headerlink\" title=\"chart lib 选型\"></a>chart lib 选型</h1><p>回顾一下技术选项的三个要点，在“拖拽排序”那一节</p>\n<h2 id=\"react-chartjs-2\"><a href=\"#react-chartjs-2\" class=\"headerlink\" title=\"react-chartjs-2\"></a>react-chartjs-2</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1jaGFydGpzLTIuanMub3JnLw==\">https://react-chartjs-2.js.org/</span></p>\n<p>基于 chartjs （知名 charts lib）</p>\n<ul>\n<li>github star 还可以，代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlYWN0Y2hhcnRqcy9yZWFjdC1jaGFydGpzLTI=\">https://github.com/reactchartjs/react-chartjs-2</span></li>\n<li>npm 下载量大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtY2hhcnRqcy0y\">https://www.npmjs.com/package/react-chartjs-2</span></li>\n<li>文档和 demo 简洁易懂 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC1jaGFydGpzLTIuanMub3JnL2V4YW1wbGVz\">https://react-chartjs-2.js.org/examples</span></li>\n</ul>\n<p>作为备选观察</p>\n<h2 id=\"recharts\"><a href=\"#recharts\" class=\"headerlink\" title=\"recharts\"></a>recharts</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWNoYXJ0cy5vcmcvemgtQ04v\">https://recharts.org/zh-CN/</span></p>\n<p>基于 D3</p>\n<ul>\n<li>github star 更多，代码更新及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JlY2hhcnRzL3JlY2hhcnRz\">https://github.com/recharts/recharts</span></li>\n<li>npm 下载量大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVjaGFydHM=\">https://www.npmjs.com/package/recharts</span></li>\n<li>文档和 demo 简洁易懂 <strong>有中文文档</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWNoYXJ0cy5vcmcvemgtQ04vZXhhbXBsZXM=\">https://recharts.org/zh-CN/examples</span></li>\n</ul>\n<h2 id=\"echarts-for-react\"><a href=\"#echarts-for-react\" class=\"headerlink\" title=\"echarts-for-react\"></a>echarts-for-react</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQuaHVzdC5jYy9lY2hhcnRzLWZvci1yZWFjdC8=\">https://git.hust.cc/echarts-for-react/</span></p>\n<p>基于百度 echarts</p>\n<ul>\n<li>github star 不太多，代码更新不太及时 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2h1c3RjYy9lY2hhcnRzLWZvci1yZWFjdA==\">https://github.com/hustcc/echarts-for-react</span></li>\n<li>npm 下载量也不太大 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWNoYXJ0cy1mb3ItcmVhY3Q=\">https://www.npmjs.com/package/echarts-for-react</span></li>\n<li>文档友好，中文文档</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>最终选择了 recharts</p>\n<h1 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"————————————–-1\"><a href=\"#————————————–-1\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"React-项目性能优化\"><a href=\"#React-项目性能优化\" class=\"headerlink\" title=\"React 项目性能优化\"></a>React 项目性能优化</h1><h1 id=\"缓存数据-减少计算\"><a href=\"#缓存数据-减少计算\" class=\"headerlink\" title=\"缓存数据 减少计算\"></a>缓存数据 减少计算</h1><p>PS：React18 开发环境下，组件会渲染两次。生产环境则不会。</p>\n<h2 id=\"useState-传入函数\"><a href=\"#useState-传入函数\" class=\"headerlink\" title=\"useState 传入函数\"></a>useState 传入函数</h2><ul>\n<li>useState 传入初始化数据</li>\n<li>如传入函数，则只在组件渲染执行一次</li>\n<li>如果数据结构较复杂，可使用函数</li>\n</ul>\n<p>代码演示，参考 react-ts-demo 中 pages&#x2F;UseStateFnDemo.tsx</p>\n<h2 id=\"useMemo-缓存数据\"><a href=\"#useMemo-缓存数据\" class=\"headerlink\" title=\"useMemo 缓存数据\"></a>useMemo 缓存数据</h2><p>（之前讲过，再回顾一遍，不用代码演示了）</p>\n<ul>\n<li>函数组件，默认，每次 state 变化都会重新执行</li>\n<li>useMemo 可以缓存某个数据，不用每次都重新生成</li>\n<li>可用于计算量比较大的数据场景</li>\n</ul>\n<p>代码参考 pages&#x2F;UseMemoAndCallback&#x2F;UseMemoDemo1.tsx</p>\n<p>注意文档中的这段话 “你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。” <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlbWVtbw==\">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</span><br><br>即，useMemo 的控制权在 React ，不一定保证每个都会缓存，但都是为了全局的性能最佳。</p>\n<p>项目示例：统计页，链接和二维码的 Elem</p>\n<h2 id=\"useCallback-缓存函数\"><a href=\"#useCallback-缓存函数\" class=\"headerlink\" title=\"useCallback 缓存函数\"></a>useCallback 缓存函数</h2><p>（之前讲过，再回顾一遍，不用代码演示了）</p>\n<p>useCallback 就是 useMemo 的语法糖，和 useMemo 一样。用于缓存函数。</p>\n<p>代码参考 pages&#x2F;UseMemoAndCallback&#x2F;UseCallbackDemo1.tsx</p>\n<p>项目示例：新增组件</p>\n<h2 id=\"React-memo-缓存组件\"><a href=\"#React-memo-缓存组件\" class=\"headerlink\" title=\"React.memo 缓存组件\"></a>React.memo 缓存组件</h2><p>当 state 变化时，React 会默认渲染所有<strong>子组件</strong>，无论其 props 是否变化</p>\n<p>但如果想要控制子组件根据 props 变化来渲染，可以使用 <code>React.memo</code></p>\n<p>代码演示，可以在 pages&#x2F;homePageDemo&#x2F;Demo3.tsx <br><br>为 <code>List</code> 组件增加 <code>React.memo</code></p>\n<p>PS：注意和 <code>useMemo</code> 的区别，一开始容易搞混了</p>\n<h1 id=\"代码体积和拆分\"><a href=\"#代码体积和拆分\" class=\"headerlink\" title=\"代码体积和拆分\"></a>代码体积和拆分</h1><h2 id=\"代码体积分析\"><a href=\"#代码体积分析\" class=\"headerlink\" title=\"代码体积分析\"></a>代码体积分析</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jcmVhdGUtcmVhY3QtYXBwLmRldi9kb2NzL2FuYWx5emluZy10aGUtYnVuZGxlLXNpemUv\">https://create-react-app.dev/docs/analyzing-the-bundle-size/</span></p>\n<pre><code class=\"shell\"># build 以后，可以直接运行结果 （看控制台提示）\nyarn global add serve\n# npm install serve -g\nserve -s build\n</code></pre>\n<p>发现 main.js 体积有 <code>1.5M</code> —— 首页加载就需要 <code>1.5M</code> ，有点大，需要拆分。</p>\n<p>分析内部发现比较大的体积来自于 antd recharts react-dom dnd-kit 等。<br><br>首先想到的：拆分页面，路由懒加载，把编辑页、统计页拆分开</p>\n<h2 id=\"路由懒加载\"><a href=\"#路由懒加载\" class=\"headerlink\" title=\"路由懒加载\"></a>路由懒加载</h2><p>代码参考 src&#x2F;router&#x2F;index.ts</p>\n<p>再进行代码体积分析，发现 main.js 减小到 <code>1.0M</code> 还是很大。<br><br>但至少编辑页面、统计页面的代码都移除了。</p>\n<p>分析结果中，发现一个不符合预期的现象：**<code>@dnd-kit</code> 是拖拽排序的，应该在编辑页，不应该在 main.js**<br><br>查代码发现，在 src&#x2F;store&#x2F;componentsReducer&#x2F;index.ts 中用到了 <code>@dnd-kit/sortable</code> ，而后者用依赖于 <code>@dnd-kit/core</code><br><br>这个是否要优化掉？（把相关代码移动到编辑页面的引用） —— <strong>不值得！！！</strong></p>\n<ul>\n<li>这部分代码只占用 50kb ，最后 GZip 压缩以后大约 16kb ，体积不算大</li>\n<li>如果移动代码，将导致代码修改较多，而且可能破坏语义、可读性</li>\n<li>综合考虑成本和收益，这里保持不变</li>\n</ul>\n<p>继续：分析结果中，占比最大的是 antd 和 react-dom ，可以抽离公共代码。</p>\n<h2 id=\"抽离公共代码\"><a href=\"#抽离公共代码\" class=\"headerlink\" title=\"抽离公共代码\"></a>抽离公共代码</h2><p>PS：生成环境需要抽离。开发环境不需要抽离，否则影响打包速度。</p>\n<p>代码参考 craco.config.js ，注意两点</p>\n<ul>\n<li>必须是生成环境。开发环境不需要抽离，否则影响打包速度。</li>\n<li>设置 <code>chunks: &#39;all&#39;</code></li>\n</ul>\n<p>重新 build 以后，发现 main.js 只有 <code>35kb</code> ，react-dom antd vendors 都被拆分出去了。</p>\n<h2 id=\"合理使用缓存\"><a href=\"#合理使用缓存\" class=\"headerlink\" title=\"合理使用缓存\"></a>合理使用缓存</h2><p>运行 build 结果，发现首页依然要加载好几个 JS 文件： main.js react-dom antd vendors<br><br>它们体积的总和依然是 1M 左右，那和优化之前一样吗？ —— <strong>不一样</strong></p>\n<ul>\n<li>优化之前是一个文件，一旦有代码改动，文件变化，缓存失效</li>\n<li>优化之后拆分多个文件，代码改动只会导致 main.js 变化，其他文件都会缓存</li>\n<li>如果不频繁升级 npm 插件，其他 js 文件不会频繁变动</li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>不用做优化，css 已经被分离为 main.css antd-chunk.css edit-page.css stat-page.css</p>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>从一开始的 1.6M 到最后的 33KB ，效果明显。</p>\n<p>PS：浏览器和服务端一般都默认支持 Gzip 压缩，体积能压缩 1&#x2F;3 左右</p>\n<h1 id=\"————————————–-2\"><a href=\"#————————————–-2\" class=\"headerlink\" title=\"————————————–\"></a>————————————–</h1><h1 id=\"React-项目单元测试\"><a href=\"#React-项目单元测试\" class=\"headerlink\" title=\"React 项目单元测试\"></a>React 项目单元测试</h1><h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><p>对比</p>\n<ul>\n<li>单元测试 - 某个功能模块、函数、组件的测试 —— 开发人员</li>\n<li>系统测试 - 整个功能流程的测试 —— 专业测试人员</li>\n</ul>\n<h2 id=\"jest-入门\"><a href=\"#jest-入门\" class=\"headerlink\" title=\"jest 入门\"></a>jest 入门</h2><p>jest 是最流行的前端单元测试工具<br><br>可参考官网首页的 demo <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamVzdGpzLmNuL2RvY3MvZ2V0dGluZy1zdGFydGVk\">https://www.jestjs.cn/docs/getting-started</span></p>\n<p>react-ts-demo 代码演示</p>\n<ul>\n<li>CRA 直接安装了 jest ，可直接写</li>\n<li>utils&#x2F;math.ts 和 utils&#x2F;math.test.ts</li>\n<li>运行 <code>npm run test</code> （看 package.json <code>scripts</code>）</li>\n</ul>\n<p>测试代码文件的位置</p>\n<ul>\n<li>统一放在 <code>__tests__</code> 目录下</li>\n<li>和源文件放在一起，增加 <code>.test.ts</code> 后缀</li>\n<li>选择后者（1. 结合更密切，可读性好；2. 不容易忘，敦促及时写单元测试）</li>\n</ul>\n<p>小结</p>\n<ul>\n<li>test it 构建测试用例</li>\n<li>expect 断言 —— 很多，后面一一学习</li>\n<li>测试文件的位置</li>\n</ul>\n<h2 id=\"组件单元测试\"><a href=\"#组件单元测试\" class=\"headerlink\" title=\"组件单元测试\"></a>组件单元测试</h2><p>注意，不是所有前端代码都适合单元测试，一般只对一些核心的、功能封装独立的组件进行单元测试。</p>\n<ul>\n<li>QuestionInfo</li>\n<li>QuestionTitle</li>\n<li>QuestionParagraph</li>\n<li>QuestionInput</li>\n<li>QuestionTextarea</li>\n<li>QuestionRadio</li>\n<li>QuestionCheckbox</li>\n</ul>\n<h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><p>操作</p>\n<ul>\n<li><code>npm run test</code> 加入到 husky <code>.husky/pre-commit</code></li>\n<li>为 package.json <code>scripts</code> <code>test</code> <strong>增加 <code>--watchAll=false</code></strong> —— 重要！否则无法正常执行 commit</li>\n<li>每次 commit 会执行测试</li>\n</ul>\n<p>自动测试的价值</p>\n<ul>\n<li>每次 commit 都自动执行，测试失败，无法提交代码（不污染现有的代码）</li>\n<li>避免各种“不小心” “忘了” 的问题 —— 自动化，电脑忘不了</li>\n<li>要及时完善组件单元测试，新组件也要添加单元测试</li>\n</ul>\n<h1 id=\"storybook\"><a href=\"#storybook\" class=\"headerlink\" title=\"storybook\"></a>storybook</h1><p>组件<strong>可视化</strong>测试<br><br>或者，它可以被理解为一种文档或组件使用介绍，通过 storybook 就可以看到组件的 UI 结构、属性配置等。</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdG9yeWJvb2suanMub3JnL2RvY3MvcmVhY3QvZ2V0LXN0YXJ0ZWQvaW5zdGFsbA==\">https://storybook.js.org/docs/react/get-started/install</span></p>\n<p>进入 react 目录，运行 <code>npx storybook init</code> ，添加 storybook<br><br>PS：期间会咨询是否使用 eslint 插件，选择否。因为我们已经自己定义好 eslint 规则了</p>\n<p>先执行 <code>npm run format</code> 和 <code>npm run lint</code> 统一代码格式（storybook 新增的组件，代码风格可能不一样）</p>\n<p>执行 <code>npm run storybook</code> 启动，可以看到现成的 demo</p>\n<p>最后，新建 <code>stories/examples</code> 文件夹，把示例都拖进来。否则太多太乱。</p>\n<h2 id=\"代码演示-3\"><a href=\"#代码演示-3\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>新建 <code>stories/question</code> 目录，在这里新建组件</p>\n<ul>\n<li>QuestionInfo.stories.tsx</li>\n<li>QuestionTitle.stories.tsx</li>\n<li>QuestionParagraph.stories.tsx</li>\n<li>QuestionInput.stories.tsx</li>\n</ul>\n<h1 id=\"React-Fiber-架构的调度执行原理\"><a href=\"#React-Fiber-架构的调度执行原理\" class=\"headerlink\" title=\"React Fiber 架构的调度执行原理\"></a>React Fiber 架构的调度执行原理</h1><blockquote>\n<p>fiber架构的调度借鉴了生成器(或者说是协程)的概念</p>\n</blockquote>\n<pre><code class=\"javascript\">let ticket_num = 0;\nlet ticket_total = 0;\n// 使用生成器,生成迭代器,迭代器用于迭代返回结果\nfunction* sale(name) &#123;\n  const saleName = name;\n  // 定义死循环,永远执行任务\n  while (true) &#123;\n    if (ticket_num &lt;= 0) &#123;\n      console.log(`$&#123;saleName&#125; =&gt; No ticket`);\n      // 生成器函数中如何直接返回,则只会有一次next方法,执行的value是return返回的值,done为true\n      return 1;\n    &#125; else &#123;\n      ticket_total++;\n      console.log(`$&#123;saleName&#125; =&gt; sales the No.$&#123;ticket_total&#125; ticket`);\n      ticket_num--;\n    &#125;\n    yield ticket_num;\n  &#125;\n&#125;\n// 当浏览器处于空闲状态时(手动实现的requestIdleCallback),使用调度器执行任务队列中的迭代器(利用迭代器可以暂停执行的特点)\nlet thread = async () =&gt; &#123;\n  //设置任务队列,存放一些迭代器.\n  let pool = [sale(&quot;A&quot;), sale(&quot;B&quot;), sale(&quot;C&quot;), sale(&quot;D&quot;)];\n  let len = pool.length;\n  let moniter = len;\n  ticket_num = 100; //迭代器执行环境和变量相绑定,可以修改变量的值,对应的迭代器执行结果也会变化\n  while (true) &#123;\n    let id = parseInt(Math.random() * len);\n    let status = pool[id].next().done;\n    if (status) moniter--;\n    if (moniter === 0) &#123;\n      console.log(&quot;All tickets saled done...&quot;);\n      break;\n    &#125;\n  &#125;\n&#125;;\nthread();\n</code></pre>\n","categories":["react"],"tags":["react"]},{"title":"Linux","url":"/2023/01/22/linux%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<h1 id=\"Linux-服务器\"><a href=\"#Linux-服务器\" class=\"headerlink\" title=\"Linux 服务器\"></a>Linux 服务器</h1><p><strong>Linux是操作系统：</strong></p>\n<p>Linux作为<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTg3JUFBJUU3JTk0JUIxJUU4JUJEJUFGJUU0JUJCJUI2\">自由软件</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJTgwJUU2JTk0JUJFJUU2JUJBJTkwJUU0JUJCJUEzJUU3JUEwJTgxJUU4JUJEJUFGJUU0JUJCJUI2\">开放源代码软件</span>发展中最著名的例子，背靠社区与商业化的使用，使其得到了广泛的应用与发展。</p>\n<p><strong>Linux无处不在：</strong></p>\n<p>世界上500个最快的超级计算机90％以上运行Linux发行版或变种，包括最快的前10名超级计算机运行的都是基于Linux内核的操作系统。Linux也广泛应用在嵌入式系统上，如手机（Mobile Phone）、平板电脑（Tablet）、路由器（Router）、电视（TV）和电子游戏机等。在移动设备上广泛使用的Android操作系统就是创建在Linux内核之上。</p>\n<p><strong>学习Linux迫在眉睫：</strong></p>\n<ul>\n<li>公司都在用</li>\n<li>小伙伴们都会用</li>\n<li>关键免费啊….</li>\n</ul>\n<p><strong>本课程的主要目标：</strong></p>\n<ul>\n<li>了解Linux操作系统(版本、目录、安装等)</li>\n<li>学会使用Linux常见的命令</li>\n<li>搭建Nginx服务，给你的Web小站一个运行环境吧~~</li>\n<li>介绍HTTP(s)及免费申请SSL证书</li>\n<li>云服务器阿里云、华为云（介绍）、云数据库RDS介绍</li>\n<li>什么是负载均衡？负载均衡有什么用？阿里云SLB介绍</li>\n</ul>\n<p><strong>前置准备【下面的方式任选其一】：</strong></p>\n<ul>\n<li>使用虚拟化软件(本地安装)</li>\n<li>购买云服务器</li>\n</ul>\n<p>版本准备：linux操作系统(Centos 7.6)</p>\n<p>可选：准备一个域名</p>\n<h2 id=\"Linux简介\"><a href=\"#Linux简介\" class=\"headerlink\" title=\"Linux简介\"></a>Linux简介</h2><h3 id=\"版本介绍\"><a href=\"#版本介绍\" class=\"headerlink\" title=\"版本介绍\"></a>版本介绍</h3><p><img data-src=\"/./assets/123-3.png\" alt=\"Linux简版介绍\"></p>\n<p>Fedora是基于RHEL，CentOS，Scientific Linux, 和Oracle Linux的社区版本。相比RHEL，Fedora打包了显著的更多的软件包。其中一个原因是，多样化的社区参与Fedora的建设，它不只是一家公司。在这个过程中，CentOS用于活动，演示和实验，因为它是对最终用户免费提供的，并具有比Fedora的一个更长的发布周期(通常每隔半年左右发布一个新版本)。</p>\n<p>Debian是包括Ubuntu在内许多发行版的上游，而Ubuntu又是Linux Mint及其他发行版的上游。Debian在服务器和桌面电脑领域都有着广泛的应用。Debian是一个纯开源计划并着重在一个关键点上，稳定性。它同时也提供了最大的和完整的软件仓库给用户。</p>\n<p>Linux的发行版本可以大体分为两类，一类是商业公司维护的发行版本，如：著名的Redhat(RHEL)，一类是社区组织维护的发行版本，如：Debian。下面介绍一下各个发行版本的特点：</p>\n<h4 id=\"Centos-Redhat\"><a href=\"#Centos-Redhat\" class=\"headerlink\" title=\"Centos(Redhat)\"></a>Centos(Redhat)</h4><p>Redhat，应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。</p>\n<p>包管理方式：采用的是基于<code>rpm</code>包的<code>yum</code>包管理方式。</p>\n<h4 id=\"Debian\"><a href=\"#Debian\" class=\"headerlink\" title=\"Debian\"></a>Debian</h4><p>Debian是社区类Linux的典范，是迄今为止最遵循GNU规范 的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支(branch)： <code>stable</code>, <code>testing</code> 和 <code>unstable</code>。其中，<code>unstable</code>为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。<code>testing</code>的版本都经 过<code>unstable</code>中的测试，相对较为稳定，也支持了不少新技术(比如SMP等)。而<code>stable</code>一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。</p>\n<p>包管理方式：采用的是基于是<code>apt-get</code>、<code>dpkg</code>包管理方式。</p>\n<h4 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h4><p>Ubuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的<code>unstable</code>版本加强而来，可以这么说，Ubuntu就是 一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择，基于<code>Gnome</code>的Ubuntu，基于<code>KDE</code>的Kubuntu以及基于<code>Xfc</code>的 Xubuntu。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。</p>\n<p>包管理方式：采用的是基于是<code>apt-get</code>、<code>dpkg</code>包管理方式。</p>\n<p>总结对比一下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Centos</th>\n<th>Debian</th>\n<th>Ubuntu</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>包管理</td>\n<td>yum</td>\n<td>apt-get</td>\n<td>apt-get</td>\n</tr>\n<tr>\n<td>桌面应用</td>\n<td>支持</td>\n<td>需要另装</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>系统资源占用</td>\n<td>小</td>\n<td>非常小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>资料</td>\n<td>最多</td>\n<td>依赖社区</td>\n<td>多</td>\n</tr>\n<tr>\n<td>更新频次</td>\n<td>长达10年</td>\n<td>1-2年</td>\n<td>3-5年</td>\n</tr>\n<tr>\n<td>软件资源</td>\n<td>较新</td>\n<td>最新</td>\n<td>新</td>\n</tr>\n<tr>\n<td>漏洞更新</td>\n<td>慢</td>\n<td>依赖社区</td>\n<td>依赖社区</td>\n</tr>\n<tr>\n<td>默认安装</td>\n<td>非常全</td>\n<td>无</td>\n<td>非常全</td>\n</tr>\n<tr>\n<td>稳定性</td>\n<td>较稳定</td>\n<td>稳定</td>\n<td>相对稳定</td>\n</tr>\n<tr>\n<td>系统操作要求</td>\n<td>较高</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>维护要求</td>\n<td>低</td>\n<td>高</td>\n<td>较高</td>\n</tr>\n<tr>\n<td>易用性</td>\n<td>一般</td>\n<td>差</td>\n<td>较好</td>\n</tr>\n<tr>\n<td>定制化</td>\n<td>一般</td>\n<td>高</td>\n<td>差</td>\n</tr>\n</tbody></table>\n<p>CentOS是RHEL发行版对应的开源版本，通常在RedHat的发布后就会很快发行。它既稳定，占用资源又少，在网络上能方便搜索到安装配置的文档，自身的帮助文档也非常强大。所以，新人学习推荐：<strong>Centos</strong></p>\n<blockquote>\n<p>本课程，后续的操作与演示，将会使用Centos 7.6 64-bit版本进行演示</p>\n</blockquote>\n<p>参考资料：<span class=\"exturl\" data-url=\"aHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy8xLzFiL0xpbnV4X0Rpc3RyaWJ1dGlvbl9UaW1lbGluZS5zdmc=\">Linux发行版及年份</span></p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><h4 id=\"Linux-vs-Windows\"><a href=\"#Linux-vs-Windows\" class=\"headerlink\" title=\"Linux vs Windows\"></a>Linux vs Windows</h4><p>下面我们Linux与Windows作一个对比：</p>\n<p>这里Linux是免费的版本，如Centos, Ubuntu，而Windows则是Windows10&#x2F;8&#x2F;7</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Linux</th>\n<th>Windows</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>费用</td>\n<td>免费</td>\n<td>付费</td>\n</tr>\n<tr>\n<td>软件支持</td>\n<td>社区，免费</td>\n<td>官方支持，收费</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>很安全</td>\n<td>各种漏洞</td>\n</tr>\n<tr>\n<td>使用习惯</td>\n<td>命令行与界面操作，需要学习</td>\n<td>图形界面操作，简单</td>\n</tr>\n<tr>\n<td>可定制性</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>应用范畴</td>\n<td>服务器</td>\n<td>工作、娱乐</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>依赖社区</td>\n<td>官方更新</td>\n</tr>\n<tr>\n<td>系统内核</td>\n<td>透明</td>\n<td>封闭</td>\n</tr>\n</tbody></table>\n<p>Linux的优势：</p>\n<ul>\n<li><strong>稳定的系统</strong></li>\n<li>安全性和漏洞的快速修补</li>\n<li>多用户</li>\n<li>用户和用户组的规划</li>\n<li><strong>相对较少的系统资源占用</strong></li>\n<li>可定制裁剪，移植到嵌入式平台（如安卓设备）</li>\n<li>可选择的多种图形用户界面（如 GNOME，KDE）</li>\n</ul>\n<p>Windows的优势：</p>\n<ul>\n<li>特定的支持厂商</li>\n<li><strong>足够的游戏娱乐支持度</strong></li>\n<li>足够的专业软件支持度</li>\n</ul>\n<h4 id=\"Linux的GUI界面\"><a href=\"#Linux的GUI界面\" class=\"headerlink\" title=\"Linux的GUI界面\"></a>Linux的GUI界面</h4><p>这里我们选择几款比较有代表性的桌面进行简单的介绍：</p>\n<ol>\n<li><p>GNOME<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ25vbWUub3JnLw==\">[官方地址]</span></p>\n<p><img data-src=\"/./assets/image-20190602081017634.png\" alt=\"/images/image-20190602081017634\"></p>\n<blockquote>\n<p>centos6.x 上默认是gnome2，7.x默认gnome3</p>\n</blockquote>\n<p><img data-src=\"/./assets/activities-overview.jpg\" alt=\"img\"></p>\n<p>上图为：GNOME3</p>\n</li>\n<li><p>KDE <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rZGUub3JnLw==\">[官方地址]</span></p>\n<p><img data-src=\"/./assets/plasma-5.12.png\" alt=\"Plasma 5.12\"></p>\n<p>上图为：Plasma 5.12 LTS</p>\n</li>\n<li><p>Unity</p>\n<p><img data-src=\"/./assets/v2-c495dceef151f7685d5964a99c970f2b_r.jpg\" alt=\"preview\"></p>\n<p><strong>Unity</strong>是<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ2Fub25pY2FsJUU1JTg1JUFDJUU1JThGJUI4\">Canonical公司</span>为<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR05PTUU=\">GNOME</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUExJThDJUU5JTlEJUEyJUU3JThFJUFGJUU1JUEyJTgz\">桌面环境</span>所开发的<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUJFJUU1JUJEJUEyJUU3JTk0JUE4JUU2JTg4JUI3JUU3JTk1JThDJUU5JTlEJUEy\">图形用户界面</span>，用于<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVWJ1bnR1\">Ubuntu</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTkzJThEJUU0JUJEJTlDJUU3JUIzJUJCJUU3JUJCJTlG\">操作系统</span>。</p>\n<blockquote>\n<p>直到Ubuntu16.04LTS，使用的都是Unity，从 Ubuntu 18.04 LTS 开始，默认的 Ubuntu 桌面将重归 GNOME。人事调整，与钱的问题….有兴趣的同学可以看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbnNpZ2h0cy51YnVudHUuY29tLzIwMTcvMDQvMDUvZ3Jvd2luZy11YnVudHUtZm9yLWNsb3VkLWFuZC1pb3QtcmF0aGVyLXRoYW4tcGhvbmUtYW5kLWNvbnZlcmdlbmNlLw==\">这里</span></p>\n</blockquote>\n</li>\n</ol>\n<p>我们来看看<span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmVuZHMuZ29vZ2xlLmNvbS90cmVuZHMvZXhwbG9yZT9kYXRlPXRvZGF5JTIwNS15JnE9R05PTUUsS0RFLC9tLzBkc2JrMG4=\">Google Trends</span></p>\n<p>参考资料：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy51YnVudHUub3JnLmNuL2Rvd25sb2Fk\">Ubuntu官方下载地址：获取 Ubuntu</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5cWJsb2cvYXJ0aWNsZS9kZXRhaWxzLzgwMTUyMDE2\">Ubuntu18.04（Gnome桌面）主题美化</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ljZV9fc25vdy9hcnRpY2xlL2RldGFpbHMvODAxNTIwNjg=\">Ubuntu 18.04配置及美化</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxpdS5pby8yMDE4LzEyLzIyL1VidW50dTE4LjA0JUU1JUFFJThDJUU3JUJFJThFJUU5JTg1JThEJUU3JUJEJUFFLyMlRTYlOTUlODglRTYlOUUlOUMlRTklQTIlODQlRTglQTclODg=\">Ubuntu18.04完美配置优化美化</span></p>\n<h4 id=\"常见软件应用\"><a href=\"#常见软件应用\" class=\"headerlink\" title=\"常见软件应用\"></a>常见软件应用</h4><ul>\n<li>数据库：MySQL、Oracle、 MongoDB、Redis</li>\n<li>web服务器：<code>Nginx</code>、Apache</li>\n<li>浏览器：Chromium(Chrome)、Firefox</li>\n<li>编辑器：Emacs，<code>Vim</code>，Nano，Atom，VScode，IntelliJ IDEA&amp;Webstorm</li>\n<li>文档：WPS Office、LibreOffice、Calligra(Ubuntu&#x2F;Debian)</li>\n<li>下载工具：<code>Aria2</code>、uGet(Ubuntu&#x2F;Debian)、XDM、qBittorrent</li>\n<li>虚拟化：VirtualBox、VMWare、</li>\n<li>系统工具：<code>git</code>、rsync、sudo、unzip、tar</li>\n<li>其他：音乐Netease Music、图片GIMP、聊天Wine QQ、播放器VLC</li>\n</ul>\n<h3 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h3><h4 id=\"Centos安装方法：\"><a href=\"#Centos安装方法：\" class=\"headerlink\" title=\"Centos安装方法：\"></a>Centos安装方法：</h4><ol>\n<li><p>下载镜像</p>\n<p><img data-src=\"/./assets/image-20190602095157756.png\" alt=\"/images/image-20190602095157756\"></p>\n<p>按需选择下载：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>DVD</th>\n<th>Minimal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>图形安装</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>自带软件包</td>\n<td>全家桶，可选择</td>\n<td>无</td>\n</tr>\n<tr>\n<td>镜像大小</td>\n<td>4G+</td>\n<td>800-900M</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>制作U盘启动盘</p>\n<p>Windows参考：<a href=\"#Windows%E4%B8%AD%E5%88%B6%E4%BD%9CUSB%E5%90%AF%E5%8A%A8%E7%9B%98\">Windows中制作USB启动盘</a></p>\n<p>Mac&#x2F;Linux参考：<a href=\"#MacOS%E4%B8%AD%E5%88%B6%E4%BD%9CUSB%E5%90%AF%E5%8A%A8%E7%9B%98\">MacOS中制作USB启动盘</a></p>\n</li>\n<li><p>修改BIOS启动顺序，重启</p>\n</li>\n<li><p>安装配置。€</p>\n</li>\n</ol>\n<p>参考资料</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmNlbnRvcy5vcmcvemgvSG93VG9zL0luc3RhbGxGcm9tVVNCa2V5\">官方U盘安装说明</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2VudG9zLm9yZy9kb3dubG9hZC8=\">镜像下载</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTgwNDgtMS5odG1s\">Centos7安装教程</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90dXRvcmlhbHMudWJ1bnR1LmNvbS90dXRvcmlhbC90dXRvcmlhbC1pbnN0YWxsLXVidW50dS1kZXNrdG9wIzA=\">Ubuntu官方安装教程</span></li>\n</ol>\n<p>常见问题：</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmppbmNodWFuZy5vcmcvMjA2Mi5odG1s\">centos7 U盘安装卡在 starting dracut initqueue hook </span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pncmprZmxta3ljL2FydGljbGUvZGV0YWlscy83ODI5MzUwNA==\">U盘安装CentOS7遇到：Warning: dracut-initqueue timeout - starting timeout scripts</span></li>\n</ol>\n<h4 id=\"Windows中制作USB启动盘\"><a href=\"#Windows中制作USB启动盘\" class=\"headerlink\" title=\"Windows中制作USB启动盘\"></a>Windows中制作USB启动盘</h4><p>操作步骤：</p>\n<ol>\n<li><p>格式化U盘(FAT32格式)</p>\n</li>\n<li><p>下载ISO镜像</p>\n</li>\n<li><p>下载资源文件中的写入程序</p>\n</li>\n<li><p>写入镜像(工具见后文)</p>\n</li>\n</ol>\n<p><img data-src=\"/./assets/1559440057311.jpg\" alt=\"1559440057311\"></p>\n<p>资源下载：</p>\n<p>Centos官网推荐：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvdXNid3JpdGVyLw==\">USBwriter</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvd2luMzJkaXNraW1hZ2VyLw==\">Win32 Disk Imager</span></p>\n<p>Ubuntu官网推荐：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ydWZ1cy5pZS8=\">rufus</span></p>\n<p><img data-src=\"/./assets/SouthEast.png\" alt=\"rufus\"></p>\n<h4 id=\"MacOS中制作USB启动盘\"><a href=\"#MacOS中制作USB启动盘\" class=\"headerlink\" title=\"MacOS中制作USB启动盘\"></a>MacOS中制作USB启动盘</h4><ol>\n<li><p>格式化U盘</p>\n<p><img data-src=\"/./assets/image-20190602094231784.png\" alt=\"/images/image-20190602094231784\"></p>\n</li>\n<li><p>使用 <code>diskutil list</code> 查看U的设备名</p>\n<pre><code>$ diskutil list\n/dev/disk0 (internal):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                         500.3 GB   disk0\n   1:                        EFI EFI                     314.6 MB   disk0s1\n   2:                 Apple_APFS Container disk1         500.0 GB   disk0s2\n\n/dev/disk1 (synthesized):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      APFS Container Scheme -                      +500.0 GB   disk1\n                                 Physical Store disk0s2\n   1:                APFS Volume APPLE SSD               342.6 GB   disk1s1\n   2:                APFS Volume Preboot                 47.6 MB    disk1s2\n   3:                APFS Volume Recovery                509.7 MB   disk1s3\n   4:                APFS Volume VM                      4.3 GB     disk1s4\n\n/dev/disk2 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:     FDisk_partition_scheme                        *123.0 GB   disk2\n   1:               Windows_NTFS LIWEI                   123.0 GB   disk2s1\n</code></pre>\n<p>上图中，&#x2F;dev&#x2F;disk2就是U盘</p>\n</li>\n<li><p>卸载U盘(不是推出) : <code>diskutil umountDisk /dev/disk2</code> (假如U盘是 &#x2F;dev&#x2F;disk2)</p>\n<pre><code>$ diskutil umountDisk /dev/disk2\nUnmount of all volumes on disk1 was successful\n</code></pre>\n</li>\n<li><p>镜像DMG写入到U盘: <code>sudo dd if=~/Downloads/ubuntu-16.04-desktop-amd64.iso of=/dev/disk2 bs=1m</code> (假如U盘是 &#x2F;dev&#x2F;disk1, 千万别搞错了)</p>\n<pre><code>$ sudo dd if=~/Downloads/ubuntu-17.04-desktop-amd64.iso of=/dev/disk2 bs=1m\nPassword:\n2151+1 records in\n2151+1 records out\n2256076800 bytes transferred in 90.277905 secs (24990354 bytes/sec)\n</code></pre>\n</li>\n<li><p>写入完成后会提示:“此电脑不能读取能插入的磁盘”, 这里选择直接推出即可</p>\n</li>\n</ol>\n<h3 id=\"Linux目录结构\"><a href=\"#Linux目录结构\" class=\"headerlink\" title=\"Linux目录结构\"></a>Linux目录结构</h3><p><img data-src=\"/./assets/linux-operation-system.jpeg\" alt=\"Linux目录结构\"></p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;bin</td>\n<td>常用二进制命令</td>\n<td>ls, cp, rm, mkdir</td>\n</tr>\n<tr>\n<td>&#x2F;usr</td>\n<td>系统程序目录</td>\n<td>命令、帮助文件、系统配置</td>\n</tr>\n<tr>\n<td>&#x2F;var</td>\n<td>这个目录中存放着在不断扩充着的东西</td>\n<td>日志</td>\n</tr>\n<tr>\n<td>&#x2F;lib</td>\n<td>系统最基本的动态连接共享库</td>\n<td>类似于Windows中的DLL</td>\n</tr>\n<tr>\n<td>&#x2F;srv</td>\n<td>存放一些服务启动之后需要提取的数据</td>\n<td>通常是空的</td>\n</tr>\n<tr>\n<td>&#x2F;home</td>\n<td>用户主目录</td>\n<td>通常是空的</td>\n</tr>\n<tr>\n<td>&#x2F;boot</td>\n<td>Linux内核及系统引导文件目录</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;dev</td>\n<td>设备文件的目录</td>\n<td>声卡，磁盘，光驱等</td>\n</tr>\n<tr>\n<td>&#x2F;etc</td>\n<td>二进制软件包配置文件的默认路径</td>\n<td>系统信息，网络配置</td>\n</tr>\n<tr>\n<td>&#x2F;lost+found</td>\n<td>系统崩溃时，产生的一些碎片文件</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;mnt</td>\n<td>临时挂载存储设备</td>\n<td>U盘</td>\n</tr>\n<tr>\n<td>&#x2F;opt</td>\n<td>软件可选的安装目录</td>\n<td>通常是空的</td>\n</tr>\n<tr>\n<td>&#x2F;proc</td>\n<td>操作系统进程信息目录</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;sbin</td>\n<td>管理员命令，系统级命令</td>\n<td>sudo用户</td>\n</tr>\n<tr>\n<td>&#x2F;tmp</td>\n<td>临时文件目录</td>\n<td>重启后，被清空</td>\n</tr>\n<tr>\n<td>&#x2F;run</td>\n<td>临时文件系统，存储系统启动以来的信息</td>\n<td>重启后，被清空</td>\n</tr>\n<tr>\n<td>&#x2F;sys</td>\n<td>系统中的设备组织成层次结构</td>\n<td>通过文件查看硬件信息</td>\n</tr>\n</tbody></table>\n<p>需要掌握的目录路径知识：</p>\n<ol>\n<li><p>查看系统内核信息</p>\n<pre><code class=\"bash\"># Centos\n$ cat /proc/version\nLinux version 3.10.0-957.10.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Mon Mar 18 15:06:45 UTC 2019\n\n# Ubuntu\n$ cat /proc/version\nLinux version 4.15.7-041507-generic (kernel@gloin) (gcc version 7.2.0 (Ubuntu 7.2.0-8ubuntu3.2)) #201802280530 SMP Wed Feb 28 10:31:47 UTC 2018\n</code></pre>\n</li>\n<li><p>查看网络信息</p>\n<pre><code class=\"bash\"># Centos DHCP\n$ cat /etc/sysconfig/network-scripts/ifcfg-eth0\nDEVICE=eth0\nBOOTPROTO=dhcp\nONBOOT=yes\n\n# 或者指定IP\n$ cat /etc/sysconfig/network-scripts/ifcfg-em1\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=none\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=em1\nUUID=fa335568-27db-47fd-a055-424173c42430\nDEVICE=em1\nONBOOT=yes\nIPADDR=192.168.4.252\nPREFIX=24\nGATEWAY=192.168.4.50\nDNS1=192.168.4.50\nIPV6_PRIVACY=no\nZONE=public\n\n# Ubuntu\n$ vi /etc/network/interfaces\n# This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\nsource /etc/network/interfaces.d/*\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\n# The primary network interface\nauto ens3\niface ens3 inet static\n        address 192.168.4.60\n        netmask 255.255.255.0\n        network 192.168.4.0\n        broadcast 192.168.4.255\n        gateway 192.168.4.50\n        # dns-* options are implemented by the resolvconf package, if installed\n        dns-nameservers 192.168.4.50\n        dns-search itheima\n</code></pre>\n<p>通常使用<code>ifconfig</code>来查看网卡的信息</p>\n</li>\n<li><p>DNS配置</p>\n<pre><code class=\"bash\">$ cat /etc/resolv.conf\noptions timeout:2 attempts:3 rotate single-request-reopen\n; generated by /usr/sbin/dhclient-script\nnameserver 100.100.2.136\nnameserver 100.100.2.138\n</code></pre>\n</li>\n<li><p>host文件</p>\n<pre><code class=\"bash\">$ cat /etc/hosts\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n</code></pre>\n</li>\n<li><p>用户&#x2F;组</p>\n<p>查看用户：</p>\n<pre><code class=\"bash\">$ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\n....\n</code></pre>\n<p>查看组：</p>\n<pre><code class=\"bash\">$ cat /etc/group\nroot:x:0:\ndaemon:x:1:\nbin:x:2:\nsys:x:3:\nadm:x:4:syslog,bttech\ntty:x:5:\ndisk:x:6:\nlp:x:7:\nmail:x:8:\nnews:x:9:\nuucp:x:10:\nman:x:12:\nproxy:x:13:\n....\n</code></pre>\n</li>\n<li><p>查看内存&#x2F;CPU</p>\n<pre><code class=\"bash\"># 查看CPU\n$ cat /proc/cpuinfo\nprocessor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 45\nmodel name\t: Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\nstepping\t: 7\nmicrocode\t: 0x714\ncpu MHz\t\t: 2117.419\ncache size\t: 20480 KB\n...\n\n# 查看内存\n$ cat /proc/meminfo\nMemTotal:       131812048 kB\nMemFree:          460820 kB\nMemAvailable:   36657836 kB\nBuffers:               0 kB\nCached:         34910784 kB\nSwapCached:      1051944 kB\nActive:         95183532 kB\nInactive:       32382012 kB\nActive(anon):   77764844 kB\nInactive(anon): 15015220 kB\nActive(file):   17418688 kB\n...\n</code></pre>\n</li>\n<li><p>其他</p>\n<ul>\n<li>&#x2F;etc&#x2F;fstab（开机自动挂载列表）</li>\n<li>&#x2F;etc&#x2F;rc.local（开机自启动文件，自启动命令，脚本）</li>\n<li>&#x2F;etc&#x2F;init.d(服务启动命令脚本目录)</li>\n<li>&#x2F;etc&#x2F;profile(全局环境变量)</li>\n<li>&#x2F;usr&#x2F;local(编译安装软件默认安装目录)</li>\n<li>&#x2F;var&#x2F;log&#x2F;message（系统日志）</li>\n<li>&#x2F;var&#x2F;log&#x2F;secure（系统安全日志）</li>\n<li><em>&#x2F;proc&#x2F;mounts</em>（系统挂载信息）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Linux启动过程\"><a href=\"#Linux启动过程\" class=\"headerlink\" title=\"Linux启动过程\"></a>Linux启动过程</h3><p>Linux启动过程：</p>\n<ul>\n<li><p>内核的引导</p>\n<p>首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>\n<p>主要是一些驱动、基本的操作指令，用来接管所有的硬件</p>\n</li>\n<li><p>运行 init</p>\n<p>就跟main函数一样，有一个起点，初始一个服务进程daemon，跟windows中的服务一样。</p>\n</li>\n<li><p>系统初始化</p>\n<p>用户及软件服务自启动</p>\n</li>\n<li><p>建立终端 </p>\n<p>Linux的多用户管理。</p>\n<p>针对对用户，登录方式有三种：</p>\n<ul>\n<li>命令行登录</li>\n<li>ssh登录</li>\n<li>图形界面登录</li>\n</ul>\n</li>\n<li><p>用户登录系统</p>\n</li>\n</ul>\n<p><img data-src=\"/./assets/bg2013081707.png\" alt=\"img\"></p>\n<h3 id=\"常用命令介绍-重点\"><a href=\"#常用命令介绍-重点\" class=\"headerlink\" title=\"常用命令介绍(重点)\"></a>常用命令介绍(重点)</h3><h4 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h4><ol>\n<li>目录相关<ul>\n<li><p><code>ls</code>: 列出目录</p>\n<p>-la 可以查看隐藏文件，文件一些基础属性</p>\n</li>\n<li><p><code>cd</code>：切换目录</p>\n<p>使用绝对路径<code>/</code>，也可以使用<code>./</code>相对路径，回到上级目录<code>cd ..</code></p>\n</li>\n<li><p><code>pwd</code>：显示目前的目录</p>\n</li>\n<li><p><code>mkdir</code>：创建一个新的目录</p>\n</li>\n<li><p><code>rmdir</code>：删除一个空的目录</p>\n</li>\n<li><p><code>cp</code>: 复制文件或目录</p>\n<pre><code class=\"bash\">cp source target\n</code></pre>\n</li>\n<li><p><code>rm</code>: 移除文件或目录</p>\n<pre><code class=\"bash\"># 删除目录\nrm -r dirpath\n\n# 强制删除，要特别注意\nrm -rf dirpath€\n</code></pre>\n</li>\n<li><p><code>mv</code>: 移动文件与目录，或修改文件与目录的名称</p>\n<pre><code>mv source target\n</code></pre>\n</li>\n<li><p><code>cat</code>用来查看文件内的内容，<code>touch</code>命令来创建文件，<code>echo</code>命令往文件里面写入内容，<code>more</code>命令来查看显示长文件内容</p>\n</li>\n</ul>\n</li>\n<li>基本属性：<ul>\n<li><p>权限管理<code>chmod</code></p>\n<p>文件基本属性分为10个字符 <code>drwxrwxrwx</code></p>\n<p><code>r</code> 代表着read读权限</p>\n<p><code>w</code>代表着write写权限</p>\n<p><code>x</code>代表着execute执行权限</p>\n<p><code>d</code>代表着目录</p>\n<p><code>chmod -R</code>递归执行，相当于是把目录下所有的文件都修改对应的权限</p>\n<p><code>chmod +x</code> 给文件一个执行&#x2F;读&#x2F;写权限</p>\n<p>修改权限的两种方式：</p>\n<p><strong>方式1： 数字方式</strong></p>\n<p><code>7</code>-<code>rwx</code></p>\n<p><code>6</code>-<code>-rw-</code></p>\n<p><code>4</code>-<code>r--</code></p>\n<p><code>0</code>-<code>---</code> 什么权限都没有，</p>\n<p>前面的3个是所有者用户的权限，</p>\n<p>中间的3个是组用户的权限，</p>\n<p>后面的3个是其他用户的权限。</p>\n<p>举例说明：</p>\n<pre><code class=\"bash\"># 对所属用户有读写权限\nchmod 600 ...\n\n# 对应 -rwxrw-rw-，相当于是取消了组与其他用户的执行权限\nchmod 755 ...\n</code></pre>\n<p><strong>方式2：</strong></p>\n<p><code>a</code>代表all所有，<code>u</code>代表user，<code>g</code>代表group，<code>o</code>代表other。</p>\n<p><code>+</code>代表增加，<code>-</code>代表减少</p>\n<p>举例说明：</p>\n<pre><code class=\"bash\"># 增加所有用户的读的权限\nchmod a+r ...\n\n# 增加用户与组的写的权限\nchmod ug+w ..\n</code></pre>\n<blockquote>\n<p>个人比较推荐数字的方式，比较好记！！</p>\n</blockquote>\n</li>\n<li><p>用户&#x2F;组权限管理<code>chown</code></p>\n<p>修改文件&#x2F;文档所属&#x2F;所属组</p>\n<pre><code>chown &lt;所属用户&gt;:&lt;所属组&gt; &lt;文件&gt;\n</code></pre>\n<p>目录：</p>\n<pre><code>chown -R &lt;所属用户&gt;:&lt;所属组&gt; &lt;文件&gt;\n</code></pre>\n<p><code>-R</code> 代表着递归</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"用户管理-x2F-登录\"><a href=\"#用户管理-x2F-登录\" class=\"headerlink\" title=\"用户管理&#x2F;登录\"></a>用户管理&#x2F;登录</h4><ol>\n<li>添加用户<code>useradd</code></li>\n<li>删除用户<code>userdel</code></li>\n<li>用户口令修改 <code>passwd</code></li>\n<li>（扩展）用户组<code>groupadd</code>&#x2F;<code>groupdel</code>&#x2F;<code>groupmod</code></li>\n</ol>\n<h4 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h4><ol>\n<li><p>远程连接<code>ssh</code></p>\n<p>配置文件的路径是在<code>/etc/ssh/sshd_config</code>目录下</p>\n<p>如果需要修改port：</p>\n<ul>\n<li>修改<code>sshd_config</code>中的<code>Port</code>参数</li>\n<li>(Centos)还需要使用<code>semanage port -a -t ssh_port_t -p tcp &lt;Port&gt;</code></li>\n<li><code>service sshd restart</code> (Centos) &#x2F; <code>service ssh restart</code> (Debian、Ubuntu)</li>\n</ul>\n<blockquote>\n<p>在测试的时候，可以关闭服务器的防火墙，但是生产系统中不推荐这么去做。</p>\n<p>如果提示没有semanage这个命令，则可以使用如下方式来安装：</p>\n<p><code>sudo yum install -y policecoreutils-python</code></p>\n<p>或者使用<code>yum whatprovides semange</code>来反查</p>\n</blockquote>\n<p>ssh登录命令的格式：<code>ssh -p Port &lt;用户名&gt;@&lt;服务器的地址&gt;</code></p>\n<p>如： </p>\n<pre><code class=\"bash\">$ ssh -p 10022 root@192.168.0.1\n</code></pre>\n<blockquote>\n<p>window推荐使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmV0c2FyYW5nLmNvbS96aC94ZnRwLw==\">xftp</span>终端</p>\n<p>mac推荐使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRlcm0yLmNvbS8=\">iterm</span></p>\n</blockquote>\n</li>\n<li><p>查看网卡配置<code>ifconfig</code></p>\n<p> 如果说没有这个命令，可以使用<code>yum install net-tools</code>进行安装</p>\n<pre><code class=\"bash\">ifconfig eth0 &lt;ip&gt; netmask 255.255.255.0\n</code></pre>\n<p>对网口进行禁用&#x2F;启用</p>\n<pre><code class=\"bash\">ifconfig eth0 down/up\n</code></pre>\n</li>\n<li><p>查看网络<code>netstat</code></p>\n<ul>\n<li><code>-t</code>：列出TCP协议端口</li>\n<li><code>-u</code>：列出UDP协议端口</li>\n<li><code>-n</code>:不使用域名与服务名，而使用IP地址和端口号</li>\n<li><code>-l</code>：仅列出在监听状态网络服务</li>\n<li><code>-a</code>：列出所有的网络连接</li>\n<li><code>-p</code>：列出所对应的进程信息</li>\n</ul>\n<pre><code class=\"bash\">netstat -anpl | grep ssh\n</code></pre>\n<p>当使用<code>netstat | more</code>进行滚屏，<code>ctrl+f/b</code>进行翻上&#x2F;下页</p>\n</li>\n<li><p>路由命令<code>route</code></p>\n<p>route查看路由</p>\n<pre><code class=\"bash\"># add/del添加删除路由\n\nroute add -net 192.168.0.0 netmask 255.255.0.0 dev etho\n\n# del删除\nroute del -net 192.168.0.0 netmask 255.255.0.0\n\n# reject\nroute add -net 192.168.0.0 netmask 255.255.0.0 reject\n</code></pre>\n</li>\n<li><p>IP命令<code>ip</code></p>\n<pre><code>ip addr show\nip route show\nip link set eth0 up/down\n</code></pre>\n<p><code>ip &lt;命令&gt; help</code>去查看命令的一些参数 </p>\n</li>\n<li><p>DNS解析：<code>nslookup</code></p>\n<p>Centos中如果没有该命令，可以使用如下的方式进行安装</p>\n<pre><code>sudo yum install bind-utils\n</code></pre>\n</li>\n<li><p>查看本机IP</p>\n<pre><code class=\"bash\">curl [链接]\n</code></pre>\n<p>几个网址也非常好记忆</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2lwLmNuLw==\">ip.cn</span> (推荐)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2lwaW5mby5pby8=\">ipinfo.io</span> (推荐)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2NpcC5jYy8=\">cip.cc</span> (推荐)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2lmY29uZmlnLm1lLw==\">ifconfig.me</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL215aXAuaXBpcC5uZXQv\">myip.ipip.net</span></li>\n</ul>\n</li>\n</ol>\n<p>GUI网络配置操作（图形化大法好啊）：</p>\n<p><code>nmtui</code></p>\n<blockquote>\n<p>如果提示<code>not found</code>命令的话，可以<code>yum install -y NetworkManager-tui</code>进行安装</p>\n</blockquote>\n<p><img data-src=\"/./assets/nmtui.png\" alt=\"nmtui\"></p>\n<h4 id=\"性能-x2F-硬件\"><a href=\"#性能-x2F-硬件\" class=\"headerlink\" title=\"性能&#x2F;硬件\"></a>性能&#x2F;硬件</h4><ol>\n<li><p><code>top</code>命令：</p>\n<p>top命令替代命令：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTEwMzIzLTEuaHRtbA==\">参考1</span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly90dXRvcmlhbHMudWJ1bnR1LmNvbS90dXRvcmlhbC90dXRvcmlhbC1pbnN0YWxsLXVidW50dS1kZXNrdG9wIzA=\">参考2</span></p>\n<pre><code>top\n\n# m切换显示内存信息\n# t切换显示CPU信息\n# M对内存倒序排序显示\n# P根据CPU的使用百分比进行排序\n</code></pre>\n</li>\n<li><p>性能测试</p>\n<ul>\n<li><p>Bench.sh: </p>\n<p>使用方法：</p>\n<pre><code class=\"bash\">wget -qO- bench.sh | bash\n\n# 或者 \n\ncurl -Lso- bench.sh | bash\n</code></pre>\n<p>Github地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RlZGR5c3VuL2Fjcm9zcy9ibG9iL21hc3Rlci9iZW5jaC5zaA==\">https://github.com/teddysun/across/blob/master/bench.sh</span></p>\n</li>\n<li><p>LemonBench</p>\n<p>使用方法：</p>\n<pre><code class=\"bash\">wget -qO- https://ilemonrain.com/download/shell/LemonBench.sh | bash\n\n# 或者\n\ncurl -fsSL https://ilemonrain.com/download/shell/LemonBench.sh | bash\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Nginx服务\"><a href=\"#Nginx服务\" class=\"headerlink\" title=\"Nginx服务\"></a>Nginx服务</h2><p>nginx [发音：engine x]是一个HTTP和反向代理服务器，一个邮件代理服务器和一个通用的TCP &#x2F; UDP代理服务器，最初由<span class=\"exturl\" data-url=\"aHR0cDovL3N5c29ldi5ydS9lbi8=\">Igor Sysoev</span>编写。</p>\n<p>据Netcraft称，nginx 在2019年5月服务或代理了 26.43％最繁忙的网站。以下是一些成功案例： Dropbox， Netflix， Wordpress.com， FastMail.FM。</p>\n<blockquote>\n<p>nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP&#x2F;UDP proxy server, originally written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, nginx served or proxied 26.43% busiest sites in May 2019. Here are some of the success stories: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9ncy5kcm9wYm94LmNvbS90ZWNoLzIwMTcvMDkvb3B0aW1pemluZy13ZWItc2VydmVycy1mb3ItaGlnaC10aHJvdWdocHV0LWFuZC1sb3ctbGF0ZW5jeS8=\">Dropbox</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuY29ubmVjdC5uZXRmbGl4LmNvbS9lbi9zb2Z0d2FyZS8=\">Netflix</span>,<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmdpbnguY29tL2Nhc2Utc3R1ZGllcy9uZ2lueC13b3JkcHJlc3MtY29tLw==\">Wordpress.com</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuZmFzdG1haWwuZm0vMjAwNy8wMS8wNC93ZWJpbWFwcG9wLWZyb250ZW5kLXByb3hpZXMtY2hhbmdlZC10by1uZ2lueC8=\">FastMail.FM</span>.</p>\n</blockquote>\n<p>从下面的当下技术架构图中，可以看出Nginx在网络中的位置与重要性。Nginx的轻量级、内存占用少、启动极快，高并发能力强的特性，使它在互联网项目中广泛应用。</p>\n<p><img data-src=\"/./assets/v2-e1826bab1d07df8e97d61aa809b94a10_hd.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>Service-Oriented Architecture，<strong>SOA</strong>面向服务的架构</p>\n</blockquote>\n<h3 id=\"Nginx简介\"><a href=\"#Nginx简介\" class=\"headerlink\" title=\"Nginx简介\"></a>Nginx简介</h3><h4 id=\"什么是反向代理\"><a href=\"#什么是反向代理\" class=\"headerlink\" title=\"什么是反向代理\"></a>什么是反向代理</h4><p>正向代理 ：</p>\n<p><img data-src=\"/./assets/v2-c8ac111c267ae0745f984e326ef0c47f_hd.jpg\" alt=\"img\"></p>\n<p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，<strong>正向代理“代理”的是客户端</strong>，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p>\n<p>反向代理：</p>\n<p><img data-src=\"/./assets/v2-4787a512240b238ebf928cd0651e1d99_hd.jpg\" alt=\"img\"></p>\n<p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即<strong>反向代理“代理”的是服务器端</strong>，而且这一个过程对于客户端而言是透明的。</p>\n<h4 id=\"Nginx的技术架构\"><a href=\"#Nginx的技术架构\" class=\"headerlink\" title=\"Nginx的技术架构\"></a>Nginx的技术架构</h4><p><img data-src=\"/./assets/v2-b24eb2b29b48f59883232a58392ddae3_hd.jpg\" alt=\"img\"></p>\n<p>Master进程的作用是<strong>读取并验证配置文件nginx.conf；管理worker进程；</strong></p>\n<p>Worker进程的作用:<strong>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；</strong></p>\n<blockquote>\n<p>注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</p>\n</blockquote>\n<p>特点：</p>\n<ul>\n<li><p>主进程Master</p>\n<p><code>Nginx</code> 启动时，会生成两种类型的 <strong>进程</strong>*，一个是 <strong>主进程</strong>（<code>master</code>），<strong>一个</strong>（<code>windows</code> 版本的目前只有一个）或 <strong>多个工作进程</strong>（<code>worker</code>）。<strong>主进程</strong> 并不处理网络请求，主要负责 <strong>调度工作进程</strong>，也就是图示的 <code>3</code> 项：<strong>加载配置</strong>、<strong>启动工作进程</strong> 及 <strong>非停升级</strong>。所以，<code>Nginx</code> 启动以后，查看操作系统的进程列表，我们就能看到 <strong>至少有两个</strong> <code>Nginx</code> 进程。</p>\n</li>\n<li><p>工作进程Worker</p>\n<p>服务器实际 <strong>处理网络请求</strong> 及 <strong>响应</strong> 的是 <strong>工作进程</strong>（<code>worker</code>），在类 <code>unix</code> 系统上，<code>Nginx</code> 可以配置 <strong>多个</strong> <code>worker</code>，而每个 <code>worker</code> <strong>进程</strong> 都可以同时处理 <strong>数以千计</strong> 的 <strong>网络请求</strong>。</p>\n</li>\n<li><p>模块化设计</p>\n<p>标准HTTP模块、可选的HTTP模块(gzip等)、邮件服务、第三方(Lua)</p>\n<p><code>Nginx</code> 的 <code>worker</code> 进程，包括 <strong>核心</strong> 和 <strong>功能性模块</strong>，<strong>核心模块</strong> 负责维持一个 <strong>运行循环</strong>（<code>run-loop</code>），执行网络请求处理的 <strong>不同阶段</strong> 的模块功能，比如：<strong>网络读写</strong>、<strong>存储读写</strong>、<strong>内容传输</strong>、<strong>外出过滤</strong>，以及 <strong>将请求发往上游服务器</strong> 等。而其代码的 <strong>模块化设计</strong>，也使得我们可以根据需要对 <strong>功能模块</strong> 进行适当的 <strong>选择</strong> 和 <strong>修改</strong>，编译成具有 <strong>特定功能</strong> 的服务器。</p>\n</li>\n<li><p>事件驱动模型</p>\n<p>基于 <strong>异步及非阻塞</strong> 的 <strong>事件驱动模型</strong>，可以说是 <code>Nginx</code> 得以获得 <strong>高并发</strong>、<strong>高性能</strong> 的关键因素，同时也得益于对 <code>Linux</code>、<code>Solaris</code> 及类 <code>BSD</code> 等操作系统内核中 <strong>事件通知</strong> 及 <code>I/O</code> <strong>性能增强功能</strong> 的采用，如 <code>kqueue</code>、<code>epoll</code> 及 <code>event ports</code>。</p>\n</li>\n<li><p>代理设计</p>\n</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjRiZGI1NGU1MWQ0NTE5MWUwY2Q3NzQ=\">浅谈Nginx服务器的内部核心架构设计</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZ2lueC5vcmcvZW4vI2FyY2hpdGVjdHVyZV9hbmRfc2NhbGFiaWxpdHk=\">Architecture and scalability</span></p>\n</li>\n</ol>\n<h4 id=\"Nginx高可用\"><a href=\"#Nginx高可用\" class=\"headerlink\" title=\"Nginx高可用\"></a>Nginx高可用</h4><p><img data-src=\"/./assets/v2-ec3208d1ea659d126fe2a008ec5ae927_hd.jpg\" alt=\"img\"></p>\n<p><strong>VRRP（Virtual Router Redundancy Protocol）</strong>，即<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tLz90PWh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVlJSUA==\">虚拟路由冗余协议</span>。可以认为它是实现路由器高可用的容错协议，即将多台提供相同功能的路由器组成一个路由器组(Router Group)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP相应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。</p>\n<p>Keepalived是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，类似的工具还有heartbeat、corosync、pacemaker。但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用。</p>\n<p>KeepAlived + Nginx来组成高可用的方案：</p>\n<p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p>\n<p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p>\n<h3 id=\"Nginx服务安装\"><a href=\"#Nginx服务安装\" class=\"headerlink\" title=\"Nginx服务安装\"></a>Nginx服务安装</h3><h4 id=\"Centos安装方式\"><a href=\"#Centos安装方式\" class=\"headerlink\" title=\"Centos安装方式\"></a>Centos安装方式</h4><p>推荐使用在线安装方式：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>yum方式</th>\n<th>源码安装</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网络</td>\n<td>需要</td>\n<td>可以不需要</td>\n</tr>\n<tr>\n<td>安装位置</td>\n<td>&#x2F;etc&#x2F;nginx配置文件，&#x2F;usr&#x2F;sbin&#x2F;nginx</td>\n<td>&#x2F;usr&#x2F;local&#x2F;nginx目录</td>\n</tr>\n<tr>\n<td>管理命令</td>\n<td>提供</td>\n<td>不提供</td>\n</tr>\n<tr>\n<td>启动</td>\n<td>service nginx start</td>\n<td>执行绝对路径&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>yum remove nginx或者rpm -e nginx</td>\n<td>rm -rf &#x2F;usr&#x2F;local&#x2F;nginx</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>在线安装</p>\n<p>添加nginx的repo：</p>\n<pre><code class=\"bash\">$ vim /etc/yum.repos.d/nginx.repo\n</code></pre>\n<p>输入以下内容：</p>\n<pre><code class=\"bash\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1\n</code></pre>\n<p><code>:wq</code>保存后，使用<code>yum update</code>，接下来就是安装了。</p>\n<pre><code class=\"bash\">yum install -y nginx\n\n# 管理命令:\n# 启动/停止/重启\nservice nginx start/stop/restart\n\n# 卸载\nyum remove -y nginx\n# 或者强制卸载，不考虑依赖\nrpm -e nginx\n</code></pre>\n</li>\n<li><p>源码安装</p>\n</li>\n</ol>\n<ul>\n<li><p>安装对应的依赖：</p>\n<pre><code>yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel\n</code></pre>\n</li>\n<li><p>下载源码包：</p>\n<pre><code class=\"bash\">wget -O /tmp/nginx.tar.gz http://nginx.org/download/nginx-&lt;version&gt;.tar.gz\n</code></pre>\n<p>比如：</p>\n<pre><code class=\"bash\">wget -O /tmp/nginx.tar.gz http://nginx.org/download/nginx-1.17.0.tar.gz\n</code></pre>\n</li>\n<li><p>解压</p>\n<pre><code class=\"bash\">cd /tmp/\ntar zxvf nginx.tar.gz\n</code></pre>\n</li>\n<li><p>编译</p>\n<pre><code class=\"bash\">$ ./configure\nConfiguration summary\n\n- using system PCRE library\n- OpenSSL library is not used\n- using system zlib library\n\n  nginx path prefix: &quot;/usr/local/nginx&quot;\n  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;\n  nginx modules path: &quot;/usr/local/nginx/modules&quot;\n  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;\n  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;\n  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;\n  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;\n  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;\n  nginx http client request body temporary files: &quot;client_body_temp&quot;\n  nginx http proxy temporary files: &quot;proxy_temp&quot;\n  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;\n  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;\n  nginx http scgi temporary files: &quot;scgi_temp&quot;\n</code></pre>\n</li>\n<li><p>安装</p>\n<pre><code class=\"bash\">make &amp;&amp; make install\n</code></pre>\n</li>\n<li><p>管理方法：</p>\n<p>直接可以使用可执行文件进行启动&#x2F;停止&#x2F;重启</p>\n<pre><code class=\"bash\"># 启动\n/usr/local/nginx/sbin/nginx\n\n# 停止\n/usr/local/nginx/sbin/nginx -s stop\n\n# 重启\n/usr/local/nginx/sbin/nginx -s reload\n</code></pre>\n</li>\n<li><p>管理脚本</p>\n<pre><code class=\"bash\">$ vi /etc/init.d/nginx\n</code></pre>\n<p>输入如下内容:</p>\n<pre><code class=\"bash\">#!/bin/sh\n#\n# nginx - this script starts and stops the nginx daemon\n#\n# chkconfig:   - 85 15\n# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \\\n#               proxy and IMAP/POP3 proxy server\n# processname: nginx\n# config:      /usr/local/nginx/conf/nginx.conf\n# config:      /etc/sysconfig/nginx\n# pidfile:     /usr/local/nginx/logs/nginx.pid\n# Source function library.\n. /etc/rc.d/init.d/functions\n# Source networking configuration.\n. /etc/sysconfig/network\n# Check that networking is up.\n[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0\nnginx=&quot;/usr/local/nginx/sbin/nginx&quot;\nprog=$(basename $nginx)\nNGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;\n[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx\nlockfile=/var/lock/subsys/nginx\nmake_dirs() &#123;\n   # make required directories\n   user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &#39;s/[^*]*--user=\\([^ ]*\\).*/\\1/g&#39; -`\n   if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then\n       useradd -M -s /bin/nologin $user\n   fi\n   options=`$nginx -V 2&gt;&amp;1 | grep &#39;configure arguments:&#39;`\n   for opt in $options; do\n       if [ `echo $opt | grep &#39;.*-temp-path&#39;` ]; then\n           value=`echo $opt | cut -d &quot;=&quot; -f 2`\n           if [ ! -d &quot;$value&quot; ]; then\n               # echo &quot;creating&quot; $value\n               mkdir -p $value &amp;&amp; chown -R $user $value\n           fi\n       fi\n   done\n&#125;\nstart() &#123;\n    [ -x $nginx ] || exit 5\n    [ -f $NGINX_CONF_FILE ] || exit 6\n    make_dirs\n    echo -n $&quot;Starting $prog: &quot;\n    daemon $nginx -c $NGINX_CONF_FILE\n    retval=$?\n    echo\n    [ $retval -eq 0 ] &amp;&amp; touch $lockfile\n    return $retval\n&#125;\nstop() &#123;\n    echo -n $&quot;Stopping $prog: &quot;\n    killproc $prog -QUIT\n    retval=$?\n    echo\n    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile\n    return $retval\n&#125;\nrestart() &#123;\n    configtest || return $?\n    stop\n    sleep 1\n    start\n&#125;\nreload() &#123;\n    configtest || return $?\n    echo -n $&quot;Reloading $prog: &quot;\n    killproc $nginx -HUP\n    RETVAL=$?\n    echo\n&#125;\nforce_reload() &#123;\n    restart\n&#125;\nconfigtest() &#123;\n  $nginx -t -c $NGINX_CONF_FILE\n&#125;\nrh_status() &#123;\n    status $prog\n&#125;\nrh_status_q() &#123;\n    rh_status &gt;/dev/null 2&gt;&amp;1\n&#125;\ncase &quot;$1&quot; in\n    start)\n        rh_status_q &amp;&amp; exit 0\n        $1\n        ;;\n    stop)\n        rh_status_q || exit 0\n        $1\n        ;;\n    restart|configtest)\n        $1\n        ;;\n    reload)\n        rh_status_q || exit 7\n        $1\n        ;;\n    force-reload)\n        force_reload\n        ;;\n    status)\n        rh_status\n        ;;\n    condrestart|try-restart)\n        rh_status_q || exit 0\n            ;;\n    *)\n        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;\n        exit 2\nesac\n</code></pre>\n<p>添加开机启动：</p>\n<pre><code class=\"bash\"># 给予执行权限\nchmod a+x /etc/init.d/nginx\n\n# 设置开机启动\nchkconfig nginx on\n\n# 启动\nsystemctl start nginx\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Ubuntu安装方式\"><a href=\"#Ubuntu安装方式\" class=\"headerlink\" title=\"Ubuntu安装方式\"></a>Ubuntu安装方式</h4><ol>\n<li><p>在线方式</p>\n<pre><code class=\"bash\">sudo apt-get install nginx\n</code></pre>\n</li>\n<li><p>源码方式</p>\n<p>安装依赖</p>\n<pre><code class=\"bash\"># 安装gcc g++\nsudo apt-get install build-essential\nsudo apt-get install libtool\n\n# 安装pcre依赖库（http://www.pcre.org/）\nsudo apt-get update\nsudo apt-get install libpcre3 libpcre3-dev\n\n# 安装zlib依赖库（http://www.zlib.net）\nsudo apt-get install zlib1g-dev\n\n# 安装SSL依赖库（16.04默认已经安装了）\nsudo apt-get install openssl\n</code></pre>\n<p>下载源码启动:</p>\n<pre><code class=\"bash\"># 下载最新版本：\n# 下面的version可以改为对应的版本\n# http://nginx.org/download/nginx-1.17.0.tar.gz\nwget -O /tmp/nginx.tar.gz http://nginx.org/download/nginx-&lt;version&gt;.tar.gz\n\n# 解压：\ncd /tmp/\ntar -zxvf nginx.tar.gz\n\n# 进入解压目录：\ncd nginx-1.13.6\n\n# 配置：\n./configure --prefix=/usr/local/nginx \n\n# 编译：\nmake\n\n# 安装：\nsudo make install\n\n# 启动：\n#注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过-h查看帮助命令。\n#查看进程：\nsudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n# 查看进程启动状态\nps -ef | grep nginx\n</code></pre>\n</li>\n</ol>\n<h3 id=\"Nginx配置及优化\"><a href=\"#Nginx配置及优化\" class=\"headerlink\" title=\"Nginx配置及优化\"></a>Nginx配置及优化</h3><ol>\n<li>配置文件结构</li>\n</ol>\n<pre><code class=\"bash\">...              #全局块\n\nevents &#123;         #events块\n   ...\n&#125;\n\nhttp      #http块\n&#123;\n    ...   #http全局块--start\n    server        #server块\n    &#123; \n        ...       #server全局块\n        location [PATTERN]   #location块\n        &#123;\n            ...\n        &#125;\n        location [PATTERN] \n        &#123;\n            ...\n        &#125;\n    &#125;\n    server\n    &#123;\n      ...\n    &#125;\n    ...     #http全局块--end\n&#125;\n</code></pre>\n<ul>\n<li><strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>\n<li><strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>\n<li><strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>\n<li><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li>\n<li><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li>\n</ul>\n<ol start=\"2\">\n<li><p>配置优化</p>\n<p>配置文件：</p>\n<pre><code class=\"bash\">user www-data;\npid /run/nginx.pid;\n\n# worker_processes用来设置Nginx服务的进程数。推荐是CPU内核数或者内核数的倍数，推荐使用CPU内核数\nworker_processes 4;\n# 默认情况下，Nginx的多个进程有可能跑在某一个CPU或CPU的某一核上，导致Nginx进程使用硬件的资源不均\nworker_cpu_affinity 0001 0010 0100 1000;\n# 设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过worker_rlimit_nofile的值\nworker_rlimit_nofile 65535;\n\nevents &#123;\n                # 设置事件驱动模型，是内核2.6以上支持\n        use epoll;\n        worker_connections 65535;\n        accept_mutex off;\n        multi_accept off;\n&#125;\n\nhttp &#123;\n        ##\n        # Basic Settings\n        ##\n        sendfile on;\n        tcp_nopush on;\n        tcp_nodelay on;\n        keepalive_timeout 60 50;\n        send_timeout 10s;\n        types_hash_max_size 2048;\n        client_header_buffer_size 4k;\n        client_max_body_size 8m;\n        include /etc/nginx/mime.types;\n        default_type application/octet-stream;\n\n        ##\n        # Logging Settings\n        ##\n        access_log /var/log/nginx/access.log;\n        error_log /var/log/nginx/error.log;\n\n        ##\n        # Gzip Settings\n        ##\n        gzip on;\n        gzip_disable &quot;msie6&quot;;\n        gzip_min_length 1024;\n        gzip_vary on;\n        gzip_comp_level 2;\n        gzip_buffers 32 4k;\n        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n\n\n        ##\n        # Virtual Host Configs\n        ##\n        include /etc/nginx/conf.d/*.conf;\n        include /etc/nginx/sites-enabled/*;\n&#125;\n</code></pre>\n</li>\n</ol>\n<p>nginxs配置说明：</p>\n<ul>\n<li><code>worker_connections</code></li>\n</ul>\n<p>设置一个进程理论允许的最大连接数，理论上越大越好，但不可以超过worker_rlimit_nofile的值。还有个问题，linux系统中有个指令open file resource limit，它设置了进程可以打开的文件句柄数量，可以用下面的指令查看你的linux系统中open file resource limit指令的值，<code>cat /proc/sys/fs/file-max</code><br>   可以将该指令设置为23900251</p>\n<pre><code class=\"bash\">   echo &quot;2390251&quot; &gt; /proc/sys/fs/file-max\n   \n   sysctl -p\n</code></pre>\n<ol start=\"3\">\n<li><p>压测工具Apache ab</p>\n<p>我们要测试 nginx 的负载能力，需要借助压力测试工具。本博客是使用 Apache 服务器自带的一个 web 压力测试工具 ApacheBench ，简称 ab。ab 是一个命令行工具，即通过 <code>ab</code> 命令行，模拟多个请求同时对某一 URL 地址进行访问，因此可以用来测试目标服务器的负载压力。</p>\n<pre><code class=\"bash\">yum -y install httpd-tools\n\n# 查看安装结果\nab -V\n\n# 简单的使用\n# -c：一次并发请求的数量；-n：请求总次数\nab -c 5000 -n 200000 http://10.211.55.6：80/index.html\n</code></pre>\n</li>\n<li><p>其他优化</p>\n<pre><code class=\"bash\">net.ipv4.ip_forward = 0\nnet.ipv4.conf.default.rp_filter = 1\nnet.ipv4.conf.default.accept_source_route = 0\nkernel.sysrq = 0\nkernel.core_uses_pid = 1\n\n# 开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理。\nnet.ipv4.tcp_syncookies = 1\nkernel.msgmnb = 65536\nkernel.msgmax = 65536\nkernel.shmmax = 68719476736\nkernel.shmall = 4294967296\n\n# timewait的数量，默认是180000\nnet.ipv4.tcp_max_tw_buckets = 6000\nnet.ipv4.tcp_sack = 1\nnet.ipv4.tcp_window_scaling = 1\nnet.ipv4.tcp_rmem = 4096        87380   4194304\nnet.ipv4.tcp_wmem = 4096        16384   4194304\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\n\n# # 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。\nnet.core.netdev_max_backlog = 262144\n\n# web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义 的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值\nnet.core.somaxconn = 262144\n\n# 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅 是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。\nnet.ipv4.tcp_max_orphans = 3276800\n\n# 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。\nnet.ipv4.tcp_max_syn_backlog = 262144\n\n# 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。\nnet.ipv4.tcp_timestamps = 0\n\n# 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。\nnet.ipv4.tcp_synack_retries = 1\n\n# 在内核放弃建立连接之前发送SYN包的数量。\nnet.ipv4.tcp_syn_retries = 1\n\n# 启用timewait快速回收\nnet.ipv4.tcp_tw_recycle = 1\n\n# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_mem = 94500000 915000000 927000000\n\n# 如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。 2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。\nnet.ipv4.tcp_fin_timeout = 1\n\n# 当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时\nnet.ipv4.tcp_keepalive_time = 30\n\n# 允许系统打开的端口范围\nnet.ipv4.ip_local_port_range = 1024   65000\n</code></pre>\n</li>\n</ol>\n<h3 id=\"HTTP-s\"><a href=\"#HTTP-s\" class=\"headerlink\" title=\"HTTP(s)\"></a>HTTP(s)</h3><h4 id=\"HTTP-x2F-HTTPS协议\"><a href=\"#HTTP-x2F-HTTPS协议\" class=\"headerlink\" title=\"HTTP&#x2F;HTTPS协议\"></a>HTTP&#x2F;HTTPS协议</h4><p><strong>超文本传输协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>）是一种用于分布式、协作式和超媒体信息系统的应用层协议，HTTP是万维网的数据通信的基础。</p>\n<p><img data-src=\"/./assets/HTTP_Request.png\" alt=\"A basic HTTP request\"></p>\n<p>请求信息包括：请求行、请求头、空行还有其他消息体</p>\n<p><img data-src=\"/./assets/image-20190605153656594.png\" alt=\"/images/image-20190605153656594\"></p>\n<p>HTTP的特点：</p>\n<ul>\n<li><p>客户端&amp;服务端</p>\n</li>\n<li><p>简单(路径+方法+传递的类型)</p>\n<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n</li>\n<li><p>灵活</p>\n<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>\n</li>\n<li><p>无连接</p>\n<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n</li>\n<li><p>无状态有会话</p>\n<p>HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。</p>\n<p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>\n<blockquote>\n<p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p>\n</blockquote>\n</li>\n</ul>\n<p>HTTP 的不足之处</p>\n<ul>\n<li>通信内容使用明文——内容可能被窃听</li>\n<li>不验证通信方的身份——可能遭遇伪装</li>\n<li>无法验证报文的完整性——报文有可能已遭篡改</li>\n</ul>\n<p>HTTPS协议：</p>\n<p><strong>超文本传输安全协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure，缩写：<strong>HTTPS</strong>；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p>\n<p>主要作用：在不安全的网络上创建一个安全信道。</p>\n<h4 id=\"HTTPS认证原理\"><a href=\"#HTTPS认证原理\" class=\"headerlink\" title=\"HTTPS认证原理\"></a>HTTPS认证原理</h4><p>认证方式：数字证书</p>\n<p>认证机构：数字证书认证机构（Certificate Authority CA），EV SSL（Extended Validation SSL Certificate）证书，OpenSSL自认证。</p>\n<p>证书信任方式：</p>\n<ul>\n<li>操作系统和浏览器内置</li>\n<li>证书颁发机构</li>\n<li>手动指定证书</li>\n</ul>\n<p>SSL握手过程：</p>\n<p><img data-src=\"/./assets/1506390796205179.png\" alt=\"SSL\"></p>\n<h4 id=\"如何配置HTTPS\"><a href=\"#如何配置HTTPS\" class=\"headerlink\" title=\"如何配置HTTPS\"></a>如何配置HTTPS</h4><ol>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcv\">Let’s Encrypt</span>组织介绍</p>\n<p><img data-src=\"/./assets/image-20190605160738126.png\" alt=\"/images/image-20190605160738126\"></p>\n</li>\n<li><p>acme来自动化申请</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05laWxwYW5nL2FjbWUuc2g=\">https://github.com/Neilpang/acme.sh</span></p>\n<p>前提：需要域名</p>\n</li>\n</ol>\n<p>前置条件：</p>\n<ol>\n<li><p>域名, 配置DNS解析，支持列表见下方</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL05laWxwYW5nL2FjbWUuc2gvd2lraS9kbnNhcGk=\">https://github.com/Neilpang/acme.sh/wiki/dnsapi</span></p>\n</li>\n<li><p>有<strong>公网IP</strong>的服务器(可选)</p>\n</li>\n<li><p>安装nginx, acme.sh</p>\n</li>\n</ol>\n<p>配置过程：</p>\n<ol>\n<li><p>安装nginx与acme.sh</p>\n<p>安装很简单, 一个命令:</p>\n<pre><code class=\"bash\">curl  https://get.acme.sh | sh\n</code></pre>\n<blockquote>\n<p>普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>\n<p>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</p>\n<pre><code>~/.acme.sh/\n</code></pre>\n<p>并创建 一个 bash 的 alias, 方便你的使用: <code>alias acme.sh=~/.acme.sh/acme.sh</code></p>\n<p>自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书</p>\n</blockquote>\n<p>使用<code>source</code>命令，使上面的安装生效</p>\n<pre><code class=\"bash\">source ~/.bashrc\n</code></pre>\n</li>\n<li><p>两种方式，激活SSL证书(推荐DNS)</p>\n<ul>\n<li><p><strong>http 方式</strong></p>\n<p>需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了</p>\n<pre><code class=\"bash\">acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/\n</code></pre>\n<p>只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong> 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.</p>\n<p>如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong> 还可以智能的从 <strong>apache</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n<pre><code class=\"bash\">acme.sh --issue  -d mydomain.com   --apache\n</code></pre>\n<p>如果你用的 <strong>nginx</strong>服务器, 或者反代, <strong>acme.sh</strong> 还可以智能的从 <strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:</p>\n<pre><code class=\"bash\">acme.sh --issue  -d mydomain.com   --nginx\n</code></pre>\n</li>\n<li><p><strong>dns 方式</strong>(推荐)</p>\n<p>在域名上添加一条 txt 解析记录, 验证域名所有权。</p>\n<p>这种方式的好处是, 你不需要任何服务器, <strong>不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证</strong>. 坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>\n<pre><code class=\"bash\">acme.sh  --issue  --dns   -d mydomain.com\n</code></pre>\n<p>然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.</p>\n<p>等待解析完成之后, 重新生成证书:</p>\n<pre><code>acme.sh  --renew   -d mydomain.com\n</code></pre>\n<p>注意第二次这里用的是 <code>--renew</code></p>\n<p>dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.</p>\n<p><strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.</p>\n<p>以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的. 然后:</p>\n<pre><code>export DP_Id=&quot;1234&quot;\n\nexport DP_Key=&quot;sADDsdasdgdsf&quot;\n\nacme.sh   --issue   --dns dns_dp   -d aa.com  -d www.aa.com\n</code></pre>\n<p>证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>\n<pre><code>acme.sh  --issue   -d  mydomain2.com   --dns  dns_dp\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>配置nginx配置，设置定时任务</p>\n<p>生成dhparam.pem</p>\n<pre><code class=\"shell\">$ openssl dhparam -out dhparam.pem 2048\n</code></pre>\n<p>nginx中正确的使用方法是使用 <code>--installcert</code> 命令,并指定目标位置, 然后证书文件会被copy到相应的位置, 例如:</p>\n<pre><code class=\"bash\">acme.sh  --installcert  -d  &lt;domain&gt;.com   \\\n        --key-file   /etc/nginx/ssl/&lt;domain&gt;.key \\\n        --fullchain-file /etc/nginx/ssl/fullchain.cer \\\n        --reloadcmd  &quot;service nginx force-reload&quot;\n</code></pre>\n<p>配置文件：</p>\n<pre><code class=\"bash\"># server部分\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    ssl on;\n    ssl_certificate         /etc/nginx/ssl/fullchain.cer;\n    ssl_certificate_key     /etc/nginx/ssl/&lt;domain&gt;.key;\n    # ssl_dhparam\n    ssl_dhparam             /etc/nginx/ssl/dhparam.pem;\n</code></pre>\n</li>\n<li><p>对网站的SSL进行检验</p>\n<p>推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zc2xsYWJzLmNvbS9zc2x0ZXN0L2FuYWx5emUuaHRtbA==\">https://ssllabs.com/ssltest/analyze.html</span></p>\n</li>\n<li><p>其他需要注意的地方：</p>\n<ul>\n<li>域名备案</li>\n<li>防火墙</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h2><h3 id=\"阿里云ECS\"><a href=\"#阿里云ECS\" class=\"headerlink\" title=\"阿里云ECS\"></a>阿里云ECS</h3><h4 id=\"虚拟化技术原理\"><a href=\"#虚拟化技术原理\" class=\"headerlink\" title=\"虚拟化技术原理\"></a>虚拟化技术原理</h4><p><strong>虚拟化</strong>：在计算机技术中，虚拟化（技术）或虚拟技术（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分区、组合为一个或多个电脑配置环境。</p>\n<p><img data-src=\"/./assets/img_adfcd9149ec08e90df41492ecb18b900.png\" alt=\"img\"></p>\n<p>主要的目的：降低成本，提高应用兼容性，提高服务可用性，提升资源复用率。</p>\n<p>虚拟化分类：</p>\n<p>主要有全虚拟化和半虚拟化。</p>\n<p>典型的全虚拟化软件有 —— VMWare、Hyper-V、KVM-x86(复杂指令集)。</p>\n<p>典型的半虚拟化软件有——Xen、KVM-PowerPC(简易指令集）</p>\n<p>参考资料：<span class=\"exturl\" data-url=\"aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzQ4ODY3\">虚拟化的发展历程和实现原理——图文详解</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3ZpcnR1YWwuNTFjdG8uY29tL2FydC8yMDE4MDMvNTY5MjI4Lmh0bQ==\">虚拟化类型</span></p>\n<h4 id=\"如何选择云服务器\"><a href=\"#如何选择云服务器\" class=\"headerlink\" title=\"如何选择云服务器\"></a>如何选择云服务器</h4><ol>\n<li><p>从硬件</p>\n<p>使用阿里云的工具进行筛选，需要登录，链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lY3MtYnV5LmFsaXl1bi5jb20vaW5zdGFuY2VUeXBlcw==\">ECS 实例规格可购买地域总览</span></p>\n<p><img data-src=\"/./assets/image-20190604221840417.png\" alt=\"/images/image-20190604221840417\"></p>\n</li>\n<li><p>从网络</p>\n<p><img data-src=\"/./assets/eZZfERlwBRWjZOGtmwVO.png\" alt=\"Explanation\"></p>\n<p>云服务器 ECS 的入网带宽和出网带宽皆以服务器角度出发。下表给出了入网带宽和出网带宽的具体内容：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">带宽类别 （Mbit&#x2F;s）</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">入网带宽</td>\n<td align=\"left\">流入云服务器 ECS 的带宽 从云服务器 ECS 内部下载外部网络资源，或者从客户端 FTP 等方式上传资源到云服务器 ECS 都是入网带宽。</td>\n</tr>\n<tr>\n<td align=\"left\">出网带宽</td>\n<td align=\"left\">流出云服务器 ECS 的带宽 从云服务器 ECS 对外提供访问，或者从客户端 FTP 等方式下载云服务器 ECS 内部资源都是出网带宽，云服务器 ECS 出网带宽就是购买的带宽值。</td>\n</tr>\n</tbody></table>\n<p>推荐公司使用固定带宽，对于测试用户或者流量比较小的用户使用按量计费带宽。</p>\n<p>举例应用场景：公司网站展示类型(按量计费)，视频(固定带宽)</p>\n<p>后期还可以购买CDN加速，分担静态资源的流量。</p>\n</li>\n<li><p>从地域</p>\n<p>每个地域完全独立。每个可用区完全隔离，但同一个地域内的可用区之间使用低时延链路相连。地域和可用区之间的关系如下图所示。</p>\n<p><img data-src=\"/./assets/155788672444660_zh-CN.jpg\" alt=\"img\"></p>\n<ul>\n<li><p>中国大陆</p>\n<p>一般情况下建议选择和您目标用户所在地域最为接近的数据中心，可以进一步提升用户访问速度。不过，在基础设施、BGP 网络品质、服务质量、云服务器操作使用与配置等方面，阿里云中国大陆地域没有太大区别。BGP 网络可以保证中国大陆全部地域的快速访问。</p>\n</li>\n<li><p>其他国家及地区</p>\n<p>其他国家及地区提供国际带宽，主要面向非中国大陆地区用户。如果您在中国大陆，使用这些地域会有较长的访问延迟，不建议您使用。</p>\n<ul>\n<li>对香港、东南亚有需求的用户，可以选择香港地域、亚太东南 1 地域、亚太东南 3 地域或亚太东南 5 地域。</li>\n<li>对日、韩有需求的用户，可以选择亚太东北 1 地域。</li>\n<li>对印度有需求的用户，可以选择亚太南部 1 地域。</li>\n<li>对澳大利亚地区有需求的用户，可以选择亚太东南 2 地域。</li>\n<li>对美洲有需求用户，可以选择美国地域。</li>\n<li>对欧洲大陆有需求的用户，可以选择欧洲中部 1 地域。</li>\n<li>对中东地区有需求的用户，可以选择中东东部 1 地域。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>从费用</p>\n</li>\n</ol>\n<h4 id=\"云服务器购买\"><a href=\"#云服务器购买\" class=\"headerlink\" title=\"云服务器购买\"></a>云服务器购买</h4><h4 id=\"认识控制台\"><a href=\"#认识控制台\" class=\"headerlink\" title=\"认识控制台\"></a>认识控制台</h4><h3 id=\"云数据库RDS\"><a href=\"#云数据库RDS\" class=\"headerlink\" title=\"云数据库RDS\"></a>云数据库RDS</h3><h4 id=\"云数据库介绍\"><a href=\"#云数据库介绍\" class=\"headerlink\" title=\"云数据库介绍\"></a>云数据库介绍</h4><ol>\n<li><p>基本概念</p>\n<p>阿里云系产品：云数据库RDS（ApsaraDB for RDS，简称RDS）是一种稳定可靠、可弹性伸缩的在线数据库服务。基于飞天分布式系统和全SSD盘高性能存储，支持MySQL、SQL Server、PostgreSQL和PPAS（高度兼容Oracle)引擎，默认部署主备架构且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案，彻底解决数据库运维的烦恼！</p>\n<p>亚马逊系产品：Amazon Relational Database Service (Amazon RDS) 让您能够在云中轻松设置、操作和扩展关系数据库。它在自动执行耗时的管理任务（如<strong>硬件预置、数据库设置、修补和备份</strong>）的同时，可提供经济实用的可调容量。这使您能够腾出时间专注于应用程序，为它们提供所需的快速性能、高可用性、安全性和兼容性。</p>\n<p>Amazon RDS 在多种类型的数据库实例（针对内存、性能或 I&#x2F;O 进行了优化的实例）上均可用，并提供六种常用的数据库引擎供您选择，包括 Amazon Aurora、PostgreSQL、MySQL、MariaDB、Oracle Database 和 SQL Server。您可以使用 AWS Database Migration Service <strong>轻松</strong>将您现有的<strong>数据库迁移或复制到 Amazon RDS</strong>。</p>\n</li>\n<li><p>特点：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>轻松管理</td>\n<td>GUI页面，从部署到生产数据库</td>\n</tr>\n<tr>\n<td>可扩展</td>\n<td>修改CPU&#x2F;内存&#x2F;存储资源</td>\n</tr>\n<tr>\n<td>高可用</td>\n<td>自动备份、快照 、自动主机更换</td>\n</tr>\n<tr>\n<td>速度快</td>\n<td>可选SSD</td>\n</tr>\n<tr>\n<td>安全</td>\n<td>可建立专网，或者连接到使用VPN</td>\n</tr>\n<tr>\n<td>经济</td>\n<td>网络成本、运维成本都低</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p><strong>本课程中使用亚马逊的RDS作为演示</strong></p>\n<h4 id=\"常见RDS-MySQL购买与操作\"><a href=\"#常见RDS-MySQL购买与操作\" class=\"headerlink\" title=\"常见RDS-MySQL购买与操作\"></a>常见RDS-MySQL购买与操作</h4><ol>\n<li><p>购买地址</p>\n<p>阿里云：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi5hbGl5dW4uY29tL3Byb2R1Y3QvcmRz\">https://cn.aliyun.com/product/rds</span></p>\n<p><img data-src=\"/./assets/image-20190605084317131.png\" alt=\"/images/image-20190605084317131\"></p>\n<p>亚马逊：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9yZHMv\">https://aws.amazon.com/cn/rds/</span></p>\n<p><img data-src=\"/./assets/image-20190605084341568.png\" alt=\"/images/image-20190605084341568\"></p>\n</li>\n<li><p>操作面板介绍(以亚马逊为主)</p>\n</li>\n</ol>\n<h4 id=\"备份与快照\"><a href=\"#备份与快照\" class=\"headerlink\" title=\"备份与快照\"></a>备份与快照</h4><h3 id=\"负载均衡SLB\"><a href=\"#负载均衡SLB\" class=\"headerlink\" title=\"负载均衡SLB\"></a>负载均衡SLB</h3><h4 id=\"什么是负载均衡\"><a href=\"#什么是负载均衡\" class=\"headerlink\" title=\"什么是负载均衡\"></a>什么是负载均衡</h4><p>负载均衡（Server Load Balancer）是对多台云服务器进行流量<strong>分发</strong>的负载均衡服务。负载均衡可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。</p>\n<h4 id=\"SLB功能介绍\"><a href=\"#SLB功能介绍\" class=\"headerlink\" title=\"SLB功能介绍\"></a>SLB功能介绍</h4><p>负载均衡通过设置虚拟服务地址，将添加的ECS实例虚拟成一个高性能、高可用的应用服务池，并根据转发规则，将来自客户端的请求分发给云服务器池中的ECS实例。</p>\n<p>负载均衡默认检查云服务器池中的ECS实例的健康状态，自动隔离异常状态的ECS实例，消除了单台ECS实例的单点故障，提高了应用的整体服务能力。此外，负载均衡还具备抗DDoS攻击的能力，增强了应用服务的防护能力。</p>\n<p>基本的功能：</p>\n<ol>\n<li><p><strong>调度</strong></p>\n<p><strong>负载均衡支持轮询、加权轮询（WRR）、加权最小连接数（WLC）和一致性哈希（CH）调度算法。</strong></p>\n</li>\n<li><p>健康检查 </p>\n<p>负载均衡会检查后端服务器的运行状况。当探测到后端服务器运行状况不佳时，会停止向其发送流量，然后将流量转发给其他正常运行的后端服务器。</p>\n</li>\n<li><p>会话保持</p>\n<p>负载均衡提供会话保持功能。在会话的生命周期内，可以将同一客户端的请求转发到同一台后端服务器上。</p>\n</li>\n<li><p>访问控制</p>\n</li>\n<li><p>高可用</p>\n<p>负载均衡可以将流量转发给多个可用区的后端服务器。并且，负载均衡已经在大部分地域支持了多可用区部署，当主可用区出现故障时，负载均衡可自动切换到备可用区上提供服务。</p>\n<p>业务场景二：</p>\n<p><img data-src=\"/./assets/1555309011947_zh-CN.png\" alt=\"img\"></p>\n</li>\n<li><p>安全防护</p>\n<p>结合云盾，可提供5Gbps的防DDoS攻击能力。</p>\n</li>\n<li><p>监控</p>\n</li>\n<li><p>证书管理</p>\n</li>\n<li><p>重定向</p>\n</li>\n<li><p>WS&#x2F;WSS支持</p>\n</li>\n<li><p>HTTP&#x2F;2支持</p>\n<p>HTTP&#x2F;2（Hypertext Transfer Protocol Version 2）是超文本传输协议的第二版，向下兼容HTTP1.X协议版本，同时带来性能的大幅提升。</p>\n</li>\n</ol>\n<h4 id=\"SLB技术架构\"><a href=\"#SLB技术架构\" class=\"headerlink\" title=\"SLB技术架构\"></a>SLB技术架构</h4><p><img data-src=\"http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4091/1551152011936_zh-CN.png\" alt=\"img\"></p>\n<h4 id=\"阿里云SLB购买与操作\"><a href=\"#阿里云SLB购买与操作\" class=\"headerlink\" title=\"阿里云SLB购买与操作\"></a>阿里云SLB购买与操作</h4><h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p><strong>A记录</strong>： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录</p>\n<p><strong>CNAME记录</strong>： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名</p>\n<p><strong>MX记录</strong>： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</p>\n<p><strong>NS记录</strong>： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录</p>\n<p><strong>TXT记录</strong>： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</p>\n<p><strong>AAAA记录</strong>： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录</p>\n<p><strong>SRV记录</strong>： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</p>\n<p><strong>SOA记录</strong>： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器</p>\n<p><strong>PTR记录</strong>： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</p>\n<h3 id=\"DNS解析中一些问题\"><a href=\"#DNS解析中一些问题\" class=\"headerlink\" title=\"DNS解析中一些问题\"></a>DNS解析中一些问题</h3><h4 id=\"A记录与CNAME记录\"><a href=\"#A记录与CNAME记录\" class=\"headerlink\" title=\"A记录与CNAME记录\"></a>A记录与CNAME记录</h4><p><code>A记录</code>是把一个域名解析到一个IP地址，而<code>CNAME记录</code>是把域名解析到另外一个域名，而这个域名最终会指向一个A记录，在功能实现在上<code>A记录</code>与<code>CNAME记录</code>没有区别。</p>\n<p><code>CNAME记录</code>在做IP地址变更时要比<code>A记录</code>方便。<code>CNAME记录</code>允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即：CNAME)到A记录的域名上。当服务器IP地址变更时，只需要更改A记录的那个域名到新IP上，其它做别名的域名会自动更改到新的IP地址上，而不必对每个域名做更改。</p>\n<h4 id=\"A记录与AAAA记录\"><a href=\"#A记录与AAAA记录\" class=\"headerlink\" title=\"A记录与AAAA记录\"></a>A记录与AAAA记录</h4><p>二者都是指向一个IP地址，但对应的IP版本不同。<code>A记录</code>指向<code>IPv4</code>地址，<code>AAAA记录</code>指向<code>IPv6</code>地址。<code>AAAA记录</code>是<code>A记录</code>的升级版本。</p>\n<h4 id=\"IPv4与IPv6\"><a href=\"#IPv4与IPv6\" class=\"headerlink\" title=\"IPv4与IPv6\"></a>IPv4与IPv6</h4><p><code>IPv4</code>，是互联网协议（Internet Protocol，IP）的第四版，也是第一个被广泛使用的版本，是构成现今互联网技术的基础协议。<code>IPv4</code> 的下一个版本就是<code>IPv6</code>，在将来将取代目前被广泛使用的<code>IPv4</code>。</p>\n<p><code>IPv4</code>中规定IP地址长度为32位（按TCP&#x2F;IP参考模型划分) ，即有2^32-1个地址。<code>IPv6</code>的提出最早是为了解决，随着互联网的迅速发展<code>IPv4</code>地址空间将被耗尽的问题。为了扩大地址空间，<code>IPv6</code>将IP地址的长度由32位增加到了128位。在<code>IPv6</code>的设计过程中除了一劳永逸地解决了地址短缺问题以外，还解决了<code>IPv4</code>中的其它问题，如：端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p>\n<h4 id=\"TTL值\"><a href=\"#TTL值\" class=\"headerlink\" title=\"TTL值\"></a>TTL值</h4><p><code>TTL</code>－生存时间（Time To Live），表示解析记录在DNS服务器中的缓存时间，<code>TTL</code>的时间长度单位是秒，一般为3600秒。比如：在访问<code>www.itcast.cn</code>时，如果在DNS服务器的缓存中没有该记录，就会向某个NS服务器发出请求，获得该记录后，该记录会在DNS服务器上保存<code>TTL</code>的时间长度，在<code>TTL</code>有效期内访问<code>www.itcast.cn</code>，DNS服务器会直接缓存中返回刚才的记录。</p>\n<h3 id=\"shell脚本入门\"><a href=\"#shell脚本入门\" class=\"headerlink\" title=\"shell脚本入门\"></a>shell脚本入门</h3><p>推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL3NoZWxsLXF1aWNrLXN0YXJ0Lmh0bWw=\">https://www.runoob.com/w3cnote/shell-quick-start.html</span></p>\n<h3 id=\"vim编辑器入门\"><a href=\"#vim编辑器入门\" class=\"headerlink\" title=\"vim编辑器入门\"></a>vim编辑器入门</h3><p>推荐：<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDczMzA4OQ==\">https://zhuanlan.zhihu.com/p/34733089</span></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"node.js内置模块","url":"/2024/01/02/node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/","content":"<h1 id=\"05-【nodejs内置模块（上）】\"><a href=\"#05-【nodejs内置模块（上）】\" class=\"headerlink\" title=\"05 【nodejs内置模块（上）】\"></a>05 【nodejs内置模块（上）】</h1><h2 id=\"nodejs-的官方API文档\"><a href=\"#nodejs-的官方API文档\" class=\"headerlink\" title=\"nodejs 的官方API文档\"></a>nodejs 的官方API文档</h2><ul>\n<li>Node.js 的API文档（英文）： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0LXY4LngvYXBpL2luZGV4Lmh0bWw=\">https://nodejs.org/docs/latest-v8.x/api/index.html</span></li>\n<li>Node.js 的API文档（中文）：<span class=\"exturl\" data-url=\"aHR0cDovL25vZGVqcy5jbi9hcGkv\">http://nodejs.cn/api/</span></li>\n</ul>\n<p>关于 Node.js 的内置模块和常见API，可以看官方文档。</p>\n<p>查阅文档时，稳定指数如下：</p>\n<ul>\n<li>红色：废弃。</li>\n<li>橙色：实验。表示当前版本可用，其他版本不确定。也许不向下兼容，建议不要在生产环境中使用该特性。</li>\n<li>绿色：稳定。与 npm 生态系统的兼容性是最高的优先级。</li>\n</ul>\n<h2 id=\"nodejs-中模块的分类\"><a href=\"#nodejs-中模块的分类\" class=\"headerlink\" title=\"nodejs 中模块的分类\"></a>nodejs 中模块的分类</h2><p>Node.js 应用由模块组成，采用 CommonJS 模块规范。Node.js中的模块分为三种：</p>\n<ul>\n<li>内置模块</li>\n<li>第三方模块</li>\n<li>自定义模块</li>\n</ul>\n<p>下面简单介绍一下。</p>\n<h3 id=\"内置模块\"><a href=\"#内置模块\" class=\"headerlink\" title=\"内置模块\"></a>内置模块</h3><pre><code class=\"javascript\">const process = require(&#39;process&#39;);\nconst path = require(&#39;path&#39;);\n\nconsole.log(process.version);\nconsole.log(path.resolve(&#39;../&#39;));\n</code></pre>\n<p>require方法用于加载模块。</p>\n<p>常见的内置模块包括：</p>\n<ul>\n<li>FS：文件系统模块</li>\n<li>path：路径模块</li>\n<li>OS：操作系统相关</li>\n<li>net：网络相关</li>\n<li>http</li>\n<li>…</li>\n</ul>\n<p>你可能会有疑问：Node.js 这么牛吗？还能直接和操作系统做交互？</p>\n<p>带着这个疑问，我们不妨简单看看 Node.js 的源码，以 os 模块举例：</p>\n<ul>\n<li>打开os模块的源码：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9vcy5qcyVFRiVCQyU4QyVFNyVCRiVCQiVFNSU4OCVCMCVFNiU5QyU4MCVFNSVCQSU5NSVFOSU4MyVBOCVFRiVCQyU4QyVFNiU4OSVCRSVFNSU4OCVCMA==\">https://github.com/nodejs/node/blob/master/lib/os.js，翻到最底部，找到</span> <code>cpus</code>这个方法</li>\n<li>进而找到 <code>getCPUs()</code></li>\n<li>internalBinding(‘os’)：通过 internalBinding 可以调用系统底层的方法。internalBinding 主要是 JS 虚拟机在做的事情。</li>\n<li><code>internalBinding(&#39;os&#39;)</code> 的实现，在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL3NyYy9ub2RlX29zLmNj\">https://github.com/nodejs/node/blob/master/src/node_os.cc</span> 里，里面都是 C++ 的代码。比如有一个<code>getCPUs</code>方法。</li>\n</ul>\n<p>现在你知道了，JS本身是没有能力获取底层系统资源的，这一切都是 JS虚拟机在和底层做交互，然后通过 JS 的表现形式，暴露给应用层。</p>\n<p>另外，还有很多库，是直接使用C&#x2F;++编写的，通过编译之后，再提供给 JS 应用层调用，或者直接提供给 Node.js层使用。</p>\n<p>**所有的编程语言底层都会回归C&#x2F;C++**，甚至是汇编语言。</p>\n<h3 id=\"require-加载第三方包的机制\"><a href=\"#require-加载第三方包的机制\" class=\"headerlink\" title=\"require 加载第三方包的机制\"></a>require 加载第三方包的机制</h3><pre><code class=\"javascript\">const express = require(&#39;express&#39;);\n</code></pre>\n<p>require 加载第三方包的机制：</p>\n<p>（1）第三方包安装好后，这个包一般会存放在当前项目的 node_modules 文件夹中。我们找到这个包的 package.json 文件，并且找到里面的main属性对应的入口模块，这个入口模块就是这个包的入口文件。</p>\n<p>（2）如果第三方包中没有找到package.json文件，或者package.json文件中没有main属性，则默认加载第三方包中的index.js文件。</p>\n<p>（3）如果在 node_modules 文件夹中没有找到这个包，或者以上所有情况都没有找到，则会向上一级父级目录下查找node_modules文件夹，查找规则如上一致。</p>\n<p>（4）如果一直找到该模块的磁盘根路径都没有找到，则会报错：can not find module xxx。</p>\n<h3 id=\"自定义模块（module）\"><a href=\"#自定义模块（module）\" class=\"headerlink\" title=\"自定义模块（module）\"></a>自定义模块（module）</h3><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>\n<p>举例：</p>\n<pre><code class=\"javascript\">var example = require(&#39;./example.js&#39;);\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n</code></pre>\n<h2 id=\"网络服务-http\"><a href=\"#网络服务-http\" class=\"headerlink\" title=\"网络服务 http\"></a>网络服务 http</h2><h3 id=\"http模块概览\"><a href=\"#http模块概览\" class=\"headerlink\" title=\"http模块概览\"></a>http模块概览</h3><p>大多数nodejs开发者都是冲着开发web server的目的选择了nodejs。正如官网所展示的，借助http模块，可以几行代码就搞定一个超迷你的web server。</p>\n<p>在nodejs中，<code>http</code>可以说是最核心的模块，同时也是比较复杂的一个模块。上手很简单，但一旦深入学习，不少初学者就会觉得头疼，不知从何入手。</p>\n<p>本文先从一个简单的例子出发，引出<code>http</code>模块最核心的四个实例。看完本文，应该就能够对http模块有个整体的认识。</p>\n<h3 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h3><p>在下面的例子中，我们创建了1个web服务器、1个http客户端</p>\n<ul>\n<li>服务器server：接收来自客户端的请求，并将客户端请求的地址返回给客户端。</li>\n<li>客户端client：向服务器发起请求，并将服务器返回的内容打印到控制台。</li>\n</ul>\n<p>代码如下所示，只有几行，但包含了不少信息量。下一小节会进行简单介绍。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\n\n// http server 例子\nvar server = http.createServer(function(serverReq, serverRes)&#123;\n    var url = serverReq.url;\n    serverRes.end( &#39;您访问的地址是：&#39; + url );\n&#125;);\n\nserver.listen(3000);\n\n// http client 例子\nvar client = http.get(&#39;http://127.0.0.1:3000&#39;, function(clientRes)&#123;\n    clientRes.pipe(process.stdout);\n&#125;);\n</code></pre>\n<h3 id=\"例子解释\"><a href=\"#例子解释\" class=\"headerlink\" title=\"例子解释\"></a>例子解释</h3><p>在上面这个简单的例子里，涉及了4个实例。大部分时候，serverReq、serverRes 才是主角。</p>\n<ul>\n<li>server：http.Server实例，用来提供服务，处理客户端的请求。</li>\n<li>client：http.ClientReques实例，用来向服务端发起请求。</li>\n<li>serverReq&#x2F;clientRes：其实都是 http.IncomingMessage实例。serverReq 用来获取客户端请求的相关信息，如request header；而clientRes用来获取服务端返回的相关信息，比如response header。</li>\n<li>serverRes：http.ServerResponse实例</li>\n</ul>\n<h3 id=\"关于http-IncomingMessage、http-ServerResponse\"><a href=\"#关于http-IncomingMessage、http-ServerResponse\" class=\"headerlink\" title=\"关于http.IncomingMessage、http.ServerResponse\"></a>关于http.IncomingMessage、http.ServerResponse</h3><p>先讲下 http.ServerResponse 实例。作用很明确，服务端通过http.ServerResponse 实例，来个请求方发送数据。包括发送响应表头，发送响应主体等。</p>\n<p>接下来是 http.IncomingMessage 实例，由于在 server、client 都出现了，初学者难免有点迷茫。它的作用是</p>\n<p>在server端：获取请求发送方的信息，比如请求方法、路径、传递的数据等。 在client端：获取 server 端发送过来的信息，比如请求方法、路径、传递的数据等。</p>\n<p>http.IncomingMessage实例 有三个属性需要注意：method、statusCode、statusMessage。</p>\n<ul>\n<li>method：只在 server 端的实例有（也就是 serverReq.method）</li>\n<li>statusCode&#x2F;statusMessage：只在 client 端 的实例有（也就是 clientRes.method）</li>\n</ul>\n<h2 id=\"网络服务-http-res\"><a href=\"#网络服务-http-res\" class=\"headerlink\" title=\"网络服务 http res\"></a>网络服务 http res</h2><h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>http模块四剑客之一的<code>res</code>，应该都不陌生了。一个web服务程序，接受到来自客户端的http请求后，向客户端返回正确的响应内容，这就是<code>res</code>的职责。</p>\n<p>返回的内容包括：状态代码&#x2F;状态描述信息、响应头部、响应主体。下文会举几个简单的例子。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\nvar server = http.createServer(function(req, res)&#123;\n    res.end(&#39;ok&#39;);\n&#125;);\nserver.listen(3000);\n</code></pre>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>在下面的例子中，我们同时设置了 状态代码&#x2F;状态描述信息、响应头部、响应主体，就是这么简单。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\n\n// 设置状态码、状态描述信息、响应主体\nvar server = http.createServer(function(req, res)&#123;\n    res.writeHead(200, &#39;ok&#39;, &#123;\n        &#39;Content-Type&#39;: &#39;text/plain&#39;\n    &#125;);\n    res.end(&#39;hello&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<h3 id=\"设置状态代码、状态描述信息\"><a href=\"#设置状态代码、状态描述信息\" class=\"headerlink\" title=\"设置状态代码、状态描述信息\"></a>设置状态代码、状态描述信息</h3><p><code>res</code>提供了 res.writeHead()、res.statusCode&#x2F;res.statusMessage 来实现这个目的。</p>\n<p>举例，如果想要设置 200&#x2F;ok ，可以</p>\n<pre><code class=\"javascript\">res.writeHead(200, &#39;ok&#39;);\n</code></pre>\n<p>也可以</p>\n<pre><code class=\"javascript\">res.statusCode = 200;\nres.statusMessage = &#39;ok&#39;;\n</code></pre>\n<p>两者差不多，差异点在于</p>\n<ol>\n<li>res.writeHead() 可以提供额外的功能，比如设置响应头部。</li>\n<li>当响应头部发送出去后，res.statusCode&#x2F;res.statusMessage 会被设置成已发送出去的 状态代码&#x2F;状态描述信息。</li>\n</ol>\n<h3 id=\"设置响应头部\"><a href=\"#设置响应头部\" class=\"headerlink\" title=\"设置响应头部\"></a>设置响应头部</h3><p><code>res</code>提供了 res.writeHead()、response.setHeader() 来实现响应头部的设置。</p>\n<p>举例，比如想把 <code>Content-Type</code> 设置为 <code>text-plain</code>，那么可以</p>\n<pre><code class=\"javascript\">// 方法一\nres.writeHead(200, &#39;ok&#39;, &#123;\n    &#39;Content-Type&#39;: &#39;text-plain&#39;\n&#125;);\n\n// 方法二\nres.setHeader(&#39;Content-Type&#39;, &#39;text-plain&#39;);\n</code></pre>\n<p>两者的差异点在哪里呢？</p>\n<ol>\n<li>res.writeHead() 不单单是设置header。</li>\n<li>已经通过 res.setHeader() 设置了header，当通过 res.writeHead() 设置同名header，res.writeHead() 的设置会覆盖之前的设置。</li>\n</ol>\n<p>关于第2点差异，这里举个例子。下面代码，最终的 <code>Content-Type</code> 为 <code>text/plain</code>。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n    res.writeHead(200, &#39;ok&#39;, &#123;\n        &#39;Content-Type&#39;: &#39;text/plain&#39;\n    &#125;);\n    res.end(&#39;hello&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>而下面的例子，则直接报错。报错信息为 <code>Error: Can&#39;t set headers after they are sent.</code>。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\n\nvar server = http.createServer(function(req, res)&#123;    \n    res.writeHead(200, &#39;ok&#39;, &#123;\n        &#39;Content-Type&#39;: &#39;text/plain&#39;\n    &#125;);\n    res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);\n    res.end(&#39;hello&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<h3 id=\"其他响应头部操作\"><a href=\"#其他响应头部操作\" class=\"headerlink\" title=\"其他响应头部操作\"></a>其他响应头部操作</h3><p>增、删、改、查 是配套的。下面分别举例说明下，例子太简单就直接上代码了。</p>\n<pre><code class=\"javascript\">// 增\nres.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\n\n// 删\nres.removeHeader(&#39;Content-Type&#39;);\n\n// 改\nres.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\nres.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);  // 覆盖\n\n// 查\nres.getHeader(&#39;content-type&#39;);\n</code></pre>\n<p>其中略显不同的是 res.getHeader(name)，name 用的是小写，返回值没做特殊处理。</p>\n<pre><code class=\"javascript\">res.setHeader(&#39;Content-Type&#39;, &#39;TEXT/HTML&#39;);\nconsole.log( res.getHeader(&#39;content-type&#39;) );  // TEXT/HTML\n\nres.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);\nconsole.log( res.getHeader(&#39;content-type&#39;) );  // text/plain\n</code></pre>\n<p>此外，还有不那么常用的：</p>\n<ul>\n<li>res.headersSent：header是否已经发送；</li>\n<li>res.sendDate：默认为true。但为true时，会在response header里自动设置Date首部。</li>\n</ul>\n<h3 id=\"设置响应主体\"><a href=\"#设置响应主体\" class=\"headerlink\" title=\"设置响应主体\"></a>设置响应主体</h3><p>主要用到 res.write() 以及 res.end() 两个方法。</p>\n<p>res.write() API的信息量略大，建议看下<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9yZXNwb25zZV93cml0ZV9jaHVua19lbmNvZGluZ19jYWxsYmFjaw==\">官方文档</span>。</p>\n<h4 id=\"response-write-chunk-encoding-callback\"><a href=\"#response-write-chunk-encoding-callback\" class=\"headerlink\" title=\"response.write(chunk[, encoding][, callback])\"></a>response.write(chunk[, encoding][, callback])</h4><ul>\n<li>chunk：响应主体的内容，可以是string，也可以是buffer。当为string时，encoding参数用来指明编码方式。（默认是utf8）</li>\n<li>encoding：编码方式，默认是 utf8。</li>\n<li>callback：当响应体flushed时触发。（TODO 这里想下更好的解释。。。）</li>\n</ul>\n<p>使用上没什么难度，只是有些注意事项：</p>\n<ol>\n<li>如果 res.write() 被调用时， res.writeHead() 还没被调用过，那么，就会把header flush出去。</li>\n<li>res.write() 可以被调用多次。</li>\n<li>当 res.write(chunk) 第一次被调用时，node 会将 header 信息 以及 chunk 发送到客户端。第二次调用 res.write(chunk) ，node 会认为你是要streaming data（WTF，该怎么翻译）。。。</li>\n</ol>\n<blockquote>\n<p>Returns true if the entire data was flushed successfully to the kernel buffer. Returns false if all or part of the data was queued in user memory. ‘drain’ will be emitted when the buffer is free again.</p>\n</blockquote>\n<h4 id=\"response-end-data-encoding-callback\"><a href=\"#response-end-data-encoding-callback\" class=\"headerlink\" title=\"response.end([data][, encoding][, callback])\"></a>response.end([data][, encoding][, callback])</h4><p>掌握了 res.write() 的话，res.end() 就很简单了。res.end() 的用处是告诉nodejs，header、body都给你了，这次响应就到这里吧。</p>\n<p>有点像个语法糖，可以看成下面两个调用的组合。至于callback，当响应传递结束后触发。</p>\n<pre><code class=\"javascript\">res.write(data, encoding);\nres.end()\n</code></pre>\n<h3 id=\"超时处理\"><a href=\"#超时处理\" class=\"headerlink\" title=\"超时处理\"></a>超时处理</h3><p>接口：response.setTimeout(msecs, callback)</p>\n<p>关于 timeout 事件的说明，同样是言简意赅（WTF），话少信息量大，最好来个demo TODO</p>\n<blockquote>\n<p>If no ‘timeout’ listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If you assign a handler on the request, the response, or the server’s ‘timeout’ events, then it is your responsibility to handle timed out sockets.</p>\n</blockquote>\n<h3 id=\"事件-close-x2F-finish\"><a href=\"#事件-close-x2F-finish\" class=\"headerlink\" title=\"事件 close&#x2F;finish\"></a>事件 close&#x2F;finish</h3><ul>\n<li>close：response.end() 被调用前，连接就断开了。此时会触发这个事件。</li>\n<li>finish：响应header、body都已经发送出去（交给操作系统，排队等候传输），但客户端是否实际收到数据为止。（这个事件后，res 上就不会再有其他事件触发）</li>\n</ul>\n<h3 id=\"其他不常用属性-x2F-方法\"><a href=\"#其他不常用属性-x2F-方法\" class=\"headerlink\" title=\"其他不常用属性&#x2F;方法\"></a>其他不常用属性&#x2F;方法</h3><ul>\n<li>response.finished：一开始是false，响应结束后，设置为true。</li>\n<li>response.sendDate：默认是true。是否自动设置Date头部。（按HTTP协议是必须要的，除非是调试用，不然不要设置为false）</li>\n<li>response.headersSent：只读属性。响应头部是否已发送。</li>\n<li>response.writeContinue()：发送 HTTP&#x2F;1.1 100 Continue 消息给客户端，提示说服务端愿意接受客户端的请求，请继续发送请求正文（body)。（TODO 做个demo啥的是大大的好）</li>\n</ul>\n<h2 id=\"网络服务-http-req\"><a href=\"#网络服务-http-req\" class=\"headerlink\" title=\"网络服务 http req\"></a>网络服务 http req</h2><h3 id=\"概览-1\"><a href=\"#概览-1\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>本文的重点会放在<code>req</code>这个对象上。前面已经提到，它其实是http.IncomingMessage实例，在服务端、客户端作用略微有差异</p>\n<ul>\n<li>服务端处：获取请求方的相关信息，如request header等。</li>\n<li>客户端处：获取响应方返回的相关信息，如statusCode等。</li>\n</ul>\n<p>服务端例子：</p>\n<pre><code class=\"javascript\">// 下面的 req\nvar http = require(&#39;http&#39;);\nvar server = http.createServer(function(req, res)&#123;\n    console.log(req.headers);\n    res.end(&#39;ok&#39;);\n&#125;);\nserver.listen(3000);\n</code></pre>\n<p>客户端例子</p>\n<pre><code class=\"javascript\">// 下面的res\nvar http = require(&#39;http&#39;);\nhttp.get(&#39;http://127.0.0.1:3000&#39;, function(res)&#123;\n    console.log(res.statusCode);\n&#125;);\n</code></pre>\n<h3 id=\"属性-x2F-方法-x2F-事件-分类\"><a href=\"#属性-x2F-方法-x2F-事件-分类\" class=\"headerlink\" title=\"属性&#x2F;方法&#x2F;事件 分类\"></a>属性&#x2F;方法&#x2F;事件 分类</h3><p>http.IncomingMessage的属性&#x2F;方法&#x2F;事件 不是特别多，按照是否客户端&#x2F;服务端 特有的，下面进行简单归类。可以看到</p>\n<ul>\n<li>服务端处特有：url</li>\n<li>客户端处特有：statusCode、statusMessage</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"center\">名称</th>\n<th align=\"center\">服务端</th>\n<th align=\"center\">客户端</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">事件</td>\n<td align=\"center\">aborted</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">事件</td>\n<td align=\"center\">close</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">headers</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">rawHeaders</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">statusCode</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">statusMessage</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">httpVersion</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">url</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"center\">socket</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">方法</td>\n<td align=\"center\">.destroy()</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n<tr>\n<td align=\"left\">方法</td>\n<td align=\"center\">.setTimeout()</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n</tr>\n</tbody></table>\n<h3 id=\"服务端的例子\"><a href=\"#服务端的例子\" class=\"headerlink\" title=\"服务端的例子\"></a>服务端的例子</h3><h4 id=\"例子一：获取httpVersion-x2F-method-x2F-url\"><a href=\"#例子一：获取httpVersion-x2F-method-x2F-url\" class=\"headerlink\" title=\"例子一：获取httpVersion&#x2F;method&#x2F;url\"></a>例子一：获取httpVersion&#x2F;method&#x2F;url</h4><p>下面是一个典型的HTTP请求报文，里面最重要的内容包括：HTTP版本、请求方法、请求地址、请求头部。</p>\n<pre><code class=\"http\">GET /hello HTTP/1.1\nHost: 127.0.0.1:3000\nConnection: keep-alive\nCache-Control: no-cache\n</code></pre>\n<p>那么，如何获取上面提到的信息呢？很简单，直接上代码</p>\n<pre><code class=\"javascript\">// getClientInfo.js\nvar http = require(&#39;http&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    console.log( &#39;1、客户端请求url：&#39; + req.url );\n    console.log( &#39;2、http版本：&#39; + req.httpVersion );\n    console.log( &#39;3、http请求方法：&#39; + req.method );\n    console.log( &#39;4、http请求头部&#39; + JSON.stringify(req.headers) );\n\n    res.end(&#39;ok&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>效果如下：</p>\n<pre><code class=\"bash\">1、客户端请求url：/hello\n2、http版本：1.1\n3、http请求方法：GET\n4、http headers：&#123;&quot;host&quot;:&quot;127.0.0.1:3000&quot;,&quot;connection&quot;:&quot;keep-alive&quot;,&quot;cache-control&quot;:&quot;no-cache&quot;,&quot;user-age\n</code></pre>\n<h4 id=\"例子二：获取get请求参数\"><a href=\"#例子二：获取get请求参数\" class=\"headerlink\" title=\"例子二：获取get请求参数\"></a>例子二：获取get请求参数</h4><p>服务端代码如下：</p>\n<pre><code class=\"javascript\">// getClientGetQuery.js\nvar http = require(&#39;http&#39;);\nvar url = require(&#39;url&#39;);\nvar querystring = require(&#39;querystring&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    var urlObj = url.parse(req.url);\n    var query = urlObj.query;\n    var queryObj = querystring.parse(query);\n    \n    console.log( JSON.stringify(queryObj) );\n    \n    res.end(&#39;ok&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>访问地址 <span class=\"exturl\" data-url=\"aHR0cDovLzEyNy4wLjAuMTozMDAwL2hlbGxvP25pY2s9Y2h5aW5ncCZoZWxsbz13b3JsZA==\">http://127.0.0.1:3000/hello?nick=chyingp&amp;hello=world</span></p>\n<p>服务端输出如下</p>\n<pre><code class=\"bash\">&#123;&quot;nick&quot;:&quot;chyingp&quot;,&quot;hello&quot;:&quot;world&quot;&#125;\n</code></pre>\n<h4 id=\"例子三：获取post请求参数\"><a href=\"#例子三：获取post请求参数\" class=\"headerlink\" title=\"例子三：获取post请求参数\"></a>例子三：获取post请求参数</h4><p>服务端代码如下</p>\n<pre><code class=\"javascript\">// getClientPostBody.js\nvar http = require(&#39;http&#39;);\nvar url = require(&#39;url&#39;);\nvar querystring = require(&#39;querystring&#39;);\n\nvar server = http.createServer(function(req, res)&#123;\n    \n    var body = &#39;&#39;;  \n    req.on(&#39;data&#39;, function(thunk)&#123;\n        body += thunk;\n    &#125;);\n\n    req.on(&#39;end&#39;, function()&#123;\n        console.log( &#39;post body is: &#39; + body );\n        res.end(&#39;ok&#39;);\n    &#125;); \n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>通过curl构造post请求：</p>\n<pre><code class=\"bash\">curl -d &#39;nick=casper&amp;hello=world&#39; http://127.0.0.1:3000\n</code></pre>\n<p>服务端打印如下：</p>\n<pre><code class=\"bash\">post body is: nick=casper&amp;hello=world\n</code></pre>\n<p>备注：post请求中，不同的<code>Content-type</code>，post body有不小差异，感兴趣的同学可以研究下。</p>\n<p>本例中的post请求，HTTP报文大概如下</p>\n<pre><code class=\"http\">POST / HTTP/1.1\nHost: 127.0.0.1:3000\nContent-Type: application/x-www-form-urlencoded\nCache-Control: no-cache\n\nnick=casper&amp;hello=world\n</code></pre>\n<h2 id=\"网络服务-https\"><a href=\"#网络服务-https\" class=\"headerlink\" title=\"网络服务 https\"></a>网络服务 https</h2><h3 id=\"模块概览\"><a href=\"#模块概览\" class=\"headerlink\" title=\"模块概览\"></a>模块概览</h3><p>这个模块的重要性，基本不用强调了。在网络安全问题日益严峻的今天，网站采用HTTPS是个必然的趋势。</p>\n<p>在nodejs中，提供了 https 这个模块来完成 HTTPS 相关功能。从官方文档来看，跟 http 模块用法非常相似。</p>\n<p>本文主要包含两部分：</p>\n<ol>\n<li>通过客户端、服务端的例子，对https模块进行入门讲解。</li>\n<li>如何访问安全证书不受信任的网站。（以 12306 为例子）</li>\n</ol>\n<p>篇幅所限，本文无法对 HTTPS协议 及 相关技术体系 做过多讲解，有问题欢迎留言交流。</p>\n<h3 id=\"客户端例子\"><a href=\"#客户端例子\" class=\"headerlink\" title=\"客户端例子\"></a>客户端例子</h3><p>跟http模块的用法非常像，只不过请求的地址是https协议的而已，代码如下：</p>\n<pre><code class=\"javascript\">var https = require(&#39;https&#39;);\n\nhttps.get(&#39;https://www.baidu.com&#39;, function(res)&#123;\n    console.log(&#39;status code: &#39; + res.statusCode);\n    console.log(&#39;headers: &#39; + JSON.stringify(res.headers));\n\n    res.on(&#39;data&#39;, function(data)&#123;\n        process.stdout.write(data);\n    &#125;);\n&#125;).on(&#39;error&#39;, function(err)&#123;\n    console.error(err);\n&#125;);\n</code></pre>\n<h3 id=\"服务端例子\"><a href=\"#服务端例子\" class=\"headerlink\" title=\"服务端例子\"></a>服务端例子</h3><p>对外提供HTTPS服务，需要有HTTPS证书。如果你已经有了HTTPS证书，那么可以跳过证书生成的环节。如果没有，可以参考如下步骤</p>\n<h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><p><strong>1.创建个目录存放证书。</strong></p>\n<pre><code class=\"bash\">mkdir cert\ncd cert\n</code></pre>\n<p><strong>2.生成私钥。</strong></p>\n<pre><code class=\"text\">openssl genrsa -out chyingp-key.pem 2048\n</code></pre>\n<p><strong>3.生成证书签名请求（csr是 Certificate Signing Request的意思）。</strong></p>\n<pre><code class=\"text\">openssl req -new \\\n  -sha256\n  -key chyingp-key.key.pem \\\n  -out chyingp-csr.pem \\\n  -subj &quot;/C=CN/ST=Guandong/L=Shenzhen/O=YH Inc/CN=www.chyingp.com&quot;\n</code></pre>\n<p><strong>4.生成证书。</strong></p>\n<pre><code class=\"text\">openssl x509 \\\n  -req -in chyingp-csr.pem \\\n  -signkey chyingp-key.pem \\\n  -out chyingp-cert.pem\n</code></pre>\n<h4 id=\"HTTPS服务端\"><a href=\"#HTTPS服务端\" class=\"headerlink\" title=\"HTTPS服务端\"></a>HTTPS服务端</h4><p>代码如下：</p>\n<pre><code class=\"javascript\">var https = require(&#39;https&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar options = &#123;\n    key: fs.readFileSync(&#39;./cert/chyingp-key.pem&#39;), // 私钥\n    cert: fs.readFileSync(&#39;./cert/chyingp-cert.pem&#39;) // 证书\n&#125;;\n\nvar server = https.createServer(options, function(req, res)&#123;\n    res.end(&#39;这是来自HTTPS服务器的返回&#39;);\n&#125;);\n\nserver.listen(3000);\n</code></pre>\n<p>由于我并没有 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jaHlpbmdwLmNvbS8=\">www.chyingp.com</span> 这个域名，于是先配置本地host</p>\n<pre><code class=\"text\">127.0.0.1 www.chyingp.com\n</code></pre>\n<p>启动服务，并在浏览器里访问 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jaHlpbmdwLmNvbTozMDAwLw==\">http://www.chyingp.com:3000</span>。注意，浏览器会提示你证书不可靠，点击 信任并继续访问 就行了。</p>\n<h2 id=\"URL-接口-代替内置模块url使用\"><a href=\"#URL-接口-代替内置模块url使用\" class=\"headerlink\" title=\"URL 接口(代替内置模块url使用)\"></a>URL 接口(代替内置模块url使用)</h2><blockquote>\n<p>nodejs内置模块<code>url</code>有些方法要被废弃，我们使用<code>URL类</code>代替</p>\n</blockquote>\n<p>浏览器原生提供<code>URL()</code>接口，它是一个构造函数，用来构造、解析和编码 URL。一般情况下，通过<code>window.URL</code>可以拿到这个构造函数。</p>\n<h3 id=\"7-1-对比url模块和URL类\"><a href=\"#7-1-对比url模块和URL类\" class=\"headerlink\" title=\"7.1 对比url模块和URL类\"></a>7.1 对比<code>url模块</code>和URL类</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>url模块</th>\n<th>URL类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protocol</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>host</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>port</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>hostname</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>search</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>query</td>\n<td><code>✅</code></td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td>path</td>\n<td><code>✅</code></td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td>pathname</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>href</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>hash</td>\n<td><code>✅</code></td>\n<td><code>✅</code></td>\n</tr>\n<tr>\n<td>origin</td>\n<td>-</td>\n<td><code>✅</code></td>\n</tr>\n</tbody></table>\n<p>可以看出来，只有三个字段不同，分别是<code>query</code>,<code>path</code>,<code>origin</code></p>\n<pre><code class=\"javascript\">打印两个对象的输出\n\n// url模块，url.parse(&#39;link&#39;)\n&#123;\n  protocol: &#39;https:&#39;,\n  slashes: true,\n  auth: null,\n  host: &#39;m.shop.com&#39;,\n  port: null,\n  hostname: &#39;m.shop.com&#39;,\n  hash: &#39;#detail&#39;,\n  search: &#39;?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  query: &#39;id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  pathname: &#39;/home/share&#39;,\n  path: &#39;/home/share?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  href: &#39;https://m.shop.com/home/share?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099#detail&#39;\n&#125;\n// new URL()\n&#123;\n  href: &#39;https://m.shop.com/home/share?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099#detail&#39;,\n  origin: &#39;https://m.shop.com&#39;,\n  protocol: &#39;https:&#39;,\n  username: &#39;&#39;,\n  password: &#39;&#39;,\n  host: &#39;m.shop.com&#39;,\n  hostname: &#39;m.shop.com&#39;,\n  port: &#39;&#39;,\n  pathname: &#39;/home/share&#39;,\n  search: &#39;?id=4433&amp;name=%E6%9D%8E%E5%A4%87&amp;directCompanyId=&amp;mobile=18951431099&#39;,\n  searchParams: URLSearchParams &#123;\n    &#39;id&#39; =&gt; &#39;4433&#39;,\n    &#39;name&#39; =&gt; &#39;李备&#39;,\n    &#39;directCompanyId&#39; =&gt; &#39;&#39;,\n    &#39;mobile&#39; =&gt; &#39;18951431099&#39; &#125;,\n  hash: &#39;#detail&#39;\n&#125;\n</code></pre>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><code>URL()</code>作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。</p>\n<pre><code class=\"javascript\">var url = new URL(&#39;http://www.example.com/index.html&#39;);\nurl.href\n// &quot;http://www.example.com/index.html&quot;\n</code></pre>\n<p>上面示例生成了一个 URL 实例，用来代表指定的网址。</p>\n<p>除了字符串，<code>URL()</code>的参数也可以是另一个 URL 实例。这时，<code>URL()</code>会自动读取该实例的<code>href</code>属性，作为实际参数。</p>\n<p>如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p>\n<pre><code class=\"javascript\">var url1 = new URL(&#39;index.html&#39;, &#39;http://example.com&#39;);\nurl1.href\n// &quot;http://example.com/index.html&quot;\n\nvar url2 = new URL(&#39;page2.html&#39;, &#39;http://example.com/page1.html&#39;);\nurl2.href\n// &quot;http://example.com/page2.html&quot;\n\nvar url3 = new URL(&#39;..&#39;, &#39;http://example.com/a/b.html&#39;)\nurl3.href\n// &quot;http://example.com/&quot;\n</code></pre>\n<p>上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是<code>..</code>，表示上层路径。</p>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><p>URL 实例的属性与<code>Location</code>对象的属性基本一致，返回当前 URL 的信息。</p>\n<ul>\n<li>URL.href：返回整个 URL</li>\n<li>URL.protocol：返回协议，以冒号<code>:</code>结尾</li>\n<li>URL.hostname：返回域名</li>\n<li>URL.host：返回域名与端口，包含<code>:</code>号，默认的80和443端口会省略</li>\n<li>URL.port：返回端口</li>\n<li>URL.origin：返回协议、域名和端口</li>\n<li>URL.pathname：返回路径，以斜杠<code>/</code>开头</li>\n<li>URL.search：返回查询字符串，以问号<code>?</code>开头</li>\n<li>URL.searchParams：返回一个<code>URLSearchParams</code>实例，该属性是<code>Location</code>对象没有的</li>\n<li>URL.hash：返回片段识别符，以井号<code>#</code>开头</li>\n<li>URL.password：返回域名前面的密码</li>\n<li>URL.username：返回域名前面的用户名</li>\n</ul>\n<pre><code class=\"javascript\">var url = new URL(&#39;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&#39;);\n\nurl.href\n// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;\nurl.protocol\n// &quot;http:&quot;\nurl.hostname\n// &quot;www.example.com&quot;\nurl.host\n// &quot;www.example.com:4097&quot;\nurl.port\n// &quot;4097&quot;\nurl.origin\n// &quot;http://www.example.com:4097&quot;\nurl.pathname\n// &quot;/path/a.html&quot;\nurl.search\n// &quot;?x=111&quot;\nurl.searchParams\n// URLSearchParams &#123;&#125;\nurl.hash\n// &quot;#part1&quot;\nurl.password\n// &quot;passwd&quot;\nurl.username\n// &quot;user&quot;\n</code></pre>\n<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写，并且会立即生效。</p>\n<pre><code class=\"javascript\">var url = new URL(&#39;http://example.com/index.html#part1&#39;);\n\nurl.pathname = &#39;index2.html&#39;;\nurl.href // &quot;http://example.com/index2.html#part1&quot;\n\nurl.hash = &#39;#part2&#39;;\nurl.href // &quot;http://example.com/index2.html#part2&quot;\n</code></pre>\n<p>上面代码中，改变 URL 实例的<code>pathname</code>属性和<code>hash</code>属性，都会实时反映在 URL 实例当中。</p>\n<h2 id=\"URLSearchParams-对象-代替内置模块querystring使用\"><a href=\"#URLSearchParams-对象-代替内置模块querystring使用\" class=\"headerlink\" title=\"URLSearchParams 对象(代替内置模块querystring使用)\"></a>URLSearchParams 对象(代替内置模块querystring使用)</h2><blockquote>\n<ol>\n<li><p>nodejs内置模块<code>querystring</code>有些方法要被废弃，我们使用<code>URLSearchParams API </code>构造代替</p>\n</li>\n<li><p>如果你的nodejs版本大于18，可以使用<code>const querystring= require(&#39;node:querystring&#39;)</code><br>&#96;&#96;querystring<code>比</code>URLSearchParams<code>性能更高，但不是 标准化的 API。使用</code>URLSearchParams&#96;当性能不重要或 当需要与浏览器代码兼容时。</p>\n</li>\n<li><p>还可以安装<code>qs</code>模块，使用方式和<code>querystring</code>一样</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><code>URLSearchParams</code>对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p>\n<p>它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号<code>?</code>有没有都行，也可以是对应查询字符串的数组或对象。</p>\n<pre><code class=\"javascript\">// 方法一：传入字符串\nvar params = new URLSearchParams(&#39;?foo=1&amp;bar=2&#39;);\n// 等同于\nvar params = new URLSearchParams(document.location.search);\n\n// 方法二：传入数组\nvar params = new URLSearchParams([[&#39;foo&#39;, 1], [&#39;bar&#39;, 2]]);\n\n// 方法三：传入对象\nvar params = new URLSearchParams(&#123;&#39;foo&#39; : 1 , &#39;bar&#39; : 2&#125;);\n</code></pre>\n<p><code>URLSearchParams</code>会对查询字符串自动编码。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#123;&#39;foo&#39;: &#39;你好&#39;&#125;);\nparams.toString() // &quot;foo=%E4%BD%A0%E5%A5%BD&quot;\n</code></pre>\n<p>上面代码中，<code>foo</code>的值是汉字，<code>URLSearchParams</code>对其自动进行 URL 编码。</p>\n<p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据。</p>\n<pre><code class=\"javascript\">const params = new URLSearchParams(&#123;foo: 1, bar: 2&#125;);\nfetch(&#39;https://example.com/api&#39;, &#123;\n  method: &#39;POST&#39;,\n  body: params\n&#125;).then(...)\n</code></pre>\n<p>上面代码中，<code>fetch</code>命令向服务器发送命令时，可以直接使用<code>URLSearchParams</code>实例。</p>\n<p><code>URLSearchParams</code>可以与<code>URL()</code>接口结合使用。</p>\n<pre><code class=\"javascript\">var url = new URL(window.location);\nvar foo = url.searchParams.get(&#39;foo&#39;) || &#39;somedefault&#39;;\n</code></pre>\n<p>上面代码中，URL 实例的<code>searchParams</code>属性就是一个<code>URLSearchParams</code>实例，所以可以使用<code>URLSearchParams</code>接口的<code>get</code>方法。</p>\n<p><code>URLSearchParams</code>实例有遍历器接口，可以用<code>for...of</code>循环遍历。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);\n\nfor (var p of params) &#123;\n  console.log(p[0] + &#39;: &#39; + p[1]);\n&#125;\n// foo: 1\n// bar: 2\n</code></pre>\n<p><code>URLSearchParams</code>没有实例属性，只有实例方法。</p>\n<h3 id=\"URLSearchParams-toString\"><a href=\"#URLSearchParams-toString\" class=\"headerlink\" title=\"URLSearchParams.toString()\"></a>URLSearchParams.toString()</h3><p><code>toString</code>方法返回实例的字符串形式。</p>\n<pre><code class=\"javascript\">var url = new URL(&#39;https://example.com?foo=1&amp;bar=2&#39;);\nvar params = new URLSearchParams(url.search);\n\nparams.toString() // &quot;foo=1&amp;bar=2&#39;\n</code></pre>\n<p>那么需要字符串的场合，会自动调用<code>toString</code>方法。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#123;version: 2.0&#125;);\nwindow.location.href = location.pathname + &#39;?&#39; + params;\n</code></pre>\n<p>上面代码中，<code>location.href</code>赋值时，可以直接使用<code>params</code>对象。这时就会自动调用<code>toString</code>方法。</p>\n<h3 id=\"URLSearchParams-has\"><a href=\"#URLSearchParams-has\" class=\"headerlink\" title=\"URLSearchParams.has()\"></a>URLSearchParams.has()</h3><p><code>has()</code>方法返回一个布尔值，表示查询字符串是否包含指定的键名。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);\nparams.has(&#39;bar&#39;) // true\nparams.has(&#39;baz&#39;) // false\n</code></pre>\n<h3 id=\"URLSearchParams-get-，URLSearchParams-getAll\"><a href=\"#URLSearchParams-get-，URLSearchParams-getAll\" class=\"headerlink\" title=\"URLSearchParams.get()，URLSearchParams.getAll()\"></a>URLSearchParams.get()，URLSearchParams.getAll()</h3><p><code>get()</code>方法用来读取查询字符串里面的指定键。它接受键名作为参数。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#39;?foo=1&#39;);\nparams.get(&#39;foo&#39;) // &quot;1&quot;\nparams.get(&#39;bar&#39;) // null\n</code></pre>\n<p>两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是<code>null</code>。</p>\n<p>如果有多个的同名键，<code>get</code>返回位置最前面的那个键值。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#39;?foo=3&amp;foo=2&amp;foo=1&#39;);\nparams.get(&#39;foo&#39;) // &quot;3&quot;\n</code></pre>\n<p>上面代码中，查询字符串有三个<code>foo</code>键，<code>get</code>方法返回最前面的键值<code>3</code>。</p>\n<p><code>getAll()</code>方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#39;?foo=1&amp;foo=2&#39;);\nparams.getAll(&#39;foo&#39;) // [&quot;1&quot;, &quot;2&quot;]\n</code></pre>\n<p>上面代码中，查询字符串有两个<code>foo</code>键，<code>getAll</code>返回的数组就有两个成员。</p>\n<h3 id=\"URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries\"><a href=\"#URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries\" class=\"headerlink\" title=\"URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()\"></a>URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</h3><p>这三个方法都返回一个遍历器对象，供<code>for...of</code>循环遍历。它们的区别在于，<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</p>\n<pre><code class=\"javascript\">var params = new URLSearchParams(&#39;a=1&amp;b=2&#39;);\n\nfor(var p of params.keys()) &#123;\n  console.log(p);\n&#125;\n// a\n// b\n\nfor(var p of params.values()) &#123;\n  console.log(p);\n&#125;\n// 1\n// 2\n\nfor(var p of params.entries()) &#123;\n  console.log(p);\n&#125;\n// [&quot;a&quot;, &quot;1&quot;]\n// [&quot;b&quot;, &quot;2&quot;]\n</code></pre>\n<p>如果直接对<code>URLSearchParams</code>进行遍历，其实内部调用的就是<code>entries</code>接口。</p>\n<pre><code class=\"javascript\">for (var p of params) &#123;&#125;\n// 等同于\nfor (var p of params.entries()) &#123;&#125;\n</code></pre>\n<h2 id=\"qs模块\"><a href=\"#qs模块\" class=\"headerlink\" title=\"qs模块\"></a>qs模块</h2><p>qs是一个npm仓库所管理的包,可通过npm install qs命令进行安装.</p>\n<ol>\n<li>qs.parse()将URL解析成对象的形式</li>\n<li>qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接</li>\n</ol>\n<pre><code class=\"javascript\">const qs = require(&#39;qs&#39;);\n\n1.qs.parse()\nconst str = &quot;username=&#39;admin&#39;&amp;password=&#39;123456&#39;&quot;;\nconsole.log(qs.parse(str)); \n// Object &#123; username: &quot;admin&quot;, password: &quot;123456&quot; &#125;\n\n2.qs.stringify()\nconst a = qs.stringify(&#123; username: &#39;admin&#39;, password: &#39;123456&#39; &#125;);\nconsole.log(a); \n// username=admin&amp;password=123456\n</code></pre>\n<pre><code class=\"javascript\">qs.stringify() 和JSON.stringify()有什么区别?\n\nvar a = &#123;name:&#39;hehe&#39;,age:10&#125;;\nqs.stringify序列化结果如\nname=hehe&amp;age=10\n--------------------\n而JSON.stringify序列化结果如下：\n&quot;&#123;&quot;a&quot;:&quot;hehe&quot;,&quot;age&quot;:10&#125;&quot;\n</code></pre>\n<h1 id=\"06-【nodejs内置模块（中）】\"><a href=\"#06-【nodejs内置模块（中）】\" class=\"headerlink\" title=\"06 【nodejs内置模块（中）】\"></a>06 【nodejs内置模块（中）】</h1><h2 id=\"1-路劲处理模块-path\"><a href=\"#1-路劲处理模块-path\" class=\"headerlink\" title=\"1.路劲处理模块 path\"></a>1.路劲处理模块 path</h2><h3 id=\"1-1-模块概览\"><a href=\"#1-1-模块概览\" class=\"headerlink\" title=\"1.1 模块概览\"></a>1.1 模块概览</h3><p>在nodejs中，path是个使用频率很高，但却让人又爱又恨的模块。部分因为文档说的不够清晰，部分因为接口的平台差异性。</p>\n<p>将path的接口按照用途归类，仔细琢磨琢磨，也就没那么费解了。</p>\n<h3 id=\"1-2-获取路径-x2F-文件名-x2F-扩展名\"><a href=\"#1-2-获取路径-x2F-文件名-x2F-扩展名\" class=\"headerlink\" title=\"1.2 获取路径&#x2F;文件名&#x2F;扩展名\"></a>1.2 获取路径&#x2F;文件名&#x2F;扩展名</h3><ul>\n<li>获取路径：path.dirname(filepath)</li>\n<li>获取文件名：path.basename(filepath)</li>\n<li>获取扩展名：path.extname(filepath)</li>\n</ul>\n<h4 id=\"1-2-1-获取所在路径\"><a href=\"#1-2-1-获取所在路径\" class=\"headerlink\" title=\"1.2.1 获取所在路径\"></a>1.2.1 获取所在路径</h4><p>例子如下：</p>\n<pre><code class=\"javascript\">var path = require(&#39;path&#39;);\nvar filepath = &#39;/tmp/demo/js/test.js&#39;;\n\n// 输出：/tmp/demo/js\nconsole.log( path.dirname(filepath) );\n</code></pre>\n<h4 id=\"1-2-2-获取文件名\"><a href=\"#1-2-2-获取文件名\" class=\"headerlink\" title=\"1.2.2 获取文件名\"></a>1.2.2 获取文件名</h4><p>严格意义上来说，path.basename(filepath) 只是输出路径的最后一部分，并不会判断是否文件名。</p>\n<p>但大部分时候，我们可以用它来作为简易的“获取文件名“的方法。</p>\n<pre><code class=\"javascript\">var path = require(&#39;path&#39;);\n\n// 输出：test.js\nconsole.log( path.basename(&#39;/tmp/demo/js/test.js&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/tmp/demo/js/test/&#39;) );\n\n// 输出：test\nconsole.log( path.basename(&#39;/tmp/demo/js/test&#39;) );\n</code></pre>\n<p>如果只想获取文件名，单不包括文件扩展呢？可以用上第二个参数。</p>\n<pre><code class=\"javascript\">// 输出：test\nconsole.log( path.basename(&#39;/tmp/demo/js/test.js&#39;, &#39;.js&#39;) );\n</code></pre>\n<h4 id=\"1-2-3-获取文件扩展名\"><a href=\"#1-2-3-获取文件扩展名\" class=\"headerlink\" title=\"1.2.3 获取文件扩展名\"></a>1.2.3 获取文件扩展名</h4><p>简单的例子如下：</p>\n<pre><code class=\"javascript\">var path = require(&#39;path&#39;);\nvar filepath = &#39;/tmp/demo/js/test.js&#39;;\n\n// 输出：.js\nconsole.log( path.extname(filepath) );\n</code></pre>\n<p>更详细的规则是如下：（假设 path.basename(filepath) &#x3D;&#x3D;&#x3D; B ）</p>\n<ul>\n<li>从B的最后一个<code>.</code>开始截取，直到最后一个字符。</li>\n<li>如果B中不存在<code>.</code>，或者B的第一个字符就是<code>.</code>，那么返回空字符串。</li>\n</ul>\n<p>直接看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYXRoLmh0bWwjcGF0aF9wYXRoX2V4dG5hbWVfcGF0aA==\">官方文档</span>的例子</p>\n<pre><code class=\"javascript\">path.extname(&#39;index.html&#39;)\n// returns &#39;.html&#39;\n\npath.extname(&#39;index.coffee.md&#39;)\n// returns &#39;.md&#39;\n\npath.extname(&#39;index.&#39;)\n// returns &#39;.&#39;\n\npath.extname(&#39;index&#39;)\n// returns &#39;&#39;\n\npath.extname(&#39;.index&#39;)\n// returns &#39;&#39;\n</code></pre>\n<h3 id=\"1-3-路径组合\"><a href=\"#1-3-路径组合\" class=\"headerlink\" title=\"1.3 路径组合\"></a>1.3 路径组合</h3><ul>\n<li>path.join([…paths])</li>\n<li>path.resolve([…paths])</li>\n</ul>\n<h4 id=\"1-3-1-path-resolve-生成完成的绝对路径\"><a href=\"#1-3-1-path-resolve-生成完成的绝对路径\" class=\"headerlink\" title=\"1.3.1 path.resolve() 生成完成的绝对路径\"></a>1.3.1 path.resolve() 生成完成的绝对路径</h4><p>语法格式：</p>\n<pre><code class=\"javascript\">path.resolve([...myPaths])\n</code></pre>\n<p>解释：</p>\n<ul>\n<li>将路径或路径片段的序列解析为绝对路径。</li>\n<li>返回的路径是<strong>从右往左</strong>处理，后面的每个 myPath 被依次解析，直到构造出一个完整的绝对路径。</li>\n</ul>\n<blockquote>\n<p>你可以想象现在你在shell下面，从左到右运行一遍<code>cd path</code>命令，最终获取的绝对路径&#x2F;文件名，就是这个接口所返回的结果了。</p>\n</blockquote>\n<p>代码举例：</p>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\n\nlet arr1 = [&#39;/foo1/foo2&#39;, &#39;dselegent&#39;, &#39;foo3&#39;];\nlet result1 = path.resolve(...arr1);\nconsole.log(result1); // 打印结果：/foo1/foo2/dselegent/foo3\n\nlet arr2 = [&#39;/foo1/foo2&#39;, &#39;/dselegent&#39;, &#39;foo3&#39;];\nlet result2 = path.resolve(...arr2);\nconsole.log(result2); // 打印结果：/dselegent/foo3\n</code></pre>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\n\n// 假设当前工作路径是 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path\n\n// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path\nconsole.log( path.resolve(&#39;&#39;) )\n\n// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path\nconsole.log( path.resolve(&#39;.&#39;) )\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;) );\n\n// 输出 /foo/bar/baz\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;./baz/&#39;) );\n\n// 输出 /tmp/file\nconsole.log( path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;) );\n\n// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path/www/js/mod.js\nconsole.log( path.resolve(&#39;www&#39;, &#39;js/upload&#39;, &#39;../mod.js&#39;) );\n</code></pre>\n<h4 id=\"1-3-2-path-join-将多个路径进行拼接\"><a href=\"#1-3-2-path-join-将多个路径进行拼接\" class=\"headerlink\" title=\"1.3.2 path.join() 将多个路径进行拼接\"></a>1.3.2 path.join() 将多个路径进行拼接</h4><p>如果是我们手动拼接路径，容易出错。这个时候，可以利用 path.join() 方法将路径进行拼接。</p>\n<p>语法格式：</p>\n<pre><code class=\"javascript\">path.join([...paths]);\n</code></pre>\n<p>解释：使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。</p>\n<p>代码举例：</p>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\n\nconst result1 = path.join(__dirname, &#39;./app.js&#39;);\nconsole.log(result1); // 返回：/Users/smyhvae/dselegent/app.js\n\nconst result2 = path.join(&#39;/foo1&#39;, &#39;foo2&#39;, &#39;./foo3&#39;);\nconsole.log(result2); // 返回：/foo1/foo2/foo3\n\nconst result3 = path.join(&#39;/foo1&#39;, &#39;foo2&#39;, &#39;/foo3&#39;);\nconsole.log(result3); // 返回：/foo1/foo2/foo3\n</code></pre>\n<h4 id=\"1-3-3-path-resolve-和-path-join-区别\"><a href=\"#1-3-3-path-resolve-和-path-join-区别\" class=\"headerlink\" title=\"1.3.3 path.resolve 和 path.join 区别\"></a>1.3.3 path.resolve 和 path.join 区别</h4><p>path.resolve 和 path.join 都是属于 path 核心模块下的方法，用来拼接路径。</p>\n<p>都可以拼接成一个完整路径.</p>\n<pre><code class=\"javascript\">const path = require(&quot;path&quot;);\n\nvar dirname = &#39;/User/Desktop&#39;;\nvar basename = &#39;abc.txt&#39;;\n\npath.join(dirname, basename);  // /User/Desktop/abc.txt\n\npath.resolve(dirname, basename);  // /User/Desktop/abc.txt\n</code></pre>\n<p>如果 dirname 是以 .&#x2F; 、..&#x2F;、不加 &#x2F; 开头的话，那么 resolve 会找到磁盘下的根目录</p>\n<pre><code class=\"javascript\">const path = require(&quot;path&quot;);\n \nvar dirname = &#39;../User/Desktop&#39;;\nvar basename = &#39;abc.txt&#39;;\n \npath.join(dirname, basename);  // ../User/Desktop/abc.txt\n \npath.resolve(dirname, basename);  // /Users/Desktop/node/User/Desktop/abc.txt\n</code></pre>\n<p>如果 basename 是以 &#x2F; 开头的，那么 resolve 就会直接返回 basename </p>\n<pre><code class=\"javascript\">const path = require(&quot;path&quot;);\n \nvar dirname = &#39;/User/Desktop&#39;;\nvar basename = &#39;/abc.txt&#39;;\n \npath.join(dirname, basename);  // /User/Desktop/abc.txt\n \npath.resolve(dirname, basename);  // /abc.txt\n</code></pre>\n<h3 id=\"1-4-几个常见路径\"><a href=\"#1-4-几个常见路径\" class=\"headerlink\" title=\"1.4 几个常见路径\"></a>1.4 几个常见路径</h3><ul>\n<li><code>__dirname</code>：这是一个常量，表示：当前执行文件所在<strong>完整目录</strong>。</li>\n<li><code>__filename</code>：这是一个常量。表示：当前执行文件的<strong>完整目录 + 文件名</strong>。</li>\n<li><code>process.cwd</code>：获取当前执行 Node命令 时的目录名。</li>\n</ul>\n<p>代码举例：</p>\n<pre><code class=\"javascript\">console.log(__dirname);\n\nconsole.log(__filename);\n\nconsole.log(process.cwd());\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"bash\">$ node app.js\n\n/Users/smyhvae/dselegent\n/Users/smyhvae/dselegent/app.js\n/Users/smyhvae/dselegent\n</code></pre>\n<h2 id=\"2-本地文件操作模块-fs\"><a href=\"#2-本地文件操作模块-fs\" class=\"headerlink\" title=\"2.本地文件操作模块 fs\"></a>2.本地文件操作模块 fs</h2><blockquote>\n<h3 id=\"Node-js-中的同步和异步的区别\"><a href=\"#Node-js-中的同步和异步的区别\" class=\"headerlink\" title=\"Node.js 中的同步和异步的区别\"></a>Node.js 中的同步和异步的区别</h3><p>fs模块对文件的几乎所有操作都有同步和异步两种形式。例如：readFile() 和 readFileSync()。</p>\n<p>区别：</p>\n<ul>\n<li>同步调用会阻塞代码的执行，异步则不会。</li>\n<li>异步调用会将 读取任务 下达到任务队列，直到任务执行完成才会回调。</li>\n<li>异常处理方面：同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数。【重要】</li>\n</ul>\n</blockquote>\n<h3 id=\"2-1-文件读取\"><a href=\"#2-1-文件读取\" class=\"headerlink\" title=\"2.1 文件读取\"></a>2.1 文件读取</h3><p><strong>同步读取</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar data;\n\ntry&#123;\n    data = fs.readFileSync(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;);\n    console.log(&#39;文件内容: &#39; + data);\n&#125;catch(err)&#123;\n    console.error(&#39;读取文件出错: &#39; + err.message);\n&#125;\n</code></pre>\n<p>输出如下：</p>\n<pre><code class=\"bash\">/usr/local/bin/node readFileSync.js\n文件内容: hello world\n</code></pre>\n<p><strong>异步读取</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.readFile(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;, function(err, data)&#123;\n    if(err)&#123;\n        return console.error(&#39;读取文件出错: &#39; + err.message);\n    &#125;\n    console.log(&#39;文件内容: &#39; + data);\n&#125;);\n</code></pre>\n<p>输出如下</p>\n<pre><code class=\"bash\">/usr/local/bin/node readFile.js\n文件内容: hello world\n</code></pre>\n<blockquote>\n<p><strong>fs&#x2F;promises 从 Node.js 14 开始可用</strong><br>从 Node.js 14 开始，fs 模块提供了两种使用基于 promises 的文件系统的方法。这些 promises 可以通过 <code>require(&#39;fs&#39;).promises</code> 或 <code>require(&#39;fs/promises&#39;) </code>获得。</p>\n</blockquote>\n<pre><code class=\"javascript\">import &#123; readFile &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const contents = await readFile(filePath, &#123; encoding: &#39;utf8&#39; &#125;);\n  console.log(contents);\n&#125; catch (err) &#123;\n  console.error(err.message);\n&#125;\n</code></pre>\n<h3 id=\"2-2-文件写入\"><a href=\"#2-2-文件写入\" class=\"headerlink\" title=\"2.2 文件写入\"></a>2.2 文件写入</h3><p>备注：以下代码，如果文件不存在，则创建文件；如果文件存在，则覆盖文件内容；</p>\n<p><strong>异步写入</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.writeFile(&#39;./fileForWrite.txt&#39;, &#39;hello world&#39;, &#39;utf8&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;文件写入成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步写入</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\ntry&#123;\n    fs.writeFileSync(&#39;./fileForWrite1.txt&#39;, &#39;hello world&#39;, &#39;utf8&#39;);\n    console.log(&#39;文件写入成功&#39;);\n&#125;catch(err)&#123;\n    throw err;\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"javascript\">import &#123; writeFile &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const contents = await writeFile(&#39;message.txt&#39;, &#39;hello world&#39;, &#123; encoding: &#39;utf8&#39; &#125;);\n  console.log(contents);\n&#125; catch (err) &#123;\n  // When a request is aborted - err is an AbortError\n  console.error(err);\n&#125;\n</code></pre>\n<h3 id=\"2-3-文件是否存在\"><a href=\"#2-3-文件是否存在\" class=\"headerlink\" title=\"2.3 文件是否存在\"></a>2.3 文件是否存在</h3><p><code>fs.exists()</code>已经是<code>deprecated</code>状态，现在可以通过下面代码判断文件是否存在。</p>\n<p><strong>异步本</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;)\n\n//检查文件是否存在于当前目录中\nfs.access(&#39;package.json&#39;, fs.constants.F_OK, err =&gt; &#123;\n    if(err) &#123;\n        console.log(&#39;package.json不存在于当前目录中&#39;)\n        return\n    &#125;\n    console.log(&#39;package.json存在于当前目录中&#39;)\n&#125;)\n\nfs.access(&#39;index.js&#39;, fs.constants.F_OK, err =&gt; &#123;\n    if(err) &#123;\n        console.log(&#39;index.js不存在于当前目录中&#39;)\n        return\n    &#125;\n    console.log(&#39;index.js存在于当前目录中&#39;)\n&#125;)\n</code></pre>\n<p><code>fs.access()</code>除了判断文件是否存在（默认模式），还可以用来判断文件的权限。</p>\n<p>备忘：<code>fs.constants.F_OK</code>等常量无法获取（node v6.1，mac 10.11.4下，<code>fs.constants</code>是<code>undefined</code>）</p>\n<p><strong>同步</strong></p>\n<pre><code class=\"javascript\">import &#123; accessSync, constants &#125; from &#39;fs&#39;;\n\ntry &#123;\n  accessSync(&#39;etc/passwd&#39;, constants.R_OK );\n  console.log(&#39;can read&#39;);\n&#125; catch (err) &#123;\n  console.error(&#39;no access!&#39;);\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"javascript\">import &#123; access, constants &#125; from &#39;node:fs/promises&#39;;\n\ntry &#123;\n  await access(&#39;/etc/passwd&#39;, constants.R_OK);\n  console.log(&#39;can access&#39;);\n&#125; catch &#123;\n  console.error(&#39;cannot access&#39;);\n&#125;\n</code></pre>\n<h3 id=\"2-4-删除文件\"><a href=\"#2-4-删除文件\" class=\"headerlink\" title=\"2.4 删除文件\"></a>2.4 删除文件</h3><p><strong>异步版本</strong></p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.unlink(&#39;./fileForUnlink.txt&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;文件删除成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步版本</strong></p>\n<pre><code class=\"javascript\">import &#123; unlinkSync &#125; from &#39;fs&#39;;\n\ntry &#123;\n  unlinkSync(&#39;/tmp/hello&#39;);\n  console.log(&#39;successfully deleted /tmp/hello&#39;);\n&#125; catch (err) &#123;\n  // handle the error\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"javascript\">import &#123; unlink &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  await unlink(&#39;/tmp/hello&#39;);\n  console.log(&#39;successfully deleted /tmp/hello&#39;);\n&#125; catch (err) &#123;\n  // handle the error\n&#125;\n</code></pre>\n<h3 id=\"2-5-创建目录\"><a href=\"#2-5-创建目录\" class=\"headerlink\" title=\"2.5 创建目录\"></a>2.5 创建目录</h3><p><strong>异步版本</strong>（如果目录已存在，会报错）</p>\n<pre><code class=\"javascript\">// fs.mkdir(path[, mode], callback)\nvar fs = require(&#39;fs&#39;);\n\nfs.mkdir(&#39;sub&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;创建目录成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步版本</strong></p>\n<pre><code class=\"javascript\">// fs.mkdirSync(path[, mode])\nvar fs = require(&#39;fs&#39;);\n\ntry&#123;\n    fs.mkdirSync(&#39;hello&#39;);\n    console.log(&#39;创建目录成功&#39;);\n&#125;catch(e)&#123;\n    throw e;\n&#125;\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"javascript\">import &#123; mkdir &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const createDir = await mkdir(projectFolder, &#123; recursive: true &#125;);\n  console.log(`created $&#123;createDir&#125;`);\n&#125; catch (err) &#123;\n  console.error(err.message);\n&#125;\n</code></pre>\n<h3 id=\"2-6-遍历目录\"><a href=\"#2-6-遍历目录\" class=\"headerlink\" title=\"2.6 遍历目录\"></a>2.6 遍历目录</h3><p>同步版本，注意：<code>fs.readdirSync()</code>只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。</p>\n<pre><code class=\"javascript\">// fs.readdirSync(path[, options])\n\nvar fs = require(&#39;fs&#39;);\nvar path = require(&#39;path&#39;);\n\nvar getFilesInDir = function(dir)&#123;\n\n    var results = [ path.resolve(dir) ];\n    var files = fs.readdirSync(dir, &#39;utf8&#39;);\n\n    files.forEach(function(file)&#123;\n\n        file = path.resolve(dir, file);\n\n        var stats = fs.statSync(file);\n\n        if(stats.isFile())&#123;\n            results.push(file);\n        &#125;else if(stats.isDirectory())&#123;\n            results = results.concat( getFilesInDir(file) );\n        &#125;\n    &#125;);\n\n    return results;\n&#125;;\n\nvar files = getFilesInDir(&#39;../&#39;);\nconsole.log(files);\n</code></pre>\n<h3 id=\"2-7-读取目录\"><a href=\"#2-7-读取目录\" class=\"headerlink\" title=\"2.7 读取目录\"></a>2.7 读取目录</h3><pre><code class=\"javascript\">import &#123; readdir &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  const files = await readdir(path);\n  for (const file of files)\n    console.log(file);\n&#125; catch (err) &#123;\n  console.error(err);\n&#125;\n</code></pre>\n<h3 id=\"2-8-删除目录\"><a href=\"#2-8-删除目录\" class=\"headerlink\" title=\"2.8 删除目录\"></a>2.8 删除目录</h3><pre><code class=\"javascript\">// 删除目录(前提没有文件在里面)\nfs.rmdir(&#39;./avatar&#39;, err =&gt; &#123;\n  if (err &amp;&amp; err.code === &#39;ENOENT&#39;) &#123;\n    console.log(&#39;目录不存在&#39;);\n  &#125;\n&#125;);\n</code></pre>\n<h3 id=\"2-9-删除整个目录\"><a href=\"#2-9-删除整个目录\" class=\"headerlink\" title=\"2.9 删除整个目录\"></a>2.9 删除整个目录</h3><pre><code class=\"javascript\">//1\nconst fs = require(&quot;fs&quot;)\nfs.(&quot;./avatar&quot;,(err,data)=&gt;&#123;\n    // console.log(data)\n    data.forEach(item=&gt;&#123;\n        fs.unlinkSync(`./avatar/$&#123;item&#125;`)\n    &#125;)\n\n    fs.rmdir(&quot;./avatar&quot;,(err)=&gt;&#123;\n        console.log(err)\n    &#125;)\n&#125;)\n\n//2\nconst fs = require(&#39;fs&#39;)\nfs.readdir(&quot;./avatar&quot;).then(async (data)=&gt;&#123;\n    let arr = []\n    data.forEach(item=&gt;&#123;\n        arr.push(fs.unlink(`./avatar/$&#123;item&#125;`))\n    &#125;)\n    await Promise.all(arr)\n    fs.rmdir(&quot;./avatar&quot;)\n&#125;)\n\n//3\nconst fs = require(&#39;fs&#39;).promises;\nfs.readdir(&#39;./image2&#39;).then(async data =&gt; &#123;\n  await Promise.all(data.map(item =&gt; fs.unlink(`./image2/$&#123;item&#125;`)));\n  await fs.rmdir(&#39;./image2&#39;);\n&#125;);\n</code></pre>\n<h3 id=\"2-10-文件重命名\"><a href=\"#2-10-文件重命名\" class=\"headerlink\" title=\"2.10 文件重命名\"></a>2.10 文件重命名</h3><p><strong>异步版本</strong></p>\n<pre><code class=\"javascript\">// fs.rename(oldPath, newPath, callback)\nvar fs = require(&#39;fs&#39;);\n\nfs.rename(&#39;./hello&#39;, &#39;./world&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;重命名成功&#39;);\n&#125;);\n</code></pre>\n<p><strong>同步版本</strong></p>\n<pre><code class=\"javascript\">// fs.renameSync(oldPath, newPath)\nvar fs = require(&#39;fs&#39;);\n\nfs.renameSync(&#39;./world&#39;, &#39;./hello&#39;);\n</code></pre>\n<p><strong>promises</strong></p>\n<pre><code class=\"javascript\">import &#123; rename &#125; from &#39;fs/promises&#39;;\n\ntry &#123;\n  await rename(&#39;./world&#39;, &#39;./hello&#39;);\n  console.log(`rename`);\n&#125; catch (err) &#123;\n  console.error(err.message);\n&#125;\n</code></pre>\n<h3 id=\"2-11-获取文件状态\"><a href=\"#2-11-获取文件状态\" class=\"headerlink\" title=\"2.11 获取文件状态\"></a>2.11 获取文件状态</h3><p>1.异步：fs.stat(path,callback):<br>  path是一个表示路径的字符串,callback接收两个参数(err,stats),其中stats就是fs.stats的一个实例；</p>\n<p>2.同步：fs.statSync(path)<br>  只接收一个path变量，fs.statSync(path)其实是一个fs.stats的一个实例；</p>\n<p>方法</p>\n<ul>\n<li>stats.isFile() – 是否文件</li>\n<li>stats.isDirectory() – 是否目录</li>\n</ul>\n<pre><code class=\"javascript\">// Node.js program to demonstrate the \n// fs.statSync() method \n  \n// Import the filesystem module \nconst fs = require(&#39;fs&#39;); \n  \n// Getting information for a file \nstatsObj = fs.statSync(&quot;test_file.txt&quot;); \n  \nconsole.log(statsObj);  \nconsole.log(&quot;Path is file:&quot;, statsObj.isFile()); \nconsole.log(&quot;Path is directory:&quot;, statsObj.isDirectory()); \n  \n// Getting information for a directory \nstatsObj = fs.statSync(&quot;test_directory&quot;); \n  \nconsole.log(statsObj); \nconsole.log(&quot;Path is file:&quot;, statsObj.isFile()); \nconsole.log(&quot;Path is directory:&quot;, statsObj.isDirectory());\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"javascript\">Stats &#123;\n  dev:3229478529,\n  mode:33206,\n  nlink:1,\n  uid:0,\n  gid:0,\n  rdev:0,\n  blksize:4096,\n  ino:1970324837039946,\n  size:0,\n  blocks:0,\n  atimeMs:1582306776282,\n  mtimeMs:1582482953967,\n  ctimeMs:1582482953968.2532,\n  birthtimeMs:1582306776282.142,\n  atime:2020-02-21T17:39:36.282Z,\n  mtime:2020-02-23T18:35:53.967Z,\n  ctime:2020-02-23T18:35:53.968Z,\n  birthtime:2020-02-21T17:39:36.282Z\n&#125;\nPath is file:true\nPath is directory:false\nStats &#123;\n  dev:3229478529,\n  mode:16822,\n  nlink:1,\n  uid:0,\n  gid:0,\n  rdev:0,\n  blksize:4096,\n  ino:562949953486669,\n  size:0,\n  blocks:0,\n  atimeMs:1582482965037.8445,\n  mtimeMs:1581074249467.7114,\n  ctimeMs:1582482964979.8303,\n  birthtimeMs:1582306776288.1958,\n  atime:2020-02-23T18:36:05.038Z,\n  mtime:2020-02-07T11:17:29.468Z,\n  ctime:2020-02-23T18:36:04.980Z,\n  birthtime:2020-02-21T17:39:36.288Z\n&#125;\nPath is file:false\nPath is directory:true\n</code></pre>\n<h3 id=\"2-12-追加文件内容\"><a href=\"#2-12-追加文件内容\" class=\"headerlink\" title=\"2.12 追加文件内容\"></a>2.12 追加文件内容</h3><blockquote>\n<p>fs.appendFile(file, data[, options], callback)</p>\n</blockquote>\n<ul>\n<li>file：可以是文件路径，也可以是文件句柄。（还可以是buffer？）</li>\n<li>data：要追加的内容。string或者buffer。</li>\n<li>options<ul>\n<li>encoding：编码，默认是<code>utf8</code></li>\n<li>mode：默认是<code>0o666</code></li>\n<li>flag：默认是<code>a</code></li>\n</ul>\n</li>\n</ul>\n<p>注意：如果<code>file</code>是文件句柄，那么</p>\n<ul>\n<li>开始追加数据前，file需要已经打开。</li>\n<li>file需要手动关闭。</li>\n</ul>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nfs.appendFile(&#39;./extra/fileForAppend.txt&#39;, &#39;hello&#39;, &#39;utf8&#39;, function(err)&#123;\n    if(err) throw err;\n    console.log(&#39;append成功&#39;);\n&#125;);\n</code></pre>\n<h2 id=\"3-事件机制模块-events\"><a href=\"#3-事件机制模块-events\" class=\"headerlink\" title=\"3.事件机制模块 events\"></a>3.事件机制模块 events</h2><p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>\n<pre><code class=\"javascript\">// 引入 events 模块\nvar EventEmitter = require(&#39;events&#39;);\n// 创建 eventEmitter 对象\nvar event = new EventEmitter();\n</code></pre>\n<p>以下程序绑定事件处理程序：</p>\n<pre><code class=\"javascript\">// 绑定事件及事件的处理程序\neventEmitter.on(&#39;eventName&#39;, eventHandler);\n</code></pre>\n<p>我们可以通过程序触发事件：</p>\n<pre><code class=\"javascript\">// 触发事件\neventEmitter.emit(&#39;eventName&#39;);\n</code></pre>\n<p><code>EventEmitter </code>的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，<code>EventEmitter </code>支持 若干个事件监听器。</p>\n<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>\n<p>让我们以下面的例子解释这个过程：</p>\n<pre><code class=\"javascript\">// 引入 events 模块\nvar EventEmitter = require(&#39;events&#39;);\n// 创建 eventEmitter 对象\nvar event = new EventEmitter();\nevent.on(&#39;someEvent&#39;, function(arg1, arg2) &#123; \n    console.log(&#39;listener1&#39;, arg1, arg2); \n&#125;); \nevent.on(&#39;someEvent&#39;, function(arg1, arg2) &#123; \n    console.log(&#39;listener2&#39;, arg1, arg2); \n&#125;); \nevent.emit(&#39;someEvent&#39;, &#39;arg1 参数&#39;, &#39;arg2 参数&#39;); \n</code></pre>\n<p>执行以上代码，运行的结果如下：</p>\n<pre><code class=\"bash\">$ node event.js \nlistener1 arg1 参数 arg2 参数\nlistener2 arg1 参数 arg2 参数\n</code></pre>\n<p>以上例子中，event 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>\n<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是<code>EventEmitter</code>最简单的用法。</p>\n<p><code>EventEmitter </code>提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件</p>\n<h1 id=\"07-【nodejs内置模块（下）】\"><a href=\"#07-【nodejs内置模块（下）】\" class=\"headerlink\" title=\"07 【nodejs内置模块（下）】\"></a>07 【nodejs内置模块（下）】</h1><h2 id=\"1-stream-模块\"><a href=\"#1-stream-模块\" class=\"headerlink\" title=\"1.stream 模块\"></a>1.stream 模块</h2><p><code>stream</code>是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>\n<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>\n<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>\n<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>\n<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>\n<h3 id=\"1-1-读取流\"><a href=\"#1-1-读取流\" class=\"headerlink\" title=\"1.1 读取流\"></a>1.1 读取流</h3><pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;hello.txt&#39;, &#39;utf-8&#39;);\n\nrs.on(&#39;open&#39;, function () &#123;\n  console.log(&#39;读取的文件已打开&#39;);\n&#125;).on(&#39;close&#39;, function () &#123;\n  console.log(&#39;读取流结束&#39;);\n&#125;).on(&#39;error&#39;, err =&gt; &#123;\n  console.log(err);\n&#125;).on(&#39;data&#39;, function (chunk) &#123;\n  //每一批数据流入完成\n  console.log(&#39;单批数据流入:&#39; + chunk.length);\n  console.log(chunk);\n&#125;);\n</code></pre>\n<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>\n<p><strong>读取视频</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;video.mp4&#39;);\n\n//每一批数据流入完成\nrs.on(&#39;data&#39;, function (chunk) &#123;\n  console.log(&#39;单批数据流入:&#39; + chunk.length);\n  console.log(chunk);\n&#125;);\n</code></pre>\n<p><img data-src=\"https://tva1.sinaimg.cn/large/0074UQWJgy1h3eigfl898j31750iztjs.jpg\"></p>\n<h3 id=\"1-2-写入流\"><a href=\"#1-2-写入流\" class=\"headerlink\" title=\"1.2 写入流\"></a>1.2 写入流</h3><p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建写入流\nlet ws = fs.createWriteStream(&#39;hello.txt&#39;, &#39;utf-8&#39;);\n\n//监听文件打开事件\nws.on(&#39;open&#39;, function () &#123;\n  console.log(&#39;文件打开&#39;);\n&#125;);\n\n//监听文件关闭事件\nws.on(&#39;close&#39;, function () &#123;\n  console.log(&#39;文件写入完成，关闭&#39;);\n&#125;);\n\n//文件流式写入\nws.write(&#39;helloworld1!&#39;, function (err) &#123;\n  if (err) &#123;\n    console.log(err);\n  &#125; else &#123;\n    console.log(&#39;内容1流入完成&#39;);\n  &#125;\n&#125;);\nws.write(&#39;helloworld2!&#39;, function (err) &#123;\n  if (err) &#123;\n    console.log(err);\n  &#125; else &#123;\n    console.log(&#39;内容2流入完成&#39;);\n  &#125;\n&#125;);\n\n//文件写入完成\nws.end(function () &#123;\n  console.log(&#39;文件写入关闭&#39;);\n&#125;);\n</code></pre>\n<p><code>pipe</code> 就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>\n<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>\n<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;video.mp4&#39;);\nlet ws = fs.createWriteStream(&#39;b.mp4&#39;);\n\nrs.on(&#39;close&#39;, function () &#123;\n  console.log(&#39;读取流结束&#39;);\n&#125;);\n\nrs.pipe(ws);\n</code></pre>\n<p><strong>pipe原理</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\n//创建读取流\nlet rs = fs.createReadStream(&#39;video.mp4&#39;);\nlet ws = fs.createWriteStream(&#39;b.mp4&#39;);\n\nrs.on(&#39;close&#39;, function () &#123;\n  ws.end();\n  console.log(&#39;读取流结束&#39;);\n&#125;);\n\n//每一批数据流入完成\nrs.on(&#39;data&#39;, function (chunk) &#123;\n  console.log(&#39;单批数据流入:&#39; + chunk.length);\n  ws.write(chunk, () =&gt; &#123;\n    console.log(&#39;单批输入流入完成&#39;);\n  &#125;);\n&#125;);\n</code></pre>\n<h2 id=\"2-资源压缩模块-zib\"><a href=\"#2-资源压缩模块-zib\" class=\"headerlink\" title=\"2.资源压缩模块 zib\"></a>2.资源压缩模块 zib</h2><h3 id=\"2-1-概览\"><a href=\"#2-1-概览\" class=\"headerlink\" title=\"2.1 概览\"></a>2.1 概览</h3><p>做过web性能优化的同学，对性能优化大杀器<strong>gzip</strong>应该不陌生。浏览器向服务器发起资源请求，比如下载一个js文件，服务器先对资源进行压缩，再返回给浏览器，以此节省流量，加快访问速度。</p>\n<p>浏览器通过HTTP请求头部里加上<strong>Accept-Encoding</strong>，告诉服务器，“你可以用gzip，或者defalte算法压缩资源”。</p>\n<blockquote>\n<p>Accept-Encoding:gzip, deflate</p>\n</blockquote>\n<p>那么，在nodejs里，是如何对资源进行压缩的呢？答案就是<strong>Zlib</strong>模块。&#x3D;</p>\n<h3 id=\"2-2-压缩的例子\"><a href=\"#2-2-压缩的例子\" class=\"headerlink\" title=\"2.2 压缩的例子\"></a>2.2 压缩的例子</h3><p>非常简单的几行代码，就完成了本地文件的gzip压缩。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar zlib = require(&#39;zlib&#39;);\n\nvar gzip = zlib.createGzip();\n\nvar readstream = fs.createReadStream(&#39;./extra/fileForCompress.txt&#39;);\nvar writestream = fs.createWriteStream(&#39;./extra/fileForCompress.txt.gz&#39;);\n\nreadstream.pipe(gzip).pipe(writestream);\n</code></pre>\n<h3 id=\"2-3-解压的例子\"><a href=\"#2-3-解压的例子\" class=\"headerlink\" title=\"2.3 解压的例子\"></a>2.3 解压的例子</h3><p>同样非常简单，就是个反向操作。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar zlib = require(&#39;zlib&#39;);\n\nvar gunzip = zlib.createGunzip();\n\nvar readstream  = fs.createReadStream(&#39;./extra/fileForCompress.txt.gz&#39;);\nvar writestream  = fs.createWriteStream(&#39;./extra/fileForCompress1.txt&#39;);\n\nreadstream.pipe(gunzip).pipe(writestream);\n</code></pre>\n<h3 id=\"2-4-服务端gzip压缩\"><a href=\"#2-4-服务端gzip压缩\" class=\"headerlink\" title=\"2.4 服务端gzip压缩\"></a>2.4 服务端gzip压缩</h3><p>首先判断 是否包含 <strong>accept-encoding</strong> 首部，且值为<strong>gzip</strong>。</p>\n<ul>\n<li>否：返回未压缩的文件。</li>\n<li>是：返回gzip压缩后的文件。</li>\n</ul>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\nvar zlib = require(&#39;zlib&#39;);\nvar fs = require(&#39;fs&#39;);\nvar filepath = &#39;./extra/fileForGzip.html&#39;;\n\nvar server = http.createServer(function(req, res)&#123;\n    var acceptEncoding = req.headers[&#39;accept-encoding&#39;];\n    var gzip;\n    \n    if(acceptEncoding.indexOf(&#39;gzip&#39;)!=-1)&#123; // 判断是否需要gzip压缩\n        \n        gzip = zlib.createGzip();\n        \n        // 记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过\n        res.writeHead(200, &#123;\n            &#39;Content-Encoding&#39;: &#39;gzip&#39;\n        &#125;);\n        fs.createReadStream(filepath).pipe(gzip).pipe(res);\n    \n    &#125;else&#123;\n\n        fs.createReadStream(filepath).pipe(res);\n    &#125;\n\n&#125;);\n\nserver.listen(&#39;3000&#39;);\n</code></pre>\n<p><strong>将js大文件返回</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\nconst zlib = require(&#39;zlib&#39;);//这两个要写在fs模块后面\nconst gzip = zlib.createGzip();\nconst http = require(&#39;http&#39;);\n\nhttp\n  .createServer((req, res) =&gt; &#123;\n    let rs = fs.createReadStream(&#39;hello.js&#39;);\n    res.writeHead(200, &#123;\n      &#39;Content-Type&#39;: &#39;application/x-javascript;charset=utf-8&#39;,\n      &#39;Content-Encoding&#39;: &#39;gzip&#39;,\n    &#125;);\n    rs.pipe(gzip).pipe(res);\n  &#125;)\n  .listen(3000, () =&gt; &#123;\n    console.log(&#39;server start&#39;);\n  &#125;);\n</code></pre>\n<h3 id=\"2-5-服务端字符串gzip压缩\"><a href=\"#2-5-服务端字符串gzip压缩\" class=\"headerlink\" title=\"2.5 服务端字符串gzip压缩\"></a>2.5 服务端字符串gzip压缩</h3><p>代码跟前面例子大同小异。这里采用了 <strong>zlib.gzipSync(str)</strong> 对字符串进行gzip压缩。</p>\n<pre><code class=\"javascript\">var http = require(&#39;http&#39;);\nvar zlib = require(&#39;zlib&#39;);\n\nvar responseText = &#39;hello world&#39;;\n\nvar server = http.createServer(function(req, res)&#123;\n    var acceptEncoding = req.headers[&#39;accept-encoding&#39;];\n    if(acceptEncoding.indexOf(&#39;gzip&#39;)!=-1)&#123;\n        res.writeHead(200, &#123;\n            &#39;content-encoding&#39;: &#39;gzip&#39;\n        &#125;);\n        res.end(zlib.gzipSync(responseText) );\n    &#125;else&#123;\n        res.end(responseText);\n    &#125;\n\n&#125;);\n\nserver.listen(&#39;3000&#39;);\n</code></pre>\n<h2 id=\"3-数据加密模块-crypto\"><a href=\"#3-数据加密模块-crypto\" class=\"headerlink\" title=\"3.数据加密模块 crypto\"></a>3.数据加密模块 crypto</h2><p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C&#x2F;C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n<h3 id=\"3-1-hash例子\"><a href=\"#3-1-hash例子\" class=\"headerlink\" title=\"3.1 hash例子\"></a>3.1 hash例子</h3><p>hash.digest([encoding])：计算摘要。encoding可以是<code>hex</code>、<code>latin1</code>或者<code>base64</code>。如果声明了encoding，那么返回字符串。否则，返回Buffer实例。注意，调用hash.digest()后，hash对象就作废了，再次调用就会出错。</p>\n<p>hash.update(data[, input_encoding])：input_encoding可以是<code>utf8</code>、<code>ascii</code>或者<code>latin1</code>。如果data是字符串，且没有指定 input_encoding，则默认是<code>utf8</code>。注意，hash.update()方法可以调用多次。</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar content = fs.readFileSync(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\nvar hash = crypto.createHash(&#39;sha256&#39;);\nvar output;\n\nhash.update(content);\n\noutput = hash.digest(&#39;hex&#39;); \n\nconsole.log(output);\n// 输出内容为：\n// b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n</code></pre>\n<p>也可以这样：</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar input = fs.createReadStream(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\nvar hash = crypto.createHash(&#39;sha256&#39;);\n\nhash.setEncoding(&#39;hex&#39;);\n\ninput.pipe(hash).pipe(process.stdout)\n\n// 输出内容为：\n// b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\n</code></pre>\n<p>hash.digest()后，再次调用digest()或者update()</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar content = fs.readFileSync(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\nvar hash = crypto.createHash(&#39;sha256&#39;);\nvar output;\n\nhash.update(content);\nhash.digest(&#39;hex&#39;); \n\n// 报错：Error: Digest already called\nhash.update(content);\n\n// 报错：Error: Digest already called\nhash.digest(&#39;hex&#39;);\n</code></pre>\n<h3 id=\"3-2-HMAC例子\"><a href=\"#3-2-HMAC例子\" class=\"headerlink\" title=\"3.2 HMAC例子\"></a>3.2 HMAC例子</h3><p>HMAC的全称是Hash-based Message Authentication Code，也即在hash的加盐运算。</p>\n<p>具体到使用的话，跟hash模块差不多，选定hash算法，指定“盐”即可。</p>\n<p>例子1：</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar secret = &#39;secret&#39;;\nvar hmac = crypto.createHmac(&#39;sha256&#39;, secret);\nvar input = fs.readFileSync(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\n\nhmac.update(input);\n\nconsole.log( hmac.digest(&#39;hex&#39;) );\n// 输出：\n// 734cc62f32841568f45715aeb9f4d7891324e6d948e4c6c60c0621cdac48623a\n</code></pre>\n<p>例子2：</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar secret = &#39;secret&#39;;\nvar hmac = crypto.createHmac(&#39;sha256&#39;, secret);\nvar input = fs.createReadStream(&#39;./test.txt&#39;, &#123;encoding: &#39;utf8&#39;&#125;);\n\nhmac.setEncoding(&#39;hex&#39;);\n\ninput.pipe(hmac).pipe(process.stdout)\n// 输出：\n// 734cc62f32841568f45715aeb9f4d7891324e6d948e4c6c60c0621cdac48623a\n</code></pre>\n<h3 id=\"3-3-MD5例子\"><a href=\"#3-3-MD5例子\" class=\"headerlink\" title=\"3.3 MD5例子\"></a>3.3 MD5例子</h3><p>MD5（Message-Digest Algorithm）是计算机安全领域广泛使用的散列函数（又称哈希算法、摘要算法），主要用来确保消息的完整和一致性。常见的应用场景有密码保护、下载文件校验等。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>运算速度快：对<code>jquery.js</code>求md5值，57254个字符，耗时1.907ms</li>\n<li>输出长度固定：输入长度不固定，输出长度固定（128位）。</li>\n<li>运算不可逆：已知运算结果的情况下，无法通过通过逆运算得到原始字符串。</li>\n<li>高度离散：输入的微小变化，可导致运算结果差异巨大。</li>\n<li>弱碰撞性：不同输入的散列值可能相同。</li>\n</ol>\n<p><strong>应用场景</strong></p>\n<ol>\n<li>文件完整性校验：比如从网上下载一个软件，一般网站都会将软件的md5值附在网页上，用户下载完软件后，可对下载到本地的软件进行md5运算，然后跟网站上的md5值进行对比，确保下载的软件是完整的（或正确的）</li>\n<li>密码保护：将md5后的密码保存到数据库，而不是保存明文密码，避免拖库等事件发生后，明文密码外泄。</li>\n<li>防篡改：比如数字证书的防篡改，就用到了摘要算法。（当然还要结合数字签名等手段）</li>\n</ol>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\nvar md5 = crypto.createHash(&#39;md5&#39;);\n\nvar result = md5.update(&#39;a&#39;).digest(&#39;hex&#39;);\n\n// 输出：0cc175b9c0f1b6a831c399e269772661\nconsole.log(result);\n</code></pre>\n<h3 id=\"3-4-例子：密码保护\"><a href=\"#3-4-例子：密码保护\" class=\"headerlink\" title=\"3.4 例子：密码保护\"></a>3.4 例子：密码保护</h3><p>前面提到，将明文密码保存到数据库是很不安全的，最不济也要进行md5后进行保存。比如用户密码是<code>123456</code>，md5运行后，得到<code>输出：e10adc3949ba59abbe56e057f20f883e</code>。</p>\n<p>这样至少有两个好处：</p>\n<ol>\n<li>防内部攻击：网站主人也不知道用户的明文密码，避免网站主人拿着用户明文密码干坏事。</li>\n<li>防外部攻击：如网站被黑客入侵，黑客也只能拿到md5后的密码，而不是用户的明文密码。</li>\n</ol>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\n\nfunction cryptPwd(password) &#123;\n    var md5 = crypto.createHash(&#39;md5&#39;);\n    return md5.update(password).digest(&#39;hex&#39;);\n&#125;\n\nvar password = &#39;123456&#39;;\nvar cryptedPassword = cryptPwd(password);\n\nconsole.log(cryptedPassword);\n// 输出：e10adc3949ba59abbe56e057f20f883e\n</code></pre>\n<p><strong>单纯对密码进行md5不安全</strong></p>\n<p>前面提到，通过对用户密码进行md5运算来提高安全性。但实际上，这样的安全性是很差的，为什么呢？</p>\n<p>稍微修改下上面的例子，可能你就明白了。相同的明文密码，md5值也是相同的。</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\n\nfunction cryptPwd(password) &#123;\n    var md5 = crypto.createHash(&#39;md5&#39;);\n    return md5.update(password).digest(&#39;hex&#39;);\n&#125;\n\nvar password = &#39;123456&#39;;\n\nconsole.log( cryptPwd(password) );\n// 输出：e10adc3949ba59abbe56e057f20f883e\n\nconsole.log( cryptPwd(password) );\n// 输出：e10adc3949ba59abbe56e057f20f883e\n</code></pre>\n<p>也就是说，当攻击者知道算法是md5，且数据库里存储的密码值为<code>e10adc3949ba59abbe56e057f20f883e</code>时，理论上可以可以猜到，用户的明文密码就是<code>123456</code>。</p>\n<p>事实上，彩虹表就是这么进行暴力破解的：事先将常见明文密码的md5值运算好存起来，然后跟网站数据库里存储的密码进行匹配，就能够快速找到用户的明文密码。（这里不探究具体细节）</p>\n<p>那么，有什么办法可以进一步提升安全性呢？答案是：密码加盐。</p>\n<p><strong>密码加盐</strong></p>\n<p>“加盐”这个词看上去很玄乎，其实原理很简单，就是在密码特定位置插入特定字符串后，再对修改后的字符串进行md5运算。</p>\n<p>例子如下。同样的密码，当“盐”值不一样时，md5值的差异非常大。通过密码加盐，可以防止最初级的暴力破解，如果攻击者事先不知道”盐“值，破解的难度就会非常大。</p>\n<pre><code class=\"javascript\">var crypto = require(&#39;crypto&#39;);\n\nfunction cryptPwd(password, salt) &#123;\n    // 密码“加盐”\n    var saltPassword = password + &#39;:&#39; + salt;\n    console.log(&#39;原始密码：%s&#39;, password);\n    console.log(&#39;加盐后的密码：%s&#39;, saltPassword);\n\n    // 加盐密码的md5值\n    var md5 = crypto.createHash(&#39;md5&#39;);\n    var result = md5.update(saltPassword).digest(&#39;hex&#39;);\n    console.log(&#39;加盐密码的md5值：%s&#39;, result);\n&#125;\n\ncryptPwd(&#39;123456&#39;, &#39;abc&#39;);\n// 输出：\n// 原始密码：123456\n// 加盐后的密码：123456:abc\n// 加盐密码的md5值：51011af1892f59e74baf61f3d4389092\n\ncryptPwd(&#39;123456&#39;, &#39;bcd&#39;);\n// 输出：\n// 原始密码：123456\n// 加盐后的密码：123456:bcd\n// 加盐密码的md5值：55a95bcb6bfbaef6906dbbd264ab4531\n</code></pre>\n<h1 id=\"09-【原生nodejs路由、获取参数、静态目录】\"><a href=\"#09-【原生nodejs路由、获取参数、静态目录】\" class=\"headerlink\" title=\"09 【原生nodejs路由、获取参数、静态目录】\"></a>09 【原生nodejs路由、获取参数、静态目录】</h1><h2 id=\"1-路由\"><a href=\"#1-路由\" class=\"headerlink\" title=\"1.路由\"></a>1.路由</h2><p><strong>index.js</strong></p>\n<pre><code class=\"javascript\">// 启动服务\nconst server = require(&#39;./server.js&#39;);\n//路由模块\nconst route = require(&#39;./route.js&#39;);\n//api\nconst apiRouter = require(&#39;./api.js&#39;);\n\nserver.use(route);\nserver.use(apiRouter);\nserver.start();\n</code></pre>\n<p><strong>server.js</strong></p>\n<pre><code class=\"javascript\">const http = require(&#39;http&#39;);\n\n//创建一个大对象存储所有的路由和api\nconst route = &#123;&#125;;\n\n// 将所有路由和api合并的函数\nfunction use(routeObj) &#123;\n  Object.assign(route, routeObj);\n&#125;\n\nfunction start() &#123;\n  http\n    .createServer(async (req, res) =&gt; &#123;\n      const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n      route[url.pathname](res);\n    &#125;)\n    .listen(3000, () =&gt; &#123;\n      console.log(&#39;启动成功&#39;);\n    &#125;);\n&#125;\n\nmodule.exports = &#123;\n  use,\n  start,\n&#125;;\n</code></pre>\n<p><strong>route.js</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\nfunction render(res, path, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;text/html&#39;&#125;;charset=utf8` &#125;);\n  res.write(fs.readFileSync(path), &#39;utf-8&#39;);\n  res.end();\n&#125;\n\nconst route = &#123;\n  &#39;/login&#39;(res) &#123;\n    render(res, &#39;./static/login.html&#39;);\n  &#125;,\n  &#39;/home&#39;(res) &#123;\n    render(res, &#39;./static/home.html&#39;);\n  &#125;,\n  &#39;/favicon.ico&#39;(res) &#123;\n    render(res, &#39;./static/favicon.ico&#39;, &#39;image/x-icon&#39;);\n  &#125;,\n  &#39;/404&#39;(res) &#123;\n    res.writeHead(404, &#123; &#39;Content-Type&#39;: &#39;text/html;charset=utf8&#39; &#125;);\n    res.write(fs.readFileSync(&#39;./static/404.html&#39;), &#39;utf-8&#39;);\n    res.end();\n  &#125;,\n&#125;;\n\nmodule.exports = route;\n</code></pre>\n<p><strong>api.js</strong></p>\n<pre><code class=\"javascript\">function render(res, data, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;application/json&#39;&#125;;charset=utf8` &#125;);\n  res.write(data);\n  res.end();\n&#125;\n\nconst apiRouter = &#123;\n  &#39;/api/login&#39;(res) &#123;\n    render(res, &#39;&#123; ok: 1 &#125;&#39;);\n  &#125;,\n&#125;;\n\nmodule.exports = apiRouter;\n</code></pre>\n<h2 id=\"2-获取参数\"><a href=\"#2-获取参数\" class=\"headerlink\" title=\"2.获取参数\"></a>2.获取参数</h2><p><strong>api.js</strong></p>\n<pre><code class=\"javascript\">function render(res, data, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;application/json&#39;&#125;;charset=utf8` &#125;);\n  res.write(data);\n  res.end();\n&#125;\n\nconst apiRouter = &#123;\n    //get请求\n  &#39;/api/login&#39;(req, res) &#123;\n    const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n    const data = &#123;&#125;;\n    let username = url.searchParams.get(&#39;username&#39;);\n    let password = url.searchParams.get(&#39;password&#39;);\n    if (username === &#39;ds&#39; &amp;&amp; password === &#39;123&#39;) &#123;\n      Object.assign(data, &#123;\n        ok: 1,\n      &#125;);\n    &#125; else &#123;\n      Object.assign(data, &#123;\n        ok: 0,\n      &#125;);\n    &#125;\n    render(res, JSON.stringify(data));\n  &#125;,\n    //post请求\n  &#39;/api/loginpost&#39;(req, res) &#123;\n    const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n    let data = &#39;&#39;;\n      //这里使用最原始的方法获取post请求参数\n      // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中\n    req.on(&#39;data&#39;, chunk =&gt; &#123;\n      data += chunk;\n    &#125;);\n       // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。\n    req.on(&#39;end&#39;, () =&gt; &#123;\n      data = JSON.parse(data);\n      if (data.username === &#39;ds&#39; &amp;&amp; data.password === &#39;123&#39;) &#123;\n        render(res, JSON.stringify(&#123; ok: 1 &#125;));\n      &#125; else &#123;\n        render(res, JSON.stringify(&#123; ok: 0 &#125;));\n      &#125;\n    &#125;);\n  &#125;,\n&#125;;\n\nmodule.exports = apiRouter;\n</code></pre>\n<p><strong>请求.js</strong></p>\n<pre><code class=\"javascript\"> login.onclick = () =&gt; &#123;\n        //get请求\n        fetch(`/api/login?username=$&#123;username.value&#125;&amp;password=$&#123;password.value&#125;`)\n          .then(res =&gt; res.text())\n          .then(res =&gt; &#123;\n            console.log(res);\n          &#125;);\n      &#125;;\n  loginpost.onclick = () =&gt; &#123;\n    //post请求\n    fetch(`/api/loginpost`, &#123;\n      method: &#39;POST&#39;,\n      body: JSON.stringify(&#123;\n        username: username.value,\n        password: password.value,\n      &#125;),\n      headers: &#123;\n        &#39;Content-Type&#39;: &#39;application/json&#39;,\n      &#125;,\n    &#125;)\n      .then(res =&gt; res.text())\n      .then(res =&gt; &#123;\n        console.log(res);\n      &#125;);\n</code></pre>\n<h2 id=\"3-静态目录\"><a href=\"#3-静态目录\" class=\"headerlink\" title=\"3.静态目录\"></a>3.静态目录</h2><p><strong>server.js</strong></p>\n<pre><code class=\"javascript\">const http = require(&#39;http&#39;);\n\nconst route = &#123;&#125;;\n\nfunction use(routeObj) &#123;\n  Object.assign(route, routeObj);\n&#125;\n\nfunction start() &#123;\n  http\n    .createServer(async (req, res) =&gt; &#123;\n      const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n      try &#123;\n        route[url.pathname](req, res);\n          //使所有匹配不到的路径走404网页\n      &#125; catch (err) &#123;\n        route[&#39;/404&#39;](req, res);\n      &#125;\n    &#125;)\n    .listen(3000, () =&gt; &#123;\n      console.log(&#39;启动成功&#39;);\n    &#125;);\n&#125;\n\nmodule.exports = &#123;\n  use,\n  start,\n&#125;;\n</code></pre>\n<p><strong>route.js</strong></p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\nconst path = require(&#39;path&#39;);\n//根据文件后缀名自动获取响应头中content-type\nconst mime = require(&#39;mime&#39;);\n\nfunction render(res, path, type = &#39;&#39;) &#123;\n  res.writeHead(200, &#123; &#39;Content-Type&#39;: `$&#123;type ? type : &#39;text/html&#39;&#125;;charset=utf8` &#125;);\n  res.write(fs.readFileSync(path), &#39;utf-8&#39;);\n  res.end();\n&#125;\n\nconst route = &#123;\n  &#39;/login&#39;(req, res) &#123;\n    render(res, &#39;./static/login.html&#39;);\n  &#125;,\n  &#39;/home&#39;(req, res) &#123;\n    render(res, &#39;./static/home.html&#39;);\n  &#125;,\n  &#39;/404&#39;(req, res) &#123;\n    const url = new URL(req.url, &#39;http://127.0.0.1&#39;);\n     /*\n     &lt;link href=&#39;/css/index.css&#39;&gt;&lt;/link&gt;根路径访问，就等于127.0.0.1:3000/css/index.css。\n     这里将项目文件夹F://项目+static+/css/index.css合并成文件路径，如果存在就读取该文件返回\n     */\n    let pathname = path.join(__dirname, &#39;static&#39;, url.pathname);\n    if (readStaticFile(res, pathname)) &#123;\n      return;\n    &#125;\n    res.writeHead(404, &#123; &#39;Content-Type&#39;: &#39;text/html;charset=utf8&#39; &#125;);\n    res.write(fs.readFileSync(&#39;./static/404.html&#39;), &#39;utf-8&#39;);\n    res.end();\n  &#125;,\n&#125;;\n\nfunction readStaticFile(res, pathname) &#123;\n  let houzhui = pathname.split(&#39;.&#39;);\n    //如果存在这些静态资源就用fs的写入方法返回回去，不走404\n  if (fs.existsSync(pathname)) &#123;\n      //mime.getType(css)\n    render(res, pathname, mime.getType(houzhui[houzhui.length - 1]));\n    return true;\n  &#125; else &#123;\n    return false;\n  &#125;\n&#125;\n\nmodule.exports = route;\n</code></pre>\n","categories":["node.js"],"tags":["node.js"]},{"title":"Node学习笔记","url":"/2024/05/24/node/","content":"<h1 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>Node.js并不是JavaScript应用，也不是编程语言，而是JavaScript的运行时。</li>\n<li>Node.js是构建在V8引擎之上的，V8引擎由C &#x2F; C++编写，因此JavaScript语言需要编译为C &#x2F; C++代码之后才能执行。</li>\n<li>Node.js采用异步IO和事件驱动的设计理念，可以高效的处理大量并发请求，提供了非阻塞IO接口和事件循环机制，使其可以编写出高性能、高扩展的应用程序。（异步IO通过libuv库来实现）</li>\n<li>Node.js使用npm作为包管理工具</li>\n<li>Node.js适合做一些IO密集型应用，不适合做一些CPU密集型应用（事件循环机制和异步IO使得Node.js有很强的处理能力，但是因为Node.js单线程的原因，容易造成CPU占用率过高）</li>\n<li>如果非要用Node.js做CPU密集型应用，需要编写C++插件，或者Node提供的cluster模块。</li>\n</ul>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ul>\n<li>npm是Node.js的包管理工具，它基于命令行，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qaWF4aWFveGlhby5uZXRsaWZ5LmFwcC8yMDE5LzA3LzMwL25vZGUvbm9kZS1ucG0v\">npm命令大全</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTQ1NzU5ODY4MDEwMzY0OTU5\">package.json配置详解</span></li>\n</ul>\n<h4 id=\"npm-install\"><a href=\"#npm-install\" class=\"headerlink\" title=\"npm install\"></a>npm install</h4><p>执行<code>npm install</code>时，npm会通过广度优先遍历算法遍历依赖树，npm会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有的依赖被处理完成。在处理每个依赖时，npm会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本。</p>\n<p><img data-src=\"/images/Snipaste_2024-05-28_18-35-31.png\" alt=\"images\"></p>\n<h4 id=\"npmrc文件\"><a href=\"#npmrc文件\" class=\"headerlink\" title=\".npmrc文件\"></a>.npmrc文件</h4><pre><code class=\"bash\">registry=http://registry.npmjs.org/\n# 定义npm的registry，即npm的包下载源\nproxy=http://proxy.example.com:8080/\n# 定义npm的代理服务器，用于访问网络\nhttps-proxy=http://proxy.example.com:8080/\n# 定义npm的https代理服务器，用于访问网络\nstrict-ssl=true\n# 是否在SSL证书验证错误时退出\ncafile=/path/to/cafile.pem\n# 定义自定义CA证书文件的路径\nuser-agent=npm/&#123;npm-version&#125; node/&#123;node-version&#125; &#123;platform&#125;\n# 自定义请求头中的User-Agent\nsave=true\n# 安装包时是否自动保存到package.json的dependencies中\nsave-dev=true\n# 安装包时是否自动保存到package.json的devDependencies中\nsave-exact=true\n# 安装包时是否精确保存版本号\nengine-strict=true\n# 是否在安装时检查依赖的node和npm版本是否符合要求\nscripts-prepend-node-path=true\n# 是否在运行脚本时自动将node的路径添加到PATH环境变量中\n</code></pre>\n<h4 id=\"package-lock-json\"><a href=\"#package-lock-json\" class=\"headerlink\" title=\"package-lock.json\"></a>package-lock.json</h4><p>文件的作用：</p>\n<ul>\n<li><p>锁定版本号、记录依赖树详细信息</p>\n</li>\n<li><p>package-lock.json帮我们做了缓存，他会通过 <code>name + version + integrity</code> 信息生成一个唯一的key，这个key能找到对应的index-v5 下的缓存记录 （npm cache 文件夹下），如果发现有缓存记录，就会找到tar包的hash值，然后将对应的二进制文件解压到node_modeules</p>\n</li>\n</ul>\n<h4 id=\"npm-run\"><a href=\"#npm-run\" class=\"headerlink\" title=\"npm run\"></a>npm run</h4><p>读取package.json的scripts对应的脚本命令，查找的规则是：</p>\n<ol>\n<li>当前项目node_modules&#x2F;.bin查找</li>\n<li>全局node_modules&#x2F;.bin查找</li>\n<li>环境变量查找</li>\n<li>找不到，报错</li>\n</ol>\n<p>node_modules&#x2F;.bin中有三个文件（Node作为跨平台工具，需要处理平台兼容性）</p>\n<ul>\n<li>.sh文件是给Linux unix Macos 使用</li>\n<li>.cmd 给windows的cmd使用</li>\n<li>.ps1 给windows的powerShell 使用</li>\n</ul>\n<h4 id=\"npm-生命周期\"><a href=\"#npm-生命周期\" class=\"headerlink\" title=\"npm 生命周期\"></a>npm 生命周期</h4><p>在package.json中的scripts字段中，我们可以利用npm脚本命名规范使用npm的生命周期特性，例如：</p>\n<pre><code class=\"javascripton\">    &quot;pretest&quot;: &quot;node prev.js&quot;,\n    &quot;test&quot;: &quot;node index.js&quot;,\n    &quot;posttest&quot;: &quot;node post.js&quot;\n</code></pre>\n<p>则执行：npm run test时，会最先执行pretest，最后执行posttest。</p>\n<h4 id=\"npx\"><a href=\"#npx\" class=\"headerlink\" title=\"npx\"></a>npx</h4><p>npx是一个命令行工具，它是npm 5.2.0版本中新增的功能。它允许用户在不安装全局包的情况下，运行已安装在本地项目中的包或者远程仓库中的包。</p>\n<p>npx的作用是在命令行中运行node包中的可执行文件，而不需要全局安装这些包。这可以使开发人员更轻松地管理包的依赖关系，并且可以避免全局污染的问题。它还可以帮助开发人员在项目中使用不同版本的包，而不会出现版本冲突的问题。</p>\n<p><strong>npx 的优势</strong></p>\n<ol>\n<li>避免全局安装：<code>npx</code>允许你执行npm package，而不需要你先全局安装它。</li>\n<li>总是使用最新版本：如果你没有在本地安装相应的npm package，<code>npx</code>会从npm的package仓库中下载并使用最新版。</li>\n<li>执行任意npm包：<code>npx</code>不仅可以执行在<code>package.json</code>的<code>scripts</code>部分定义的命令，还可以执行任何npm package。</li>\n<li>执行GitHub gist：<code>npx</code>甚至可以执行GitHub gist或者其他公开的JavaScript文件。</li>\n</ol>\n<p><strong>npm 和 npx 区别</strong></p>\n<ul>\n<li><p><code>npx</code>侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令</p>\n</li>\n<li><p><code>npm</code>侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。</p>\n</li>\n</ul>\n<h4 id=\"npm私服\"><a href=\"#npm私服\" class=\"headerlink\" title=\"npm私服\"></a>npm私服</h4><p><strong>优势：</strong></p>\n<ul>\n<li><strong>可以离线使用</strong>，你可以将npm私服部署到内网集群，这样离线也可以访问私有的包。</li>\n<li><strong>提高包的安全性</strong>，使用私有的npm仓库可以更好的管理你的包，避免在使用公共的npm包的时候出现漏洞。</li>\n<li><strong>提高包的下载速度</strong>，使用私有 npm 仓库，你可以将经常使用的 npm 包缓存到本地，从而显著提高包的下载速度，减少依赖包的下载时间。这对于团队内部开发和持续集成、部署等场景非常</li>\n</ul>\n<p><strong>搭建：</strong></p>\n<ul>\n<li>可以克隆npm或cnpm仓库，更改yaml配置文件为自己想要的设置即可</li>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly92ZXJkYWNjaW8ub3JnL3poLWNuLw==\">verdaccio工具</span><ul>\n<li><code>npm install verdaccio -g</code></li>\n<li><code>verdaccio</code></li>\n<li>访问localhost:4873</li>\n<li>使用npm操作时，加上<code>--registry http://localhost:4873</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Node模块化\"><a href=\"#Node模块化\" class=\"headerlink\" title=\"Node模块化\"></a>Node模块化</h2><h4 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h4><ul>\n<li><p>支持引入内置模块例如 <code>http</code> <code>os</code> <code>fs</code> <code>child_process</code> 等nodejs内置模块</p>\n</li>\n<li><p>支持引入第三方模块<code>express</code> <code>md5</code> <code>koa</code> 等</p>\n</li>\n<li><p>支持引入自己编写的模块 .&#x2F; ..&#x2F; 等</p>\n</li>\n<li><p>支持引入addon C++扩展模块 .node文件</p>\n</li>\n</ul>\n<h4 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h4><ul>\n<li>import静态导入需要在顶层调用</li>\n<li>import导入json文件需要添加断言（低版本node不可用）</li>\n<li>支持函数式动态导入</li>\n</ul>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ol>\n<li>CommonJS基于运行时的同步加载，ESM基于编译时的异步加载</li>\n<li>CommonJS是可以修改值的，ESM值并且不可修改（可读的）</li>\n<li>CommonJS不可以tree shaking，ESM支持tree shaking</li>\n<li>CommonJS中顶层的this指向这个模块本身，而ESM中顶层this指向undefined</li>\n</ol>\n<h4 id=\"require执行顺序\"><a href=\"#require执行顺序\" class=\"headerlink\" title=\"require执行顺序\"></a>require执行顺序</h4><ol>\n<li>.js文件，调用compile函数进行执行。</li>\n<li>.json文件，读取文件内容，调用JSON.parse方法处理。</li>\n<li>.node文件，通过process.dlopen方法进行处理。</li>\n</ol>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><h4 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h4><ul>\n<li>浏览器端的全局对象是window</li>\n<li>Node环境的全局对象是global</li>\n<li>global上定义的变量在当前环境执行任何文件时都可以访问到</li>\n<li>ES2020推出globalThis用于兼容window和global（自动切换）</li>\n</ul>\n<h4 id=\"dirname\"><a href=\"#dirname\" class=\"headerlink\" title=\"__dirname\"></a>__dirname</h4><p>当前模块所在目录的绝对路径</p>\n<h4 id=\"filename\"><a href=\"#filename\" class=\"headerlink\" title=\"__filename\"></a>__filename</h4><p>当前模块文件所在的绝对路径，包括文件名和文件扩展名</p>\n<h4 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h4><h4 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h4><h4 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h4><ul>\n<li><p><code>process.argv</code></p>\n<ul>\n<li>第一个参数是当前执行环境的路径</li>\n<li>第二个参数是当前执行的文件的路径</li>\n<li>剩余的参数是传递给脚本文件的命令行参数</li>\n</ul>\n</li>\n<li><p><code>process.env</code>环境变量</p>\n</li>\n<li><p><code>process.cwd()</code>返回当前工作目录路径</p>\n</li>\n<li><p><code>process.on(event,listener)</code>，监听进程变化</p>\n</li>\n<li><p><code>process.exit([code])</code>，退出Node进程，提供退出码</p>\n</li>\n<li><p><code>process.pid</code>返回进程id</p>\n</li>\n</ul>\n<h4 id=\"Buffer类\"><a href=\"#Buffer类\" class=\"headerlink\" title=\"Buffer类\"></a>Buffer类</h4><p>Node.js 6.0版本开始，<code>Buffer</code>构造函数的使用已被弃用，推荐使用<code>Buffer.alloc()</code>、<code>Buffer.from()</code>等方法来创建<code>Buffer</code>实例。</p>\n<h4 id=\"DOM、BOM\"><a href=\"#DOM、BOM\" class=\"headerlink\" title=\"DOM、BOM\"></a>DOM、BOM</h4><p>Node环境中无法操作DOM和BOM，不过可以借助一些工具进行模拟，例如：<code>jsdom</code></p>\n<pre><code class=\"javascript\">const fs = require(&#39;node:fs&#39;)\nconst &#123; JSDOM &#125; = require(&#39;jsdom&#39;) // jsdom模拟浏览器环境\nconst dom = new JSDOM(`&lt;!DOCTYPE html&gt;&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;`)\nconst document = dom.window.document\nconst window = dom.window\nfetch(&#39;https://api.thecatapi.com/v1/images/search?limit=10&amp;page=1&#39;).then(res =&gt; res.json()).then(data =&gt; &#123;\n    const app = document.getElementById(&#39;app&#39;)\n    data.forEach(item=&gt;&#123;\n       const img =  document.createElement(&#39;img&#39;)\n       img.src = item.url\n       img.style.width = &#39;200px&#39;\n       img.style.height = &#39;200px&#39;\n       app.appendChild(img)\n    &#125;)\n    fs.writeFileSync(&#39;./index.html&#39;, dom.serialize())\n&#125;)\n</code></pre>\n<h2 id=\"path模块\"><a href=\"#path模块\" class=\"headerlink\" title=\"path模块\"></a>path模块</h2><p>path模块在windows和posix系统中是有差异的。</p>\n<ul>\n<li>posix表示可移植操作系统接口，也就是定义了一套标准，遵守这套标准的操作系统有(unix,like unix,linux,macOs,windows wsl)，用于多个平台间相互兼容</li>\n<li>Windows 并没有完全遵循 POSIX 标准，在 Windows 系统中，路径使用反斜杠（<code>\\</code>）作为路径分隔符。这与 POSIX 系统使用的正斜杠（<code>/</code>）是不同的</li>\n</ul>\n<p><strong>差异举例：</strong></p>\n<pre><code>path.basename(&#39;C:\\temp\\myfile.html&#39;); \n// 在posix中 返回: &#39;C:\\temp\\myfile.html&#39;\n// 在windows中 返回 empmyfile.html\n</code></pre>\n<ul>\n<li>path.basename返回文件名（包括后缀）</li>\n</ul>\n<pre><code class=\"javascript\">path.basename(&#39;C:/fs/dmq/MI/index.html&#39;) //返回index.html\n</code></pre>\n<ul>\n<li><code>path.extname</code>返回扩展名</li>\n<li><code>path.join</code>路径拼接（路径拼接）</li>\n<li><code>path.resolve</code>解析绝对路径并且返回绝对路径（路径解析）</li>\n<li><code>path.parse</code>将路径解析为对象</li>\n<li><code>path.format</code>将对象解析为路径</li>\n</ul>\n<h2 id=\"os模块\"><a href=\"#os模块\" class=\"headerlink\" title=\"os模块\"></a>os模块</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>API</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>os.type()</strong></td>\n<td>它在 Linux 上返回 <code>&#39;Linux&#39;</code>，在 macOS 上返回 <code>&#39;Darwin&#39;</code>，在 Windows 上返回 <code>&#39;Windows_NT&#39;</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><strong>os.platform()</strong></td>\n<td>返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为 <code>&#39;aix&#39;</code>、<code>&#39;darwin&#39;</code>、<code>&#39;freebsd&#39;</code>、<code>&#39;linux&#39;</code>、<code>&#39;openbsd&#39;</code>、<code>&#39;sunos&#39;</code>、以及 <code>&#39;win32&#39;</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><strong>os.release()</strong></td>\n<td>返回操作系统的版本例如10.xxxx win10</td>\n</tr>\n<tr>\n<td>4</td>\n<td><strong>os.homedir()</strong></td>\n<td>返回用户目录 例如c:\\user\\xiaoman 原理就是 windows <code>echo %USERPROFILE% </code>posix $HOME</td>\n</tr>\n<tr>\n<td>5</td>\n<td><strong>os.arch()</strong></td>\n<td>返回cpu的架构  可能的值为 <code>&#39;arm&#39;</code>、<code>&#39;arm64&#39;</code>、<code>&#39;ia32&#39;</code>、<code>&#39;mips&#39;</code>、<code>&#39;mipsel&#39;</code>、<code>&#39;ppc&#39;</code>、<code>&#39;ppc64&#39;</code>、<code>&#39;s390&#39;</code>、<code>&#39;s390x&#39;</code>、以及 <code>&#39;x64&#39;</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td><strong>os.cups()</strong></td>\n<td>获取<code>cpu线程</code>和cpu详细信息</td>\n</tr>\n<tr>\n<td>7</td>\n<td><strong>os.networkInterfaces()</strong></td>\n<td>获取<code>网络信息</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"process模块\"><a href=\"#process模块\" class=\"headerlink\" title=\"process模块\"></a>process模块</h2><ul>\n<li><p><code>process.argv</code></p>\n<ul>\n<li>第一个参数是当前执行环境的路径</li>\n<li>第二个参数是当前执行的文件的路径</li>\n<li>剩余的参数是传递给脚本文件的命令行参数</li>\n</ul>\n</li>\n<li><p><code>process.env</code>环境变量</p>\n</li>\n<li><p><code>process.cwd()</code>返回当前工作目录路径</p>\n</li>\n<li><p><code>process.on(event,listener)</code>，监听进程变化</p>\n</li>\n<li><p><code>process.exit([code])</code>，退出Node进程，提供退出码</p>\n</li>\n<li><p><code>process.pid</code>返回进程id</p>\n</li>\n<li><p><code>process.arch</code>返回操作系统CPU架构</p>\n</li>\n<li><p><code>process.memoryUsage</code>获取当前进程内存使用情况</p>\n</li>\n<li><p><code>process.kill(process.pid)</code>用于杀死一个进程</p>\n</li>\n</ul>\n<h2 id=\"child-process模块\"><a href=\"#child-process模块\" class=\"headerlink\" title=\"child_process模块\"></a>child_process模块</h2><p>子进程是Nodejs核心API，如果你会shell命令，他会有非常大的帮助，或者你喜欢编写前端工程化工具之类的，他也有很大的用处，以及处理CPU密集型应用。</p>\n<h4 id=\"创建子进程\"><a href=\"#创建子进程\" class=\"headerlink\" title=\"创建子进程\"></a>创建子进程</h4><p>Nodejs创建子进程共有<code>7个</code>API Sync同步API ，不加是异步API</p>\n<ol>\n<li>spawn  执行命令</li>\n<li>exec   执行命令</li>\n<li>execFile   执行可执行文件</li>\n<li>fork   创建node子进程</li>\n<li><code>execSync</code> 执行命令 同步执行</li>\n<li><code>execFileSync</code> 执行可执行文件 同步执行</li>\n<li><code>spawnSync</code> 执行命令 同步执行</li>\n</ol>\n<h2 id=\"cluster模块\"><a href=\"#cluster模块\" class=\"headerlink\" title=\"cluster模块\"></a>cluster模块</h2><ul>\n<li><p>cluster模块也用于创建node子进程</p>\n</li>\n<li><p>相比较于child_process模块，cluster模块主要用于利用多核CPU的优势，通过创建多个工作进程来提高应用程序的并发处理能力。</p>\n</li>\n<li><p>cluster模块创建的每个工作进程都是独立地node.js进程，他们共享一个端口和监听器，由主进程负责分配请求到各个工作进程。</p>\n</li>\n<li><p>cluster模块自动实现请求的负载均衡，主进程会根据工作进程的负载请情况将请求分配给不同的工作进程。</p>\n</li>\n<li><p>进程通过process.send方法进行通信，但常用于工作进程和主进程之间的通信。</p>\n</li>\n<li><p>cluster模块支持优雅关闭工作进程，允许工作进程在关闭之前完成当前正在处理的请求。</p>\n</li>\n</ul>\n<h2 id=\"ffmpeg工具\"><a href=\"#ffmpeg工具\" class=\"headerlink\" title=\"ffmpeg工具\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mZm1wZWcucDJocC5jb20vZG93bmxvYWQuaHRtbA==\">ffmpeg工具</span></h2><p>FFmpeg 是一个开源的跨平台多媒体处理工具，可以用于处理音频、视频和多媒体流。它提供了一组强大的命令行工具和库，可以进行视频转码、视频剪辑、音频提取、音视频合并、流媒体传输等操作。</p>\n<h2 id=\"events模块\"><a href=\"#events模块\" class=\"headerlink\" title=\"events模块\"></a>events模块</h2><p>Node.js的事件模型采用发布订阅的设计思想，将发布者和订阅者之间解耦合，使得双方能够独立地扩展自己。</p>\n<pre><code class=\"javascript\">const EventEmitter = require(&#39;events&#39;);\nconst event = new EventEmitter()\n//监听test\nevent.on(&#39;test&#39;,(data)=&gt;&#123;\n    console.log(data)\n&#125;)\nevent.emit(&#39;test&#39;,&#39;data数据&#39;) //派发事件\n</code></pre>\n<p>event实例默认监听10个为上限，可以通过<code>setMaxListeners()</code>方法来设置监听上限。</p>\n<pre><code class=\"javascript\">event.setMaxListeners(20)\n</code></pre>\n<p><code>event.once方法</code>可以只订阅一次</p>\n<pre><code class=\"javascript\">event.once(&#39;test&#39;,(data)=&gt;&#123;\n    console.log(&#39;once取代on，只监听一次&#39;)\n&#125;)\n</code></pre>\n<p><code>event.off</code>方法取消订阅</p>\n<pre><code class=\"javascript\">event.on(&#39;test&#39;, fn) // 订阅事件\nevent.off(&#39;test&#39;, fn) // 取消事件订阅\n</code></pre>\n<h4 id=\"SSE\"><a href=\"#SSE\" class=\"headerlink\" title=\"SSE\"></a>SSE</h4><ul>\n<li><p>SSE（server send events）服务端推送事件</p>\n</li>\n<li><p>是一种实现服务端向客户端推送数据的技术，也被称为事件流</p>\n</li>\n<li><p>它是基于HTTP协议，利用HTTP协议长连接的优势，实现服务端向客户端推送实时数据。</p>\n</li>\n<li><p>浏览器端需要使用<code>EventSource</code>注册api地址，服务端需要对该地址的响应头中设置Content-Type为 <code>text/event-stream </code></p>\n</li>\n</ul>\n<p><strong>node后端：</strong></p>\n<pre><code class=\"javascript\">import express from &#39;express&#39;;\nconst app = express();\napp.get(&#39;/api/sse&#39;, (req, res) =&gt; &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-Type&#39;: &#39;text/event-stream&#39;, //核心返回数据流\n        &#39;Connection&#39;: &#39;close&#39;\n    &#125;)\n    const data = fs.readFileSync(&#39;./index.txt&#39;, &#39;utf8&#39;)\n    const total = data.length;\n    let current = 0;\n    //mock sse 数据\n    let time = setInterval(() =&gt; &#123;\n        console.log(current, total)\n        if (current &gt;= total) &#123;\n            console.log(&#39;end&#39;)\n            clearInterval(time)\n            return\n        &#125;\n        //返回自定义事件名\n        res.write(`event:name\\n`)\n        //返回数据\n        res.write(`data:$&#123;data.split(&#39;&#39;)[current]&#125;\\n\\n`)\n        current++\n    &#125;, 300)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Listening on port 3000&#39;);\n&#125;);\n</code></pre>\n<p><strong>客户端：</strong></p>\n<pre><code class=\"javascript\">const sse = new EventSource(&#39;http://localhost:3000/api/sse&#39; )\nif (sse.readyState === EventSource.CONNECTING) &#123;\n  console.log(&#39;正在连接服务器...&#39;);\n&#125; else if (sse.readyState === EventSource.OPEN) &#123;\n  console.log(&#39;已经连接上服务器！&#39;);\n&#125; else if (sse.readyState === EventSource.CLOSED) &#123;\n  console.log(&#39;连接已经关闭。&#39;);\n&#125;\nsse.onmessage = (data)=&gt;&#123;\n    console.log(data);\n&#125;\nsse.onerror = (e)=&gt;&#123;\n    sse.close(); //关闭连接\n    console.error(e);\n&#125;\nsse.addEventListener(&#39;open&#39;, (e) =&gt; &#123;\n    console.log(&#39;连接成功&#39;);\n&#125;)\n//对应后端nodejs自定义的事件名lol\nsse.addEventListener(&#39;name&#39;, (e) =&gt; &#123;\n    console.log(e.data)\n&#125;)\n</code></pre>\n<h2 id=\"util模块\"><a href=\"#util模块\" class=\"headerlink\" title=\"util模块\"></a>util模块</h2><p>Node.js内部提供的工具集模块，方便快速开发</p>\n<ul>\n<li><p><code>util.promisify</code>将函数改为promise类型的形式</p>\n</li>\n<li><p><code>util.callbackify</code>将promise类型的api改为函数形式</p>\n</li>\n<li><p><code>util.format</code>用于格式化文本</p>\n<ul>\n<li><code>%s</code>: <code>String</code> 将用于转换除 <code>BigInt</code>、<code>Object</code> 和 <code>-0</code> 之外的所有值。 <code>BigInt</code> 值将用 <code>n</code> 表示，没有用户定义的 <code>toString</code> 函数的对象使用具有选项 <code>&#123; depth: 0, colors: false, compact: 3 &#125;</code> 的 <code>util.inspect()</code> 进行检查。</li>\n<li><code>%d</code>: <code>Number</code> 将用于转换除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%i</code>: <code>parseInt(value, 10)</code> 用于除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%f</code>: <code>parseFloat(value)</code> 用于除 <code>Symbol</code> 之外的所有值。</li>\n<li><code>%j</code>: JSON。 如果参数包含循环引用，则替换为字符串 <code>&#39;[Circular]&#39;</code>。</li>\n<li><code>%o</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 <code>&#123; showHidden: true, showProxy: true &#125;</code> 的 <code>util.inspect()</code>。 这将显示完整的对象，包括不可枚举的属性和代理。</li>\n<li><code>%O</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 <code>util.inspect()</code>。 这将显示完整的对象，但不包括不可枚举的属性和代理。</li>\n<li><code>%c</code>: <code>CSS</code>. 此说明符被忽略，将跳过任何传入的 CSS。</li>\n<li><code>%%</code>: 单个百分号 (<code>&#39;%&#39;</code>)。 这不消费参数。</li>\n</ul>\n</li>\n<li><p>其他工具函数省略</p>\n</li>\n</ul>\n<h2 id=\"pngquant工具\"><a href=\"#pngquant工具\" class=\"headerlink\" title=\"pngquant工具\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbmdxdWFudC5vcmcv\">pngquant工具</span></h2><p><code>pngquant</code> 是一个用于压缩 PNG 图像文件的工具。它可以显著减小 PNG 文件的大小，同时保持图像质量和透明度。通过减小文件大小，可以提高网页加载速度，并节省存储空间。<code>pngquant</code> 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。</p>\n<h2 id=\"fs模块\"><a href=\"#fs模块\" class=\"headerlink\" title=\"fs模块\"></a>fs模块</h2><p>在 Node.js 中，<code>fs</code> 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 <code>fs</code> 模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，<code>Node.js 核心API之一</code>。</p>\n<h4 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h4><ul>\n<li><p>fs支持同步和异步两种模式 增加了<code>Sync</code> fs 就会采用同步的方式运行代码，会阻塞下面的代码，不加Sync就是异步的模式不会阻塞。</p>\n</li>\n<li><p>fs新增了promise版本，只需要在引入包后面增加&#x2F;promise即可，fs便可支持promise回调。</p>\n</li>\n<li><p>fs返回的是一个buffer二进制数据 每两个十六进制数字表示一个字节</p>\n</li>\n</ul>\n<h4 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h4><ul>\n<li><code>fs.readFile</code>异步读取文件</li>\n<li><code>fs.writeFile</code>异步写入文件</li>\n<li><code>fs.appendFile</code>文件异步追加写入内容</li>\n<li><code>fs.copyFile</code>文件异步拷贝写入</li>\n<li><code>fs.open</code>异步打开文件</li>\n<li><code>fs.close</code>异步关闭文件</li>\n<li><code>fs.read</code>异步读取文件</li>\n<li><code>fs.write</code>异步将Buffer中的数据写入文件</li>\n<li><code>fs.access</code>异步检查文件是否可读可写</li>\n<li><code>fs.stat</code>异步获取文件目录的stats对象（文件夹信息）</li>\n<li><code>fs.mkdir</code>异步创建文件夹</li>\n<li><code>fs.readdir</code>异步读取文件夹</li>\n<li><code>fs.rmdir</code>异步删除目录</li>\n<li><code>fs.unlink</code>异步删除文件</li>\n<li>以上方法都有对应的同步执行的方法，在方法名后面加上Sync后缀即可。</li>\n</ul>\n<h4 id=\"fs-x2F-promises\"><a href=\"#fs-x2F-promises\" class=\"headerlink\" title=\"fs&#x2F;promises\"></a>fs&#x2F;promises</h4><p>node中fs模块的方法提供了Promise版本的调用形式，导入即可使用promise的使用方式调用api</p>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><p>Node.js中fs模块是由libuv来进行调度的，文件读取完成之后libuv才会将fs的结果推入V8的队列。</p>\n<h4 id=\"writeFileSync\"><a href=\"#writeFileSync\" class=\"headerlink\" title=\"writeFileSync\"></a>writeFileSync</h4><ul>\n<li>第一个参数是要写入的文件</li>\n<li>第二个参数是写入的内容</li>\n<li>第三个参数是写入方式配置项，其flag有以下配置：<ul>\n<li><code>&#39;a&#39;</code>: 打开文件进行追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;ax&#39;</code>: 类似于 <code>&#39;a&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;a+&#39;</code>: 打开文件进行读取和追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;ax+&#39;</code>: 类似于 <code>&#39;a+&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;as&#39;</code>: 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;as+&#39;</code>: 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。</li>\n<li><code>&#39;r&#39;</code>: 打开文件进行读取。 如果文件不存在，则会发生异常。</li>\n<li><code>&#39;r+&#39;</code>: 打开文件进行读写。 如果文件不存在，则会发生异常。</li>\n<li><code>&#39;rs+&#39;</code>: 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。</li>\n<li><code>&#39;w&#39;</code>: 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。</li>\n<li><code>&#39;wx&#39;</code>: 类似于 <code>&#39;w&#39;</code> 但如果路径存在则失败。</li>\n<li><code>&#39;w+&#39;</code>: 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。</li>\n<li><code>&#39;wx+&#39;</code>: 类似于 <code>&#39;w+&#39;</code> 但如果路径存在则失败。</li>\n</ul>\n</li>\n</ul>\n<p>例如追加文件内容除了可以使用<code>appendFileSync</code>之外，还可以：</p>\n<pre><code class=\"javascript\">fs.writeFileSync(&#39;index.txt&#39;, &#39;追加的内容&#39;,&#123;\n    flag: &#39;a&#39; //配置options中的flag\n&#125;)\n</code></pre>\n<h4 id=\"可写流\"><a href=\"#可写流\" class=\"headerlink\" title=\"可写流\"></a>可写流</h4><pre><code class=\"javascript\">const fs = require(&#39;node:fs&#39;)\nlet verse = [\n    &#39;待到秋来九月八&#39;,\n    &#39;我花开后百花杀&#39;,\n    &#39;冲天香阵透长安&#39;,\n    &#39;满城尽带黄金甲&#39;\n]\nlet writeStream = fs.createWriteStream(&#39;index.txt&#39;) //创建写入流\nverse.forEach(item =&gt; &#123;\n    writeStream.write(item + &#39;\\n&#39;) //写入内容\n&#125;)\nwriteStream.end()\nwriteStream.on(&#39;finish&#39;,()=&gt;&#123; //监听写入完成事件\n    console.log(&#39;写入完成&#39;)\n&#125;)\n</code></pre>\n<p>我们可以创建一个可写流 打开一个通道，可以一直写入数据，用于处理大量的数据写入，写入完成之后调用end 关闭可写流，监听finish 事件 写入完成</p>\n<h4 id=\"硬链接、软连接\"><a href=\"#硬链接、软连接\" class=\"headerlink\" title=\"硬链接、软连接\"></a>硬链接、软连接</h4><h6 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h6><ul>\n<li>文件存储在磁盘上，磁盘的最小存储单位叫做<code>扇区</code>，每个扇区存储512字节</li>\n<li>操作系统读取磁盘时，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，多个扇区称之为<code>块</code></li>\n<li><code>块</code>是文件读取的最小单位</li>\n<li>文件数据都存储在<code>块</code>中，因此需要一个地方存储文件的元信息，这中存储文件元信息的区域就叫做<code>inode</code>，索引节点</li>\n<li>创建软链接时生成了新的<code>inode</code>，创建硬链接时没有。</li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-07-39.png\" alt=\"扇区、块和inode\"></p>\n<p><strong>inode中包含信息：</strong></p>\n<ul>\n<li>文件的字节数</li>\n<li>文件拥有者ID</li>\n<li>文件的Group ID</li>\n<li>文件读、写、执行权限</li>\n<li>文件的时间戳</li>\n<li>链接数</li>\n<li>文件数据block的位置</li>\n</ul>\n<p>每一个 <code>inode</code> 都有一个唯一的标识码 ，上面的输出信息中 <code>ino</code> 就是 <code>inode</code> 的唯一标识码，在 <code>linux</code> 系统内部使用 <code>inode</code> 的标识码来识别文件，并不使用文件名。之前系的</p>\n<p>在 <code>linux</code> 系统中，目录也是一种文件。目录文件包含一系列目录项，每一个目录项由两部分组成：所包含文件的文件名，以及文件名对应的 <code>inode</code> 标识码。我们可以使用 <code>ls -i</code> 来列出目录中的文件以及所有的 <code>inde</code> 标识码。这里也可以解释可能小伙伴们觉得说不通的问题，仅修改目录的读权限，并不能实现读取目录下所有文件内容的原因，最后需要通过递归目录下的文件来进行修改。</p>\n<h6 id=\"软链接\"><a href=\"#软链接\" class=\"headerlink\" title=\"软链接\"></a>软链接</h6><p>软链接类似于 <code>Window</code> 中的 “快捷方式” 。创建软链接会创建一个新的 <code>inode</code>，比如为文件 <code>a</code> 创建了软链接文件 b，文件 <code>b</code> 内部会指向 <code>a</code> 的 <code>inode</code>。当我们读取文件<code>b</code>的时候，系统会自动导向文件 <code>a</code> ，文件 <code>b</code> 就是文件 <code>a</code> 软连接(或者叫符号链接)。</p>\n<ul>\n<li>访问：创建了软链接后我们就可以使用不同的文件名访问相同的内容，</li>\n<li>修改：修改文件 <code>a</code> 的内容，文件 <code>b</code> 的内容也会发生改变，对文件内容的修改向放映到所有文件。</li>\n<li>删除：当我们删除源文件 <code>a</code> 时，在访问软连接文件 b 是，会报错 <code>&quot;No such file or directory&quot;</code></li>\n</ul>\n<p>可以直接使用 <code>linux</code> 命令 <code>ln -s source target</code> 来创建软链接(注意：表示 <code>target</code> “指向” <code>source</code>）</p>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-12-05.png\" alt=\"软链接\"></p>\n<h6 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h6><p>一般情况，一个文件名”唯一”对应一个 <code>inode</code>。但是 <code>linux</code> 允许多个文件名都指向同一个 <code>inode</code>。表示我们可以使用不同对文件名访问同样的内容；对文件内容进行修改将放映到所有文件；删除一个文件不影响另一个文件对访问。这种机制就被称为”硬链接”</p>\n<p>硬链接的创建 可以直接使用 <code>linux</code> 命令 <code>ln source target</code> 来创建硬链接（注意：<code>source</code> 已存在的文件，target 是将要建立的链接）</p>\n<p><img data-src=\"/images/Snipaste_2024-05-29_14-14-11.png\" alt=\"硬链接\"></p>\n<h6 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h6><pre><code class=\"javascript\">fs.linkSync(&#39;./index.txt&#39;, &#39;./index2.txt&#39;) //硬链接\nfs.symlinkSync(&#39;./index.txt&#39;, &#39;./index3.txt&#39; ,&quot;file&quot;) //软连接\n</code></pre>\n<h6 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h6><p><strong>硬链接的作用和用途如下：</strong></p>\n<ol>\n<li>文件共享：硬链接允许多个文件名指向同一个文件，这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的修改会反映在所有引用文件上。</li>\n<li>文件备份：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始文件保持同步。</li>\n<li>文件重命名：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。</li>\n</ol>\n<p><strong>软链接的一些特点和用途如下：</strong></p>\n<ol>\n<li>软链接可以创建指向文件或目录的引用。这使得你可以在不复制或移动文件的情况下引用它们，并在不同位置使用不同的文件名访问相同的内容。</li>\n<li>软链接可以用于创建快捷方式或别名，使得你可以通过一个简短或易记的路径来访问复杂或深层次的目录结构。</li>\n<li>软链接可以用于解决文件或目录的位置变化问题。如果目标文件或目录被移动或重命名，只需更新软链接的目标路径即可，而不需要修改引用该文件或目录的其他代码。</li>\n</ol>\n<h2 id=\"crypto模块\"><a href=\"#crypto模块\" class=\"headerlink\" title=\"crypto模块\"></a>crypto模块</h2><p>crypto模块的目的是为了提供通用的<code>加密和哈希算法</code>。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。nodejs用C&#x2F;C++实现这些算法后，通过crypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n<p>密码学是计算机科学中的一个重要领域，它涉及到加密、解密、哈希函数和数字签名等技术。Node.js是一个流行的服务器端JavaScript运行环境，它提供了强大的密码学模块，使开发人员能够轻松地在其应用程序中实现各种密码学功能。本文将介绍密码学的基本概念，并探讨Node.js中常用的密码学API。</p>\n<h4 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h4><pre><code class=\"javascript\">js复制代码const crypto = require(&#39;node:crypto&#39;);\n\n// 生成一个随机的 16 字节的初始化向量 (IV)\nconst iv = Buffer.from(crypto.randomBytes(16));\n\n// 生成一个随机的 32 字节的密钥\nconst key = crypto.randomBytes(32);\n\n// 创建加密实例，使用 AES-256-CBC 算法，提供密钥和初始化向量\nconst cipher = crypto.createCipheriv(&quot;aes-256-cbc&quot;, key, iv);\n\n// 对输入数据进行加密，并输出加密结果的十六进制表示\ncipher.update(&quot;小满zs&quot;, &quot;utf-8&quot;, &quot;hex&quot;);\nconst result = cipher.final(&quot;hex&quot;);\n\n// 解密\nconst de = crypto.createDecipheriv(&quot;aes-256-cbc&quot;, key, iv);\nde.update(result, &quot;hex&quot;);\nconst decrypted = de.final(&quot;utf-8&quot;);\n\nconsole.log(&quot;Decrypted:&quot;, decrypted);\n</code></pre>\n<p>对称加密是一种简单而快速的加密方式，它使用相同的密钥（称为对称密钥）来进行加密和解密。这意味着发送者和接收者在加密和解密过程中都使用相同的密钥。对称加密算法的加密速度很快，适合对大量数据进行加密和解密操作。然而，对称密钥的安全性是一个挑战，因为需要确保发送者和接收者都安全地共享密钥，否则有风险被未授权的人获取密钥并解密数据。</p>\n<h4 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h4><pre><code class=\"javascript\">js复制代码const crypto = require(&#39;node:crypto&#39;)\n// 生成 RSA 密钥对\nconst &#123; privateKey, publicKey &#125; = crypto.generateKeyPairSync(&#39;rsa&#39;, &#123;\n  modulusLength: 2048,\n&#125;);\n\n// 要加密的数据\nconst text = &#39;小满zs&#39;;\n\n// 使用公钥进行加密\nconst encrypted = crypto.publicEncrypt(publicKey, Buffer.from(text, &#39;utf-8&#39;));\n\n// 使用私钥进行解密\nconst decrypted = crypto.privateDecrypt(privateKey, encrypted);\n\nconsole.log(decrypted.toString());\n</code></pre>\n<p>非对称加密使用一对密钥，分别是公钥和私钥。发送者使用接收者的公钥进行加密，而接收者使用自己的私钥进行解密。公钥可以自由分享给任何人，而私钥必须保密。非对称加密算法提供了更高的安全性，因为即使公钥泄露，只有持有私钥的接收者才能解密数据。然而，非对称加密算法的加密速度相对较慢，不适合加密大量数据。因此，在实际应用中，通常使用非对称加密来交换对称密钥，然后使用对称加密算法来加密实际的数据。</p>\n<h4 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h4><pre><code class=\"javascript\">const crypto = require(&#39;node:crypto&#39;);\n// 要计算哈希的数据\nlet text = &#39;123456&#39;;\n// 创建哈希对象，并使用 MD5 算法\nconst hash = crypto.createHash(&#39;md5&#39;);\n// 更新哈希对象的数据\nhash.update(text);\n// 计算哈希值，并以十六进制字符串形式输出\nconst hashValue = hash.digest(&#39;hex&#39;);\nconsole.log(&#39;Text:&#39;, text);\nconsole.log(&#39;Hash:&#39;, hashValue);\n</code></pre>\n<p>哈希函数具有以下特点：</p>\n<ol>\n<li>固定长度输出：不论输入数据的大小，哈希函数的输出长度是固定的。例如，常见的哈希函数如 MD5 和 SHA-256 生成的哈希值长度分别为 128 位和 256 位。</li>\n<li>不可逆性：哈希函数是单向的，意味着从哈希值推导出原始输入数据是非常困难的，几乎不可能。即使输入数据发生微小的变化，其哈希值也会完全不同。</li>\n<li>唯一性：哈希函数应该具有较低的碰撞概率，即不同的输入数据生成相同的哈希值的可能性应该非常小。这有助于确保哈希值能够唯一地标识输入数据。</li>\n</ol>\n<p>使用场景</p>\n<ol>\n<li>我们可以避免密码明文传输 使用md5加密或者sha256</li>\n<li>验证文件完整性，读取文件内容生成md5 如果前端上传的md5和后端的读取文件内部的md5匹配说明文件是完整的</li>\n</ol>\n<h2 id=\"md转html\"><a href=\"#md转html\" class=\"headerlink\" title=\"md转html\"></a>md转html</h2><h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>ejs：模板渲染库，使用特定语法填充内容，进行模板渲染</li>\n<li>marked：用于将Markdown语法转为HTML</li>\n<li>browserSync：用于在浏览器实时预览和同步刷新</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>index.js</p>\n<pre><code class=\"javascript\">const ejs = require(&#39;ejs&#39;); // 导入ejs库，用于渲染模板\nconst fs = require(&#39;node:fs&#39;); // 导入fs模块，用于文件系统操作\nconst marked = require(&#39;marked&#39;); // 导入marked库，用于将Markdown转换为HTML\nconst readme = fs.readFileSync(&#39;README.md&#39;); // 读取README.md文件的内容,直接read的结果是buffer中的数据，通过toString方法变为原始内容\nconst browserSync = require(&#39;browser-sync&#39;); // 导入browser-sync库，用于实时预览和同步浏览器\nconst openBrowser =  () =&gt; &#123;\n    // 创建浏览器服务\n    const browser = browserSync.create()\n    // 初始化浏览器服务 ，传入目录和主页\n    browser.init(&#123;\n        server: &#123;\n            baseDir: &#39;./&#39;,\n            index: &#39;index.html&#39;,\n        &#125;\n    &#125;)\n    return browser\n&#125;\n// ejs模板进行渲染，传入变量\nejs.renderFile(&#39;template.ejs&#39;, &#123;\n    content: marked.parse(readme.toString()),\n    title:&#39;markdown to html&#39;\n&#125;,(err,data)=&gt;&#123;\n    if(err)&#123;\n        console.log(err)\n    &#125;\n    // 将文件内容写入到index.html\n    let writeStream = fs.createWriteStream(&#39;index.html&#39;)\n    writeStream.write(data)\n    writeStream.close()\n    writeStream.on(&#39;finish&#39;,()=&gt;&#123;\n        // index.html写入完毕之后，打开浏览器实时预览\n        openBrowser()\n    &#125;)\n&#125;)     \n</code></pre>\n<p>template.ejs</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;  &lt;!-- 引入css样式 --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- content %&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>index.css</p>\n<pre><code class=\"css\">/* Markdown通用样式 */\n/* 设置全局字体样式 */\nbody &#123;\n    font-family: Arial, sans-serif;\n    font-size: 16px;\n    line-height: 1.6;\n    color: #333;\n  &#125;\n  /* 设置标题样式 */\n  h1,h2,h3,h4,h5,h6 &#123;\n    margin-top: 1.3em;\n    margin-bottom: 0.6em;\n    font-weight: bold;\n  &#125;\n  h1 &#123;\n    font-size: 2.2em;\n  &#125;\n  h2 &#123;\n    font-size: 1.8em;\n  &#125;\n  h3 &#123;\n    font-size: 1.6em;\n  &#125;\n  h4 &#123;\n    font-size: 1.4em;\n  &#125;\n  h5 &#123;\n    font-size: 1.2em;\n  &#125;\n  h6 &#123;\n    font-size: 1em;\n  &#125;\n  /* 设置段落样式 */\n  p &#123;\n    margin-bottom: 1.3em;\n  &#125;\n  /* 设置链接样式 */\n  a &#123;\n    color: #337ab7;\n    text-decoration: none;\n  &#125;\n  a:hover &#123;\n    text-decoration: underline;\n  &#125;\n  /* 设置列表样式 */\n  ul,\n  ol &#123;\n    margin-top: 0;\n    margin-bottom: 1.3em;\n    padding-left: 2em;\n  &#125;\n  /* 设置代码块样式 */\n  pre &#123;\n    background-color: #f7f7f7;\n    padding: 1em;\n    border-radius: 4px;\n    overflow: auto;\n  &#125;\n  code &#123;\n    font-family: Consolas, Monaco, Courier, monospace;\n    font-size: 0.9em;\n    background-color: #f7f7f7;\n    padding: 0.2em 0.4em;\n    border-radius: 4px;\n  &#125;\n  /* 设置引用样式 */\n  blockquote &#123;\n    margin: 0;\n    padding-left: 1em;\n    border-left: 4px solid #ddd;\n    color: #777;\n  &#125;\n  /* 设置表格样式 */\n  table &#123;\n    border-collapse: collapse;\n    width: 100%;\n    margin-bottom: 1.3em;\n  &#125;\n  table th,\n  table td &#123;\n    padding: 0.5em;\n    border: 1px solid #ccc;\n  &#125;\n  /* 添加一些额外的样式，如图片居中显示 */\n  img &#123;\n    display: block;\n    margin: 0 auto;\n    max-width: 100%;\n    height: auto;\n  &#125;\n  /* 设置代码行号样式 */\n  pre code .line-numbers &#123;\n    display: inline-block;\n    width: 2em;\n    padding-right: 1em;\n    color: #999;\n    text-align: right;\n    user-select: none;\n    pointer-events: none;\n    border-right: 1px solid #ddd;\n    margin-right: 0.5em;\n  &#125;\n  /* 设置代码行样式 */\n  pre code .line &#123;\n    display: block;\n    padding-left: 1.5em;\n  &#125;\n  /* 设置代码高亮样式 */\n  pre code .line.highlighted &#123;\n    background-color: #f7f7f7;\n  &#125;\n  /* 添加一些响应式样式，适应移动设备 */\n  @media only screen and (max-width: 768px) &#123;\n    body &#123;\n      font-size: 14px;\n      line-height: 1.5;\n    &#125;\n    h1 &#123;\n      font-size: 1.8em;\n    &#125;\n    h2 &#123;\n      font-size: 1.5em;\n    &#125;\n    h3 &#123;\n      font-size: 1.3em;\n    &#125;\n    h4 &#123;\n      font-size: 1.1em;\n    &#125;\n    h5 &#123;\n      font-size: 1em;\n    &#125;\n    h6 &#123;\n      font-size: 0.9em;\n    &#125;\n    table &#123;\n      font-size: 14px;\n    &#125;\n  &#125;    \n</code></pre>\n<h2 id=\"zlib模块\"><a href=\"#zlib模块\" class=\"headerlink\" title=\"zlib模块\"></a>zlib模块</h2><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>Node.js中zlib模块用于对数据提供压缩和解压缩的功能，以便在应用程序中减少数据的传输大小、节省带宽和提高性能</li>\n<li>该模块包含各种压缩算法，包含Deflate、Gzip和Raw Deflate等</li>\n</ul>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ul>\n<li><p>数据压缩，减少数据的大小，这在网络传输和磁盘存储中很有用，可以节省带宽和存储空间</p>\n</li>\n<li><p>数据解压缩</p>\n</li>\n<li><p>流压缩，zlib模块支持流式的方式进行数据的压缩和解压缩，使得可以对大型文件或者网络数据流进行逐步处理，而不需要将整个数据加载到内存中。</p>\n<pre><code class=\"javascript\">// 压缩文件（以Gzip为例）\nconst zlib = require(&#39;zlib&#39;)\nconst fs = require(&#39;node:fs&#39;)\nconst readStream = fs.createReadStream(&#39;./test.txt&#39;);\nconst writeStream = fs.createWriteStream(&#39;./test.txt.gz&#39;);\n// 将readStream利用zlib进行压缩,pipe到下一个管道，最后pipe到写入流\nreadStream.pipe(zlib.createGzip()).pipe(writeStream)\n// 解压缩文件\nconst reStr = fs.createReadStream(&#39;./test.txt.gz&#39;);\nconst wrStr = fs.createWriteStream(&#39;./t.txt&#39;);\nconst gunzip = zlib.createGunzip();\nreStr.pipe(gunzip).pipe(wrStr);\ngunzip.on(&#39;error&#39;, (err) =&gt; &#123;\n    console.error(&#39;Gunzip error:&#39;, err);\n&#125;);\n  reStr.on(&#39;end&#39;, () =&gt; &#123;\n    console.log(&#39;Input file has been read.&#39;);\n&#125;);\n  wrStr.on(&#39;finish&#39;, () =&gt; &#123;\n    console.log(&#39;Output file has been written.&#39;);\n&#125;);\n</code></pre>\n<h4 id=\"对比-1\"><a href=\"#对比-1\" class=\"headerlink\" title=\"对比\"></a>对比</h4><ol>\n<li>压缩算法：Gzip 使用的是 Deflate 压缩算法，该算法结合了 LZ77 算法和哈夫曼编码。LZ77 算法用于数据的重复字符串的替换和引用，而哈夫曼编码用于进一步压缩数据。</li>\n<li>压缩效率：Gzip 压缩通常具有更高的压缩率，因为它使用了哈夫曼编码来进一步压缩数据。哈夫曼编码根据字符的出现频率，将较常见的字符用较短的编码表示，从而减小数据的大小。</li>\n<li>压缩速度：相比于仅使用 Deflate 的方式，Gzip 压缩需要更多的计算和处理时间，因为它还要进行哈夫曼编码的步骤。因此，在压缩速度方面，Deflate 可能比 Gzip 更快。</li>\n<li>应用场景：Gzip 压缩常用于文件压缩、网络传输和 HTTP 响应的内容编码。它广泛应用于 Web 服务器和浏览器之间的数据传输，以减小文件大小和提高网络传输效率。</li>\n<li>deflate是一种过时的压缩方式，现代浏览器对其支持并不友好</li>\n</ol>\n</li>\n</ul>\n<p><strong>zlib模块可以用于对发送网络请求返回的数据进行压缩，节省带宽和传输速率。</strong></p>\n<h4 id=\"brotli\"><a href=\"#brotli\" class=\"headerlink\" title=\"brotli\"></a>brotli</h4><ul>\n<li>针对常见的 Web 资源内容，Brotli 的性能比 Gzip 提高了 17-25%；</li>\n<li>当 Brotli 压缩级别为 1 时，压缩率比 Gzip 的最高级别 9 还要高；</li>\n<li>在处理不同的 HTML 文档时，Brotli 依然能提供非常高的压缩率。</li>\n<li>除了 IE 和 Opera Mini 之外，几乎所有主流浏览器都已支持 Brotli 算法。</li>\n<li>尽管 Brotli 在压缩方面表现出色，但随着压缩级别的提高，Brotli 压缩所需的时间也会相应增加。换句话说，Brotli 需要更多的计算能力，这可能意味着更高的设备和软件成本。</li>\n<li>Brotli 要求浏览器必须支持 HTTPS 才能使用。</li>\n</ul>\n<h2 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h2><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>http模块是Node.js中用于创建和处理HTTP服务器和客户端的核心模块</li>\n<li>http模块使得基于HTTP协议的应用程序更加简单和灵活</li>\n<li>http模块也可以用于创建代理服务器，用于转发客户端的请求到其他服务器，代理服务器可以用于负载均衡、缓存、安全过滤或跨域请求等场景。通过在代理服务器上添加逻辑，可以对请求和响应进行修改、记录或过滤。</li>\n<li>http模块也可以创建文件服务器，用于提供静态文件，通过读取文件并将其作为响应发送给客户端。</li>\n</ul>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code class=\"javascript\">const http = require(&#39;http&#39;)\nconst httpServer = http.createServer((req,res)=&gt;&#123;\n    if(req.method === &#39;POST&#39;)&#123;&#125;\n    else if(req.method === &#39;GET&#39;)&#123;&#125;\n&#125;)\nhttpServer.listen(98,()=&gt;&#123;\n    console.log(&#39;服务器启动，端口：98&#39;);\n&#125;)\n</code></pre>\n<h4 id=\"url模块\"><a href=\"#url模块\" class=\"headerlink\" title=\"url模块\"></a>url模块</h4><p>可以通过url模块来解析req的请求路径，来进一步精细化响应内容。</p>\n<pre><code class=\"javascript\">const http = require(&#39;node:http&#39;); // 引入 http 模块\nconst url = require(&#39;node:url&#39;); // 引入 url 模块\n// 创建 HTTP 服务器，并传入回调函数用于处理请求和生成响应\nhttp.createServer((req, res) =&gt; &#123;\n  const &#123; pathname, query &#125; = url.parse(req.url, true); // 解析请求的 URL，获取路径和查询参数\n  if (req.method === &#39;POST&#39;) &#123; // 检查请求方法是否为 POST\n    if (pathname === &#39;/post&#39;) &#123; // 检查路径是否为 &#39;/post&#39;\n      let data = &#39;&#39;;\n      req.on(&#39;data&#39;, (chunk) =&gt; &#123;\n        data += chunk; // 获取 POST 请求的数据\n        console.log(data);\n      &#125;);\n      req.on(&#39;end&#39;, () =&gt; &#123;\n        res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置响应头的 Content-Type 为 &#39;application/json&#39;\n        res.statusCode = 200; // 设置响应状态码为 200\n        res.end(data); // 将获取到的数据作为响应体返回\n      &#125;);\n    &#125; else &#123;\n      res.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置响应头的 Content-Type 为 &#39;application/json&#39;\n      res.statusCode = 404; // 设置响应状态码为 404\n      res.end(&#39;Not Found&#39;); // 返回 &#39;Not Found&#39; 作为响应体\n    &#125;\n  &#125; else if (req.method === &#39;GET&#39;) &#123; // 检查请求方法是否为 GET\n    if (pathname === &#39;/get&#39;) &#123; // 检查路径是否为 &#39;/get&#39;\n      console.log(query.a); // 打印查询参数中的键名为 &#39;a&#39; 的值\n      res.end(&#39;get success&#39;); // 返回 &#39;get success&#39; 作为响应体\n    &#125;\n  &#125;\n&#125;).listen(98, () =&gt; &#123;\n  console.log(&#39;server is running on port 98&#39;); // 打印服务器启动的信息\n&#125;);\n</code></pre>\n<h2 id=\"net模块\"><a href=\"#net模块\" class=\"headerlink\" title=\"net模块\"></a>net模块</h2><p><strong>介绍：</strong></p>\n<ul>\n<li>net模块是Node.js的核心模块之一，提供了用于创建基于网络的应用程序的API</li>\n<li>net模块主要用于<strong>创建TCP服务器和TCP客户端，以及处理网络通信</strong></li>\n</ul>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li><p>服务端之间的通讯</p>\n<ul>\n<li><p>服务端之间的通讯可以直接使用TCP通讯，而不需要上升到http层</p>\n</li>\n<li><p>server.js（TCP层面的服务端）</p>\n<pre><code class=\"javascript\">const net = require(&#39;net&#39;)\nconst server = net.createServer((client)=&gt;&#123;\n  setTimeout(() =&gt; &#123;\n  client.write(&#39;发送TCP内容&#39;)\n  &#125;, 1000);\n&#125;)\nserver.listen(3000,()=&gt;&#123;\n  console.log(&#39;3000端口启动服务&#39;);\n&#125;)\n</code></pre>\n</li>\n<li><p>connection.js（TCP层面的客户端）</p>\n<pre><code class=\"javascript\">const net = require(&#39;net&#39;)\nconst connection = net.createConnection(&#123;\n  host:&#39;127.0.0.1&#39;,\n  port:3000\n&#125;)\nconnection.on(&#39;data&#39;,(data)=&gt;&#123;\n  console.log(data.toString());\n&#125;)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>从传输层实现http协议</p>\n<pre><code class=\"javascript\">const net = require(&#39;net&#39;);\nconst html = `&lt;h1&gt;TCP Server&lt;/h1&gt;`\nconst reposneHeader = [\n    &#39;HTTP/1.1 200 OK&#39;,\n    &#39;Content-Type: text/html&#39;,\n    &#39;Content-Length: &#39; + html.length,\n    &#39;Server: Nodejs&#39;,\n    &#39;\\r\\n&#39;,\n    html\n]\nconst http = net.createServer((connect)=&gt;&#123;\n  connect.on(&#39;data&#39;,(data)=&gt;&#123;\n    console.log(data.toString().slice(0,3));\n    if(data.toString().startsWith(&#39;GET&#39;))&#123;\n      connect.write(reposneHeader.join(&#39;\\r\\n&#39;)) //向TCP连接中写入html响应\n      connect.end()\n    &#125;\n  &#125;)\n&#125;)\nhttp.listen(3000,()=&gt;&#123;\n  console.log(&#39;服务启动&#39;);\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><ul>\n<li>动静分离是Web服务器架构中常用的优化技术，用于提高网站的性能和可伸缩性</li>\n<li>原理就是将静态资源的请求和动态内容分开处理（通过url，例如加上static后缀表示静态）</li>\n<li>好处在于：<ul>\n<li>性能优化（静态资源内容不变，可以利用缓存）</li>\n<li>负载均衡（动态内容请求分发到不同的服务器或服务上，平衡服务器的负载）</li>\n<li>安全性（动态内容往往涉及敏感信息，动静分离可以更好地管理访问控制和安全策略）</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"javascript\">import http from &#39;node:http&#39; // 导入http模块\nimport fs from &#39;node:fs&#39; // 导入文件系统模块\nimport path from &#39;node:path&#39; // 导入路径处理模块\nimport mime from &#39;mime&#39; // 导入mime模块\nconst server = http.createServer((req, res) =&gt; &#123;\n    const &#123; url, method &#125; = req\n    // 处理静态资源\n    if (method === &#39;GET&#39; &amp;&amp; url.startsWith(&#39;/static&#39;)) &#123;\n        const filePath = path.join(process.cwd(), url) // 获取文件路径\n        const mimeType = mime.getType(filePath) // 获取文件的MIME类型\n        console.log(mimeType) // 打印MIME类型\n        fs.readFile(filePath, (err, data) =&gt; &#123; // 读取文件内容\n            if (err) &#123;\n                res.writeHead(404, &#123;\n                    &quot;Content-Type&quot;: &quot;text/plain&quot; // 设置响应头为纯文本类型\n                &#125;)\n                res.end(&#39;not found&#39;) // 返回404 Not Found\n            &#125; else &#123;\n                res.writeHead(200, &#123;\n                    &quot;Content-Type&quot;: mimeType, // 设置响应头为对应的MIME类型\n                    &quot;Cache-Control&quot;: &quot;public, max-age=3600&quot; // 设置缓存控制头\n                &#125;)\n                res.end(data) // 返回文件内容\n            &#125;\n        &#125;)\n    &#125;\n    // 处理动态资源\n    if (url.startsWith(&#39;/api&#39;)) &#123;\n        // ...处理动态资源的逻辑\n    &#125;\n&#125;)\nserver.listen(80) // 监听端口80\n</code></pre>\n<h2 id=\"邮件服务\"><a href=\"#邮件服务\" class=\"headerlink\" title=\"邮件服务\"></a>邮件服务</h2><p>邮件服务可以用于给成员发送邮件、通知成员信息，在node.js上创建邮件服务，需要提供授权码。</p>\n<p><strong>工具：</strong></p>\n<ul>\n<li>js-yaml：用于将yaml转为js对象</li>\n<li>nodemailer：用于创建邮件服务</li>\n</ul>\n<p><strong>使用：</strong></p>\n<pre><code class=\"javascript\">// node.js发送邮件\nconst yamlTrans = require(&#39;js-yaml&#39;);\nconst fs = require(&#39;fs&#39;);\nconst nodemailer = require(&#39;nodemailer&#39;)\nconst yamlCode = fs.readFileSync(&#39;./data.yaml&#39;,&#39;utf-8&#39;);\nconst dataObj = yamlTrans.load(yamlCode);\n//nodemailer.createTransport创建transPort服务,传入auth信息和配置项\n//授权码需要到对应官网生成\nconst transPort = nodemailer.createTransport(&#123;\n    serviece:&#39;qq&#39;,\n    port:587,\n    host:&#39;smtp.qq.cmo&#39;,\n    secure:true,\n    auth:&#123;\n        pass:dataObj.pass, //授权码需要去官网申请生成\n        user:dataObj.user\n    &#125;\n&#125;)\n// sendMail方法发送邮件，传入接收方信息\ntransPort.sendMail(&#123;\n    to: send.qq.com,\n    from: dataObj.user,\n    subject: &#39;邮件标题&#39;,\n    text: &#39;邮件内容&#39;\n&#125;)\n</code></pre>\n<h2 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h2><p>防盗链是指在网页或其他资源中，通过直接链接的方式链接到其他网站上的图片、视频或者其他媒体文件，显示在自己的网页上，这种行为通常会给被链接的网站带来额外的带宽消耗和资源浪费，而且可能侵犯了原始网站的版权。采用措施有：</p>\n<ul>\n<li><strong>通过HTTP引用检查</strong>：（查看请求来源地址，不匹配则不提供资源）</li>\n<li><strong>使用Referrer检查</strong>：检查HTTP请求中的Referrer字段，该字段指示了请求资源的来源页面（不匹配则不提供服务）</li>\n<li><strong>使用访问控制列表</strong>（ACL）：网站管理员可以配置服务器的访问控制列表，只允许特定的域名或IP地址访问资源，其他来源的请求将被拒绝。</li>\n<li><strong>使用防盗链插件或脚本</strong>：一些网站平台和内容管理系统提供了专门的插件或脚本来防止盗链。这些工具可以根据需要配置，阻止来自未经授权的网站的盗链请求。</li>\n<li><strong>使用水印技术</strong>：在图片或视频上添加水印可以帮助识别盗链行为，并提醒用户资源的来源。</li>\n</ul>\n<pre><code class=\"javascript\">import express from &#39;express&#39;;\nconst app = express();\nconst whitelist = [&#39;localhost&#39;];\n//防盗链中间件\nconst preventHotLinking = (req,res,next)=&gt;&#123;\n    const referer = req.get(&#39;referer&#39;); //请求中的referrer字段标识请求来源\n    if(referer)&#123;\n        const &#123;hostname&#125; = new URL(referer);\n        if(!whistlist.includes(hostname))&#123;\n            res.status(403).send(&#39;我不允许你访问我的资源&#39;);\n            return;\n        &#125;\n    &#125;\n    next();\n&#125;;\napp.use(preventHotLinking);\napp.listen(3000,()=&gt;&#123;\n    console.log(&#39;3000端口启动&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"响应头和请求头\"><a href=\"#响应头和请求头\" class=\"headerlink\" title=\"响应头和请求头\"></a>响应头和请求头</h2><p><strong>响应头：</strong></p>\n<ul>\n<li><p>HTTP响应头（HTTP response headers）是在HTTP响应中发送的元数据信息，用于描述响应的特性、内容和行为。他们以键值对的形式出现。每个键值对由一个标头字段和响应值组成。</p>\n<pre><code class=\"http\">Access-Control-Allow-Origin: *\nCache-Control:public, max-age=0, must-revalidate\nContent-Type:text/html; charset=utf-8\nServer:nginx\nDate:Mon, 08 Jan 2024 18:32:47 GMT\n</code></pre>\n</li>\n</ul>\n<p><strong>cors：</strong></p>\n<ul>\n<li><p>跨域资源共享（CORS）是一种机制，用于在浏览器中实现跨域请求访问资源的权限控制。</p>\n</li>\n<li><p>当一个网页通过XMLHttpRequest或者Fetch Api进行跨域请求时，浏览器会根据同源策略进行限制。</p>\n</li>\n<li><p>同源策略要求请求的协议、域名和端口号必须一致。</p>\n</li>\n</ul>\n<p><strong>请求头：</strong></p>\n<ul>\n<li><p>Accept：指定客户端能够处理的内容类型。</p>\n</li>\n<li><p>Accept-Language：指定客户端偏好的自然语言。</p>\n</li>\n<li><p>Content-Language：指定请求或响应实体的自然语言。</p>\n</li>\n<li><p>Content-Type：指定请求或响应实体的媒体类型。</p>\n</li>\n<li><p>DNT (Do Not Track)：指示客户端不希望被跟踪。</p>\n</li>\n<li><p>Origin：指示请求的源（协议、域名和端口）。</p>\n</li>\n<li><p>User-Agent：包含发起请求的用户代理的信息。</p>\n</li>\n<li><p>Referer：指示当前请求的源 URL。</p>\n</li>\n<li><p>Content-type: application&#x2F;x-www-form-urlencoded | multipart&#x2F;form-data |  text&#x2F;plain</p>\n</li>\n</ul>\n<p><strong>请求方法支持：</strong></p>\n<p>服务端默认只支持GET、POST、HEAD、OPTIONS请求，使用其他 restful api请求方法需要添加响应头<code>Access-Control-Allow-Methods: *</code></p>\n<h2 id=\"SSE-1\"><a href=\"#SSE-1\" class=\"headerlink\" title=\"SSE\"></a>SSE</h2><ul>\n<li><p>SSE（Server-Sent-Events）是一种在客户端和服务器之间实现单向事件流的机制，允许服务器主动向客户端发送事件数据，在SSE中可以自定义事件来完成。</p>\n</li>\n<li><p>SSE核心就是：</p>\n<ul>\n<li>前端通过<code>EventSource</code> 来注册事件源，监听对应事件。</li>\n<li>后端通过设置响应头<code>Content-Type</code>为：<code>text/event-stream</code> 之后 发送具有特定类型的事件数据。</li>\n</ul>\n</li>\n</ul>\n<p><strong>前端：</strong></p>\n<pre><code class=\"javascript\">const sse = new EventSource(&#39;http://localhost:3000/sse&#39;);\nsse.addEventListener(&#39;test&#39;,(event)=&gt;&#123;\n    console.log(event.data);\n&#125;)\n</code></pre>\n<p><strong>后端：</strong></p>\n<pre><code class=\"javascript\">app.get(&#39;/sse&#39;(req,res)=&gt;&#123;\n    res.setHeader(&#39;Content-Type&#39;,&#39;text/event-stream&#39;); //设置事件响应头\n    res.status(200);\n    setInterval(()=&gt;&#123;\n        res.write(&#39;event: test\\n&#39;); // 发送对应的事件\n        res.write(&#39;data: &#39; + new Date().getTime() + &#39;\\n\\n&#39;);\n    &#125;,1000)\n&#125;)\n</code></pre>\n<h2 id=\"ORM框架\"><a href=\"#ORM框架\" class=\"headerlink\" title=\"ORM框架\"></a>ORM框架</h2><ul>\n<li>ORM(Object Relation Map)：对象关系映射，常用于为关系型数据库提供类型安全的支持。</li>\n</ul>\n<h4 id=\"knex\"><a href=\"#knex\" class=\"headerlink\" title=\"knex\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9rbmV4anMub3JnL2d1aWRlL3F1ZXJ5LWJ1aWxkZXIuaHRtbCNzZWxlY3Q=\">knex</span></h4><ul>\n<li>knex是一个基于JavaScript的查询生成器</li>\n<li>knex允许使用JavaScript代码来生成和执行SQL查询语句</li>\n<li>knex提供了一种简单和直观的方式来与关系型数据库进行交互，而无需编写SQL语句</li>\n<li>可以使用knex来定义表结构，执行查询、插入、更新和删除等操作。</li>\n</ul>\n<p><strong>连接数据库：</strong></p>\n<pre><code class=\"javascript\">import knex from &#39;knex&#39;;\nconst db = knex(&#123;\n    client: &quot;mysql2&quot;,\n    connection:&#123;\n        user:root,\n        password:&#39;123456&#39;,\n        host:localhost,\n        port:3306,\n        database:test\n    &#125;\n&#125;)\n</code></pre>\n<p>增删改查详见官网。</p>\n<p><strong>事务：</strong></p>\n<p>事务相当于分组的一个概念，可以使用事务来确保一组数据库操作的原子性，要么全部成功提交，要么全部回滚。</p>\n<h4 id=\"prisma\"><a href=\"#prisma\" class=\"headerlink\" title=\"prisma\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcmlzbWEueW9nYS9nZXR0aW5nLXN0YXJ0ZWQ=\">prisma</span></h4><p>Prisma 和 Knex 都是现代的 Node.js ORM（对象关系映射）库，它们可以帮助开发者以面向对象的方式来操作数据库。尽管它们的目标相似，但它们在设计理念、功能特性和使用方式上存在一些区别：</p>\n<ul>\n<li>prisma和TypeScript联系紧密</li>\n<li>prisma提供强大的类型安全</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcHJpc21h\">prisma CLI</span></p>\n<p>prisma对应的脚手架可以快速创建模板结构。</p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h4 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h4><p><strong>概念：</strong></p>\n<ul>\n<li><p>MVC是一种常用的软件架构模式，用于设计和组织应用程序的代码</p>\n</li>\n<li><p>它将应用程序分为三个主要的组件：模型(Model)、视图(view)和控制器(Controller)，各自负责不同的模块</p>\n</li>\n</ul>\n<p><strong>作用：</strong></p>\n<ul>\n<li>MVC将应用程序的逻辑数据等和界面相分离，以提高代码的可维护性、可扩展性和可重用性。</li>\n<li>通过将不同职责分配给不同组件，MVC提供了一种清晰的结构使得开发人员更好的管理应用程序的各个部分</li>\n</ul>\n<h4 id=\"loC控制反转\"><a href=\"#loC控制反转\" class=\"headerlink\" title=\"loC控制反转\"></a>loC控制反转</h4><p><strong>概念：</strong></p>\n<ul>\n<li><p>控制反转（IoC）是一种设计原则，它将组件的控制权从组件自身转移到外部容器。</p>\n</li>\n<li><p>传统上，组件负责自己的创建和管理，而控制反转则将这个责任转给了一个外部的容器或框架。容器负责创建组件实例并管理它们的生命周期，组件只需声明自己所需的依赖关系，并通过容器获取这些依赖。</p>\n</li>\n<li><p>loC控制反转使得组件更加松耦合、可测试和可维护。</p>\n</li>\n</ul>\n<p><strong>依赖注入：</strong></p>\n<ul>\n<li><p>依赖注入（DI）是实现控制反转的一种具体技术。</p>\n</li>\n<li><p>它通过将组件的依赖关系从组件内部移动到外部容器来实现松耦合。</p>\n</li>\n<li><p>组件不再负责创建或管理它所依赖的其他组件，而是通过构造函数、属性或方法参数等方式将依赖关系注入到组件中。</p>\n</li>\n<li><p>依赖注入可以通过构造函数注入（Constructor Injection）、属性注入（Property Injection）或方法注入（Method Injection）等方式实现。</p>\n</li>\n</ul>\n<p><strong>工具包：</strong></p>\n<p>可以使用inversify、reflect-metadata、inversify-express-utils来实现。</p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p><strong>介绍：</strong></p>\n<p>JWT（JSON Web Token）是一种开放的标准，是一种基于JSON的安全令牌，用于在客户端和服务端之间传输信息。</p>\n<p><strong>组成：</strong></p>\n<p>JWT由三部分组成，它们通过点（.）进行分隔：</p>\n<ol>\n<li>Header（头部）：包含了令牌的类型和使用的加密算法等信息。通常采用Base64编码表示。</li>\n<li>Payload（负载）：包含了身份验证和授权等信息，如用户ID、角色、权限等。也可以自定义其他相关信息。同样采用Base64编码表示。</li>\n<li>Signature（签名）：使用指定的密钥对头部和负载进行签名，以确保令牌的完整性和真实性。</li>\n</ol>\n<p><strong>工作流程：</strong></p>\n<ol>\n<li>用户通过提供有效的凭证（例如用户名和密码）进行身份验证。</li>\n<li>服务器验证凭证，并生成一个JWT作为响应。JWT包含了用户的身份信息和其他必要的数据。</li>\n<li>服务器将JWT发送给客户端。</li>\n<li>客户端在后续的请求中，将JWT放入请求的头部或其他适当的位置。</li>\n<li>服务器在接收到请求时，验证JWT的签名以确保其完整性和真实性。如果验证通过，服务器使用JWT中的信息进行授权和身份验证。</li>\n</ol>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p><strong>内存存储系统</strong></p>\n<p><strong>介绍：</strong></p>\n<p>Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，提供了一个高效的键值存储解决方案，并支持多种数据结构，如：string字符串、hashes哈希、lists列表、sets集合和sorted sets有序集合等等。</p>\n<p><strong>应用：</strong></p>\n<p>Redis被广泛应用于缓存、消息队列和实时统计等场景。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>内存存储，因此具有快速的读写功能，能持久化数据到硬盘，以便在重新启动后恢复数据</li>\n<li>多种数据结构，Redis支持多种数据结构</li>\n<li>发布&#x2F;订阅，Redis支持发布订阅模式，允许多个客户端订阅同一个或多个频道，以接收实时发布的消息，这使得Redis可以用于实时消息系统</li>\n<li>事务支持，Redis支持事务，可以将多个命令打包成一个原子操作执行，确保命令要么全部成功，要么全部失败</li>\n<li>持久化，Redis提供两种持久化数据的方式：<ul>\n<li>RDB（Redis Database），RDB是将数据以快照的形式保存到磁盘。</li>\n<li>AOF（Append Only File），AOF是将每个写操作追加到文件中，确保数据在意外宕机或重启后的持久性</li>\n</ul>\n</li>\n<li>高可用性，Redis支持主从复制和Sentine哨兵机制，通过主从复制可以创建多个Redis实例的副本，以提高读取性和容错能力。<code>sentinel</code>是一个用于监控和自动故障转移的系统，可以在主节点宕机时自动将节点提升为主节点。</li>\n<li>缓存，Redis的快速读写能力和灵活的数据结构使其被广泛应用于缓存层，它可以将常用的数据存储在内存中，以加快数据访问速度，减轻后端数据库的负载。</li>\n<li>实时统计，Redis的计数器和有序集合等数据结构使其非常适合实时统计的场景，可以存储和更新计数器，并对有序集合进行排名和范围查询，用于统计和排行榜功能。</li>\n</ul>\n<p><strong>安装</strong></p>\n<p>安装文件，配置环境变量，然后启动即可。</p>\n<p>连接redis服务可以使用Navicate或者在vscode中下载对应的插件。</p>\n<p><strong>发布订阅模式：</strong></p>\n<p>在redis中，发布订阅模式通过命令：publish、subscribe、unsubscribe、psubscribe命令和punsubscribe命令来进行操作。</p>\n<p><strong>事务：</strong></p>\n<ul>\n<li>redis支持事务，允许用户将多个命令打包在一起作为一个单元进行执行，事务提供了一种原子性操作的机制，要么所有命令都执行成功，要么所有命令都不成功。</li>\n<li>Redis的事务不支持回滚操作，如果在事务执行期间发生错误，事务会继续执行，而不会会回滚已执行的命令。</li>\n<li>Redis事务常用命令：<ul>\n<li>multi：开启一个事务</li>\n<li>exec：执行事务中所有命令</li>\n<li>watch：对一个或多个键进行监视</li>\n<li>discard：取消事务，清空事务队列中的命令。</li>\n</ul>\n</li>\n</ul>\n<p><strong>redis持久化：</strong></p>\n<ul>\n<li>RDB（Redis Database）持久化<ul>\n<li>RDB持久化是一种快照的形式，会将内存中的数据定期保存到磁盘上。</li>\n<li>可以通过配置Redis服务器，设置自动触发RDB快照的条件，比如指定时间间隔或指定操作次数自动保存。</li>\n<li>RDB持久化生成的快照文件是二进制文件，包含了Redis数据的完整状态。</li>\n<li>在恢复数据时，可以通过加载快照文件将数据重新加载到内存中。</li>\n</ul>\n</li>\n<li>RDB使用：<ul>\n<li>找到redis的redis.conf文件，配置其中的save字段。</li>\n<li>或者在redis启动的命令行中输入save，手动保存快照。</li>\n</ul>\n</li>\n<li>AOF（Append Only File）持久化<ul>\n<li>AOF持久化记录了Redis服务器执行的所有写操作命令，在文件中以追加的方式保存</li>\n<li>当redis重启时，可以重新执行AOF文件中保存的命令，以重新构建数据集。相比于RDB持久化，AOF持久化提供了更好的数据恢复保证，因为它记录了每个写操作，而不是快照的形式。</li>\n<li>AOF文件相对于RDB文件更大，恢复数据的速度可能会比较慢。</li>\n</ul>\n</li>\n<li>AOF使用：<ul>\n<li>redus.conf文件的appendonly字段设置为yes。</li>\n</ul>\n</li>\n</ul>\n<p><strong>redis主从复制：</strong></p>\n<ul>\n<li>redis主从复制是一种数据复制和同步机制，其中一个redis服务器（主服务器）将其数据复制到一个或多个其他Redis服务器（从服务器）中，主从复制提供了数据冗余备份、读写分离和故障恢复等功能。</li>\n</ul>\n<p><strong>ioredis：在node.js中与Redis进行交互的三方库。</strong></p>\n<h2 id=\"lua\"><a href=\"#lua\" class=\"headerlink\" title=\"lua\"></a>lua</h2><p>轻量级、可嵌入的脚本语言。</p>\n<p><strong>介绍：</strong></p>\n<ul>\n<li>lua是一种轻量级、高效、可嵌入的脚本语言，被广泛应用于嵌入式系统、游戏开发、Web应用和脚本编写等领域。</li>\n<li>其设计目标之一就是作为扩展和嵌入式脚本语言，可以与其他编程语言无缝集成。</li>\n<li>在redius中可以直接执行lua脚本（.lua文件）。</li>\n<li>web应用为了增强性能和可扩展性，通常将Lua、Redis和Nginx结合使用，以构建高性能的Web应用程序或API服务。</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVhLm9yZy8=\">安装</span></p>\n<h2 id=\"corn表达式\"><a href=\"#corn表达式\" class=\"headerlink\" title=\"corn表达式\"></a>corn表达式</h2><p>corn表达式是一种用汉语指定定时任务执行时间的字符串表示形式，由6个或7个字段组成，每个字段表示任务执行的时间单位和范围。</p>\n<p><strong>格式为：</strong></p>\n<pre><code class=\"markdown\">*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬    ┬\n│    │    │    │    │    │\n│    │    │    │    │    └── 星期（0 - 6，0表示星期日）\n│    │    │    │    └───── 月份（1 - 12）\n│    │    │    └────────── 日（1 - 31）\n│    │    └─────────────── 小时（0 - 23）\n│    └──────────────────── 分钟（0 - 59）\n└───────────────────────── 秒（0 - 59）\n</code></pre>\n<p>常见的Cron表达式示例：</p>\n<ul>\n<li><code>* * * * * *</code>：每秒执行一次任务。</li>\n<li><code>0 * * * * *</code>：每分钟的整点执行一次任务。</li>\n<li><code>0 0 * * * *</code>：每小时的整点执行一次任务。</li>\n<li><code>0 0 * * * *</code>：每天的午夜执行一次任务。</li>\n<li><code>0 0 * * 1 *</code>：每周一的午夜执行一次任务。</li>\n<li><code>0 0 1 * * *</code>：每月的1号午夜执行一次任务。</li>\n<li><code>0 0 1 1 * *</code>：每年的1月1日午夜执行一次任务。</li>\n</ul>\n<p><strong>掘金定时自动签到：</strong></p>\n<pre><code class=\"javascript\">const schedule = require(&#39;node-schedule&#39;)\nconst axios = require(&#39;axios&#39;);\nconst aid = &#39;******&#39; //输入掘金账号的aid\nconst uid = &#39;******&#39; //输入掘金账号的uid\nconst cookie = &#39;******&#39; //输入在掘金的cookie\nschedule.scheduleJob(&#39;48 15 * * *&#39;,()=&gt;&#123;\n    //corn表达式表示43分钟15小时每天每月每星期（每天15点43分）点执行\n    axios.post(`https://api.juejin.cn/growth_api/v1/check_in?aid=$&#123;aid&#125;&amp;uid=$&#123;uid&#125;`,&#123;&#125;,&#123;\n        headers:&#123;\n            referer: &#39;https://juejin.cn/&#39;,\n            cookie: `sessionid=$&#123;&#125;`\n        &#125;\n    &#125;).then(res=&gt;&#123;\n        console.log(&#39;签到成功&#39;);\n    &#125;).catch(err=&gt;&#123;\n        console.log(&#39;出现错误&#39;,err);\n    &#125;)\n&#125;)\n</code></pre>\n<h2 id=\"serverLess\"><a href=\"#serverLess\" class=\"headerlink\" title=\"serverLess\"></a>serverLess</h2><p><strong>介绍：</strong></p>\n<ul>\n<li>serverLess并不是一项技术，而是一个架构模型（无服务器架构）。</li>\n<li>在传统模式下，部署一个服务需要选择服务器（linux、windows等），并且需要安装环境，熟悉操作系统命令，知晓安全知识等，都需要一定的成本，serverLess的核心思想就是让开发者更多关注业务本身而不是服务器运行成本。</li>\n</ul>\n<p><strong>Faas：函数即服务</strong></p>\n<p>FaaS是一种Serverless计算模型，它允许开发人员编写和部署函数代码，而无需关心底层的服务器管理。在FaaS中，开发人员只需关注函数的实现和逻辑，将其上传到云平台上，平台会负责函数的运行和扩展。当有请求触发函数时，云平台会自动为函数提供所需的计算资源，并根据请求量进行弹性扩展。这种按需计算的模式使开发人员可以更专注于业务逻辑的实现，同时实现了资源的高效利用。</p>\n<p>每个函数即一个服务，函数内只需处理业务，可以使用BASS层提供的服务已完成业务，无需关心背后计算资源的问题。</p>\n<p><strong>Baas：后端即服务</strong></p>\n<p>后端即服务是一种提供面向移动应用和Web应用的后端功能的云服务模型。BaaS为开发人员提供了一组预构建的后端服务，如用户身份验证、数据库存储、文件存储、推送通知等，以简化应用程序的开发和管理。开发人员可以使用BaaS平台提供的API和SDK，直接集成这些功能到他们的应用中，而无需自己构建和维护后端基础设施。</p>\n<p>对后端的资源当成一种服务，如文件存储，数据存储，推送服务，身份验证。该层只需提供对应的服务，无需关心业务。定义为底层基础服务，由其他服务调用，正常不触及用户终端。</p>\n<p><strong>脚手架快速编写：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHNlcnZlcmxlc3MtZGV2cy9z\">https://www.npmjs.com/package/@serverless-devs/s</span></strong></p>\n<h2 id=\"webSocket\"><a href=\"#webSocket\" class=\"headerlink\" title=\"webSocket\"></a>webSocket</h2><p><strong>传统HTTP的不足：</strong></p>\n<ul>\n<li><p>传统HTTP是一种单向请求–响应协议，客户端发送请求之后，服务器才会响应并返回相应的数据。</p>\n</li>\n<li><p>在传统HTTP中，客户端需要主动发送请求才能获取服务器上的资源，而且每次请求都需要重新建立连接，这种方式在实时通信和持续获取资源的场景下效率较低。</p>\n</li>\n</ul>\n<p><strong>Socket：</strong></p>\n<p>socket提供了实时的双向通信能力，可以实时地传输数据。客户端和服务器之间的通信是即时的，数据的传输和响应几乎是实时完成的，不需要轮询或定时发送请求。</p>\n<p><strong>node中使用webSocket：</strong></p>\n<ul>\n<li><strong>客户端：</strong></li>\n</ul>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        * &#123;\n            padding: 0;\n            margin: 0;\n        &#125;\n        html,\n        body,\n        .room &#123;\n            height: 100%;\n            width: 100%;\n        &#125;\n        .room &#123;\n            display: flex;\n        &#125;\n        .left &#123;\n            width: 300px;\n            border-right: 0.5px solid #f5f5f5;\n            background: #333;\n        &#125;\n        .right &#123;\n            background: #1c1c1c;\n            flex: 1;\n            display: flex;\n            flex-direction: column;\n        &#125;\n        .header &#123;\n            background: #8d0eb0;\n            color: white;\n            padding: 10px;\n            box-sizing: border-box;\n            font-size: 20px;\n        &#125;\n        .main &#123;\n            flex: 1;\n            padding: 10px;\n            box-sizing: border-box;\n            font-size: 20px;\n            overflow: auto;\n        &#125;\n        .main-chat &#123;\n            color: green;\n        &#125;\n        .footer &#123;\n            min-height: 200px;\n            border-top: 1px solid green;\n        &#125;\n        .footer .ipt &#123;\n            width: 100%;\n            height: 100%;\n            color: green;\n            outline: none;\n            font-size: 20px;\n            padding: 10px;\n            box-sizing: border-box;\n        &#125;\n        .groupList &#123;\n            height: 100%;\n            overflow: auto;\n        &#125;\n        .groupList-items &#123;\n            height: 50px;\n            width: 100%;\n            background: #131313;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;div class=&quot;room&quot;&gt;\n    &lt;div class=&quot;left&quot;&gt;\n        &lt;div class=&quot;groupList&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;\n        &lt;header class=&quot;header&quot;&gt;聊天室&lt;/header&gt;\n        &lt;main class=&quot;main&quot;&gt;\n        &lt;/main&gt;\n        &lt;footer class=&quot;footer&quot;&gt;\n            &lt;div class=&quot;ipt&quot; contenteditable&gt;&lt;/div&gt;\n        &lt;/footer&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;body&gt;\n    &lt;script type=&quot;module&quot;&gt;\n        const sendMessage = (message) =&gt; &#123;\n            const div = document.createElement(&#39;div&#39;);\n            div.className = &#39;main-chat&#39;;\n            div.innerText = `$&#123;message.user&#125;:$&#123;message.text&#125;`;\n            main.appendChild(div)\n        &#125;\n        const groupEl = document.querySelector(&#39;.groupList&#39;);\n        const main = document.querySelector(&#39;.main&#39;);\n        import &#123; io &#125; from &quot;https://cdn.socket.io/4.7.4/socket.io.esm.min.js&quot;;\n        const name = prompt(&#39;请输入你的名字&#39;);\n        const room = prompt(&#39;请输入房间号&#39;);\n        const socket = io(&#39;ws://localhost:3000&#39;);\n        //键盘按下发送消息\n        document.addEventListener(&#39;keydown&#39;, (e) =&gt; &#123;\n            if (e.key === &#39;Enter&#39;) &#123;\n                e.preventDefault();\n                const ipt = document.querySelector(&#39;.ipt&#39;);\n                socket.emit(&#39;message&#39;, &#123;\n                    text: ipt.innerText,\n                    room: room,\n                    user: name\n                &#125;);\n                sendMessage(&#123;\n                    text: ipt.innerText,\n                    user: name,\n                &#125;)\n                ipt.innerText = &#39;&#39;;\n            &#125;\n        &#125;)\n        //连接成功socket\n        socket.on(&#39;connect&#39;, () =&gt; &#123;\n            socket.emit(&#39;join&#39;, &#123; name, room &#125;);//加入一个房间\n            socket.on(&#39;message&#39;, (message) =&gt; &#123;\n                sendMessage(message)\n            &#125;)\n            socket.on(&#39;groupList&#39;, (groupList) =&gt; &#123;\n                console.log(groupList);\n                groupEl.innerHTML = &#39;&#39;\n                Object.keys(groupList).forEach(key =&gt; &#123;\n                    const item = document.createElement(&#39;div&#39;);\n                    item.className = &#39;groupList-items&#39;;\n                    item.innerText = `房间名称:$&#123;key&#125; 房间人数:$&#123;groupList[key].length&#125;`\n                    groupEl.appendChild(item)\n                &#125;)\n            &#125;)\n        &#125;)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li><strong>服务端：</strong></li>\n</ul>\n<pre><code class=\"javascript\">import http from &#39;http&#39;\nimport &#123; Server &#125; from &#39;socket.io&#39;\nimport express from &#39;express&#39;\nconst app = express()\napp.use(&#39;*&#39;, (req, res, next) =&gt; &#123;\n    res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n    res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);\n    res.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);\n    next();\n&#125;)\nconst server = http.createServer(app)\nconst io = new Server(server, &#123;\n    cors: true //允许跨域\n&#125;)\nconst groupList = &#123;&#125;\n/**\n * [&#123;1008:[&#123;name,room,id&#125;]&#125;]\n */\nio.on(&#39;connection&#39;, (socket) =&gt; &#123;\n    //加入房间\n    socket.on(&#39;join&#39;, (&#123; name, room &#125;) =&gt; &#123;\n        socket.join(room)\n        if (groupList[room]) &#123;\n            groupList[room].push(&#123; name, room, id: socket.id &#125;)\n        &#125; else &#123;\n            groupList[room] = [&#123; name, room, id: socket.id &#125;]\n        &#125;\n        socket.emit(&#39;message&#39;, &#123; user: &#39;管理员&#39;, text: `$&#123;name&#125;进入了房间` &#125;)\n        socket.emit(&#39;groupList&#39;, groupList)\n        socket.broadcast.emit(&#39;groupList&#39;, groupList)\n    &#125;)\n    //发送消息\n    socket.on(&#39;message&#39;, (&#123; text, room, user &#125;) =&gt; &#123;\n        socket.broadcast.to(room).emit(&#39;message&#39;, &#123;\n            text,\n            user\n        &#125;)\n    &#125;)\n    //断开链接内置事件\n    socket.on(&#39;disconnect&#39;, () =&gt; &#123;\n        Object.keys(groupList).forEach(key =&gt; &#123;\n            let leval = groupList[key].find(item =&gt; item.id === socket.id)\n            if (leval) &#123;\n                socket.broadcast.to(leval.room).emit(&#39;message&#39;, &#123; user: &#39;管理员&#39;, text: `$&#123;leval.name&#125;离开了房间` &#125;)\n            &#125;\n            groupList[key] = groupList[key].filter(item =&gt; item.id !== socket.id)\n        &#125;)\n        socket.broadcast.emit(&#39;groupList&#39;, groupList)\n    &#125;)\n&#125;);\nserver.listen(3000, () =&gt; &#123;\n    console.log(&#39;listening on :3000&#39;);\n&#125;);\n</code></pre>\n<h2 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h2><p><strong>介绍：</strong></p>\n<ul>\n<li>爬虫也称为网络爬虫或网络蜘蛛，是指一种自动化程序或脚本，用于在互联网上浏览和提取信息。</li>\n<li>爬虫模拟人类在网页上的行为，通过HTTP协议发送请求，获取网页内容，然后解析并提取需要的内容。</li>\n<li>在node中使用爬虫需要借助模拟浏览器环境的包（如 puppeteer）来模拟浏览器环境。</li>\n</ul>\n<p><strong>工具：</strong></p>\n<ul>\n<li>puppeteer（模拟浏览器环境）</li>\n</ul>\n<p><strong>使用：</strong></p>\n<p>npm包：</p>\n<pre><code class=\"bash\">npm i puppeteer\n</code></pre>\n<p>index.js：</p>\n<pre><code class=\"javascript\">import puppeteer from &quot;puppeteer&quot;;\nconst btnText = process.argv[2];\nconst browser = await puppeteer.launch(&#123;\n    headless:false, //取消无头模式\n&#125;)\nconst page = await browser.newPage(); //打开一个页面\nconsole.log(page);\npage.setViewport(&#123; width:1920,height:1080 &#125;); //设置页面宽高\nawait page.goto(&#39;https://juejin.cn/&#39;); //跳转\nawait page.waitForSelector(&#39;.side-navigator-wrap&#39;); //等待元素出现\nconst elements = await page.$$(&#39;.side-navigator-wrap .nav-item-wrap span&#39;) //获取元素\nconst articleList = [];\nconst collectFunc = async()=&gt;&#123;\n    await page.waitForSelector(&#39;.entry-list&#39;)\n    const elements = await page.$$(&#39;.entry-list .title-row a&#39;)\n    for await (let el of elements) &#123;\n        const text = await el.getProperty(&#39;innerText&#39;)\n        const name = await text.jsonValue()\n        articleList.push(name)\n    &#125;\n    console.log(articleList)\n&#125;\nfor await (let el of elements) &#123;\n    const text = await el.getProperty(&#39;innerText&#39;) //获取span的属性\n    const name = await text.jsonValue() //获取内容\n    if (name.trim() === (btnText || &#39;前端&#39;)) &#123;\n        await el.click() //自动点击对应的菜单\n        collectFunc() //调用函数\n    &#125;\n&#125;\n</code></pre>\n<p><strong>可以结合node子进程跑python脚本，使用pip仓库中相应的包和功能。</strong></p>\n<h2 id=\"C-扩展\"><a href=\"#C-扩展\" class=\"headerlink\" title=\"C++扩展\"></a>C++扩展</h2><p>Node.js在IO方面具有极强的能力，但是对CPU密集型的任务有所不足，为了填补这部分缺点，node.js支持C&#x2F;C++为其编写原生的nodejs插件，补充这方面能力。</p>\n<p><strong>node.js中C++扩展：</strong></p>\n<p>c++编写的代码能够被编译成一个动态链接库(dll),可以被nodejs require引入使用，后缀是<code>.node</code></p>\n<p>.node文件的原理就是(<code>window dll</code>) (<code>Mac dylib</code>) (<code>Linux so</code>)</p>\n<p>c++扩展编写语法</p>\n<ul>\n<li><p>NAN(Native Abstractions for Nodejs) 一次编写，到处编译</p>\n<ul>\n<li>因为 Nodejs和V8都更新的很快所有每个版本的方法名也不一样，对我们开发造成了很大的问题例如</li>\n<li>0.50版本 <code>Echo(const Prototype&amp;proto)</code></li>\n<li>3.00版本 <code>Echo(Object&lt;Prototype&gt;&amp; proto)</code></li>\n</ul>\n</li>\n<li><p>NAN的就是一堆宏判断，判断各种版本的API，用来实现兼容所以他会到处编译</p>\n<ul>\n<li>N-API(node-api) 无需重新编译</li>\n<li>基于C的API</li>\n<li>c++ 封装 node-addon-api</li>\n</ul>\n</li>\n</ul>\n<p>N-API 是一个更现代的选择，它提供了一个稳定的、跨版本的 API，使得你的插件可以在不同版本的 Node.js 上运行，而无需修改代码。这大大简化了编写和维护插件的过程。</p>\n<p>对于 C++，可以使用 node-addon-api，这是 N-API 的一个封装，提供了一个更易于使用的 C++ API。这将使你的代码更易于阅读和维护。</p>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>使用C++编写的Nodejs库如<code>node-sass</code> <code>node-jieba</code> 等</li>\n<li>CPU密集型应用</li>\n<li>代码保护</li>\n</ol>\n<p><strong>需要安装C++编辑器：</strong></p>\n<pre><code class=\"bash\">npm install --global --production windows-build-tools #管理员运行\n#如果安装过python 以及c++开发软件就不需要装这个了\nnpm install node-gyp -g #全局安装\nnpm install node-addon-api -D #装到项目里\n</code></pre>\n<p><strong>使用：</strong></p>\n<p><strong>cpu.cpp：</strong></p>\n<pre><code class=\"c++\">#define NAPI_VERSION 3  //指定addon版本\n#define NAPI_CPP_EXCEPTIONS //启用 Node.js N-API 中的 C++ 异常支持\n#include &lt;napi.h&gt;  //addon API\n#include &lt;windows.h&gt; //windwos API\n\nNapi::Value GetScreenSize(const Napi::CallbackInfo&amp; info) &#123;\n    Napi::Env env = info.Env(); //指定环境\n\n    int cx = GetSystemMetrics(SM_CXSCREEN); //获取设备宽\n    int cy = GetSystemMetrics(SM_CYSCREEN); //获取设备高\n\n    Napi::Object result = Napi::Object::New(env); //创建一个对象\n    result.Set(&quot;width&quot;, cx);\n    result.Set(&quot;height&quot;, cy);\n\n    return result; //返回对象\n&#125;\n\nNapi::Object Init(Napi::Env env, Napi::Object exports) &#123;\n    //抛出一个函数  getScreenSize \n    exports.Set(&quot;getScreenSize&quot;, Napi::Function::New(env, GetScreenSize));\n    return exports;\n&#125;\n//addon固定语法 必须抛出这个方法\nNODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)\n</code></pre>\n<p><strong>binding.gyp：</strong></p>\n<pre><code class=\"python\">&#123;\n    &quot;targets&quot;:[\n        &#123;\n            &quot;target_name&quot;: &quot;cpu&quot;, //名称\n            &quot;sources&quot;: [ &quot;cpu.cpp&quot; ], //指定文件\n            &quot;include_dirs&quot;: [\n                 &quot;&lt;!@(node -p \\&quot;require(&#39;node-addon-api&#39;).include\\&quot;)&quot; //引入addon\n            ]\n        &#125;\n    ]\n&#125;\n</code></pre>\n<p><strong>index.js：</strong></p>\n<pre><code class=\"javascript\">const addon = require(&#39;./build/Release/cpu.node&#39;)\nconsole.log(addon.getScreenSize())\n</code></pre>\n<p><strong>命令行中打包addon：</strong></p>\n<pre><code class=\"bash\">node-gyp configure #生成配置文件\nnode-gyp build  #打包addon\n</code></pre>\n<h2 id=\"大文件上传\"><a href=\"#大文件上传\" class=\"headerlink\" title=\"大文件上传\"></a>大文件上传</h2><p>大文件上传方案：</p>\n<ul>\n<li>大文件分片：将大文件切分成较小的片段（通常称为分片或者块），然后逐个上传这些分片<ul>\n<li>优点是：提高上传的稳定性，因为上传失败时只需要重新上传该分片而不需要重新上传整个文件，同时分片上传还可以利用多个网络连接并行上传多个分片，提高上传速度。</li>\n</ul>\n</li>\n<li>断点续传：如果上传中止，断点传输可以记录已成功上传的分片信息，以便在恢复上传时继续上传未完成的任务，而不是重新上传整个文件<ul>\n<li>优点是可以大大减少上传失败的影响，并节省时间和带宽。</li>\n</ul>\n</li>\n</ul>\n<p>前端：</p>\n<pre><code class=\"html\">&lt;script&gt;\n    const fileDOM = document.getElementById(&#39;file&#39;);\n    fileDOM.addEventListener(&#39;change&#39;,(e)=&gt;&#123;\n        const file = e.target.files[0];\n        //对文件进行分片\n        const chunks = sliceFile(file);\n        //上传分片数据\n        postChunksData(chunks);\n    &#125;)\n    function sliceFile(file,size=1024 * 1024 * 4) &#123;\n        const chunks = [];\n        for(let i=0;i&lt;file.size;i+=size)&#123;\n            chunks.push(file.slice(i , i + size));\n        &#125;\n        return chunks;\n    &#125;\n    function postChunksData(chunks) &#123;\n        const list = [];\n        for(let i=0;i&lt;chunks.length;i++)&#123;\n            //使用formData上传所有分片\n            const formData = new FormData();\n            formData.append(&#39;index&#39;,i);\n            formData.append(&#39;total&#39;,chunks.length);\n            formData.append(&#39;fileName&#39;,&#39;分片文件&#39;);\n            formData.append(&#39;file&#39;,chunks[i]);\n            list.push(fetch(&#39;http://localhost:3000/up&#39;,&#123;\n                method:&#39;POST&#39;,\n                body: formData,\n            &#125;))\n        &#125;\n        //上传完所有分片之后将文件合并\n        Promise.all(list).then(res =&gt; &#123;\n            fetch(&#39;http://localhost:3000/merge&#39;,&#123;\n                method:&quot;POST&quot;,\n                headers:&#123;\n                    &quot;Content-Type&quot;:&quot;application/json&quot;\n                &#125;,\n                body:JSON.stringify(&#123;\n                    fileName:&quot;分片上传文件&quot;,\n                &#125;)\n            &#125;).then(res=&gt;&#123;\n                console.log(res);\n            &#125;)\n        &#125;)\n    &#125;    \n&lt;/script&gt;\n</code></pre>\n<p>服务端：</p>\n<pre><code class=\"javascript\">import express from &#39;express&#39;\nimport multer from &#39;multer&#39;\nimport cors from &#39;cors&#39;\nimport fs from &#39;node:fs&#39;\nimport path from &#39;node:path&#39;\nconst storage = multer.diskStorage(&#123;\n    destination: (req, file, cb) =&gt; &#123;\n        cb(null, &#39;uploads/&#39;)\n    &#125;,\n    filename: (req, file, cb) =&gt; &#123;\n        cb(null, `$&#123;req.body.index&#125;-$&#123;req.body.fileName&#125;`)\n    &#125;\n&#125;)\nconst upload = multer(&#123; storage &#125;)\nconst app = express()\napp.use(cors())\napp.use(express.json())\n// 使用multer将数据存到服务器磁盘中\napp.post(&#39;/up&#39;, upload.single(&#39;file&#39;), (req, res) =&gt; &#123;\n    res.send(&#39;ok&#39;)\n&#125;)\n// 使用fs.appendFileSync将切片文件进行合成\napp.post(&#39;/merge&#39;, async (req, res) =&gt; &#123;\n    const uploadPath = &#39;./uploads&#39;\n    let files = fs.readdirSync(path.join(process.cwd(), uploadPath))\n    files = files.sort((a, b) =&gt; a.split(&#39;-&#39;)[0] - b.split(&#39;-&#39;)[0])\n    const writePath = path.join(process.cwd(), `video`, `$&#123;req.body.fileName&#125;.mp4`)\n    files.forEach((item) =&gt; &#123;\n        fs.appendFileSync(writePath, fs.readFileSync(path.join(process.cwd(), uploadPath, item)))\n        fs.unlinkSync(path.join(process.cwd(), uploadPath, item))\n    &#125;)\n    res.send(&#39;ok&#39;)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Server is running on port 3000&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"文件流下载\"><a href=\"#文件流下载\" class=\"headerlink\" title=\"文件流下载\"></a>文件流下载</h2><ul>\n<li><p>文件流下载是一种将文件内容通过流的形式发送给客户端，实现文件下载的方法，适用于处理大型文件或者需要实时生成文件内容的情况。</p>\n</li>\n<li><p>核心知识响应头：</p>\n<ul>\n<li>Content-Type指定下载文件的MIME类型<ul>\n<li><code>application/octet-stream</code>（二进制流数据）</li>\n<li><code>application/pdf</code>：Adobe PDF 文件。</li>\n<li><code>application/json</code>：JSON 数据文件</li>\n<li><code>image/jpeg</code>：JPEG 图像文件</li>\n</ul>\n</li>\n<li><code>Content-Disposition</code> 指定服务器返回的内容在浏览器中的处理方式。它可以用于控制文件下载、内联显示或其他处理方式<ul>\n<li><code>attachment</code>：指示浏览器将响应内容作为附件下载。通常与 <code>filename</code> 参数一起使用，用于指定下载文件的名称</li>\n<li><code>inline</code>：指示浏览器直接在浏览器窗口中打开响应内容，如果内容是可识别的文件类型（例如图片或 PDF），则在浏览器中内联显示</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>前端：</p>\n<pre><code class=\"html\">&lt;script&gt;\n         const btn = document.getElementById(&#39;btn&#39;)\n         btn.onclick = () =&gt; &#123;\n            fetch(&#39;http://localhost:3000/download&#39;,&#123;\n                method:&quot;post&quot;,\n                body:JSON.stringify(&#123;\n                    fileName:&#39;1.png&#39;\n                &#125;),\n                headers:&#123;\n                    &quot;Content-Type&quot;:&quot;application/json&quot;\n                &#125;\n            &#125;).then(res=&gt;res.arrayBuffer()).then(res=&gt;&#123; //请求到stream流式数据后，通过res.arrayBuffer方法获得Buffer数据，用Blob容器存储二进制缓冲数据，通过URL.createObjectURL创建URL地址，赋给a标签进行下载。\n                const blob = new Blob([res],&#123;type:&#39;image/png&#39;&#125;)\n                const url = URL.createObjectURL(blob)\n                const a = document.createElement(&#39;a&#39;)\n                a.href = url\n                a.download = &#39;1.png&#39;\n                a.click()\n            &#125;)\n         &#125;\n     &lt;/script&gt;\n</code></pre>\n<p>服务端：</p>\n<pre><code class=\"javascript\">import express from &#39;express&#39;\nimport fs from &#39;fs&#39;\nimport path from &#39;path&#39;\nimport cors from &#39;cors&#39;\nconst app = express()\napp.use(cors())\napp.use(express.json())\napp.use(express.static(&#39;./static&#39;))\napp.post(&#39;/download&#39;, function (req, res) &#123; //当请求download路径时，通过fs读取文件数据，设置响应头后返回文件数据\n    const fileName = req.body.fileName\n    const filePath = path.join(process.cwd(), &#39;./static&#39;, fileName)\n    const content = fs.readFileSync(filePath)\n    res.setHeader(&#39;Content-Type&#39;, &#39;application/octet-stream&#39;)\n    res.setHeader(&#39;Content-Disposition&#39;, &#39;attachment;filename=&#39; + fileName)\n    res.send(content)\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;http://localhost:3000&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"HTTP缓存\"><a href=\"#HTTP缓存\" class=\"headerlink\" title=\"HTTP缓存\"></a>HTTP缓存</h2><p>HTTP缓存分为两大类：强缓存和协商缓存。这两种缓存都是通过HTTP响应头来控制，目的是提高网站的性能。</p>\n<ul>\n<li><p>强缓存</p>\n<ul>\n<li><p>强缓存之后则不需要重新向服务器发送请求，而是从浏览器缓存（内存缓存或者硬盘缓存中）读取。</p>\n<ul>\n<li>memory cache(内存缓存) 内存缓存存储在浏览器内存当中，一般刷新网页的时候会发现很多内存缓存</li>\n<li>disk cache(硬盘缓存) 硬盘缓存是存储在计算机硬盘中，空间大，但是读取效率比内存缓存慢</li>\n</ul>\n</li>\n<li><p>强缓存设置需要服务端设置对应的响应头Cache-Control，响应头含义如下：</p>\n<ul>\n<li><code>max-age</code>：浏览器资源缓存的时长(秒)。</li>\n<li><code>no-cache</code>：不走强缓存，<strong>走协商缓存</strong>。</li>\n<li><code>no-store</code>：禁止任何缓存策略。</li>\n<li><code>public</code>：资源即可以被浏览器缓存也可以被代理服务器缓存(CDN)。</li>\n<li><code>private</code>：资源只能被客户端缓存。</li>\n</ul>\n</li>\n<li><pre><code class=\"javascript\">const express = require(&#39;express&#39;);\nconst app = express();\napp.get(&#39;/&#39;,(req,res)=&gt;&#123;\n    res.setHeader(&#39;Cache-Control&#39;,&#39;public, max-age=20&#39;);\n    res.json(&#123;\n        name:&quot;cache&quot;,\n        version:&#39;1.0.0&#39;\n    &#125;)\n&#125;);\napp.listen(3000,()=&gt;&#123;\n    console.log(&#39;服务启动&#39;)\n&#125;)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>协商缓存</p>\n<ul>\n<li><p>当涉及到缓存机制时，强缓存优先于协商缓存。当资源的强缓存生效时，客户端可以直接从本地缓存中获取资源，而无需与服务器进行通信。</p>\n<p>如果强缓存未命中（例如<code>max-age</code>过期），或者服务器响应中设置了<code>Cache-Control: no-cache</code>，则客户端会发起协商缓存的请求。在协商缓存中，客户端会发送带有缓存数据标识的请求头部字段，以向服务器验证资源的有效性。</p>\n<p>服务器会根据客户端发送的协商缓存字段（如<code>If-Modified-Since</code>和<code>If-None-Match</code>）来判断资源是否发生变化。如果资源未发生修改，服务器会返回状态码 304（Not Modified），通知客户端可以使用缓存的版本。如果资源已经发生变化，服务器将返回最新的资源，状态码为 200。</p>\n</li>\n<li><blockquote>\n<p>服务端通过设置响应头<code>Last-Modified</code>和<code>If-Modified-Since</code>来通知客户端最后修改时间，客户端在后续请求中通过<code>If-Modified-Since</code>请求头携带该时间，服务器判断资源是否有更新，如何没有返回304状态码。</p>\n</blockquote>\n</li>\n<li><pre><code class=\"javascript\">import express from &#39;express&#39;\nimport cors from &#39;cors&#39;\nimport fs from &#39;node:fs&#39;\nconst getModifyTime = () =&gt; &#123;\n    return fs.statSync(&#39;./index.js&#39;).mtime.toISOString() //获取文件最后修改时间\n&#125;\nconst app = express()\napp.use(cors())\napp.get(&#39;/api&#39;, (req, res) =&gt; &#123;\n    res.setHeader(&#39;Cache-Control&#39;, &#39;no-cache, max-age=2592000&#39;)//表示走协商缓存\n    const ifModifiedSince = req.headers[&#39;if-modified-since&#39;] //获取浏览器上次修改时间\n    res.setHeader(&#39;Last-Modified&#39;, getModifyTime())\n    if (ifModifiedSince &amp;&amp; ifModifiedSince === getModifyTime()) &#123;\n        console.log(&#39;304&#39;)\n        res.statusCode = 304\n        res.end()\n        return\n    &#125; else &#123;\n        console.log(&#39;200&#39;)\n        res.end(&#39;value&#39;)\n    &#125;\n&#125;)\napp.listen(3000, () =&gt; &#123;\n    console.log(&#39;Example app listening on port 3000!&#39;)\n&#125;)\n</code></pre>\n</li>\n<li><p>ETag：</p>\n<p>ETag 和 If-None-Match：服务器通过 ETag 响应头给资源生成一个唯一标识符。客户端在后续请求中通过 If-None-Match 请求头携带该标识符，服务器根据标识符判断资源是否有更新。如果没有更新，返回 304 状态码。</p>\n<blockquote>\n<p>ETag 优先级比 Last-Modified 高</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP2\"><a href=\"#HTTP2\" class=\"headerlink\" title=\"HTTP2\"></a>HTTP2</h2><ul>\n<li><p>HTTP2是超文本传输协议的下一个主要版本，是对HTTP&#x2F;1.1协议的重大改进。目标是改善性能、效率和安全性，提供更快更高效的网络通信。</p>\n</li>\n<li><p>多路复用</p>\n</li>\n<li><p>HTTP&#x2F;2支持在单个TCP连接上同时发送多个请求和响应，这意味着可以避免建立多个连接，减少网络延迟，提高效率。</p>\n</li>\n<li><p>二进制分帧</p>\n<ul>\n<li>在HTTP2应用层和传输层之间增加了二进制分帧层，将请求和响应拆分为多个帧，这种二进制格式的设计使得协议更加高效，并且容易解析和处理。<ul>\n<li>数据帧（Data Frame）：用于传输请求和响应的实际数据。</li>\n<li>头部帧（Headers Frame）：包含请求或响应的头部信息。</li>\n<li>优先级帧（Priority Frame）：用于指定请求的优先级。</li>\n<li>设置帧（Settings Frame）：用于传输通信参数的设置。</li>\n<li>推送帧（Push Promise Frame）：用于服务器主动推送资源。</li>\n<li>PING 帧（PING Frame）：用于检测连接的活跃性。</li>\n<li>重置帧（RST_STREAM Frame）：用于重置数据流或通知错误。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>头部压缩</p>\n<ul>\n<li>HTTP2采用首部表和动态压缩算法来减少头部的大小，这减少了每个请求和响应的开销，提高了传输效率。</li>\n</ul>\n</li>\n<li><p>node中实现</p>\n<ul>\n<li><blockquote>\n<p>可以使用openssl 生成 tls证书：</p>\n<p>生成私钥</p>\n<pre><code class=\"sh\">openssl genrsa -out server.key 1024\n</code></pre>\n<p>生成证书请求文件(用完可以删掉也可以保留)</p>\n<pre><code class=\"sh\">openssl req -new -key server.key -out server.csr\n</code></pre>\n<p>生成证书</p>\n<pre><code class=\"sh\">openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650\n</code></pre>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"javascript\">import http2 from &#39;node:http2&#39;\nimport fs from &#39;node:fs&#39;\nconst server = http2.createSecureServer(&#123;\n    key: fs.readFileSync(&#39;server.key&#39;),\n    cert: fs.readFileSync(&#39;server.crt&#39;)\n&#125;)\nserver.on(&#39;stream&#39;, (stream, headers) =&gt; &#123;\n    stream.respond(&#123;\n        &#39;content-type&#39;: &#39;text/html; charset=utf-8&#39;,\n        &#39;:status&#39;: 200\n    &#125;)\n    stream.on(&#39;error&#39;, (err) =&gt; &#123;\n        console.log(err)\n    &#125;)\n    stream.end(`\n      &lt;h1&gt;http2&lt;/h1&gt;\n    `)\n&#125;)\nserver.listen(80, () =&gt; &#123;\n    console.log(&#39;server is running on port 80&#39;)\n&#125;)\n</code></pre>\n</li>\n</ul>\n<h1 id=\"Node中事件循环\"><a href=\"#Node中事件循环\" class=\"headerlink\" title=\"Node中事件循环\"></a>Node中事件循环</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29sb3ZpbmcvcC8xNjUyMzY0OC5odG1s\">https://www.cnblogs.com/goloving/p/16523648.html</span></p>\n<blockquote>\n<p>本篇出于学习<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzcyNzQ4OTM3MTQ5NzA5MTg5Njk=\">node.js教程</span>后所整理，内容中有大量引用和参照，详细可点击前去了解</p>\n</blockquote>\n","categories":["Node.js"],"tags":["node.js"]},{"title":"react技术揭秘","url":"/2024/01/29/react%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/","content":"<h1 id=\"React-理念\"><a href=\"#React-理念\" class=\"headerlink\" title=\"React 理念\"></a>React 理念</h1><h3 id=\"react-理念\"><a href=\"#react-理念\" class=\"headerlink\" title=\"react 理念\"></a>react 理念</h3><blockquote>\n<p>React 被设计用于 JavaScript 构建快速响应的大型 Web 应用程序。</p>\n<p>由此可见，<code>快速响应</code>是 react 框架的关键</p>\n</blockquote>\n<h3 id=\"难点限制\"><a href=\"#难点限制\" class=\"headerlink\" title=\"难点限制\"></a>难点限制</h3><p>需要解决快速响应的难点就要解决以下两种限制：</p>\n<ul>\n<li><p>CPU 的瓶颈</p>\n<p>遇到大量计算操作时，页面掉帧导致卡顿</p>\n<ul>\n<li><pre><code class=\"javascriptx\">function App() &#123;\n  const len = 3000;\n  return (\n      &lt;ul&gt;\n          &#123;\nnew Map(len).fill(0).map((item, index) =&gt; &lt;li&gt;index&lt;/li&gt;);\n          &#125;\n      &lt;/ul&gt;\n  )\n&#125;\n</code></pre>\n</li>\n<li><p>这样当页面执行 js 代码时，由于渲染线程和 js 脚本执行互斥，所以页面迟迟没有渲染，造成卡顿</p>\n</li>\n<li><p>解决方案：</p>\n<ul>\n<li><p>在浏览器每一帧的时间中，预留一些时间给 JS 线程，React 利用这部分时间更新组件（预留的初始时间是 5ms）。</p>\n</li>\n<li><p>预留的时间不够用时，react 将线程控制权交还给浏览器，使其有时间渲染 UI 界面。</p>\n</li>\n<li><blockquote>\n<p>这种将长任务拆分到每一帧中，每次执行一小段任务的操作成为时间切片</p>\n</blockquote>\n</li>\n<li><pre><code class=\"javascriptx\">// 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode,启用时间切片\n// ReactDOM.render(&lt;App/&gt;, rootEl);\nReactDOM.unstable_createRoot(rootEl).render(&lt;App /&gt;);\n</code></pre>\n</li>\n<li><blockquote>\n<p>解决 CPU 瓶颈的关键在于实现时间切片，而时间切片的关键是：<code>将同步的更新变为可中断的异步更新</code>。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>IO 的瓶颈</p>\n<p>发送网络请求后，需要等待数据返回才能进一步操作</p>\n<ul>\n<li><p>网络延迟是无法解决的，如何在网络延迟客观存在的情况下，减少用于对网络延迟的感知？</p>\n</li>\n<li><p>如果请求数据和显示页面并行执行，就会造成页面的卡顿，而一旦先显示页面，后面请求数据再更新就会流畅很多。</p>\n</li>\n<li><blockquote>\n<p>react 采用的方案是：将界面 UI 的同步更新变为可中断的异步更新</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"React15-架构\"><a href=\"#React15-架构\" class=\"headerlink\" title=\"React15 架构\"></a>React15 架构</h1><p>React15 的架构分为协调器和渲染器</p>\n<h3 id=\"协调器\"><a href=\"#协调器\" class=\"headerlink\" title=\"协调器\"></a>协调器</h3><ul>\n<li>Reconciler 协调器负责找出变化的组件。</li>\n<li>React 中通过<code>this.setState</code>、<code>this.forceUpdate</code>和<code>ReactDOM.render</code>等 API 进行更新。每当有更新发生，协调器就会做如下工作：<ul>\n<li>调用函数组件或者类组件的<code>render</code>方法，将返回的 JSX 转化为虚拟 DOM</li>\n<li>将虚拟 DOM 和上次更新时的虚拟 DOM 比对</li>\n<li>通过比对找出本次更新中变化的虚拟 DOM</li>\n<li>通知渲染器将比那花的虚拟 DOM 渲染到页面上</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"渲染器\"><a href=\"#渲染器\" class=\"headerlink\" title=\"渲染器\"></a>渲染器</h3><ul>\n<li>React 支持跨平台，所以不同平台有不同的 Renderer 渲染器，浏览器环境是<code>ReactDOM</code></li>\n<li>Renderer 渲染器负责将变化的组件渲染到页面上</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li><p>mount 的组件会同步递归更新子组件，造成 UI 卡顿。</p>\n<blockquote>\n<p>在协调器 Reconciler 中，mount 的组件会调用 mountComponent，update 的组件会调用 updateComponent 方法，这两个方法都会递归更新子组件，而递归更新子组件是非常消耗性能的。</p>\n</blockquote>\n</li>\n<li><p>同步更新 UI 视图，界面卡顿</p>\n<blockquote>\n<p>视图同步更新，并且 React15 不会中断进行中的更新</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"React16-架构\"><a href=\"#React16-架构\" class=\"headerlink\" title=\"React16 架构\"></a>React16 架构</h1><p>React16 架构可以分为三层：</p>\n<ul>\n<li>Scheduler 调度器：负责调度任务的优先级，高优先级的任务先进入 Reconciler 进行协调</li>\n<li>Reconciler 协调器：找出变化的组件</li>\n<li>Renderer 渲染器：将变化的组件渲染到页面上</li>\n</ul>\n<p>React16 架构相比 React15 添加了 Scheduler 调度器</p>\n<h3 id=\"调度器\"><a href=\"#调度器\" class=\"headerlink\" title=\"调度器\"></a>调度器</h3><ul>\n<li><p>首先以浏览器是否有剩余时间作为任务终端的标准，那么就需要一种机制，当浏览器有剩余时间时通知我们。可以使用<code>requestIdleCallback</code>这个 API，但是因为下面的原因被弃用了：</p>\n<ul>\n<li>浏览器兼容性（跨平台所不能容忍的）</li>\n<li>触发频率不稳定，会受很多因素影响</li>\n</ul>\n</li>\n<li><p>Scueduler 调度器库由此诞生，并且独立于 React</p>\n</li>\n</ul>\n<h3 id=\"协调器-1\"><a href=\"#协调器-1\" class=\"headerlink\" title=\"协调器\"></a>协调器</h3><ul>\n<li><blockquote>\n<p>React15 中的 Reconciler 协调器是同步递归处理虚拟 DOM 的，这样会造成 UI 视图层的卡顿。在 React16 中将更新工作从递归变成了可以中断的循环过程，每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间</p>\n</blockquote>\n</li>\n<li><p>React16 解决中断更新时，DOM 渲染不完全的问题</p>\n<blockquote>\n<p>React16 中，调度器和协调器不再是交替工作，当调度器将任务交给协调器之后，协调器会为变化的虚拟 DOM 打上增&#x2F;删&#x2F;改 的标记</p>\n<p>整个工作都在内存中进行，只有当所有组件都完成协调的工作，才会统一交给渲染器进行渲染。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"渲染器-1\"><a href=\"#渲染器-1\" class=\"headerlink\" title=\"渲染器\"></a>渲染器</h3><p>Renderer 渲染器根据 Reconciler 为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。</p>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li>例如：点击 button 按钮，触发更新</li>\n<li>调度器受到更新，判断是否有凄然优先级更高的任务需要执行，如果没有就将组件状态改变，交给协调器</li>\n<li>协调器接收到更新，将变化的虚拟 DOM 打上标记，交给渲染器</li>\n<li>渲染器对打标记的 DOM 元素执行对应的操作</li>\n</ul>\n<p><strong>中间两个任务（调度器和协调器）随时都可能由于以下原因被中断：</strong></p>\n<ul>\n<li><p>有其他更高优先级的任务需要执行</p>\n</li>\n<li><p>当前帧没有剩余时间</p>\n<blockquote>\n<p>由于调度器和协调器的工作都在内存中进行，不会更新到页面上，所以即使反复中断，对用户来说也无感</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"Fiber介绍\"><a href=\"#Fiber介绍\" class=\"headerlink\" title=\"Fiber介绍\"></a>Fiber介绍</h1><blockquote>\n<p>Fiber 其实是一个数据结构，需要记录节点和节点之间的关系，在Fiber架构中的任务是可以中断执行的，继续执行时会丢弃原来完成的工作从头再来（数据不可变的原因），并且即使重新执行中断的任务，对用户侧来说也是无感的，因为Fiber架构的视图更新是后缓冲区视图 替换 前缓冲区视图的过程。<br>顺便理解一下componentWillMount、componentWillReceiveProps、componentWillUpdate这三个钩子被废弃的原因：因为render阶段是异步执行、可被中断的，再次回来的时候有可能会丢弃已经完成的工作从头再来，这样就可能会导致Fiber节点在render阶段重复调用<code>componentWillMount</code>这几个钩子，导致不符合开发者预期，并且当这几个钩子中存在副作用时，就会出现问题。</p>\n</blockquote>\n<pre><code class=\"javascript\">// Fiber中关键字段\n&#123;\n  type, //DOM类型\n  key, //reconciler在协调过程中，决定该fiber是否要复用\n  child, //组件render函数返回值\n  sibling,\n  return, //return属性指向父节点\n  pendingProps,\n  memoizedProps,\n  pendingWorkPriority,\n  alternate,\n  ...\n&#125;\n</code></pre>\n<h1 id=\"Fiber架构\"><a href=\"#Fiber架构\" class=\"headerlink\" title=\"Fiber架构\"></a>Fiber架构</h1><p>Fiber架构出现的原因：</p>\n<blockquote>\n<p> 由于JS单线程执行，并且React15版本的reconciler协调阶段只能一次执行完，不能被中途打断，这就导致：当更新渲染的执行任务较多时，协调阶段一次执行的时间花费就很长，这时就会出现掉帧、卡顿的现象。由此推出Fiber架构<br> Fiber架构实现逻辑：<br> Fiber架构借鉴生成器(或者说协程)的概念，将任务分给一个个的迭代器执行，迭代器完成执行任务的过程发生在浏览器空闲阶段，这样就不会阻塞UI的渲染。（由于RequestIdleCallback存在兼容性问题、并且在大量用户操作的时候不够稳定，因此使用RequestAnimationFrame和disPatchEvent消息队列来完成）</p>\n</blockquote>\n<h1 id=\"双缓冲更新机制\"><a href=\"#双缓冲更新机制\" class=\"headerlink\" title=\"双缓冲更新机制\"></a>双缓冲更新机制</h1><blockquote>\n<p>双缓冲更新机制就是: 在视图需要进行更新时,通过在后台更新新的fiber树,如果遇到优先级更高的任务,就暂停当前的执行(conscrent模型)任务,此时,即使更新到一半,对于用户侧来说也是无影响的,当整个新的fiber树构建完成之后,才会去用新的fiber树替换掉旧的fiber树.</p>\n</blockquote>\n<h1 id=\"Fiber-架构心智模型\"><a href=\"#Fiber-架构心智模型\" class=\"headerlink\" title=\"Fiber 架构心智模型\"></a>Fiber 架构心智模型</h1><h3 id=\"代数效应\"><a href=\"#代数效应\" class=\"headerlink\" title=\"代数效应\"></a>代数效应</h3><ul>\n<li>代数效应是函数式编程中的概念，用于<code>将副作用和函数相分离</code>。</li>\n<li>代数效应能够将副作用从函数逻辑中分离，使函数关注点保持纯粹</li>\n<li>代数效应最明显的应用就是 Hooks</li>\n<li>代数效应和 Fiber 架构：<ul>\n<li>Fiber（纤程）和 Generator（协程）可以理解为代数效应思想在 JS 中的体现。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h3><ul>\n<li>React Fiber 可以理解为：</li>\n<li>React 内部实现了一套状态更新机制，支持任务的不同优先级，可以中断和恢复，并且恢复后可以复用之前的中间状态。</li>\n<li>其中每个任务更新单元就是 React Element 对应的 Fiber 节点。</li>\n</ul>\n<h1 id=\"Fiber-原理\"><a href=\"#Fiber-原理\" class=\"headerlink\" title=\"Fiber 原理\"></a>Fiber 原理</h1><h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ul>\n<li>在 React15 及以前，协调器采用递归的方式创建虚拟 DOM，递归过程是不能中断的，如果组件树嵌套很深就会占用线程很多时间，造成 UI 卡顿。</li>\n<li>React16 将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归虚拟 DOM 数据结构无法满足需要了，就有了全新的 Fiber 架构。</li>\n</ul>\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>React16 之后，虚拟 DOM 在 React 中有个正式的称呼：Fiber</li>\n<li>Fiber 包含三层含义：<ul>\n<li>Fiber 架构，React16 的 Reconciler 协调器基于 Fiber 节点实现，被称为 Fiber Reconciler</li>\n<li>Fiber 数据结构，作为静态的数据结构，每一个 Fiber 节点对应一个 React 组件，保存了该组件的类型、对应的 DOM 节点等信息</li>\n<li>Fiber 动态工作单元，每一个 Fiber 节点保存了本次更新中该组件改变的状态和要执行的工作</li>\n</ul>\n</li>\n<li>Fiber 节点对应 DOM 节点、Fiber 节点构成的 Fiber 树对应 DOM 树。<ul>\n<li>组件<code>mount</code>时，<code>Reconciler协调器</code>根据 JSX 描述的组件内容生成组件对应的<code>Fiber节点</code>。</li>\n<li>组件<code>update</code>时，<code>Reconciler协调器</code>将<code>JSX</code>与<code>Fiber节点</code>保存的数据对比（diff 算法），生成组件对应的<code>Fiber节点</code>，并根据对比结果为<code>Fiber节点</code>打上<code>标记</code>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>双缓存<ul>\n<li>在内存中构建并直接替换的技术叫双缓存，目的是不会出现白屏闪烁情况。</li>\n<li><code>React</code>使用“双缓存”来完成<code>Fiber树</code>的构建与替换——对应着<code>DOM树</code>的创建与更新</li>\n<li>在<code>React</code>中最多会同时存在两棵<code>Fiber树</code>。当前屏幕上显示内容对应的<code>Fiber树</code>称为<code>current Fiber树</code>，正在内存中构建的<code>Fiber树</code>称为<code>workInProgress Fiber树</code>。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"diff-算法\"><a href=\"#diff-算法\" class=\"headerlink\" title=\"diff 算法\"></a>diff 算法</h1><p>由于<code>Diff</code>操作本身也会带来性能损耗，React 文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中<code>n</code>是树中元素的数量。</p>\n<p>如果在<code>React</code>中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。</p>\n<p>为了降低算法复杂度，<code>React</code>的<code>diff</code>会预设三个限制：</p>\n<ul>\n<li><p>只对同级元素进行<code>Diff</code>。如果一个<code>DOM节点</code>在前后两次更新中跨越了层级，那么<code>React</code>不会尝试复用他。</p>\n</li>\n<li><p>两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React 会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。</p>\n</li>\n<li><p>开发者可以通过 <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</p>\n</li>\n</ul>\n<h3 id=\"单节点-diff\"><a href=\"#单节点-diff\" class=\"headerlink\" title=\"单节点 diff\"></a>单节点 diff</h3><p><img data-src=\"/images/Snipaste_2024-07-01_07-44-22.jpg\"></p>\n<ul>\n<li>当<code>key相同</code>且<code>type不同</code>时，代表我们已经找到本次更新的<code>p</code>对应的上次的<code>fiber</code>，但是<code>p</code>与<code>li</code> <code>type</code>不同，不能复用。既然唯一的可能性已经不能复用，则剩下的<code>fiber</code>都没有机会了，所以都需要标记删除。</li>\n<li>当<code>key不同</code>时只代表遍历到的该<code>fiber</code>不能被<code>p</code>复用，后面还有兄弟<code>fiber</code>还没有遍历到。所以仅仅标记该<code>fiber</code>删除。</li>\n</ul>\n<h3 id=\"多节点-diff\"><a href=\"#多节点-diff\" class=\"headerlink\" title=\"多节点 diff\"></a>多节点 diff</h3><p><code>Diff算法</code>的整体逻辑会经历两轮遍历：（对 Children 和 Fiber 进行遍历）</p>\n<ul>\n<li><p>第一轮遍历：处理<code>更新</code>的节点。</p>\n<ul>\n<li>如果 DOM 节点可以复用，比较下一个节点</li>\n<li>不可复用分两种情况<ul>\n<li><code>key</code>不同导致不可复用，立即跳出整个遍历，<strong>第一轮遍历结束。</strong></li>\n<li><code>key</code>相同<code>type</code>不同导致不可复用，会将<code>oldFiber</code>标记为<code>DELETION</code>，并继续遍历</li>\n</ul>\n</li>\n<li>遍历完，跳出第一轮遍历。</li>\n</ul>\n</li>\n<li><p>第二轮遍历：处理剩下的不属于<code>更新</code>的节点，需要对第一轮遍历的结果分别讨论：</p>\n<ul>\n<li><p><code>newChildren</code>与<code>oldFiber</code>同时遍历完</p>\n<p>那就是最理想的情况：只需在第一轮遍历进行组件<a href=\"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L825\"><code>更新</code></a>。此时<code>Diff</code>结束。</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5pYW1rYXNvbmcuY29tL2RpZmYvbXVsdGkuaHRtbCNuZXdjaGlsZHJlbiVFNiVCMiVBMSVFOSU4MSU4RCVFNSU4RSU4NiVFNSVBRSU4QyVFRiVCQyU4Q29sZGZpYmVyJUU5JTgxJThEJUU1JThFJTg2JUU1JUFFJThD\">#</span><code>newChildren</code>没遍历完，<code>oldFiber</code>遍历完</p>\n<p>已有的<code>DOM节点</code>都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记<code>Placement</code>。</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5pYW1rYXNvbmcuY29tL2RpZmYvbXVsdGkuaHRtbCNuZXdjaGlsZHJlbiVFOSU4MSU4RCVFNSU4RSU4NiVFNSVBRSU4QyVFRiVCQyU4Q29sZGZpYmVyJUU2JUIyJUExJUU5JTgxJThEJUU1JThFJTg2JUU1JUFFJThD\">#</span><code>newChildren</code>遍历完，<code>oldFiber</code>没遍历完</p>\n<p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的<code>oldFiber</code>，依次标记<code>Deletion</code>。</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5pYW1rYXNvbmcuY29tL2RpZmYvbXVsdGkuaHRtbCNuZXdjaGlsZHJlbiVFNCVCOCU4RW9sZGZpYmVyJUU5JTgzJUJEJUU2JUIyJUExJUU5JTgxJThEJUU1JThFJTg2JUU1JUFFJThD\">#</span><code>newChildren</code>与<code>oldFiber</code>都没遍历完</p>\n<p>这意味着有节点在这次更新中改变了位置。接下来需要处理移动的节点并标记节点的移动进行处理。</p>\n</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2></li>\n</ul>\n<h1 id=\"实现-useState\"><a href=\"#实现-useState\" class=\"headerlink\" title=\"实现 useState\"></a>实现 useState</h1><pre><code class=\"javascript\">let workInProgressHook;\nlet isMount = true;\nconst fiber = &#123;\n  memoizedState: null,\n  stateNode: App,\n&#125;;\nfunction schedule() &#123;\n  workInProgressHook = fiber.memoizedState;\n  const app = fiber.stateNode();\n  isMount = false;\n  return app;\n&#125;\nfunction dispatchAction(queue, action) &#123;\n  const update = &#123;\n    action,\n    next: null,\n  &#125;;\n  if (queue.pending === null) &#123;\n    update.next = update;\n  &#125; else &#123;\n    update.next = queue.pending.next;\n    queue.pending.next = update;\n  &#125;\n  queue.pending = update;\n  schedule();\n&#125;\nfunction useState(initialState) &#123;\n  let hook;\n  if (isMount) &#123;\n    hook = &#123;\n      queue: &#123;\n        pending: null,\n      &#125;,\n      memoizedState: initialState,\n      next: null,\n    &#125;;\n    if (!fiber.memoizedState) &#123;\n      fiber.memoizedState = hook;\n    &#125; else &#123;\n      workInProgressHook.next = hook;\n    &#125;\n    workInProgressHook = hook;\n  &#125; else &#123;\n    hook = workInProgressHook;\n    workInProgressHook = workInProgressHook.next;\n  &#125;\n  let baseState = hook.memoizedState;\n  if (hook.queue.pending) &#123;\n    let firstUpdate = hook.queue.pending.next;\n    do &#123;\n      const action = firstUpdate.action;\n      baseState = action(baseState);\n      firstUpdate = firstUpdate.next;\n    &#125; while (firstUpdate !== hook.queue.pending);\n    hook.queue.pending = null;\n  &#125;\n  hook.memoizedState = baseState;\n  return [baseState, dispatchAction.bind(null, hook.queue)];\n&#125;\nfunction App() &#123;\n  const [num, updateNum] = useState(0);\n  console.log(`$&#123;isMount ? &quot;mount&quot; : &quot;update&quot;&#125; num: `, num);\n  return &#123;\n    click() &#123;\n      updateNum((num) =&gt; num + 1);\n    &#125;,\n  &#125;;\n&#125;\nwindow.app = schedule();\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWFjdC5pYW1rYXNvbmcuY29tL3Byb2Nlc3MvZmliZXIuaHRtbCNmaWJlciVFNyU5QSU4NCVFNyVCQiU5MyVFNiU5RSU4NA==\">React 技术揭秘</span></p>\n","categories":["react"],"tags":["react,react源码"]},{"title":"serviceWorker","url":"/2024/02/02/serviceWorker/","content":"<h2 id=\"serviceWorker-html\"><a href=\"#serviceWorker-html\" class=\"headerlink\" title=\"serviceWorker.html\"></a>serviceWorker.html</h2><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n        //数据库\n        console.log(window.indexedDB);\n        //service worker\n        console.log(window.navigator.serviceWorker);\n        //service Worker是后台运行的脚本，充当一个代理服务器，拦截用户发出的网络请求。还可以修改用户的请求或者直接向用户发出回应，使得用户可以在离线情况下使用网络应用。还可以在本地缓存资源文件，加快访问速度。\n        if(&#39;serviceWorker&#39; in navigator)&#123;\n             window.addEventListener(&#39;load&#39;,()=&gt;&#123;\n             navigator.serviceWorker.register(&#39;./service-worker.js&#39;);\n            &#125;)\n        &#125;\n        navigator.serviceWorker.register(&#39;./service-worker.js&#39;).then(res=&gt;&#123;\n            console.info(&#39;注册成功&#39;);\n        &#125;).catch(err=&gt;&#123;\n            console.error(&#39;注册失败&#39;);\n        &#125;)\n        // 为了节省内存，当service-Worker不使用时是休眠的，他也不回保存数据，所以重新启动时，为了拿到数据需要将数据放在IndexedDb中\n        //服务端部署消息，监听代码\n        window.addEventListener(&#39;message&#39;,data=&gt;&#123;\n            if(data.source===&#39;service-worker&#39;)&#123;\n                console.log(data.msg,&#39;serviceWorker发送来的消息&#39;);\n            &#125;\n        &#125;)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"serviceWorker-js\"><a href=\"#serviceWorker-js\" class=\"headerlink\" title=\"serviceWorker.js\"></a>serviceWorker.js</h2><pre><code class=\"javascript\">//serviceWorker是基于事件驱动的。\n//serviceWorker安装事件\nself.addEventListener(&#39;install&#39;,event=&gt;&#123;\n    console.log(event,&#39;安装事件&#39;);\n    event.waitUntil(()=&gt;&#123;\n        console.info(&#39;安装完成&#39;);\n    &#125;)\n&#125;)\n//serviceWorker激活事件（当安装完成之后就开始激活）\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    let cacheWhiteList = [&#39;product-v2&#39;];\n    event.waitUntil(\n        caches.keys().then(cacheNames=&gt;&#123;\n            return Promise.all(\n                cacheNames.map(cacheName=&gt;&#123;\n                    if(cacheWhiteList.indexOf(cacheName) === -1)&#123;\n                        return caches.delete(cacheName);\n                    &#125;\n                &#125;)\n            )\n        &#125;)\n    )\n&#125;)\n//serviceWorker与网页的通信\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    event.waitUntil(\n        self.clients.matchAll().then((client)=&gt;&#123;\n            client.postMessage(&#123;\n                msg:&quot;Hello serviceWorker&quot;,\n                source:&quot;serviceWorker&quot;\n            &#125;)\n        &#125;)\n    )\n&#125;)\n</code></pre>\n","categories":["JS"],"tags":["JS","serviceWorker"]},{"title":"JS中类型化数组typedArray","url":"/2023/12/11/typedArray/","content":"<p>#JS中类型化数组（typed array）<br>JavaScript 的类型化数组是一种特殊的数组，可以存储和操作固定类型的数据，如整数、浮点数、字节等。相比于普通的 JavaScript 数组，类型化数组有以下几个优点：</p>\n<p>更加高效：类型化数组在内存中是连续存储的，这意味着它们可以更快地被读取和写入。此外，它们还允许我们直接访问底层的二进制数据，而不需要进行类型转换或拷贝操作。<br>更加节省空间：由于类型化数组只能存储固定类型的数据，因此它们使用的内存空间可以更加紧凑。例如，使用 Int8Array 数组可以将每个元素压缩为 1 个字节，而使用普通的 JavaScript 数组则需要至少 8 个字节来存储一个数字。<br>更加易于处理二进制数据：类型化数组可以帮助我们更加方便地处理二进制数据，如音频、视频、图像等。这些数据通常以二进制格式存储，而类型化数组可以直接读取和操作这些数据，而不需要进行复杂的解析和转换操作。<br>总之，类型化数组可以带来更高效、更紧凑、更直接的二进制数据处理体验，是 JavaScript 中处理二进制数据时非常有用的工具。虽然普通的 JavaScript 数组也可以存储二进制数据，但它们没有类型化数组那样的高效和直接性。因此，在需要处理大量二进制数据时，使用类型化数组会更加合适。</p>\n<p>Int8Array:<br>①只能存储8位有符号整数（-128到127），②使用固定大小的内存来存储数据，每个元素占用一个字节（8位）③元素连续存储</p>\n<pre><code class=\"javascript\">// 以长度参数构造对象\nvar int8 = new Int8Array(2);\nint8[0] = 42;\nconsole.log(int8[0]); // 42\nconsole.log(int8.length); // 2\nconsole.log(int8.BYTES_PER_ELEMENT); // 数组所占用的字节数\n// 以数组构造对象\nvar arr = new Int8Array([21, 31]);\nconsole.log(arr[1]); // 31\n// 从另一数组构造对象\nvar x = new Int8Array([21, 31]);\nvar y = new Int8Array(x);\nconsole.log(y[0]); // 21\n// 从 ArrayBuffer 构造对象\nvar buffer = new ArrayBuffer(8);\nvar z = new Int8Array(buffer, 1, 4);\n</code></pre>\n<p>还有：Uint8Array等类型<br>forEach的回调函数中不传参数</p>\n<pre><code class=\"javascript\">const dfs = function(root)&#123;\n    console.log(root.val,&#39;还好&#39;);\n    root.children.forEach(dfs);//forEach回调不传参数，默认传的参数就是item项\n&#125;\n</code></pre>\n","categories":["JS"],"tags":["JS","typedArray"]},{"title":"vue-router","url":"/2024/04/12/vue-router/","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"vue-router源码\"><a href=\"#vue-router源码\" class=\"headerlink\" title=\"vue-router源码\"></a>vue-router源码</h1><h3 id=\"vue-router路由模式\"><a href=\"#vue-router路由模式\" class=\"headerlink\" title=\"vue-router路由模式\"></a>vue-router路由模式</h3><h4 id=\"hash模式（-）\"><a href=\"#hash模式（-）\" class=\"headerlink\" title=\"hash模式（#）\"></a>hash模式（#）</h4><p>SEO不友好，资源不变，不会刷新。</p>\n<h4 id=\"history模式（-x2F-）\"><a href=\"#history模式（-x2F-）\" class=\"headerlink\" title=\"history模式（&#x2F;）\"></a>history模式（&#x2F;）</h4><p>SEO友好，重新请求资源。</p>\n<p><strong>history模式发布时出现的问题：</strong></p>\n<p>发布到服务器上时，点击路由跳转正常但是刷新后路由跳转404，出现的原因刷新后跳转的根路径并不是当前项目的index.html导致资源路径不匹配单页面应用路由，采取的方法是<strong>每次请求资源都fallback到index.html文件</strong>，可以使用静态资源服务器的支持。（例如在nginx中location字段添加：<strong>try_files字段</strong>）</p>\n<h3 id=\"vue-router内部处理\"><a href=\"#vue-router内部处理\" class=\"headerlink\" title=\"vue-router内部处理\"></a>vue-router内部处理</h3><h6 id=\"vue-router主体架构：\"><a href=\"#vue-router主体架构：\" class=\"headerlink\" title=\"vue-router主体架构：\"></a>vue-router主体架构：</h6><p>当使用vue.use(vue-router)时，会执行vue-router导出的实例中的install方法，将app作为参数传入，内部会用app.component注册两个全局组件RouterLink和RouterView，接着在app.config.globalProperties上设置$route和$router属性，通过app.provide将router和currentRoute传递下去。</p>\n<h6 id=\"路由变化但不跳转原理：\"><a href=\"#路由变化但不跳转原理：\" class=\"headerlink\" title=\"路由变化但不跳转原理：\"></a>路由变化但不跳转原理：</h6><p>history.pushState和history.replaceState方法，会改变地址栏的但不进行跳转。</p>\n<h6 id=\"history模式实现路由匹配：\"><a href=\"#history模式实现路由匹配：\" class=\"headerlink\" title=\"history模式实现路由匹配：\"></a>history模式实现路由匹配：</h6><p>内部的mather函数会将routes中的path路径转为正则表达式，与当前的路由进行匹配，匹配成功就将对应的组件添加到router-view中。</p>\n<h6 id=\"router-view实现路由展示：\"><a href=\"#router-view实现路由展示：\" class=\"headerlink\" title=\"router-view实现路由展示：\"></a>router-view实现路由展示：</h6><pre><code class=\"javascript\">import &#123; defineComponent &#125; from vue;\nimport Home from &#39;../views/Home&#39;;  //导入默认的全部组件\nconst routerView =  defineComponent(&#123;\n    name:&quot;routerView&quot;,\n    props:&#123;&#125;,\n    setup(props , &#123; slots &#125;)&#123;\n        return ()=&gt;&#123;\n            // return h(&#39;div&#39;,&#123;        //不使用组件默认的方式\n            //     class:&#39;routerViewClass&#39;,\n            //     onClick()&#123;\n            //         //处理点击 逻辑\n            //     &#125;,\n            // &#125;,slots.default())\n            return h(Home,&#123;\n                onClick()&#123;\n                    //处理对应的逻辑\n                &#125;\n            &#125;)\n        &#125;\n    &#125;,\n&#125;)\nexport default routerView;\n</code></pre>\n<p>路由provide一个currentRoute（shallowRef对象）将当前的路由路径捆绑在一起，传递下去，当currentRoute发生变化的时候就会改变相应的router-view。</p>\n","categories":["vue-router原理"],"tags":["vue-router原理"]},{"title":"vue3源码中的位运算","url":"/2023/09/02/vue3%E6%BA%90%E7%A0%81%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"<p>vue3中通过位运算进行类型判断<br>性能提高，可读性减小：</p>\n<p>快速判断：位运算是底层的二进制操作，比起其他逻辑运算符，如逻辑与 &amp;&amp;、逻辑或 ||，位运算更加高效。在某些场景下，使用位运算可以对多个类型进行快速判断，避免了复杂的条件判断和函数调用。<br>位运算的特性：位运算的特性使得它可以用较少的存储空间表示和处理多个状态或标志位。通过将多个类型的判断压缩到一个整数中，可以节省内存空间，并且减少了不必要的变量声明和赋值操作，从而提升了性能。</p>\n","categories":["vue"],"tags":["vue","位运算"]},{"title":"v8引擎编译原理","url":"/2024/05/21/v8%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","content":"<h1 id=\"v8-执行-JS\"><a href=\"#v8-执行-JS\" class=\"headerlink\" title=\"v8 执行 JS\"></a>v8 执行 JS</h1><p><img data-src=\"/images/image123.png\" alt=\"alt text\"></p>\n<h1 id=\"v8-引擎介绍\"><a href=\"#v8-引擎介绍\" class=\"headerlink\" title=\"v8 引擎介绍\"></a>v8 引擎介绍</h1><p>Blink 内核用于解析 HTML、DOM、CSS 渲染、嵌入了 v8 引擎用于解析 Javascript</p>\n<p>V8 是谷歌的开源高性能 JavaScript 和 WebAssembly 引擎，用 C++编写。它被用于 Chrome 和 Node.js 等。<strong>用于解析并执行 JavaScript 代码。</strong></p>\n<h1 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h1><ul>\n<li>初始化运行环境<ul>\n<li>堆栈空间</li>\n<li>全局执行上下文</li>\n<li>全局作用域</li>\n<li>事件循环系统</li>\n</ul>\n</li>\n<li>利用 Scanner 扫描器将输入的代码词法分析成 tokens<ul>\n<li>分析的结果就是一个个的 tokens 对象组成的数组</li>\n<li>分析的过程利用了有限自动状态机的概念</li>\n</ul>\n</li>\n<li>利用 parser 解析器将 tokens 转化为抽象语法树<ul>\n<li>根据分析 tokens 构造出一种树形关系结构</li>\n<li><strong>预解析</strong>：在 JS 代码执行之前对代码进行可选的预处理，用于提高执行效率</li>\n<li><strong>延迟解析</strong>：只有代码执行到的部分才会去解析，节省了不必要的时间和开销，提高了 JavaScript 的执行效率，其中 vite 脚手架就是利用了这个优点（还有 esbuild 打包快的优势），提高了效率。</li>\n</ul>\n</li>\n<li>利用 <code>ignation解释器</code>将 AST（抽象语法树）转为字节码（不直接转为机器码？）<ul>\n<li>当年v8以超越同行10倍的运行速度而备受青睐,其本质原因是当时v8将JS源码直接编译为机器码,使得首次运行速度和后续执行速度都很快,但也存在一个问题就是内存占用太大,并且编译时占用太多时间</li>\n<li>字节码使得v8能够很好的进行优化与反优化,当执行代码时,对机器码的存储和复用等操作时都十分繁琐(存储占用大,分析繁琐等),但是分析字节码就更加容易一些</li>\n<li>字节码跨平台能力强</li>\n<li>字节码更快的加载和解析执行</li>\n<li>动态优化易操作</li>\n<li>代码安全性</li>\n</ul>\n</li>\n<li>利用 <code>TurboFan编译器</code>将字节码转为 CPU 和 ARM 识别的机器码</li>\n</ul>\n<h1 id=\"v8-中的对象结构\"><a href=\"#v8-中的对象结构\" class=\"headerlink\" title=\"v8 中的对象结构\"></a>v8 中的对象结构</h1><h3 id=\"常规属性和排序属性\"><a href=\"#常规属性和排序属性\" class=\"headerlink\" title=\"常规属性和排序属性\"></a>常规属性和排序属性</h3><ul>\n<li>v8 中的对象主要分为三个指针构成的，分别是：隐藏类、常规属性和排序属性。</li>\n<li>对象的属性数字会从小到大排列，字符串会按照原创建顺序</li>\n<li>对象中数字属性被称为排序属性，字符串属性被称为常规属性</li>\n</ul>\n<h3 id=\"快属性和慢属性\"><a href=\"#快属性和慢属性\" class=\"headerlink\" title=\"快属性和慢属性\"></a>快属性和慢属性</h3><ul>\n<li>JS 对象很多属性是在原型链上进行查找，这样就会很慢，v8 将部分常规属性（10 个）直接存储到对象本身（对象内属性），以提高属性的查询效率。</li>\n<li>快属性容量是 10 个。</li>\n</ul>\n<h3 id=\"封装、继承、多态\"><a href=\"#封装、继承、多态\" class=\"headerlink\" title=\"封装、继承、多态\"></a>封装、继承、多态</h3><ul>\n<li>封装就是将抽象出来的数据和对数据的操作封装在一起，数据在内部被保护，程序其他部分只有通过成员才能对数据进行操作</li>\n<li>继承：有原型链继承、寄生继承和 call、apply 借用法继承。</li>\n<li>多态就是函数重载：同一个函数可以根据调用的情况（参数类型和数量等）来进行不同的操作。</li>\n</ul>\n<h1 id=\"隐藏类\"><a href=\"#隐藏类\" class=\"headerlink\" title=\"隐藏类\"></a>隐藏类</h1><p>JavaScript 是一门动态语言，其各种不确定性导致 JavaScript 的执行效率要远低于静态语言，V8 为了提升 JavaScript 的执行效率，借鉴了很多静态语言的特性，比如：JIT 机制，为了加速运算而引入了内联缓存，为了提升对象的属性访问速度而引入了隐藏类。</p>\n<p>隐藏类是 V8 引擎在运行时自动生成和管理的数据结构，用于跟踪对象的属性和方法，相当于提前定义好对象的形状，以便于提高操作对象的效率。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><ul>\n<li>当 JavaScript 运行时，例如查找对象上的某一个属性，V8 引擎会通过快慢属性去查找，整个过程非常耗时，因为 V8 在使用一个对象时，并不知道对象的具体形状（属性方法等）</li>\n<li>而 C++在声明一个对象前就需要定义该对象的结构，C++代码执行前是需要被编译的，编译时对象的结构就已经固定，也就是当代码执行时，对象的形状是无法改变</li>\n<li>所以 V8 引入了隐藏类的概念，用于跟踪对象的属性和方法以此在内存中快速查找对象属性</li>\n</ul>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>隐藏类就是把 JavaScript 的对象也进行静态化，<code>我们假设这个对象不会删除和新增</code>，这样形状就固定了</p>\n<p>满足条件之后 V8 就会创建隐藏类，在这个隐藏类会创建对象的基础属性</p>\n<p>在 V8 引擎中，每个隐藏类都有一个编号（<code>map id</code>），用于唯一标识该隐藏类</p>\n<p>举个例子，假设我们有以下两个对象：</p>\n<pre><code class=\"javascript\">let obj1 = &#123; name: 1, age: 2 &#125;;\nlet obj2 = &#123; name: 1, age: 2, address: 3 &#125;;\n</code></pre>\n<p>这两个对象具有相同的形状，即都有属性<code>name</code>和<code>age</code>，但<code>obj2</code>还额外有一个属性<code>address</code>。V8 会为它们生成两个不同的隐藏类</p>\n<pre><code class=\"sh\">// 隐藏类1：包含属性name和age\nHiddenClass_1\n├── map_id: 1\n├── property_names: [&#39;name&#39;, &#39;age&#39;]\n├── transitions: &#123;&#125;\n└── prototype: Object.prototype\n\n// 隐藏类2：包含属性name、age和address\nHiddenClass_2\n├── map_id: 2\n├── property_names: [&#39;name&#39;, &#39;age&#39;, &#39;address&#39;]\n├── transitions:\n│   ├── a: HiddenClass_1\n│   ├── b: HiddenClass_1\n│   └── c: null\n└── prototype: Object.prototype\n</code></pre>\n<p>可以看到，隐藏类 1 包含属性<code>name</code>和<code>age</code>，没有过渡表；而隐藏类 2 包含属性<code>name</code>、<code>age</code>和<code>address</code>，其中属性<code>name</code>和<code>age</code>的过渡表指向隐藏类 1，属性<code>address</code>没有过渡表，表示该属性是新添加的</p>\n<p><strong>如果两个对象属性一样呢？</strong></p>\n<p>如果两个对象具有相同的属性，它们将共享同一个隐藏类。具体来说，当两个对象的属性顺序和类型都相同时，V8 会为它们生成一个共享的隐藏类。</p>\n<p>举个例子，假设我们有以下两个对象：</p>\n<pre><code class=\"ini\">let obj1 = &#123; name: 1, age: 2 &#125;;\nlet obj2 = &#123; name: 1, age: 2 &#125;;\n</code></pre>\n<p>这两个对象具有相同的形状，即都有属性<code>name</code>和<code>age</code>，且属性的顺序和类型完全一致。V8 会为它们生成一个共享的隐藏类，如下所示：</p>\n<pre><code class=\"javascript\">HiddenClass_1\n├── map_id: 1\n├── property_names: [&#39;name&#39;, &#39;age&#39;]\n├── transitions: &#123;&#125;\n└── prototype: Object.prototype\n</code></pre>\n<p>可以看到，隐藏类 1 包含属性<code>name</code>和<code>age</code>，没有过渡表，而且两个对象都<code>共享</code>这个隐藏类。</p>\n<blockquote>\n<p>这种共享隐藏类的机制可以节省内存空间，因为不同的对象可以共享相同的隐藏类结构。</p>\n</blockquote>\n<p><img data-src=\"/images/Snipaste_2024-05-28_21-49-19.png\" alt=\"JavaScript隐藏类机制\"></p>\n<h1 id=\"v8引擎垃圾回收\"><a href=\"#v8引擎垃圾回收\" class=\"headerlink\" title=\"v8引擎垃圾回收\"></a>v8引擎垃圾回收</h1><blockquote>\n<p>首先垃圾回收机制是对于<code>引用数据类型而言的</code>,普通数据类型由于不知道后续是否会引用某个变量导致不能轻易将变量进行销毁</p>\n</blockquote>\n<h3 id=\"标记清除法\"><a href=\"#标记清除法\" class=\"headerlink\" title=\"标记清除法\"></a>标记清除法</h3><blockquote>\n<p>标记清除法是目前在JS引擎中最常用的算法,该算法分为<code>标记</code>和<code>清除</code>两个阶段,标记阶段将所有<code>活动对象做上标记</code>,默认标记为0,清除阶段将<code>没有标记的活动对象进行清除</code>,也就是销毁掉标记为0的对象</p>\n</blockquote>\n<ul>\n<li>优点: 实现简单</li>\n<li>缺点: 清除之后由于剩余对象的内存位置不变,就会出现<code>内存碎片</code>,这时候为了分配到合适的位置就要进行内存利用的算法判断,<code>导致分配效率慢</code></li>\n</ul>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><blockquote>\n<p>引用计数法的策略是跟踪每个对象被使用的次数,当对象被其他变量引用时,它的<code>引用次数就会加1</code>,引用次数为0就表示没有变量在使用它,就可以将其清除</p>\n</blockquote>\n<ul>\n<li>优点: 清晰,并且可以立即回收垃圾</li>\n<li>缺点: 需要一个计数器,同时计数器需要占很大的位置,因为<code>引用数量的上限可能会很大</code>,同时最重要的是无法解决<code>循环引用而无法回收的问题</code></li>\n</ul>\n<h3 id=\"分代式垃圾回收\"><a href=\"#分代式垃圾回收\" class=\"headerlink\" title=\"分代式垃圾回收\"></a>分代式垃圾回收</h3><blockquote>\n<p>V8 中将堆内存分为新生代和老生代两区域，采用不同的策略管理垃圾回收<br>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</p>\n</blockquote>\n<h5 id=\"新生代\"><a href=\"#新生代\" class=\"headerlink\" title=\"新生代\"></a>新生代</h5><blockquote>\n<p>新生代堆内存一分为二:<code>使用区</code>和<code>空闲区</code>,新加入的对象就会放在使用区,当<code>使用区快写满时,就开始进行垃圾回收</code>，新生代垃圾回收器会对使用区中的<code>活动对象做标记</code>，标记完成之后<code>将使用区的 活动对象 复制进空闲区</code>并进行排序，随后进入垃圾清理阶段，即<code>将非活动对象占用的空间清理掉</code>。最后<code>进行角色互换</code>，把原来的使用区变成空闲区，把原来的空闲区变成使用区.当一个对象经过<code>多次复制后依然存活</code>，它将会被认为是生命周期较长的对象，随后<code>会被移动到老生代中</code>，采用老生代的垃圾回收策略进行管理<br>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中<br>新生代采用复制方式的原因是因为:新生代中的大多数对象都是很快变为垃圾(需要进行清除),如果直接原地清除就要频繁清理对象,<code>只复制活动对象到空闲区之后就可以直接清除整个使用区</code>,提高了清除效率</p>\n</blockquote>\n<h5 id=\"老生代\"><a href=\"#老生代\" class=\"headerlink\" title=\"老生代\"></a>老生代</h5><blockquote>\n<p>对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是<code>标记清除法</code>了<br>而标记清除法造成的<code>内存碎片问题</code>采用标记整理算法进行优化.</p>\n</blockquote>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><blockquote>\n<p>分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，<code>新老生代的回收机制及频率是不同的</code>，可以说此机制的出现很大程度<code>提高了垃圾回收机制的效率</code></p>\n</blockquote>\n<h3 id=\"并行回收\"><a href=\"#并行回收\" class=\"headerlink\" title=\"并行回收\"></a>并行回收</h3><p>新生代对象空间采用并行策略,在执行垃圾回收时,会启动多个线程来负责垃圾清理,以此增加效率</p>\n<blockquote>\n<p>并行和并发: 并发是:一个处理器同时处理多个任务(并发是逻辑上同时发生),并行是:多个处理器同时处理多个不同任务(并行是物理上同时发生)</p>\n</blockquote>\n","categories":["v8引擎编译原理"],"tags":["v8引擎","底层原理"]},{"title":"webWorker","url":"/2024/01/11/webworker/","content":"<p>#引言<br>首先我们知道JS中是没有并行,并发等概念的,这是因为JS是一门单线程的语言,其中的异步执行也是利用事件循环机制进行的,并不是严格意义上的异步.由于JS单线程的特性,使得JS在执行时如果遇到大量的任务就会使得过程运行缓慢.主渲染线程的延迟明显,使得用户体验较差.</p>\n<p>#web-worker<br>web-worker的作用就是用来缓解这一问题的</p>\n<p>利用web-worker,我们可以利用浏览器新开辟一个进程,将需要大量执行的过程在这个进程中执行,然后将结果返回给我们的主进程即可.</p>\n<p>#使用示例<br>#worker.html<br><!DOCTYPE html></p>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .p{\n      line-break: unset;\n    }\n  </style>\n  <a id=\"link\"></a>\n    <p class=\"p\">\n      <%= sjdfl =%>\n    </p>\n</head>\n<body>\n  <script>\n    const \\u4e2d\\u6587 = '这是转义之后的字符';\n// 使用webworker,分担主线程的压力\n// const worker = new Worker()\n//创建一个worker\nconst worker = new Worker('./worker.js')\n    console.log(worker);\nworker.postMessage('sdfj');\nworker.postMessage({method:'echo',argus:[1,2,3,4]})\n//主线程关闭worker\nsetTimeout(()=>{\nworker.terminate()\n// worker.postMessage('close')\n},1000)\nworker.addEventListener('message',(e)=>{\n  console.log(e.data);\n})\n/**\n * 主线程监听worker错误\n */\nworker.onerror=(e)=>{\n  worker.terminate()\n  console.error('worker错误');\n}\n/**\n * 直接转移数据的控制权\n */\n// 创建4字节的缓冲区\nlet abfer = new ArrayBuffer(4);\n// 创建32位整数数组作为视图，引用缓冲区\nlet tes = new Int32Array(abfer);\nconsole.log(tes,'ArrayBuffer');\nworker.postMessage(abfer,[abfer]); //转交控制权，主线程不再存储\n/**\n * 模拟文件下载功能\n */\nconst blob = new Blob(['文件下载']);\nconst link = document.getElementById('link');\nlink.href = window.URL.createObjectURL(blob);;\nlink.download = '测试文件.txt';\nsetTimeout(()=>{\n  // link.click();\n},2000)\n/**\n * 创建worker线程加载js文件\n * ！！必须指定script标签的type为浏览器不知道的类型\n */\n// const blob1 = new Blob(document.getElementById('scriptDom').textContent);\n// const url1 = new window.URL.createObjectURL(blob1);\n// const worker2 = new Worker(url1);\n/**\n * 使用worker线程，完成轮询\n */\n//创建worker\nfunction createWorker(f){\n  const fnBlob = new Blob(['('+f.toString()+')()'])\n  const fnUrl = window.URL.createObjectURL(fnBlob);\n  return new Worker(fnUrl);\n}\nconst fnWorker = createWorker((e)=>{\n  let cache;\n  // setInterval(()=>{\n    fetch('/data').then(res=>{\n      if(cache != res){\n        console.log('变化了');\n      }\n    })\n  // },1000)\n});\n  </script>\n<script id=\"scriptDom\" type=\"app/worker\">\n  console.log('我是被woeker加载的文件');\n</script>\n</body>\n</html>\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .p{\n      line-break: unset;\n    }\n  </style>\n  <a id=\"link\"></a>\n    <p class=\"p\">\n      <%= sjdfl =%>\n    </p>\n</head>\n<body>\n  <script>\n    const \\u4e2d\\u6587 = '这是转义之后的字符';\n// 使用webworker,分担主线程的压力\n// const worker = new Worker()\n//创建一个worker\nconst worker = new Worker('./worker.js')\n    console.log(worker);\nworker.postMessage('sdfj');\nworker.postMessage({method:'echo',argus:[1,2,3,4]})\n//主线程关闭worker\nsetTimeout(()=>{\nworker.terminate()\n// worker.postMessage('close')\n},1000)\nworker.addEventListener('message',(e)=>{\n  console.log(e.data);\n})\n/**\n * 主线程监听worker错误\n */\nworker.onerror=(e)=>{\n  worker.terminate()\n  console.error('worker错误');\n}\n/**\n * 直接转移数据的控制权\n */\n// 创建4字节的缓冲区\nlet abfer = new ArrayBuffer(4);\n// 创建32位整数数组作为视图，引用缓冲区\nlet tes = new Int32Array(abfer);\nconsole.log(tes,'ArrayBuffer');\nworker.postMessage(abfer,[abfer]); //转交控制权，主线程不再存储\n/**\n * 模拟文件下载功能\n */\nconst blob = new Blob(['文件下载']);\nconst link = document.getElementById('link');\nlink.href = window.URL.createObjectURL(blob);;\nlink.download = '测试文件.txt';\nsetTimeout(()=>{\n  // link.click();\n},2000)\n/**\n * 创建worker线程加载js文件\n * ！！必须指定script标签的type为浏览器不知道的类型\n */\n// const blob1 = new Blob(document.getElementById('scriptDom').textContent);\n// const url1 = new window.URL.createObjectURL(blob1);\n// const worker2 = new Worker(url1);\n/**\n * 使用worker线程，完成轮询\n */\n//创建worker\nfunction createWorker(f){\n  const fnBlob = new Blob(['('+f.toString()+')()'])\n  const fnUrl = window.URL.createObjectURL(fnBlob);\n  return new Worker(fnUrl);\n}\nconst fnWorker = createWorker((e)=>{\n  let cache;\n  // setInterval(()=>{\n    fetch('/data').then(res=>{\n      if(cache != res){\n        console.log('变化了');\n      }\n    })\n  // },1000)\n});\n  </script>\n<script id=\"scriptDom\" type=\"app/worker\">\n  console.log('我是被woeker加载的文件');\n</script>\n</body>\n</html>\n```\n\n<p>#worker.js</p>\n<pre><code class=\"javascript\">//接受数据\nconsole.log(self);\nself.addEventListener(&#39;message&#39;,(e)=&gt;&#123;\n    console.log(e.data);\n    self.postMessage(&#39;我接受到了你的消息&#39;)\n    if(e.data === &#39;close&#39;)&#123;\n        self.postMessage(&#39;听你的我关闭&#39;);\n        self.close();\n    &#125;\n&#125;,false)\n// self.addEventListener(&#39;close&#39;,(e)=&gt;&#123;\n//     console.log(&#39;关闭&#39;);\n// &#125;)\n/**\n * worker内部加载脚本\n * 只能加载，不能获取其中内容\n */\nimportScripts(&#39;./main.js&#39;);\n</code></pre>\n<p>#serviceWorker.js</p>\n<pre><code class=\"javascript\">//serviceWorker是基于事件驱动的。\n//serviceWorker安装事件\nself.addEventListener(&#39;install&#39;,event=&gt;&#123;\n    console.log(event,&#39;安装事件&#39;);\n    event.waitUntil(()=&gt;&#123;\n        console.info(&#39;安装完成&#39;);\n    &#125;)\n&#125;)\n//serviceWorker激活事件（当安装完成之后就开始激活）\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    let cacheWhiteList = [&#39;product-v2&#39;];\n    event.waitUntil(\n        caches.keys().then(cacheNames=&gt;&#123;\n            return Promise.all(\n                cacheNames.map(cacheName=&gt;&#123;\n                    if(cacheWhiteList.indexOf(cacheName) === -1)&#123;\n                        return caches.delete(cacheName);\n                    &#125;\n                &#125;)\n            )\n        &#125;)\n    )\n&#125;)\n//serviceWorker与网页的通信\nself.addEventListener(&#39;active&#39;,(event)=&gt;&#123;\n    event.waitUntil(\n        self.clients.matchAll().then((client)=&gt;&#123;\n            client.postMessage(&#123;\n                msg:&quot;Hello serviceWorker&quot;,\n                source:&quot;serviceWorker&quot;\n            &#125;)\n        &#125;)\n    )\n&#125;)\n</code></pre>\n","categories":["JS"],"tags":["JS","webWorker"]},{"title":"vue源码解读","url":"/2023/11/02/vue%E5%8E%9F%E7%90%86/","content":"<h1 id=\"vue-解析\"><a href=\"#vue-解析\" class=\"headerlink\" title=\"vue 解析\"></a>vue 解析</h1><h1 id=\"一、响应式系统：\"><a href=\"#一、响应式系统：\" class=\"headerlink\" title=\"一、响应式系统：\"></a>一、响应式系统：</h1><ul>\n<li>响应式的目的就是为了解决计算机语言的程序性</li>\n<li>vue2 采用<code>Object.defineProperty</code>的方式来代理对象的属性，但是这个 api 有个问题就是需要先显式地去声明这个对象的属性（属性需要先写出来），就导致向对象添加属性或删除属性时兼管不到。</li>\n<li>vue3 中通过<code>Proxy</code>来代理整个对象，就解决了这个问题，但由于我们操作的都是返回的代理对象，并且在调用时打点调用（上下文是代理对象，监听不到源对象的 get 和 set），所以需要使用<code>reflect</code>方法指定执行上下文。</li>\n<li>代理到源对象的 get 和 set 方法后，就将当前的响应性表（也可以看成是桶，结构是 weakMap(对象名，map(属性名，set 副作用集合))），源对象执行 get 方法时，会收集当前副作用函数，存储到表中，执行 set 方法时，会将表中对应的副作用函数拿出来遍历执行。</li>\n</ul>\n<h2 id=\"reactivity-模块\"><a href=\"#reactivity-模块\" class=\"headerlink\" title=\"reactivity 模块\"></a>reactivity 模块</h2><p><img data-src=\"/images/Snipaste_2024-05-31_14-44-09.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"reactive：\"><a href=\"#reactive：\" class=\"headerlink\" title=\"reactive：\"></a>reactive：</h2><p>创建代理对象（用于收集依赖）</p>\n<p><img data-src=\"/images/vue1.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><strong>需要注意的是：当使用代理对象的 this 时，其 this 指向普通对象，导致的结果就是后续使用代理对象收集不到使用 this 指定的函数，解决方法是通过 Reflect 反射。</strong></p>\n<p>此时，就创建了代理对象，并将普通对象和代理对象存在 map 中，此时可以通过 Proxy 代理的拦截器收集依赖，但是视图中的赋值并不是响应性的（需要执行依赖）。</p>\n<h2 id=\"effect：\"><a href=\"#effect：\" class=\"headerlink\" title=\"effect：\"></a>effect：</h2><p><strong>副作用函数，用于触发依赖，更新视图</strong></p>\n<p>首先通过 reactiveEffect 类创建副作用实例：通过实例的 run 方法可以执行里面的函数</p>\n<p><img data-src=\"/images/vue2.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>通过 track 函数收集依赖。<strong>（在 Proxy 对象的 getter 中执行）</strong></p>\n<p><img data-src=\"/images/vue3.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>通过 trigger 函数触发依赖 <strong>（在 Proxy 对象的 setter 中执行）</strong></p>\n<p><img data-src=\"/images/vue4.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"ref-函数：\"><a href=\"#ref-函数：\" class=\"headerlink\" title=\"ref 函数：\"></a>ref 函数：</h2><p><img data-src=\"/images/vue5.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"computed-函数：\"><a href=\"#computed-函数：\" class=\"headerlink\" title=\"computed 函数：\"></a>computed 函数：</h2><p><img data-src=\"/images/vue7.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"scheduler-调度器：\"><a href=\"#scheduler-调度器：\" class=\"headerlink\" title=\"scheduler 调度器：\"></a>scheduler 调度器：</h2><p><img data-src=\"/images/vue8.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"watch-函数：\"><a href=\"#watch-函数：\" class=\"headerlink\" title=\"watch 函数：\"></a>watch 函数：</h2><p><img data-src=\"/images/vue9.png\" alt=\"/images/image-20240123164938769\"></p>\n<h1 id=\"二、运行时-runtime：\"><a href=\"#二、运行时-runtime：\" class=\"headerlink\" title=\"二、运行时 runtime：\"></a>二、运行时 runtime：</h1><h2 id=\"runtime-模块\"><a href=\"#runtime-模块\" class=\"headerlink\" title=\"runtime 模块\"></a>runtime 模块</h2><p><img data-src=\"/images/Snipaste_2024-06-02_15-17-35.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"createVNode-函数：\"><a href=\"#createVNode-函数：\" class=\"headerlink\" title=\"createVNode 函数：\"></a>createVNode 函数：</h2><p><img data-src=\"/images/vue10.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"h-函数：\"><a href=\"#h-函数：\" class=\"headerlink\" title=\"h 函数：\"></a>h 函数：</h2><p><img data-src=\"/images/vue11.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"nodeOps-对象：\"><a href=\"#nodeOps-对象：\" class=\"headerlink\" title=\"nodeOps 对象：\"></a>nodeOps 对象：</h2><p>封装 dom 元素操作</p>\n<p><img data-src=\"/images/vue13.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"patchProp-函数：\"><a href=\"#patchProp-函数：\" class=\"headerlink\" title=\"patchProp 函数：\"></a>patchProp 函数：</h2><p>根据元素类型（class 属性，style 属性，事件，dom Properties 和其他属性），进行不同的 patch 打补丁操作</p>\n<p><img data-src=\"/images/vue14.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"render-函数：\"><a href=\"#render-函数：\" class=\"headerlink\" title=\"render 函数：\"></a>render 函数：</h2><p><img data-src=\"/images/vue12.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"组件渲染：\"><a href=\"#组件渲染：\" class=\"headerlink\" title=\"组件渲染：\"></a>组件渲染：</h2><p><img data-src=\"/images/vue16.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"patch-函数（diff-算法）：\"><a href=\"#patch-函数（diff-算法）：\" class=\"headerlink\" title=\"patch 函数（diff 算法）：\"></a>patch 函数（diff 算法）：</h2><p><img data-src=\"/images/vue15.png\" alt=\"/images/image-20240123164938769\"></p>\n<h1 id=\"三、编译时-compile：\"><a href=\"#三、编译时-compile：\" class=\"headerlink\" title=\"三、编译时 compile：\"></a>三、编译时 compile：</h1><p>将 template 模板转为 render 函数。这个过程中共经历了三大步骤：1、解析（解析 template 模板，生成 AST 抽象语法树）；2、转化（转化 AST，生成 JavaScript AST）；3、生成（生成 render 函数）</p>\n<h2 id=\"compile-模块\"><a href=\"#compile-模块\" class=\"headerlink\" title=\"compile 模块\"></a>compile 模块</h2><p><img data-src=\"/images/Snipaste_2024-06-02_11-30-05.png\" alt=\"image\"></p>\n<h2 id=\"baseParse-函数：\"><a href=\"#baseParse-函数：\" class=\"headerlink\" title=\"baseParse 函数：\"></a>baseParse 函数：</h2><p>baseParse 函数<strong>根据 template 模板</strong>，通过有限自动状态机的概念解析得到<strong>tokens</strong>，然后通过扫描 tokens 最终得到<strong>AST</strong>（抽象语法树）。</p>\n<h2 id=\"transform-函数\"><a href=\"#transform-函数\" class=\"headerlink\" title=\"transform 函数:\"></a>transform 函数:</h2><p>transform 函数将<strong>抽象语法树 AST</strong>转化为<strong>JavaScript AST</strong>（抽象语法树）。</p>\n<h2 id=\"generate-函数：\"><a href=\"#generate-函数：\" class=\"headerlink\" title=\"generate 函数：\"></a>generate 函数：</h2><p>根据<strong>JavaScript AST</strong>（抽象语法树）<strong>生成 render 函数</strong>。(render 函数的本质是字符串，字符串的换行和空格需要进行处理)。</p>\n<h2 id=\"compile-函数：\"><a href=\"#compile-函数：\" class=\"headerlink\" title=\"compile 函数：\"></a>compile 函数：</h2><p>根据<strong>字符串 render 函数</strong>通过<strong>new Function(render)()</strong> 方法创建出 renderFn 函数（这里不用 eval 函数的原因是出于安全性考虑），改名为 compile 函数。</p>\n<h2 id=\"parseInterpolation-函数：\"><a href=\"#parseInterpolation-函数：\" class=\"headerlink\" title=\"parseInterpolation 函数：\"></a>parseInterpolation 函数：</h2><h6 id=\"（处理插值表达式）\"><a href=\"#（处理插值表达式）\" class=\"headerlink\" title=\"（处理插值表达式）\"></a>（处理插值表达式）</h6><p>找到 }} 的索引位置，拿到双大括号内部的字符串，通过 trim 方法去除空格拿 到变量，通过 with 语法改变作用域，bind 语法绑定 this 指向从而使用这个变量。</p>\n<h2 id=\"parseAttributes-函数：\"><a href=\"#parseAttributes-函数：\" class=\"headerlink\" title=\"parseAttributes 函数：\"></a>parseAttributes 函数：</h2><h6 id=\"（处理-props-属性，v-指令等）\"><a href=\"#（处理-props-属性，v-指令等）\" class=\"headerlink\" title=\"（处理 props 属性，v-指令等）\"></a>（处理 props 属性，v-指令等）</h6><p>通过正则表达式判断是否是 Vue 指令，如果是指令，就返回指令对象，如果不是指令就返回普通属性的对象。然后通过 nameSet 函数拿到 props 属性。</p>\n<h2 id=\"createStructuralDirectiveTransform-函数：\"><a href=\"#createStructuralDirectiveTransform-函数：\" class=\"headerlink\" title=\"createStructuralDirectiveTransform 函数：\"></a>createStructuralDirectiveTransform 函数：</h2><p><strong>（统一处理指令）</strong></p>\n<h2 id=\"transform-指令系列函数：\"><a href=\"#transform-指令系列函数：\" class=\"headerlink\" title=\"transform 指令系列函数：\"></a>transform 指令系列函数：</h2><p><strong>transformIf(v-if)</strong></p>\n<p>AST 中添加对应属性，JavascriptAST 中相应变动，在生成 render 函数时，通过 v-if 绑定的变量名，在 render 字符串中添加上三元表达式。</p>\n<h1 id=\"四、运行时-编译时合并\"><a href=\"#四、运行时-编译时合并\" class=\"headerlink\" title=\"四、运行时+编译时合并\"></a>四、运行时+编译时合并</h1><p>此时只能导入模块中的函数进行使用，尚未处理合并的逻辑：</p>\n<h2 id=\"1、render-渲染\"><a href=\"#1、render-渲染\" class=\"headerlink\" title=\"1、render 渲染\"></a>1、render 渲染</h2><pre><code class=\"javascript\">&lt;script setup&gt;\nconst &#123; createApp,h &#125; = Vue;\nconst App = &#123;\n    render()&#123;\n        return h(&#39;div&#39;,&#39;hello world&#39;);\n    &#125;\n&#125;\nconst app = createApp(App);\napp.mount(&#39;#app&#39;);\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"createApp-函数：\"><a href=\"#createApp-函数：\" class=\"headerlink\" title=\"createApp 函数：\"></a>createApp 函数：</h2><p>createApp 函数调用 createAppAPI 函数，传入 render 函数拿到结果</p>\n<h2 id=\"createAppAPI-函数\"><a href=\"#createAppAPI-函数\" class=\"headerlink\" title=\"createAppAPI 函数\"></a>createAppAPI 函数</h2><p>接受 render 函数，返回 createApp 函数，createApp 函数拿到 rootComponent 和 rootProps 作为参数，定义出 app 对象，声明出 component 属性、container 属性和 mount 方法，mount 方法拿 rootContainer 作为参数，通过 createVNode 函数，传入 rootComponent 和 rootProps 创建出 vnode 虚拟节点，然后调用 render 函数，传入 vnode 虚拟节点和 rootContainer 进行执行。最后返回这个 app 对象</p>\n<h2 id=\"mount-函数：\"><a href=\"#mount-函数：\" class=\"headerlink\" title=\"mount 函数：\"></a>mount 函数：</h2><p>为了兼容不同的平台（宿主环境），需要去进行不同的处理：</p>\n<p>mount 函数接受参数（选择器字符串或者 dom 元素），通过 nromalizeContainer 函数获取到 dom 元素。mount 方法将 dom 元素作为 rootContainer，通过 createVNode 函数创建出 vnode 虚拟节点，然后调用 render 函数，传入 vnode 虚拟节点和 rootContainer 进行执行。</p>\n<h2 id=\"normalizeContainer-函数：\"><a href=\"#normalizeContainer-函数：\" class=\"headerlink\" title=\"normalizeContainer 函数：\"></a>normalizeContainer 函数：</h2><p>如果参数是选择器字符串，就通过 querySelector 选择出 dom 元素，并返回。</p>\n<h2 id=\"2、template-模板渲染\"><a href=\"#2、template-模板渲染\" class=\"headerlink\" title=\"2、template 模板渲染\"></a>2、template 模板渲染</h2><pre><code class=\"javascript\">&lt;script setup&gt;\nconst &#123; createApp,h &#125; = Vue;\nconst App = &#123;\n    template:`&lt;div&gt;hello world&lt;/div&gt;`\n&#125;\nconst app = createApp(App);\napp.mount(&#39;#app&#39;);\n&lt;/script&gt;\n</code></pre>\n<p>此时 app 中是 template 组件模板，而不是 render 函数，所以需要将模板变为 render 函数。</p>\n<p>在 finishComponentSetup 函数中进行判断：如果当前存在 compile 编译器，并且 component 中不存在 render 函数，就利用 compile 函数生成 render 函数，赋值到 component 组件实例中去，最后赋值给：instance 的 render。</p>\n<h1 id=\"Vue3-更新优化\"><a href=\"#Vue3-更新优化\" class=\"headerlink\" title=\"Vue3 更新优化\"></a>Vue3 更新优化</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjU0MDkyOTU0NDMxNjY4Mjg0\">https://juejin.cn/post/7254092954431668284</span></p>\n<h2 id=\"1、静态提升\"><a href=\"#1、静态提升\" class=\"headerlink\" title=\"1、静态提升\"></a>1、静态提升</h2><p>Vue3 在处理 template 模板时会对静态模板进行标识。将 ：<strong>静态的模板</strong>（不存在变化的模板）提<strong>升并进行缓存</strong>、静态的<strong>类等样式进行缓存</strong>。</p>\n<p>静态提升有利于代码的复用，减少不必要的 DOM 操作和比对（因为它们不会变化）。</p>\n<h2 id=\"2、预字符串化\"><a href=\"#2、预字符串化\" class=\"headerlink\" title=\"2、预字符串化\"></a>2、预字符串化</h2><p>将<strong>不会变化的静态模板字符串缓存保留为 render 函数字符串的形式</strong></p>\n<p>预字符串化跳过了编译时，能有效减少运行时的计算和处理，提高性能。</p>\n<h2 id=\"3、缓存事件处理函数\"><a href=\"#3、缓存事件处理函数\" class=\"headerlink\" title=\"3、缓存事件处理函数\"></a>3、缓存事件处理函数</h2><p>Vue3 会将<strong>事件处理函数在编译阶段缓存起来</strong>，以便在组件整个生命周期中重复使用，避免了重复创建的开销。</p>\n<p>缓存事件处理函数使得事件处理这种固定内容的函数不会被重复创建，减少了内存分配和垃圾回收机制的压力。</p>\n<h2 id=\"4、Block-Tree\"><a href=\"#4、Block-Tree\" class=\"headerlink\" title=\"4、Block Tree\"></a>4、Block Tree</h2><p>Vue3 中的 Block Tree 会将<strong>条件渲染 v-if</strong>和<strong>循环渲染 v-for</strong>的内容封装为一个单独的 Block，从而避免大量的 VNode 节点创建和销毁。</p>\n<p>Block Tree 使得 Vue3 在编译之后的模板会被拆分成多个块，每个块对应一个节点或一组节点，这些块可以被独立地更新和渲染，从而避免不必要的渲染操作。</p>\n<h2 id=\"5、树结构打平\"><a href=\"#5、树结构打平\" class=\"headerlink\" title=\"5、树结构打平\"></a>5、树结构打平</h2><blockquote>\n<p>vue3中每一块都会追踪其所有带更新类型标记的后代节点,动态内容表示会更新,静态内容表示不会更新,当虚拟DOM树需要进行更新时,就会将当前虚拟DOM分块打平为一个数组,数组中仅包含动态的节点而会跳过静态节点的比对,从而提升效率</p>\n</blockquote>\n<h2 id=\"6-、patchFlag\"><a href=\"#6-、patchFlag\" class=\"headerlink\" title=\"6 、patchFlag\"></a>6 、patchFlag</h2><p>Vue3 中引入了 PatchFlag 地概念，会<strong>标记 VNode 中哪些部分在后续可能会发生变化</strong>，从而实现<strong>只对变化的部分进行比较和更新</strong>。</p>\n<p><strong>patchFlag 可选值有：</strong></p>\n<ul>\n<li><code>0</code> 或 <code>1</code>：静态节点，没有动态特性。</li>\n<li><code>2</code>：元素有动态绑定的类。</li>\n<li><code>4</code>：元素有动态绑定的样式。</li>\n<li><code>8</code>：元素有动态绑定的属性。</li>\n<li><code>16</code>：元素有动态绑定的事件监听器。</li>\n<li><code>32</code>：元素有动态绑定的文本插值。</li>\n</ul>\n","categories":["vue"],"tags":["源码","vue"]},{"title":"whistle抓包","url":"/2024/05/17/whistle%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"whistle简单使用\"><a href=\"#whistle简单使用\" class=\"headerlink\" title=\"whistle简单使用\"></a>whistle简单使用</h1><h3 id=\"whistle安装启动\"><a href=\"#whistle安装启动\" class=\"headerlink\" title=\"whistle安装启动\"></a>whistle安装启动</h3><p>安装：npm i -g whistle</p>\n<p>使用：w2 start</p>\n<p>访问：访问对应的页面</p>\n<p>作用：</p>\n<ul>\n<li>任何的链接都会经过工具转发一下，并记录下来</li>\n<li>使用前需要配置代理到whistle服务的地址和端口上（设置代理如下）</li>\n</ul>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>设置代理：</p>\n<ul>\n<li>手机端省略</li>\n<li>电脑端：<ul>\n<li>网络偏好设置—高级—代理—网页代理、安全网页代理</li>\n<li>配置代理的ip地址和端口号（8899）</li>\n</ul>\n</li>\n</ul>\n<p>确认证书：</p>\n<p>一般会自动下载，也可以打开8899端口找到证书下载并确认信任</p>\n<p><strong>查看抓包情况和设置代理转发：</strong></p>\n<p>打开127.0.0.1:8899端口进行设置</p>\n<h1 id=\"whistle高级\"><a href=\"#whistle高级\" class=\"headerlink\" title=\"whistle高级\"></a>whistle高级</h1><h3 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a>mock数据</h3><p>设置线上地址转发到本地json文件（使用file路径），模拟请求数据。</p>\n<h3 id=\"部分文件请求转发（重要）\"><a href=\"#部分文件请求转发（重要）\" class=\"headerlink\" title=\"部分文件请求转发（重要）\"></a>部分文件请求转发（重要）</h3><p>例如线上环境有某个文件报错，生产环境无法复现，可以将该文件地址转发到本地的js文件（使用file路径），方便进行调试，提高调试效率。</p>\n<h3 id=\"请求转发\"><a href=\"#请求转发\" class=\"headerlink\" title=\"请求转发\"></a>请求转发</h3><p>可以作为跨域的一种方案，将本地的请求转发到线上的路径，这样就不会发生跨域问题</p>\n<h3 id=\"注入html、css和-js\"><a href=\"#注入html、css和-js\" class=\"headerlink\" title=\"注入html、css和 js\"></a>注入html、css和 js</h3><p>whistle会自动根据响应内容的类型，判断是否注入相应的文本以及如何注入（是否用标签包裹）</p>\n<p>例如：</p>\n<pre><code class=\"yaml\">https://www.baidu.com  css:///Users/dmq/Desktop/test.css\n</code></pre>\n<p>这将会在百度的官网注入自定义的css样式。</p>\n<h6 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a>举例：</h6><p>向百度网站注入vconsole.js源码，方便调试打印日志。</p>\n<ol>\n<li><p>下载vconsole到本地或者直接复制源码到whistle中的values中</p>\n</li>\n<li><p>本地js文件创建VConsole实例，或者直接在whistle的values中创建js文件，文件中创建vconsole实例。</p>\n</li>\n<li><p>在rules中向百度网站注入两个js文件（以whistle中配置values为示例）</p>\n<pre><code class=\"yaml\">www.baidu.com  jsPrepend://&#123;vConsole.min.js&#125;  #引入源码\nwww.baidu.com  jsPrepend://&#123;vconsole.js&#125;  #引入实例化js\nwww.baidu.com  log://  #在whistle中也打印log\n</code></pre>\n</li>\n</ol>\n<h3 id=\"同步抓包日志\"><a href=\"#同步抓包日志\" class=\"headerlink\" title=\"同步抓包日志\"></a>同步抓包日志</h3><p>在rules中配置网站的输出，可以将抓包的log日志同步到whistle中的log面板，配置例如：</p>\n<pre><code class=\"yaml\">www.baidu.com   log:// #同步日志\n</code></pre>\n<h3 id=\"解决跨域问题\"><a href=\"#解决跨域问题\" class=\"headerlink\" title=\"解决跨域问题\"></a>解决跨域问题</h3><p>可以单独设置网站允许跨域访问，例如在rules中配置：</p>\n<pre><code class=\"yaml\">https://localhost:5500/list   resCors://*  #表示该网站允许跨域访问\n</code></pre>\n<p>或者使用前端转发代理来处理跨域：</p>\n<pre><code class=\"yaml\">https://localhost:8080/list   https://localhost:5500/list  \n#将请求的网址代理到同域名同端口的网址，就不会发生跨域。\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTc3NjU1L2FydGljbGUvZGV0YWlscy8xMTkyODMwMjg=\">本文学习自b站，原文档地址</span></p>\n","categories":["whistle"],"tags":["whistle","抓包工具"]},{"title":"中前台解决方案","url":"/2023/02/12/%E4%B8%AD%E5%89%8D%E5%8F%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"<h1 id=\"中前台通用项目\"><a href=\"#中前台通用项目\" class=\"headerlink\" title=\"中前台通用项目\"></a>中前台通用项目</h1><h1 id=\"一、工具和包\"><a href=\"#一、工具和包\" class=\"headerlink\" title=\"一、工具和包\"></a>一、工具和包</h1><h2 id=\"vite\"><a href=\"#vite\" class=\"headerlink\" title=\"vite\"></a>vite</h2><p><strong>一、介绍</strong></p>\n<p>webpack进行构建时，默认只会抓取并构建整个应用，然后才能提供服务，项目构建时慢、且项目中任何错误都会影响到整个项目的构建，此外webpack是基于node.js的打包工具 (vue-cli基于webpack)，其中可以使用CommonJS的语法。而Vite是一个基于ES模块的构建工具，它不再依赖于CommonJS规范。</p>\n<p><code>**vite**</code> <strong>不会在一开始就构建你的整个项目</strong>，而是会将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码（项目代码）</strong> 两部分，对于 <strong>源码</strong> 部分，它会根据 <strong>路由来拆分</strong> 代码模块，只会去构建一开始就必须要构建的内容。</p>\n<p><code>vite</code> 以  <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9Nb2R1bGVz\">原生 ESM</span> 的方式为浏览器提供源码，让浏览器接管了 <strong>打包</strong> 的部分工作。</p>\n<p><strong>问题：</strong>早期版本不支持CommonJS的语法，导致依赖都无法使用</p>\n<p><strong>解决：</strong><code>vite</code> 在后期提供了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52aXRlanMuZGV2L2d1aWRlL2RlcC1wcmUtYnVuZGxpbmcuaHRtbA==\">依赖预构建</span> 的功能，其中一个非常重要的目的就是为了解决 <strong>CommonJS 和 UMD 兼容性</strong> 问题。目前 <code>vite</code> 会先将 <code>CommonJS 或 UMD 发布的依赖项转换为 ESM</code> 之后，再重新进行编译。这也可以理解为 <strong>速度对业务的一个妥协</strong>。</p>\n<p><strong>二、使用</strong></p>\n<p>1、vite中需要在vite.config.js中配置@符号表示根路径</p>\n<pre><code class=\"javascript\">//       在defineConfig中进行配置：\n // 软链接\n  resolve: &#123;\n    alias: &#123;\n      &#39;@&#39;: join(__dirname, &#39;/src&#39;)\n    &#125;\n  &#125;,\n</code></pre>\n<p>2、vite中通过import.meta获取到元信息，如环境变量的获取：<code>import.meta.env.VITE_BASE_API</code> ，批量导入函数：</p>\n<p><code>import.meta.globEager(&#39;./modules/*.js&#39;)</code></p>\n<p>3、vite-plugin-svg-icons插件中使用createSvgIconsPlugin进行批量注册文件夹中的svg图标 （在vite.config.js中配置plugins）</p>\n<pre><code class=\"javascript\"> plugins: [\n    vue(),\n    createSvgIconsPlugin(&#123;\n      // 指定需要缓存的图标文件夹\n      iconDirs: [path.resolve(process.cwd(), &#39;src/assets/icons&#39;)],\n      // 指定symbolId格式\n      symbolId: &#39;icon-[name]&#39;\n    &#125;)\n  ],\n</code></pre>\n<p>4.代理服务器 （在vite.config.js中的defineConfig中配置：）</p>\n<pre><code class=\"javascript\">server: &#123;\n    proxy: &#123;\n      // 代理所有 /api 的请求，该求情将被代理到 target 中\n      &#39;/api&#39;: &#123;\n        // 代理请求之后的请求地址\n        target: &#39;https://api.imooc-front.lgdsunday.club/&#39;,\n        // target: &#39;http://127.0.0.1:3005/&#39;,\n        // 跨域\n        changeOrigin: true\n      &#125;\n    &#125;\n  &#125;\n</code></pre>\n<p>5、环境配置文件<code>.env.development</code> 开发环境文件和<code>.env.production</code> 生产环境文件 等</p>\n<p>作用：区分不同环境下的变量，比如开发环境下需要使用任意修改的假数据，但是生产环境下需要使用真实数据</p>\n<p>使用：只有以<code>VITE_</code> 为前缀的变量，才会暴露给vite进行处理，使用时使用<code>import.meta.env.变量名</code></p>\n<h2 id=\"tailwindcss\"><a href=\"#tailwindcss\" class=\"headerlink\" title=\"tailwindcss\"></a>tailwindcss</h2><p><strong>一、优势：</strong></p>\n<p>如果期望在整个项目中进行统一的划分，这样的一套变量通过css来实现，就不得不维护一个庞大的变量组，除此之外还有很多其他的问题，此时tailwindcss的优势就体现出来了</p>\n<p><strong>二、简介：</strong></p>\n<p>tailwindcss提供了很多类名，每一个类名对应一个具体的css内容，设计理念为：<strong>原子化css</strong>，css设计粒度上有4中形式，<strong>颗粒度自上而下逐渐增大，颗粒度越大则约束行越高，可定制性越弱</strong></p>\n<p>css设计粒度的四种形式：</p>\n<p>①<strong>行内样式</strong>：样式全部写入行内，自由度最高，可定制化最强，但是不方便复用。</p>\n<p>②<strong>原子化css</strong>：每一个类名代表一个css属性，自由度很强，可定义化很高，也方便复用，但是大量样式会导致大量的类名</p>\n<p>③<strong>传统形式</strong>：通过一些class来描述一段css属性，封装性强，语义化强，自由度和可定制化性一般</p>\n<p>④<strong>组件形式</strong>：封装性强，语义化强，但是自由度和可定制化性较差</p>\n<p>注意点：tailwindcss的构建顺序为移动优先，项目中构建尽量和tailwind设计保持一致。</p>\n<p><strong>三、使用：</strong></p>\n<p>①直接使用类名，注意可以指定<strong>不同屏幕尺寸</strong>和<strong>不同主题</strong>下对应的样式。</p>\n<p>②还可以自己配置特殊的样式（在tailwind.config.js中进行配置）</p>\n<p>③tailwindcss生态下有很多可以使用的插件。例如如下配置：</p>\n<pre><code class=\"javascript\">module.exports = &#123;\n  // 手动切换暗模式\n  darkMode: &#39;class&#39;,\n  // Tailwind 应用范围\n  content: [&#39;./index.html&#39;, &#39;./src/**/*.&#123;vue,js&#125;&#39;],\n  theme: &#123;\n    extend: &#123;\n      height: &#123;\n        header: &#39;72px&#39;,\n        main: &#39;calc(100vh - 72px)&#39;\n      &#125;,\n      fontSize: &#123;\n        xs: [&#39;0.25rem&#39;, &#39;0.35rem&#39;],\n        sm: [&#39;0.35rem&#39;, &#39;0.45rem&#39;],\n        base: [&#39;0.42rem&#39;, &#39;0.52rem&#39;],\n        lg: [&#39;0.55rem&#39;, &#39;0.65rem&#39;],\n        xl: [&#39;0.65rem&#39;, &#39;0.75rem&#39;]\n      &#125;,\n      boxShadow: &#123;\n        &#39;l-white&#39;: &#39;-10px 0 10px white&#39;,\n        &#39;l-zinc&#39;: &#39;-10px 0 10px #18181b&#39;\n      &#125;,\n      colors: &#123;\n        main: &#39;#f44c58&#39;,\n        &#39;success-100&#39;: &#39;#F2F9EC&#39;,\n        &#39;warn-100&#39;: &#39;#FCF6ED&#39;,\n      &#125;,\n      backdropBlur: &#123;\n        &#39;4xl&#39;: &#39;240px&#39;\n      &#125;,\n      variants: &#123;\n        scrollbar: [&#39;dark&#39;]\n      &#125;\n    &#125;\n  &#125;,\n  // 注册下载的tailwind-scroll-bar工具包，使用全新的scroll-bar\n  plugins: [require(&#39;tailwind-scrollbar&#39;)]\n&#125;\n</code></pre>\n<p>④ tailwind进行主题替换</p>\n<p>tailwind中有一个dark mode的概念，在使用css时，加上dark前缀的表示暗黑模式下的样式。需要在tailwind.config.js中进行配置：darkMode : ‘ class ‘,</p>\n<p>然后监听主题的切换行为，保存到vuex中并进行持久化处理，然后根据vuex中保存的当前主题修改html元素中的class属性  。  ( dark 或者 light )</p>\n<p>⑤<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGFpbHdpbmQtc2Nyb2xsYmFy\">tailwind-scrollbar</span> tailwind中scrollbar组件</p>\n<h2 id=\"Prettier\"><a href=\"#Prettier\" class=\"headerlink\" title=\"Prettier\"></a>Prettier</h2><p>Prettier是一个代码格式插件，下载插件之后，在项目根目录中配置 .prettierrc文件即可使用。例如：</p>\n<pre><code class=\"javascript\">&#123;\n  // 代码结尾不加分号\n  &quot;semi&quot;: false,\n  // 优先单引号\n  &quot;singleQuote&quot;: true,\n  // 不添加尾随逗号\n  &quot;trailingComma&quot;: &quot;none&quot;\n&#125;\n</code></pre>\n<h2 id=\"vueuse\"><a href=\"#vueuse\" class=\"headerlink\" title=\"vueuse\"></a>vueuse</h2><p>一、<code>useScroll（）</code>方法，获得dom元素的<code>响应式</code>位置数据</p>\n<p>二、<code>useScrollLock（）</code>方法，将dom元素的滚动<code>上锁</code>（无法滚动）</p>\n<p>三<code>、useVModel（）</code>方法，更方便的使用v-model，获得的是响应式数据</p>\n<p>四、<code>useElementBounding（）</code>方法，获得响应式的元素的宽高属性</p>\n<p>五、<code>useFullscreen（）</code>方法，将dom元素全屏显示</p>\n<p>六、<code>useIntersectionObserver（）</code>方法，监视dom元素是否在视窗显示</p>\n<p>七、 <span class=\"exturl\" data-url=\"aHR0cHM6Ly92dWV1c2Uub3JnL3NoYXJlZC93YXRjaERlYm91bmNlZC8=\">watchDebounced</span> 防抖功能的监视属性，在监视属性的基础之上，第三个参数中配置debounce属性设置防抖的时长</p>\n<p>八、<span class=\"exturl\" data-url=\"aHR0cHM6Ly92dWV1c2Uub3JnL2NvcmUvdXNlRnVsbHNjcmVlbi8jdXNlZnVsbHNjcmVlbg==\">useFullScreen</span>，全屏方法</p>\n<h2 id=\"GSAP\"><a href=\"#GSAP\" class=\"headerlink\" title=\"GSAP\"></a>GSAP</h2><p>js动效库，官网地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nc2FwLmZyYW1lci53aWtpLw==\">https://gsap.framer.wiki/</span></p>\n<h2 id=\"vuex-persisterdstate\"><a href=\"#vuex-persisterdstate\" class=\"headerlink\" title=\"vuex-persisterdstate\"></a>vuex-persisterdstate</h2><p>自动进行vuex配置模块的持久化存储处理</p>\n<h2 id=\"file-saver\"><a href=\"#file-saver\" class=\"headerlink\" title=\"file-saver\"></a><strong>file-saver</strong></h2><p>小文件下载</p>\n<h2 id=\"streamsaver\"><a href=\"#streamsaver\" class=\"headerlink\" title=\"streamsaver\"></a>streamsaver</h2><p>大文件下载</p>\n<h2 id=\"driver-js\"><a href=\"#driver-js\" class=\"headerlink\" title=\"driver.js\"></a>driver.js</h2><p>功能引导</p>\n<h2 id=\"vee-validata\"><a href=\"#vee-validata\" class=\"headerlink\" title=\"vee-validata\"></a>vee-validata</h2><p>表单校验</p>\n<h2 id=\"md5\"><a href=\"#md5\" class=\"headerlink\" title=\"md5\"></a>md5</h2><p>用于密码加密</p>\n<h2 id=\"cropperjs\"><a href=\"#cropperjs\" class=\"headerlink\" title=\"cropperjs\"></a>cropperjs</h2><p>图片裁剪</p>\n<h2 id=\"dayjs\"><a href=\"#dayjs\" class=\"headerlink\" title=\"dayjs\"></a>dayjs</h2><p>日期工具</p>\n<h1 id=\"二、组件\"><a href=\"#二、组件\" class=\"headerlink\" title=\"二、组件\"></a>二、组件</h1><p><strong>1、vite通用组件自动化注册</strong></p>\n<p>① 使用vite中的<code>import.meta.glob（）</code>方法，得到文件路径名称和导入函数的对象</p>\n<pre><code class=\"javascript\">import &#123; defineAsyncComponent &#125; from &#39;vue&#39;\n\nexport default &#123;\n  install(app) &#123;\n    // 获取当前路径任意文件夹下的 index.vue 文件\n    const components = import.meta.glob(&#39;./*/index.vue&#39;)\n    // 遍历获取到的组件模块\n    for (const [key, value] of Object.entries(components)) &#123;\n      // 拼接组件注册的 name\n      const componentName = &#39;m-&#39; + key.replace(&#39;./&#39;, &#39;&#39;).split(&#39;/&#39;)[0]\n      // 通过 defineAsyncComponent 异步导入指定路径下的组件\n      app.component(componentName, defineAsyncComponent(value))\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>② 然后在main.js中引入实例，使用<code>app.use（）</code>一下即可。</p>\n<p>③ 此外，指令也可以进行自动化全局注册，但是由于<code>import.meta.glob()</code>方法是异步的（适合于组件注册），指令在进行导入时需要使用<code>import.meta.globEager()</code>同步导入方法。</p>\n<pre><code class=\"javascript\">/**\n * 全局指令注册\n */\nexport default &#123;\n  async install(app) &#123;\n    // https://cn.vitejs.dev/guide/features.html#glob-import\n    // import.meta.globEager 为同步导入\n    const directives = import.meta.globEager(&#39;./modules/*.js&#39;)\n    for (const [key, value] of Object.entries(directives)) &#123;\n      // 拼接组件注册的 name\n      const arr = key.split(&#39;/&#39;)\n      const directiveName = arr[arr.length - 1].replace(&#39;.js&#39;, &#39;&#39;)\n      // 完成注册\n      app.directive(directiveName, value.default)\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>2、svg-icon组件</strong>：</p>\n<p>动态绑定svg中use标签的xlink:href属性，svg中使用图标的方式：</p>\n<p>①直接写路径加名称：</p>\n<pre><code class=\"html\">&lt;svg&gt;\n  &lt;use xlink:href=&quot;./access/image.svg&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>②使用symbol标签，配合id属性</p>\n<pre><code class=\"html\">&lt;symbol id=&#39;name&#39;&gt;&lt;/symbol&gt;\n&lt;svg&gt;\n  &lt;use xlink:href=&quot;#name&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n</code></pre>\n<p>项目中使用了工具包<code>vite-plugin-svg-icons</code>，配置后直接生成了全部的symbol标签，id熟悉绑定了name , 直接使用即可，此外需要在main.js中导入</p>\n<pre><code class=\"javascript\">import &#39;virtual:svg-icons-register&#39; //导入svg-icons-register\n</code></pre>\n<p><strong>3、popup弹层组件</strong></p>\n<p><strong>4、button按钮通用组件</strong></p>\n<p>在button组件中绑定自己定义的icon组件，组件中绑定传过来的icon-name ,class 和iconColor等。组件需要使用时传入type标识按钮风格，size标识按钮大小，icon标识图标名称，iconColor标识图标颜色，iconClass表示图标的类名，isActiveAnim表示是否需要动画，loading标识加载状态。给按钮添加点击事件emits出去，如果loading为false就不触发事件</p>\n<p><strong>5、popover气泡卡片</strong></p>\n<p>设置两个插槽：具名插槽用于表示出发弹出层的视图，匿名插槽用于表示弹出层视图中展示的内容。同时希望可以控制弹层的位置</p>\n<p><strong>6、瀑布流组件</strong></p>\n<p><strong>7、长列表组件</strong></p>\n<p><strong>8、confirm确认组件</strong></p>\n<p>虚拟dom的概念就是通过js来描述dom元素，vnode虚拟节点就是告诉vue页面上需要渲染什么样式的节点。h函数就是用来创建vnode函数，h函数接收三个参数：要渲染的dom元素，attrs对象和子元素，render函数：可以根据vnode虚拟节点来渲染</p>\n<p><strong>9、trigger-menu移动端tab-bar</strong></p>\n<p><strong>10、倒计时count-down组件</strong></p>\n<h1 id=\"三、API\"><a href=\"#三、API\" class=\"headerlink\" title=\"三、API\"></a>三、API</h1><p>一、<code>window.navigator.userAgent</code>属性，拿到用户的设备信息</p>\n<p>二、<code>Element.getBoundingClientRect()</code>方法，获得dom元素的位置信息</p>\n<p>三、<code>window.matchMedia()</code>方法，接受一个媒体查询解析的字符串，返回一个MediaQueryLise对象，对象有<code>change</code>事件和<code>matches</code>属性（是否匹配成功），例如：</p>\n<pre><code class=\"javascript\">matchMedia = window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;)\nthemeClassName = matchMedia.matches ? &#39;dark&#39; : &#39;light&#39;\n</code></pre>\n<p>匹配系统窗口的scheme主题是否是dark模式。</p>\n<p>四、<code>window.getComputedStyle()</code> 方法返回DOM元素的css样式属性，包含位置等信息，第二个参数可以指定对应要获得的属性</p>\n<p>五、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0ludGVyc2VjdGlvbk9ic2VydmVy\">window.IntersectionObserver</span> 观察目标元素与祖先元素或顶级文档视口交叉状态</p>\n<p>六、<code>Element.requestFullscreen()</code>让指定元素全屏显示。<code>Document.exitFullscreen()</code>退出全屏。</p>\n<p>七、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0hpc3RvcnkvcHVzaFN0YXRl\">History.pushState()</span> 方法，改变url但是不会跳转页面 </p>\n<p>八、<code>URL.createObjectURL（）</code>方法，获得到对应的blob对象 ，可以将文件对象变成一个可以访问的文件对象链接</p>\n<p>九、<code>BroadcastChannel</code>广播通道，进行同源页面之间的通信（但是存在兼容性问题）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"四、vue3技巧\"><a href=\"#四、vue3技巧\" class=\"headerlink\" title=\"四、vue3技巧\"></a>四、vue3技巧</h1><p><strong>一、transition动画标签钩子函数</strong></p>\n<p>使用js进行自定义动画样式和触发时机.（before-enter、enter、leave等事件），只使用js设置动画时，可以给transition组件的css属性绑定为false</p>\n<p><strong>二、自定义指令实现图片懒加载</strong></p>\n<p>方案：监听所有图片<strong>是否可见</strong>（交互api），如果图片不可见，就不加载图片（设置src属性），如果图片可见就加载图片。</p>\n<p>注意细节是：①对于每一个img，当监视到在视口中出现过，就可以赋值属性src，然后就可以使用<code>stop（）</code>方法停止监视dom元素是否在视口显示 ②使用<code>import.meta.globEager（）</code>方法，可以同步导入所有的指令，然后一同注册</p>\n<p><strong>三、多组件共享数据的方式</strong></p>\n<p>①父传子（绑定数据，使用props接收）②子传父（自定义事件）③依赖注入Provide &#x2F; inject（ 适用于嵌套层级较深 ）④全局状态管理vuex或者pina</p>\n<p><strong>四、搜索框匹配内容高亮显示</strong></p>\n<p>使用字符串的replace（）方法，传入正则，将匹配的内容替换为高亮显示的内容（使用v-html进行渲染）</p>\n<p>五、<strong>h函数和render函数</strong></p>\n<p>①模板 VS  渲染函数：Vue模板会被预编译成虚拟DOM渲染函数，Vue也提供了API使我们可以不使用模板进行编译：直接手写渲染函数，渲染函数相比于模板更加灵活，而模板更加直观和方便。</p>\n<p>②h函数用于创建vnodes虚拟节点，第一个参数是dom类型（可以使用’div’等，也可以使用组件），第二个参数是props(包括组件中的属性和方法  ，或者dom的属性如style)，第三个参数是子元素。</p>\n<p>③render函数，第一个参数是要渲染的虚拟节点，第二个参数是要渲染的位置（传入dom元素）</p>\n<p><strong>六、状态驱动css</strong></p>\n<p>将响应式数据绑定到css之中：<code>v-bind(变量名称)</code></p>\n<p><strong>七、从部分组件到路由的跳转动画</strong></p>\n<p>①<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0hpc3RvcnkvcHVzaFN0YXRl\">History.pushState()</span> 方法改变url地址栏（注意要绑定对应的动态路由，不然一刷新就会空白）②设置过渡动画（可以使用GSAP）</p>\n<p><strong>八、router-view作用域插槽</strong></p>\n<p>使用<strong>router-view作用域插槽</strong>，配合<strong>transition中的自定义事件</strong>，加上<strong>keep-alive的include属性</strong>缓存动态数组中的组件，利用<strong>component组件的is属性</strong>动态绑定上router-virew的作用域插槽，实现移动端下路由切换时的动态效果</p>\n<h1 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"五、其他业务\"><a href=\"#五、其他业务\" class=\"headerlink\" title=\"五、其他业务\"></a>五、其他业务</h1><p><strong>一、人类行为验证</strong></p>\n<p>目前人类行为验证的实现方案，主要分为两种：</p>\n<ol>\n<li><p>收费平台，年费在几万到几十万不等，有专门的技术人员帮助对接： </p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20v\">极验</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kdW4uMTYzLmNvbS90cmlhbC9zZW5zZQ==\">网易易盾</span></p>\n</li>\n<li><p>…</p>\n</li>\n<li><p>免费开源，验证的精准度，需要看服务端的能力： </p>\n</li>\n<li><p><code>gitee</code> 开源的： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vTG9uZ2Jvd0VudGVycHJpc2UvU2xpZGVyQ2FwdGNoYT9fZnJvbT1naXRlZV9zZWFyY2g=\">SliderCaptcha</span></p>\n</li>\n</ol>\n<p><strong>二、头像裁剪与上传</strong></p>\n<p><strong>三、对象存储服务</strong></p>\n<p><strong>四、移动端页面过渡</strong></p>\n<p>维护一个虚拟任务栈的数组，当push操作时，将vuex中的routerType改为push ，back操作时，将routerType改为back。</p>\n<p><strong>五、虚拟任务栈缓存</strong></p>\n<p>使用keep-alive组件中的include属性进行设置，属性值中包含的组件会进行缓存，在使用路由进行跳转的时候，改变vuex中的routerType属性（PC端下永远为none），根据routerType的属性进行路由跳转时动画的设置。</p>\n<p><strong>六、第三方登录</strong></p>\n<p>  <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb25uZWN0LnFxLmNvbS8=\">QQ互联平台</span> </p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuLndlaXhpbi5xcS5jb20v\">微信开放平台</span> </p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9XZWJzaXRlX0FwcC9XZUNoYXRfTG9naW4vV2VjaGF0X0xvZ2luLmh0bWw=\">微信登录对接官方文档</span> </p>\n<p><strong>七、用户反馈</strong></p>\n<p> <span class=\"exturl\" data-url=\"aHR0cHM6Ly90eGMucXEuY29tLw==\">腾讯兔小巢</span> （url地址中改为product）</p>\n<p><strong>八、第三方分享</strong></p>\n<p>当前微信不支持不同网站的分享</p>\n<p> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuLndlaWJvLmNvbS9pbmRleC5waHAjX2xvZ2luTGF5ZXJfMTY0NjYzNzMwNzIzMg==\">新浪微博开发平台</span> </p>\n<p> <strong>九、第三方支付</strong></p>\n<p>微信支付不支持PC网站应用（迂回）</p>\n<p> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuLmFsaXBheS5jb20v\">支付宝开放平台</span>  </p>\n<p><strong>十、项目上线与发布</strong></p>\n","categories":["中前台解决方案"],"tags":["中前台解决方案"]},{"title":"函数重载","url":"/2024/05/08/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>函数重载是指在编程语言中允许定义多个同名函数，但是他们的参数类型、参数个数或者返回类型不同，编译器或解析器会根据调用时提供的参数类型和个数来确定使用哪个函数</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>函数重载的主要目的就是提高代码的可读性和灵活性，同时避免了为不同功能编写不同的函数名导致的变量命名冲突和混乱。</p>\n<h1 id=\"实现函数重载\"><a href=\"#实现函数重载\" class=\"headerlink\" title=\"实现函数重载\"></a>实现函数重载</h1><h2 id=\"ts\"><a href=\"#ts\" class=\"headerlink\" title=\"ts\"></a>ts</h2><p>ts中进行函数重载其实就是根据型参数组的个数和对变量进行typeof检测，然后根据不同的情况进行分支处理</p>\n<pre><code class=\"ts\">// 函数重载的声明\nfunction average(numbers: number[]): number; // 函数签名1：接受数字数组并返回数字\nfunction average(...numbers: number[]): number; // 函数签名2：接受可变数量的数字参数并返回数字\n// 函数实现\nfunction average(...args: any[]): number &#123; // 实际函数实现\n    let sum = 0;\n    if (args.length === 1 &amp;&amp; Array.isArray(args[0])) &#123; // 如果传入的是数组\n        const numbers = args[0] as number[]; // 类型断言为数字数组\n        for (const num of numbers) &#123;\n            sum += num;\n        &#125;\n        return sum / numbers.length;\n    &#125; else if (args.length &gt; 1) &#123; // 如果传入的是多个数字\n        for (const num of args) &#123;\n            sum += num;\n        &#125;\n        return sum / args.length;\n    &#125; else &#123;\n        throw new Error(&#39;Invalid arguments&#39;); // 抛出错误，不支持的参数类型\n    &#125;\n&#125;\n\n// 调用函数重载\nconsole.log(average([1, 2, 3, 4, 5])); // 输出: 3\nconsole.log(average(1, 2, 3, 4, 5)); // 输出: 3\n</code></pre>\n<h2 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h2><p>js中也可以通过typeof和形参数组进行函数重载，不过当然还有更好的做法，jQuery作者常用如下实现函数重载（进行重载之前要调用一次函数）：</p>\n<pre><code class=\"javascript\">function addMethod(object,name,fn)&#123;\n    const old = object[name];\n    object[name] = function (...args)&#123;\n        if(args.length === fn.length)&#123;\n            return fn.apply(this,args);\n        &#125;else if(typeof old === &#39;function&#39;)&#123;\n            return old.apply(this,args);\n        &#125;\n    &#125;\n&#125;;\nconst searcher = &#123;&#125;; //将对象中对应属性的重载方法全部存储起来\naddMethod(searcher,&#39;getUsers&#39;,()=&gt;&#123;\n    console.log(&#39;查询所有用户&#39;);\n&#125;);\naddMethod(searcher,&#39;getUsers&#39;,(name=&#39;a&#39;)=&gt;&#123; //注意默认参数的形参数量不与计数\n    console.log(&#39;按照姓名查询用户&#39;);\n&#125;);\n\nsearcher.getUsers();\n</code></pre>\n<p>另一种实现方法就是使用映射：</p>\n<pre><code class=\"javascript\">function createOverload()&#123;\n    const fnMap = new Map();\n    function overload(...args)&#123;\n        const key = args.map((it) =&gt; typeof it).join(&#39;,&#39;);\n        const fn = fnMap.get(key);\n        if(!fn)&#123;\n            throw new TypeError(&#39;没有找到对应的实现&#39;);\n        &#125;\n        return fn.apply(this,args);\n    &#125;\n    overload.addImpl = function(...args)&#123;\n        const fn = args.pop();\n        if(typeof fn !== &#39;function&#39;)&#123;\n            throw new TypeError(&#39;最后一个参数必须是函数&#39;)\n        &#125;\n        const key = args.join(&#39;,&#39;);\n        fnMap.set(key,fn);\n    &#125;;\n    return overload;\n&#125;\nconst getUsers = createOverload();\ngetUsers.addImpl(()=&gt;&#123;\n    console.log(&#39;查询所有用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;number&#39;,(page,size=10)=&gt;&#123;\n    console.log(&#39;按照页码和数量查询用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;number&#39;,&#39;number&#39;,(page,size=10)=&gt;&#123;\n    console.log(&#39;按照页码和数量查询用户&#39;);\n&#125;)\ngetUsers.addImpl(&#39;string&#39;,(name)=&gt;&#123;\n    console.log(&#39;按照姓名查询用户&#39;);\n&#125;);\ngetUsers.addImpl(&#39;string&#39;,&#39;string&#39;,()=&gt;&#123;\n    console.log(&#39;按照性别查询用户&#39;);\n&#125;);\ngetUsers(&#39;asfsdf&#39;);\n</code></pre>\n<p>总结一下实现思路，通过createOverload函数调用可以返回一个重载后的函数，createOverload函数中创建了一个map，map中将参数类型和个数与对应的函数相匹配，返回的重载函数在调用时会根据参数的类型去map中寻找对应的函数，通过apply绑定this作用域和参数执行即可。</p>\n","categories":["JS"],"tags":["JS,函数重载"]},{"title":"webpack笔记","url":"/2023/10/21/webpack/","content":"<h1 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a><a href=\"*https://babeljs.io/setup*\">babel</a></h1><h6 id=\"1执行编译的命令\"><a href=\"#1执行编译的命令\" class=\"headerlink\" title=\"1执行编译的命令\"></a>1执行编译的命令</h6><p>在package.json文件中添加执行babel的命令</p>\n<p>（在scripts中添加：”build”:”babel src -d dist”）</p>\n<ul>\n<li><code>babel src --out-dir dist*</code></li>\n</ul>\n<h6 id=\"2-Babel的配置文件\"><a href=\"#2-Babel的配置文件\" class=\"headerlink\" title=\"2.Babel的配置文件\"></a>2.Babel的配置文件</h6><ul>\n<li><p>安装配置文件  <code>npm install @babel/preset-env@7.11.0--save-dev</code></p>\n</li>\n<li><p>创建配置文件.babelrc,并配置</p>\n</li>\n</ul>\n<p><code>&#123;</code></p>\n<p><code>&quot;presets&quot;:[&quot;@babel/preset-env&quot;]*</code></p>\n<p><code>&#125;</code></p>\n<h6 id=\"3-npm-run-build进行打包\"><a href=\"#3-npm-run-build进行打包\" class=\"headerlink\" title=\"3 .npm run build进行打包\"></a>3 .npm run build进行打包</h6><h1 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h1><h2 id=\"【1】-webpack是什么\"><a href=\"#【1】-webpack是什么\" class=\"headerlink\" title=\"【1】 webpack是什么\"></a>【1】 webpack是什么</h2><p><code>const &#123; webpack &#125; = require(&quot;webpack&quot;)</code></p>\n<p><em>webpack是静态模块打包器，当webpack处理应用程序时，会将所有这些模块打包成一个或多个文件</em></p>\n<p>处理  js  css  图片  图标字体  静态文件</p>\n<h2 id=\"【2】使用webpack\"><a href=\"#【2】使用webpack\" class=\"headerlink\" title=\"【2】使用webpack\"></a>【2】使用webpack</h2><p>1  初始化项目   <code>npm init</code></p>\n<p>2  安装webpack 需要的包</p>\n<p><code>npm install --save-dev webpack-cli@3.3.12 webpack@4.44.1</code></p>\n<p>3  配置webpack (创建webpack.config.js)</p>\n<p>创建配置信息(官网查找)</p>\n<p>4  package.json的script中配置webpack命令</p>\n<p> <code>&quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;</code></p>\n<p>5  npm run webpack</p>\n<h2 id=\"【3】output-和-entry-webpack-config-js中配置\"><a href=\"#【3】output-和-entry-webpack-config-js中配置\" class=\"headerlink\" title=\"【3】output 和 entry(webpack.config.js中配置)\"></a>【3】output 和 entry(webpack.config.js中配置)</h2><p>1  entry指定入口文件</p>\n<p>entry中配置多个入口文件 :</p>\n<p> <code>entry: &#123;</code></p>\n<p> <code>main: &#39;./src/index.js&#39;</code>,</p>\n<p> <code>search: &#39;./src/search.js</code></p>\n<p> <code>&#125;</code></p>\n<p>2  output中配置多个出口文件</p>\n<p>单个出口:</p>\n<p><code>output: &#123;</code></p>\n<p><code>path: path.resolve(__dirname, &#39;dist&#39;),  //出口文件夹路径</code></p>\n<p>  <code>filename: &#39;bundle.js&#39;   //出口文件名称</code></p>\n<p><code>&#125;</code></p>\n<p><em>&#x2F;&#x2F; 注意如果配置了多个入口,但是只配置了一个出口,会报错</em></p>\n<p><em>&#x2F;&#x2F; 此时采用动态输出名指定输出文件: 使用[name]指定动态输出文件</em></p>\n<p><code>output: &#123;</code></p>\n<p><code>path: path.resolve(__dirname, &#39;dist&#39;),</code></p>\n<p> <code>filename: &#39;[name].js&#39;</code></p>\n<p> <code>&#125;</code></p>\n<h2 id=\"【4】loader-（-将webpack和其他工具进行联通-）\"><a href=\"#【4】loader-（-将webpack和其他工具进行联通-）\" class=\"headerlink\" title=\"【4】loader （ 将webpack和其他工具进行联通 ）\"></a>【4】loader （ 将webpack和其他工具进行联通 ）</h2><p>1  什么是loader (加载器,webpack本身是用来打包js ,要想打包css 图片等静态资源和模块 ,必须要使用loader)</p>\n<p>2  babel-loader( webpack中使用 babel ,先用babel将ES6代码转成ES5的代码 , 然后再交给webpack进行打包)</p>\n<p> (1) 安装:</p>\n<p><code>npm install--save - dev babel - loader@8.1.0 @babel/core@7.11.0 @babel/preset - env@7.11.0</code></p>\n<p>(2)  创建babel配置文件</p>\n<p>.babelrc 文件，并且配置</p>\n<p><code>&#123;</code></p>\n<p><code>&quot;presets&quot;:[&quot;@babel/preset-env&quot;]*</code></p>\n<p><code>&#125;</code></p>\n<p>(3)  配置loader  再webpack.config.js中，再原有的基础之上</p>\n<p><code>module: &#123;</code></p>\n<p>   <code>配置多个loader规则</code></p>\n<p><code>rules: &#123;</code></p>\n<p> <code>//匹配需要处理的文件类型</code></p>\n<p><code>test: /\\.js$/,</code></p>\n<p><code>//排除不需要打包的的文件类型(node modules</code></p>\n<p>  <code>exclude:/node_modules/,</code></p>\n<p><code>// 联通webpack和babel ,处理文件</code></p>\n<p> <code>loader: &#39;babel-loader&#39;</code></p>\n<p>  <code>&#125;</code></p>\n<p><code>&#125;</code></p>\n<p> (4)  但是这样也只是转义了语法，ES6代码中的一些新的API无法转成ES5，此时需要引入模块，然后使用API</p>\n<p><em>&#x2F;&#x2F; 这也就是babel&#x2F;polyfill的作用</em></p>\n<h2 id=\"【6】-使用babel-x2F-polyfill-（-core-js-）\"><a href=\"#【6】-使用babel-x2F-polyfill-（-core-js-）\" class=\"headerlink\" title=\"【6】 使用babel&#x2F;polyfill （ core-js ）\"></a>【6】 使用babel&#x2F;polyfill （ core-js ）</h2><p>(1)  安装</p>\n<p>npm install –save-dev <span class=\"exturl\" data-url=\"bWFpbHRvOiYjOTk7JiN4NmY7JiN4NzI7JiN4NjU7JiN4MmQ7JiN4NmE7JiMxMTU7JiN4NDA7JiN4MzM7JiN4MmU7JiM1NDsmIzQ2OyYjeDM1Ow==\">&#99;&#x6f;&#x72;&#x65;&#x2d;&#x6a;&#115;&#x40;&#x33;&#x2e;&#54;&#46;&#x35;</span></p>\n<p>(2)  在需要处理的js文件中引入core-js稳定版</p>\n<p> <code>import &#39;core-js/stable&#39;  (在要处理的js文件中引入)</code></p>\n<p>（3）npm run webpack 进行打包处理</p>\n<h2 id=\"【7】plugins\"><a href=\"#【7】plugins\" class=\"headerlink\" title=\"【7】plugins\"></a>【7】plugins</h2><p>1  plugins介绍，插件，loader被用于转成某些类型的模块，而插件则可以用于执行范围更广的任务</p>\n<p> 需要什么功能就使用对应功能的插件</p>\n<p>2  举例应用：html-webpack-plugin插件</p>\n<p> html中需要在html中手动添加js文件 ， 此插件可以直接将js的引入嵌入html文件中</p>\n<p> (1)安装</p>\n<p> <code>npm install --save-dev html-webpack-plugin@4.3.0</code></p>\n<p>(2)配置html-webpack-plugin插件 （在webpack.config.js中引入）</p>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\n\nmodule.exports = &#123;\n  mode: &#39;development&#39;,\n  entry: &#123;\n    // 单入口\n    // index: &#39;./src/index.js&#39;\n    \n    // 多入口\n    index: &#39;./src/index.js&#39;,\n    search: &#39;./src/search.js&#39;\n  &#125;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;[name].js&#39;\n  &#125;,\n  plugins: [\n    // 单入口\n    // new HtmlWebpackPlugin(&#123;\n    //   template: &#39;./index.html&#39;\n    // &#125;)\n    \n    // 多入口\n    new HtmlWebpackPlugin(&#123;\n      template: &#39;./index.html&#39;,\n      filename: &#39;index.html&#39;,\n      chunks: [&#39;index&#39;],\n      minify: &#123;\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n      &#125;\n    &#125;),\n    new HtmlWebpackPlugin(&#123;\n      template: &#39;./search.html&#39;,\n      filename: &#39;search.html&#39;,\n      chunks: [&#39;search&#39;]\n    &#125;)\n  ]\n&#125;;\n</code></pre>\n<h2 id=\"【8】webpack处理css文件-（可以在js中引入css文件-，webpack将css文件当成模块）\"><a href=\"#【8】webpack处理css文件-（可以在js中引入css文件-，webpack将css文件当成模块）\" class=\"headerlink\" title=\"【8】webpack处理css文件 （可以在js中引入css文件 ，webpack将css文件当成模块）\"></a>【8】webpack处理css文件 （可以在js中引入css文件 ，webpack将css文件当成模块）</h2><h4 id=\"一-css-loader\"><a href=\"#一-css-loader\" class=\"headerlink\" title=\"一  css-loader\"></a>一  css-loader</h4><p><em>&#x2F;&#x2F;1  js中  import ‘&#x2F;src&#x2F;index.css’</em></p>\n<p><em>&#x2F;&#x2F; 2  安装css-loader</em></p>\n<p><em>&#x2F;&#x2F;  npm install –save-dev <span class=\"exturl\" data-url=\"bWFpbHRvOiYjOTk7JiMxMTU7JiMxMTU7JiN4MmQ7JiN4NmM7JiN4NmY7JiM5NzsmI3g2NDsmIzEwMTsmIzExNDsmI3g0MDsmI3gzNDsmIzQ2OyYjNDk7JiM0NjsmIzQ5Ow==\">&#99;&#115;&#115;&#x2d;&#x6c;&#x6f;&#97;&#x64;&#101;&#114;&#x40;&#x34;&#46;&#49;&#46;&#49;</span></em></p>\n<p><em>&#x2F;&#x2F; 3  webpack.config.js中配置 module</em></p>\n<pre><code class=\"javascript\">module: &#123;\n  rules: [\n    &#123;\n      test: /\\.css$/,\n      loader: &#39;css-loader&#39;\n    &#125;\n  ]\n&#125;\n</code></pre>\n<p><em>&#x2F;&#x2F; 此时css-loader帮助webpack认识了css文件，然后引入，但是不会生效(因为没有style标签)</em></p>\n<p><em>&#x2F;&#x2F; 此时还需要一个style-loader</em></p>\n<h4 id=\"二-style-loader\"><a href=\"#二-style-loader\" class=\"headerlink\" title=\"二  style-loader\"></a>二  style-loader</h4><p><em>&#x2F;&#x2F; (1)  安装</em></p>\n<p><code>npm install --save-dev style-loader@1.2.1</code></p>\n<p><em>&#x2F;&#x2F; (2)  配置style-loader（webpack.config.js中）</em></p>\n<pre><code class=\"javascript\">module: &#123;\n  rules: [\n    &#123;\n      test: /\\.css$/,\n      //  loader:&#39;css-loader&#39;\n      use: [&#39;style-loader&#39;, &#39;css-loader&#39;]  //注意会从右向左的顺序执行\n    &#125;\n  ]\n&#125;\n</code></pre>\n<p><em>&#x2F;&#x2F; 三  如果不想直接使用css文件，而是想要用link标签引入外部css文件，需要用到一个插件</em></p>\n<p>mini-css-extract-plugin</p>\n<p><em>&#x2F;&#x2F; (1) 安装</em></p>\n<p><code>npm install --save-dev mini-css-extract-plugin@0.9.0</code></p>\n<p><em>&#x2F;&#x2F; （2）在webpack.config.js中导入</em></p>\n<pre><code class=\"javascript\">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\n</code></pre>\n<p><em>&#x2F;&#x2F; （3）在webpakc.config.js中配置（ rules中use和plugins）</em></p>\n<pre><code class=\"javascript\">// webpack.config.js\n\nconst path = require(&#39;path&#39;);\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);\n\nmodule.exports = &#123;\n  mode: &#39;development&#39;,\n  entry: &#39;./src/index.js&#39;,\n  output: &#123;\n    filename: &#39;js/[name].js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.css$/,\n        // loader: &#39;css-loader&#39;\n        use: [&#39;MiniCssExtractPlugin.loader&#39;, &#39;css-loader&#39;]  //注意会从右向左的顺序执行\n      &#125;\n    ]\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: &#39;./index.html&#39;,\n      filename: &#39;index.html&#39;\n    &#125;),\n    new MiniCssExtractPlugin(&#123;\n      filename: &#39;css/[name].css&#39;\n    &#125;)\n  ]\n&#125;;\n</code></pre>\n<h2 id=\"【9】使用loader处理图片问题\"><a href=\"#【9】使用loader处理图片问题\" class=\"headerlink\" title=\"【9】使用loader处理图片问题\"></a>【9】使用loader处理图片问题</h2><h3 id=\"四-使用file-loader处理CSS文件中的图片\"><a href=\"#四-使用file-loader处理CSS文件中的图片\" class=\"headerlink\" title=\"四  使用file-loader处理CSS文件中的图片\"></a>四  使用file-loader处理CSS文件中的图片</h3><p><em>&#x2F;&#x2F; webpack只能处理内部的资源，外部的远程图片不用考虑webpack</em></p>\n<p><em>&#x2F;&#x2F; webpack不认识png等格式结尾的文件，此时就需要使用 file-loader</em></p>\n<p><em>&#x2F;&#x2F; (1)  安装file-loader：</em></p>\n<p> <code>npm install --save-dev file-loader@6.0.0</code></p>\n<p><em>&#x2F;&#x2F; (2)  在webpack.config.js的rules中配置file-loader</em></p>\n<pre><code class=\"javascript\">// webpack.config.js\n\nconst path = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);\n\nmodule.exports = &#123;\n  mode: &#39;development&#39;,\n  entry: &#39;./src/index.js&#39;,\n  output: &#123;\n    filename: &#39;js/[name].js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.css$/,\n        use: [\n          &#123;\n            loader: MiniCssExtractPlugin.loader,\n            options: &#123;\n              publicPath: &#39;../&#39;\n            &#125;\n          &#125;,\n          &#39;css-loader&#39;\n        ]\n      &#125;,\n      &#123;\n        test: /\\.(jpg|png|gif)$/,\n        use: &#123;\n          loader: &#39;file-loader&#39;,\n          options: &#123;\n            name: &#39;img/[name].[ext]&#39; //指定图片名称\n          &#125;\n        &#125;\n      &#125;\n    ]\n  &#125;,\n  plugins: [\n    new MiniCssExtractPlugin(&#123;\n      filename: &#39;css/[name].css&#39;\n    &#125;)\n  ]\n&#125;;\n</code></pre>\n<p><em>&#x2F;&#x2F; （注意file-loader处理的图片会放到新的目录，此时需要和minicss插件配合使用）</em></p>\n<h3 id=\"五-使用html-withimg-loader处理HTML图片-（处理html中使用的图片）\"><a href=\"#五-使用html-withimg-loader处理HTML图片-（处理html中使用的图片）\" class=\"headerlink\" title=\"五  使用html-withimg-loader处理HTML图片  （处理html中使用的图片）\"></a>五  使用html-withimg-loader处理HTML图片  （处理html中使用的图片）</h3><p><em>&#x2F;&#x2F; （1）安装</em></p>\n<p><code>npm install --save-dev html-withimg-loader@0.1.16</code></p>\n<p><em>&#x2F;&#x2F; （2）webpack.config.js的module的rules中配置文件</em></p>\n<pre><code class=\"javascript\"> &#123;\n   test: /\\.(html|html)$/,  //待处理文件\nloader: &#39;html-withimg-loader&#39;\n&#125;\n</code></pre>\n<p><em>&#x2F;&#x2F; （3）npm run webpack进行打包</em></p>\n<p><em>&#x2F;&#x2F; 但是注意他与 file-loader的配合使用，过程中会将图片当成模块，解决方法在module中rules中配置</em></p>\n<pre><code class=\"javascript\">// webpack.config.js\n\nconst path = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);\n\nmodule.exports = &#123;\n  mode: &#39;development&#39;,\n  entry: &#39;./src/index.js&#39;,\n  output: &#123;\n    filename: &#39;js/[name].js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  &#125;,\n  module: &#123;\n    rules: [\n    &#123;\n      test: /\\.css$/,\n      use: [\n        &#123;\n          loader: MiniCssExtractPlugin.loader,\n          options: &#123;\n            publicPath: &#39;../&#39;\n          &#125;\n        &#125;,\n        &#39;css-loader&#39;\n      ]\n    &#125;,\n    &#123;\n      test: /\\.(jpg|png|gif)$/,\n      use: &#123;\n        loader: &#39;file-loader&#39;,\n        options: &#123;\n          name: &#39;img/[name].[ext]&#39;,\n          esModule: false //不将html中引入的图片当成模块处理\n        &#125;\n      &#125;\n    &#125;\n    ]\n  &#125;,\n  plugins: [\n    new MiniCssExtractPlugin(&#123;\n      filename: &#39;css/[name].css&#39;\n    &#125;)\n  ]\n&#125;;\n</code></pre>\n<h3 id=\"六-使用file-loader处理js图片\"><a href=\"#六-使用file-loader处理js图片\" class=\"headerlink\" title=\"六  使用file-loader处理js图片\"></a>六  使用file-loader处理js图片</h3><p> 将js中引入的图片的地址更换成打包后的图片的地址<br> 在webpack.config.js的module中的rules中进行配置</p>\n<pre><code class=\"javascript\">// webpack.config.js\n\nconst path = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);\n\nmodule.exports = &#123;\n  mode: &#39;development&#39;,\n  entry: &#39;./src/index.js&#39;,\n  output: &#123;\n    filename: &#39;js/[name].js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  &#125;,\n  module: &#123;\n    rules: [\n    &#123;\n      // 匹配图片文件\n      test: /\\.(jpg|png|gif)$/,\n      use: &#123;\n        // 使用file-loader处理\n        loader: &#39;file-loader&#39;,\n        options: &#123;\n          name: &#39;img/[name].[ext]&#39;, // 指定输出文件的名称和路径\n          esModule: false // 不将html中引入的图片当成模块处理\n        &#125;\n      &#125;\n    &#125;\n    ]\n  &#125;,\n  plugins: [\n    new MiniCssExtractPlugin(&#123;\n      filename: &#39;css/[name].css&#39;\n    &#125;)\n  ]\n&#125;;\n</code></pre>\n<h3 id=\"七-使用url-loader处理图片\"><a href=\"#七-使用url-loader处理图片\" class=\"headerlink\" title=\"七  使用url-loader处理图片\"></a>七  使用url-loader处理图片</h3><p>（ file-loader的功能过于单一 ，url功能更加全面，但其底层是由file-loader来封装的，配置时，只需要配置url-loader即可）</p>\n<p>（1）安装 url-loader</p>\n<p> <code>npm install --save-dev url-loader@4.1.0</code></p>\n<p> （2）配置url-loader</p>\n<p> webpack中的module中的rules下进行配置</p>\n<pre><code class=\"javascript\">&#123;\n  test: /\\.(jpg|png|gif)$/,\n  use: &#123;\n    loader: &#39;url-loader&#39;,\n    options: &#123;\n      name: &#39;img/[name].[ext]&#39;,   // 设置文件夹名称和文件名称\n      esModule: false,   // 设置其引入不是一个路径\n      limit: 3000   // 将3kb以内的图片转成base64格式，存到js中\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>使用url-loader的前提时要引入file-loader（url-loader是由file-loader封装而来）</p>\n<h3 id=\"八-使用webpack-dev-server搭建开发环境\"><a href=\"#八-使用webpack-dev-server搭建开发环境\" class=\"headerlink\" title=\"八  使用webpack-dev-server搭建开发环境\"></a>八  使用webpack-dev-server搭建开发环境</h3><p>比如：自动打包（打包热启动），当修改文件内容时，自动进行打包处理（打包之后的文件不会生成在磁盘中，而是存在内存里）</p>\n<p>（1）安装：</p>\n<p>  <code>npm install --save-dev webpack-dev-server@3.11.0</code></p>\n<p>(2) 配置命令（在package.json的scripts中配置）</p>\n<pre><code class=\"javascript\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,   // 测试命令\n  &quot;webpack&quot;: &quot;webpack&quot;,   // 运行 webpack 命令\n  &quot;dev&quot;: &quot;webpack-dev-server&quot;   // 运行 webpack-dev-server 命令\n  // &quot;dev&quot;: &quot;webpack-dev-server --open chrome&quot;  //重新打包，并且打包之后自动开启 Chrome 浏览器\n&#125;\n</code></pre>\n<h1 id=\"webpack配置示例\"><a href=\"#webpack配置示例\" class=\"headerlink\" title=\"webpack配置示例\"></a>webpack配置示例</h1><pre><code class=\"javascript\">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst CssMinimizerWebpackPlugin = require(&quot;css-minimizer-webpack-plugin&quot;)\nconst CopyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;)\nconst EslintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\nconst &#123;VueLoaderPlugin&#125; = require(&quot;vue-loader&quot;)\nconst path = require(&quot;path&quot;)\nconst &#123;DefinePlugin&#125; = require(&quot;webpack&quot;)\nconst TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;)\nconst getStyleLoaders = (pre) =&gt; &#123;\n    return [\n        // 针对vue项目\n        isProdcution ? MiniCssExtractPlugin.loader : &quot;vue-style-loader&quot;,\n        &#39;css-loader&#39;,\n        &#123;\n            // 处理css兼容性\n            // 配合package.json之中的browserslist来指定兼容性做到什么程度\n            loader: &#39;postcss-loader&#39;,\n            options: &#123;\n                postcssOptions: &#123;\n                    plugins: [&#39;postcss-preset-env&#39;]\n                &#125;\n            &#125;\n        &#125;,\n        pre &amp;&amp; pre === &quot;sass-loader&quot; ? &#123;\n            loader: &quot;sass-loader&quot;,\n            options: &#123;\n                additionalData: `@use &quot;@/styles/element/index.scss&quot; as *;`\n            &#125;\n        &#125; : pre === &quot;less-loader&quot; ? &#123;\n            loader: &#39;less-loader&#39;,\n            options: &#123;\n                lessOptions: &#123;\n                    modifyVars: &#123;\n                        &#39;primary-color&#39;: &#39;#1DA57A&#39;,\n                        &#39;link-color&#39;: &#39;#1DA57A&#39;,\n                        &#39;border-radius-base&#39;: &#39;2px&#39;,\n                    &#125;,\n                    javascriptEnabled: true,\n                &#125;\n            &#125;,\n        &#125; : pre\n    ].filter(Boolean)\n&#125;\nconst isProdcution = process.env.NODE_ENV === &quot;production&quot; ? true : false\nlet cdn = isProdcution ? &#123;\n    // css: [&quot;https://cdn.jsdelivr.net/npm/element-plus/dist/index.css&quot;],\n    css: [\n        &quot;https://cdn.jsdelivr.net/npm/ant-design-vue@3.2.20/dist/antd.min.css&quot;\n    ],\n    js: [\n        &quot;https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js&quot;,\n        &#39;https://cdnjs.cloudflare.com/ajax/libs/vue-router/4.2.2/vue-router.global.prod.min.js&#39;,\n        &quot;https://cdn.jsdelivr.net/npm/ant-design-vue@3.2.20/dist/antd.min.js&quot;\n        // &quot;https://cdn.jsdelivr.net/npm/element-plus&quot;\n    ]\n&#125; : &#123;&#125;\nmodule.exports = &#123;\n    entry: &#39;./src/main.js&#39;,\n    output: &#123;\n        filename: &quot;static/js/[name].js&quot;,\n        path: isProdcution ? path.resolve(__dirname, &quot;../dist&quot;) : undefined,\n        chunkFilename: &quot;static/js/[name].[hash:10].chunk.js&quot;,\n        assetModuleFilename: &quot;static/assets/[hash:10][ext]&quot;,\n        clean: true\n    &#125;,\n    module: &#123;\n        rules: [\n            &#123;\n                oneOf: [\n                    &#123;\n                        test: /\\.css$/,\n                        use: getStyleLoaders()\n                    &#125;,\n                    &#123;\n                        test: /\\.less$/,\n                        use: getStyleLoaders(&quot;less-loader&quot;)\n                    &#125;,\n                    &#123;\n                        test: /\\.s[ac]ss$/,\n                        use: getStyleLoaders(&quot;sass-loader&quot;)\n                    &#125;,\n                    &#123;\n                        test: /\\.styl$/,\n                        use: getStyleLoaders(&quot;stylus-loader&quot;)\n                    &#125;,\n                    // 处理图片\n                    &#123;\n                        test: /\\.(jpe?g|png|gif|webp)$/,\n                        type: &#39;asset&#39;,\n                        parser: &#123;\n                            dataUrlCondition: &#123;\n                                maxSize: 10*1024 // 小于10kb\n                            &#125;\n                        &#125;\n                    &#125;,\n                    // 处理其他字体资源\n                    &#123;\n                        test: /\\.(woff2?|ttf)$/,\n                        type: &#39;asset/resource&#39;,\n        \n                    &#125;\n                ]\n            &#125;,\n            // 处理js  eslint babel\n            &#123;\n                test: /\\.js$/,\n                include: path.resolve(__dirname, &quot;../src&quot;),\n                loader: &quot;babel-loader&quot;,\n                options: &#123;\n                    // 开启缓存\n                    cacheDirectory: true,\n                    // 缓存不需要压缩\n                    cacheCompression: false\n                &#125;\n            &#125;,\n            &#123;\n                test: /\\.svg$/,\n                type: &#39;asset&#39;,\n                loader: &#39;svgo-loader&#39;,\n                exclude: [path.resolve(__dirname, &#39;../src/icons&#39;)],\n                options: &#123;\n                    multipass: true,\n                    js2svg: &#123;\n                        indent: 2,\n                        pretty: true,\n                    &#125;\n                &#125;\n            &#125;,\n            &#123;\n                test: /\\.svg$/,\n                include: [path.resolve(__dirname, &#39;../src/icons&#39;)],\n                use: [\n                    &#123;\n                        loader: &#39;svg-sprite-loader&#39;,\n                        options: &#123;\n                            symbolId: &#39;icon_[name]&#39;\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            &#123;\n                test: /\\.vue$/,\n                loader: &quot;vue-loader&quot;,\n                options: &#123;\n                    cacheDirectory: path.resolve(__dirname, &quot;../node_modules/.cache/vue-loader&quot;)\n                &#125;\n            &#125;\n        ]\n    &#125;,\n    resolve: &#123;\n        extensions: [&quot;.vue&quot;, &quot;.js&quot;, &quot;.json&quot;],\n        alias: &#123;\n            &#39;@&#39;: path.resolve(__dirname, &#39;../src&#39;)\n        &#125;\n    &#125;,\n    plugins: [\n        new EslintWebpackPlugin(&#123;\n            context: path.resolve(__dirname, &quot;../src&quot;),\n            exclude: &quot;node_modules&quot;,\n            cache: true,\n            cacheLocation: path.resolve(__dirname, &quot;../node_modules/.cache/.eslintcache&quot;)\n        &#125;),\n        new HtmlWebpackPlugin(&#123;\n            template: path.resolve(__dirname, &quot;../public/index.html&quot;),\n            cdnTag: cdn\n        &#125;),\n        new VueLoaderPlugin(),\n        // 定义环境变量 cross-env 定义的环境变量是给打包工具使用的\n        // DefinePlugin 是给源代码使用的，解决vue3的警告问题\n        new DefinePlugin(&#123;\n            __VUE_OPTIONS_API__: true,\n            __VUE_PROD_DEVTOOLS__: false\n        &#125;),\n        isProdcution &amp;&amp; new MiniCssExtractPlugin(&#123;\n            filename: &quot;static/css/[name].[contenthash:10].css&quot;,\n            chunkFilename: &quot;static/css/[name].[contenthash:10].chunk.css&quot;\n        &#125;),\n        isProdcution &amp;&amp; new CopyWebpackPlugin(&#123;\n            patterns: [\n                &#123;\n                    from: path.resolve(__dirname, &quot;../public&quot;),\n                    to: path.resolve(__dirname, &quot;../dist&quot;),\n                    globOptions: &#123;\n                        // 忽律index.html文件\n                        ignore: [&quot;**/index.html&quot;]\n                    &#125;\n                &#125;\n            ]\n        &#125;)\n    ].filter(Boolean),\n    optimization: &#123;\n        splitChunks: &#123;\n            chunks: &#39;all&#39;,\n            cacheGroups: &#123;\n                vue: &#123;\n                    test: /[\\\\/]node_modules[\\\\/]vue(.*)?[\\\\/]/,\n                    name: &quot;vue-chunk&quot;,\n                    priority: 30\n                &#125;,\n                &quot;ant-design-vue&quot;: &#123;\n                    test: /[\\\\/]node_modules[\\\\/]ant-design-vue(.*)?[\\\\/]/,\n                    name: &quot;ant-design-vue-chunk&quot;,\n                    priority: 20\n                &#125;,\n                // elementPlus: &#123;\n                //     test: /[\\\\/]node_modules[\\\\/]element-plus(.*)?[\\\\/]/,\n                //     name: &quot;elementPlus-chunk&quot;,\n                //     priority: 20\n                // &#125;,\n                libs: &#123;\n                    test: /[\\\\/]node_modules[\\\\/]/,\n                    name: &quot;libs-chunk&quot;,\n                    priority: 10\n                &#125;\n            &#125;\n        &#125;,\n        // 代码分割会导致缓存失效，因为每次都需要重新引入，名字就会发生变化\n        runtimeChunk: &#123;\n            name: entrypoint =&gt; `runtime-$&#123;entrypoint.name&#125;.js`\n        &#125;,\n        minimize: isProdcution,\n        minimizer: [\n            new CssMinimizerWebpackPlugin(),\n            new TerserWebpackPlugin()\n        ]\n    &#125;,\n    mode: isProdcution ? &quot;production&quot; : &quot;development&quot;,\n    performance: false,\n    devtool: isProdcution ? &quot;source-map&quot; : &quot;cheap-module-source-map&quot;,\n    devServer: &#123;\n        host: &#39;localhost&#39;,\n        port: 3000,\n        open: false,\n        hot: true,\n        // 解决html5 history 刷新404 的问题\n        historyApiFallback: true\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"实现miniwebpack\"><a href=\"#实现miniwebpack\" class=\"headerlink\" title=\"实现miniwebpack\"></a>实现miniwebpack</h1><h3 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h3><p>我们都知道webpack是基于babel进行语法转换的，因此我们需要提前了解一些babel的使用方法：</p>\n<ul>\n<li>@babel&#x2F;parser模块：用于将js代码转为抽象语法树</li>\n<li>@babel&#x2F;traverse模块：用于遍历和操作抽象语法树（处理导入的模块）</li>\n<li>@babel&#x2F;core模块：babel的核心模块，用于将抽象语法树转换为代码信息对象（包含重要的code属性，表示转换后生成的代码）</li>\n<li>@babel&#x2F;preset-env模块：babel中的一个预设，可以在babel.transformFromAst中第三个参数中presets字段传入，可以根据当前环境将代码转成相应的兼容版本。</li>\n</ul>\n<h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h3><p><img data-src=\"/images/Snipaste_2024-05-07_07-23-59.jpg\" alt=\"miniwebpack\"></p>\n<h3 id=\"开始编码\"><a href=\"#开始编码\" class=\"headerlink\" title=\"开始编码\"></a>开始编码</h3><pre><code class=\"javascript\">const fs = require(&quot;fs&quot;);\nconst path = require(&quot;path&quot;);\n// @babel/parser用于将js代码转化为抽象语法树\nconst parser = require(&quot;@babel/parser&quot;);\n// @babel/traverse用于遍历和操作抽象语法树\nconst traverse = require(&quot;@babel/traverse&quot;).default;\n// Babel 的核心功能包含在 @babel/core 模块中\nconst babel = require(&quot;@babel/core&quot;);\n// 1. 分析依赖\nfunction parseModules(file) &#123;\n  const entry = getModuleInfo(file);\n  const temp = [entry];\n  const depsGraph = &#123;&#125;;\n  getDeps(temp, entry);\n  temp.forEach((moduleInfo) =&gt; &#123; //遍历全部模块信息数组\n    depsGraph[moduleInfo.file] = &#123; //映射file路径和code、deps\n      deps: moduleInfo.deps,\n      code: moduleInfo.code,\n    &#125;;\n  &#125;);\n  return depsGraph;\n&#125;\nfunction getDeps(temp, &#123;deps&#125;) &#123;\n  Object.keys(deps).forEach((key) =&gt; &#123;\n    const child = getModuleInfo(deps[key]);\n    temp.push(child);\n    getDeps(temp, child);\n  &#125;);\n&#125;\nfunction getModuleInfo(file) &#123;\n  // 读取文件\n  const body = fs.readFileSync(file, &quot;utf-8&quot;);\n  // 转化为AST\n  const ast = parser.parse(body, &#123;sourceType: &quot;module&quot;&#125;);\n  const deps = &#123;&#125;;\n  traverse(ast, &#123;\n    // 获取import导入的模块\n    ImportDeclaration(&#123;node&#125;) &#123;\n      const dirname = path.dirname(file);\n      // 获取标准化路径\n      const absPath = &quot;./&quot; + path.join(dirname, node.source.value);\n      deps[node.source.value] = absPath;\n    &#125;,\n  &#125;);\n  const &#123;code&#125; = babel.transformFromAst(ast, null, &#123;\n    // 使用预设\n    presets: [&quot;@babel/preset-env&quot;],\n  &#125;);\n  const moduleInfo = &#123;file, deps, code&#125;;\n  return moduleInfo;\n&#125;\n// 2. 实现bundle\nfunction bundle(file) &#123;\n  //将模块转为引用路径和映射code、deps的对象\n  const depsGraph = JSON.stringify(parseModules(file));\n  return `(function (graph) &#123;\n    function require(file) &#123;\n      function absRequire(realPath) &#123;\n        return require(graph[file].deps[realPath]);  //递归调用获取返回值\n      &#125;\n      var exports = &#123;&#125;;   //exports对象，用于存储模块的返回值信息\n      (function (require, exports, code) &#123;\n        eval(code);   //eval函数用于执行字符串的js代码，传入require，exports和code\n      &#125;)(absRequire, exports, graph[file].code);\n      return exports;\n    &#125;\n    require(&#39;$&#123;file&#125;&#39;);\n  &#125;)($&#123;depsGraph&#125;);`;\n&#125;\nconst content = bundle(&quot;./src/index.js&quot;);\n//将内容写入到输出文件 \nfs.writeFileSync(&quot;./dist/bundle.js&quot;, content);\n//webpack打包后的js文件就是一个立即执行函数，传入的参数是一个对象，对象的键是模块路径，值是模块函数代码\n</code></pre>\n","categories":["webpack"],"tags":["webpack","前端工程化"]},{"title":"前端模块化","url":"/2024/03/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/","content":"<h1 id=\"modules模块化\"><a href=\"#modules模块化\" class=\"headerlink\" title=\"modules模块化\"></a>modules模块化</h1><h3 id=\"模块化的优点：\"><a href=\"#模块化的优点：\" class=\"headerlink\" title=\"模块化的优点：\"></a>模块化的优点：</h3><p>可维护性、可复用性。</p>\n<h4 id=\"模块化的发展\"><a href=\"#模块化的发展\" class=\"headerlink\" title=\"模块化的发展\"></a>模块化的发展</h4><p>1、ES6之前没有模块化时，浏览器环境需要使用script进行引入js文件<br>2、后来使用全局变量+命名空间（namespace）处理，就是使用IIFE自动执行函数创建一个函数作用域，赋值给一个全局变量。<br>这样做的缺点是：依赖于全局变量，污染全局变量，不安全。<br>    依赖于约定命名空间来避免冲突，可靠性不高。<br>    需要手动管理依赖并控制执行顺序，容易出错。<br>    需要在最终上线前手动合并所有用到的模块。<br>3、node端模块系统：Common.js，缺点是浏览器端无法使用<br>4、AMD(Asynchronous module definition)异步加载模块定义，CMD(模块标准)<br>    采用异步方式加载，需要全局环境定义require和define，不需要引入其他的变量。<br>5、ES6 modules、引入和暴露方式更加多样，支持复杂的静态分析和静态、动态导入。</p>\n<h1 id=\"Bundler打包工具\"><a href=\"#Bundler打包工具\" class=\"headerlink\" title=\"Bundler打包工具\"></a>Bundler打包工具</h1><h3 id=\"诞生原因：\"><a href=\"#诞生原因：\" class=\"headerlink\" title=\"诞生原因：\"></a>诞生原因：</h3><p>使用import export这种异步加载方式在大多数浏览器中无法使用。</p>\n<h3 id=\"常见工具\"><a href=\"#常见工具\" class=\"headerlink\" title=\"常见工具\"></a>常见工具</h3><p>一、<strong>Webpack</strong>（单JS文件入口），Webpack采用代码分割、异步加载等技术，可以将多个模块打包成一个或者多个bundle,，构建的产物是一个函数。Webpack主要用于构建复杂的前端项目，如Web应用、SPA单页面应用等，支持模块化开发、代码分割、资源优化和静态文件处理等功能。。</p>\n<p>二、<strong>rollup</strong>用静态的方式分析代码，对未使用的代码更加彻底的进行树摇优化，输出的bundle更加的精简。</p>\n<p>三、<strong>snowpack</strong>（使用于新版浏览器）<br>1、出现的原因（其他Bundler的问题）：<br>当资源越来越多时，打包的速度会越来越慢，大中型项目中，启动时间可能达到好几分钟。（vite的理念来源于snowpack，充分使用了新版浏览器支持es modules的特性。）<br>2、优势：<br>snowpack利用新版浏览器支持es modules的特性，开发模式不会被打包，每个文件编译一次，永久被缓存，当一个文件修改的时候就只需要重新build那一个文件。（适用于新版浏览器）<br>四、<strong>vite</strong><br>vite基于snowpack的理念（利用新版浏览器支持es modules的特性），基于es-modules，采用rollup进行构建 ，开发模式不会打包，每个文件当使用时才会去加载，修改时只需要重新build那一个文件。<br>五、<strong>vue-cli</strong><br>vue-cli底层基于webpack，webpack通过导入导出的语句分析整个项目，将目标代码转化成兼容浏览器的js代码，只有打包后的几个文件，这个过程需要耗费一些时间。</p>\n<h1 id=\"webpack配置支持ES-Module\"><a href=\"#webpack配置支持ES-Module\" class=\"headerlink\" title=\"webpack配置支持ES Module\"></a>webpack配置支持ES Module</h1><p>webpack默认只支持CommonJS规范，配置支持ES Module规范，需要进行如下配置：<br>一：将ES Module语法的js文件通过webpack进行打包即可。<br>二：webpack默认target为web，在使用node内置库时会报错，可以修改target属性。</p>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\nmodule.exports = &#123;\n    entry: &#39;./bin/core.js&#39;,\n    output: &#123;\n        path:path.join(__dirname,&#39;/dist&#39;),\n        filename: &#39;core.js&#39;,\n    &#125;,\n    mode: &#39;production&#39;, //改变打包模式\n    target: &#39;node&#39; //进入node环境，默认是web\n&#125;\n</code></pre>\n<p>三、webpack配置babel-loader，兼容低版本node<br>方案一：安装babel-loader、@babel&#x2F;core、@babel&#x2F;preset-env（有时需要@babel&#x2F;plugin-transform-runtime插件）</p>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;);\nmodule.exports = &#123;\n    entry: &#39;./bin/core.js&#39;,\n    output: &#123;\n        path:path.join(__dirname,&#39;/dist&#39;),\n        filename: &#39;core.js&#39;,\n    &#125;,\n    mode: &#39;production&#39;, //改变打包模式\n    target: &#39;node&#39;, //进入node环境，默认是web\n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.js$/,\n                use: &#123;\n                    loader: &#39;babel-loader&#39;,  //使用babel-loader\n                    options: &#123;\n                        presets: [&#39;@babel/preset-env&#39;],\n                        plugins:[\n                            [\n                                &#39;@babel/plugin-transform-runtime&#39;,\n                                &#123;\n                                    corejs: 3,\n                                    regenerator: true,\n                                    useESModules: true,\n                                    helpers: true,\n                                &#125;,\n                            ],\n                        ]\n                    &#125;,\n                &#125;\n            &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<p>方案二：node.js实验功能<br>将js后缀更改为mjs后缀，即可（需要node版本为14以上）,小于14版本的时候，node执行时需要加上–experimental-modules参数，例如：<br><code>node --experimental-modules index.js</code></p>\n<h1 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h1><h2 id=\"冷知识\"><a href=\"#冷知识\" class=\"headerlink\" title=\"冷知识\"></a>冷知识</h2><p><code>npm dedupe</code>命令</p>\n<blockquote>\n<p>该命令用于去重依赖和优化依赖树,<code>npm dedupe</code>命令会检查node_modules中的依赖树,并尝试将公共依赖上移,以减少冗余的副本,优化依赖树<br><code>package-lock.json</code>文件<br>默认的<code>package.json</code>文件中存在依赖版本兼容,导致后续依赖包升级或某些其他情况下,每一个环境中执行<code>npm install</code>命令时,安装的依赖版本不同,这时候就有了<code>package-lock.json</code>文件,它可以精确锁定版本号和依赖,并存储仓库地址信息,使得依赖安装更快.<br>最佳的实践方式是:把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去(库项目一般是给其他仓库安装使用,不使用lock文件就可以复用主项目加载过的包)。<br><code>npm ci</code>命令<br><code>npm ci</code>命令会完全根据 package-lock.json 安装依赖，这可以保证整个开发团队都使用版本完全一致的依赖;执行<code>npm ci</code>时,会先删除项目中所有的node_modules再安装.<code>npm ci</code>永远不会改变<code>package.json</code>和<code>package-lock.json</code>文件<br>依赖是否出现在最终打包后的代码中取决于该依赖是否被引用<br><code>devDependencies</code>开发依赖<br>用于指定生产依赖,该依赖不会被自动加载(被别的模块依赖时)<br>并不是只有在 dependencies 中的模块才会被一起打包，而在 devDependencies 中的依赖一定不会被打包。实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块。dependencies 和 devDependencies 在业务中更多的只是一个规范作用，我们自己的应用项目中，使用 npm install 命令安装依赖时，dependencies 和 devDependencies 内容都会被下载。<br><code>peerDependencies</code>对等依赖<br>用于指定依赖于某些三方模块作为基础(被别的模块进行加载时)<br><code>peerDependencies</code>主要意义在于声明该模块无法脱离某个三方模块单独存在,而如果放在<code>devDependencies</code>字段中就无法共享主模块中已下载的三方模块<br>使用场景有: 插件不能单独运行 , 插件正确运行的前提是核心依赖库必须先下载安装 , 不希望核心依赖库被重复下载 等<br><code>npm pack</code>打包命令<br><code>npm pack</code>命令可以根据package.json中的<code>bundledDependencies</code>字段和其他信息,将当前仓库打包为一个.tgz格式的压缩文件,在发布到npm仓库之前可以用于本地功能测试、单文件离线下载、包的分发(离线分发给团队成员使用)等<br>通过npm安装此tgz包可以使用<code>npm install package_name-1.0.0.tgz</code>来安装tgz包<br><code>bundledDependencies</code>打包依赖<br><code>bundledDependencies</code>打包依赖字段会被<code>npm pack</code>命令所使用,当执行<code>npm pack</code>命令时,会根据此字段将项目打包为几个模块tgz包.</p>\n</blockquote>\n","categories":["前端工程化"],"tags":["ESModules"]},{"title":"jenkins配合git hook持续集成","url":"/2024/02/02/%E4%BD%BF%E7%94%A8Jenkins%E9%85%8D%E5%90%88github%20hook%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/","content":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>Centos 7.4</li>\n<li>JDK 1.8</li>\n</ul>\n<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><p>以下包含相关所有的步骤，可根据现有环境进行跳过</p>\n<ol>\n<li>安装JDK</li>\n<li>安装Centos</li>\n<li>Jenkins和Github配置</li>\n<li>配置任务</li>\n</ol>\n<h3 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h3><p>Jenkins需要JDK才可以运行，我们首先安装JDK</p>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcmFjbGUuY29tL3RlY2huZXR3b3JrL2phdmEvamF2YXNlL2Rvd25sb2Fkcy9qZGs4LWRvd25sb2Fkcy0yMTMzMTUxLmh0bWw=\">下载链接查看地址</span></p>\n<p>首先点击Accept License Agreement，选择Linux对应版本</p>\n<p><strong>注</strong>若想要直接获取下载链接，使用wget进行下载是不行的，我们可以先点击链接进行下载，然后在chrome中的下载任务中查看下载链接进行复制。</p>\n<pre><code>cd /usr/local/src\nwget `your download url`\n</code></pre>\n<h4 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h4><pre><code>tar -zxvf jdk-8u91-linux-x64.tar.gz\n</code></pre>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><p>将以下内容追加到 &#x2F;etc&#x2F;profile末尾,替换你对应的解压路径</p>\n<pre><code>JAVA_HOME=/usr/local/tools/jdk1.8.0_144\n\nJRE_HOME=$JAVA_HOME/jre\n\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n\nCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib/dt.jar\n\nexport JAVA_HOME JRE_HOME PATH CLASSPATH\n</code></pre>\n<h4 id=\"启用配置\"><a href=\"#启用配置\" class=\"headerlink\" title=\"启用配置\"></a>启用配置</h4><pre><code>source /etc/profile\n</code></pre>\n<h4 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h4><pre><code>java -version\n</code></pre>\n<h3 id=\"安装Centos\"><a href=\"#安装Centos\" class=\"headerlink\" title=\"安装Centos\"></a>安装Centos</h3><p>使用yum进行安装</p>\n<pre><code>#安装自动选择最快源的插件\n$ yum install yum-fastestmirror -y\n#添加Jenkins源:\n$ sudo wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo\n$ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key\n #安装jenkins\n$ yum install jenkins\n</code></pre>\n<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4><pre><code>service jenkins start\n</code></pre>\n<h4 id=\"更改端口\"><a href=\"#更改端口\" class=\"headerlink\" title=\"更改端口\"></a>更改端口</h4><pre><code>vim /etc/sysconfig/jenkins\nservice jenkins restart\n</code></pre>\n<h3 id=\"Jenkins和Github配置\"><a href=\"#Jenkins和Github配置\" class=\"headerlink\" title=\"Jenkins和Github配置\"></a>Jenkins和Github配置</h3><p>这里的配置就比较多了，主要是在github上生成key,然后在Jenkins与项目进行绑定即可</p>\n<h4 id=\"初始化Jenkins\"><a href=\"#初始化Jenkins\" class=\"headerlink\" title=\"初始化Jenkins\"></a>初始化Jenkins</h4><p>这几步非常简单，按照提示进行即可</p>\n<ol>\n<li>访问你的IP:8080</li>\n<li>cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword 把密码输入进去</li>\n<li>Install suggested plugins进行安装</li>\n<li>设置账户密码</li>\n</ol>\n<h3 id=\"配置Github-webhooks\"><a href=\"#配置Github-webhooks\" class=\"headerlink\" title=\"配置Github webhooks\"></a>配置Github webhooks</h3><h4 id=\"在对项目有写权限的用户上获取token\"><a href=\"#在对项目有写权限的用户上获取token\" class=\"headerlink\" title=\"在对项目有写权限的用户上获取token\"></a>在对项目有写权限的用户上获取token</h4><p>进入github –&gt; setting –&gt; Personal Access Token –&gt; Generate new token</p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-1.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-1.png\" alt=\"img\"></a></p>\n<p>点击保存，获取token,并<strong>保存好你的token</strong></p>\n<h4 id=\"设置webhooks\"><a href=\"#设置webhooks\" class=\"headerlink\" title=\"设置webhooks\"></a>设置webhooks</h4><p>进入GitHub上指定的项目 –&gt; setting –&gt; WebHooks&amp;Services –&gt; add webhook –&gt; 输入刚刚部署jenkins的服务器的IP</p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-2.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-2.png\" alt=\"img\"></a></p>\n<h3 id=\"配置Jenkins的Git-Plugin\"><a href=\"#配置Jenkins的Git-Plugin\" class=\"headerlink\" title=\"配置Jenkins的Git Plugin\"></a>配置Jenkins的Git Plugin</h3><p>新版Jenkins在初始的时候已经默认安装了Git Plugin和相关依赖的Plugin，我们不用在重复进行安装，直接配置即可</p>\n<p>系统管理 –&gt; 系统设置 –&gt; GitHub –&gt; Add GitHub Sever</p>\n<p>填写API URL为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS8=\">https://api.github.com</span></p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-3.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-3.png\" alt=\"img\"></a></p>\n<p>点击旁边的Add按钮, 添加Secret Text<br><a href=\"http://callmedadaxin.github.io/images/jenkins-4.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-4.png\" alt=\"img\"></a></p>\n<h3 id=\"配置任务\"><a href=\"#配置任务\" class=\"headerlink\" title=\"配置任务\"></a>配置任务</h3><h3 id=\"1-新建\"><a href=\"#1-新建\" class=\"headerlink\" title=\"1.新建\"></a>1.新建</h3><p>回到主页 –&gt; 新建任务 –&gt; 新建一个自由风格的软件项目</p>\n<p><a href=\"http://callmedadaxin.github.io/images/jenkins-5.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-5.png\" alt=\"img\"></a></p>\n<h3 id=\"2-配置源码管理\"><a href=\"#2-配置源码管理\" class=\"headerlink\" title=\"2.配置源码管理\"></a>2.配置源码管理</h3><p><a href=\"http://callmedadaxin.github.io/images/jenkins-6.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-6.png\" alt=\"img\"></a></p>\n<h3 id=\"3-构建触发器，构建环境\"><a href=\"#3-构建触发器，构建环境\" class=\"headerlink\" title=\"3.构建触发器，构建环境\"></a>3.构建触发器，构建环境</h3><p><a href=\"http://callmedadaxin.github.io/images/jenkins-7.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-7.png\" alt=\"img\"></a></p>\n<h3 id=\"4-编写你的构建脚本\"><a href=\"#4-编写你的构建脚本\" class=\"headerlink\" title=\"4.编写你的构建脚本\"></a>4.编写你的构建脚本</h3><p><a href=\"http://callmedadaxin.github.io/images/jenkins-8.png\"><img data-src=\"http://callmedadaxin.github.io/images/jenkins-8.png\" alt=\"img\"></a></p>\n<p>保存，应用</p>\n<h2 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h2><ul>\n<li>项目会自动clone在&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;</li>\n<li>执行的全局脚本确定已经软链到 &#x2F;usr&#x2F;bin,否则访问不到</li>\n</ul>\n","categories":["jenkins配合git hook持续集成"],"tags":["jenkins","github hook"]},{"title":"前端监控","url":"/2024/04/29/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/","content":"<h1 id=\"前端监控\"><a href=\"#前端监控\" class=\"headerlink\" title=\"前端监控\"></a>前端监控</h1><h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><strong>为什么要进行前端监控：</strong></p>\n<ul>\n<li>页面的访问行为，PV、UV、IP、PV 点击率、UV 点击率、停留时长</li>\n<li>用户的操作行为，模块曝光、</li>\n<li>模块点击</li>\n<li>页面的性能，首屏渲染时间、API 请求时间</li>\n<li>异常的监控，JS Error、API 异常、业务异常</li>\n<li>业务的监控，成交金额、每日消息数</li>\n</ul>\n<p><strong>常见的应用场景：</strong></p>\n<ul>\n<li>流量分析</li>\n</ul>\n<p><strong>常见的前端监控平台：</strong></p>\n<ul>\n<li>百度统计</li>\n<li>阿里云 ARMS</li>\n<li>友盟</li>\n</ul>\n<p><strong>前端监控的数据有什么作用</strong></p>\n<ul>\n<li>流量数据监控，如：PV、UV、点击率、页面停留时长等</li>\n<li>自定义事件监控，如：曝光事件、滑动事件、请求事件等</li>\n<li>交易指标监控，如：成交额、转化率等</li>\n<li>其他综合分析，如：用户画像分析、流量漏斗、销量预测等</li>\n</ul>\n<p><strong>前端监控的三个阶段</strong></p>\n<ul>\n<li>初阶：使用第三方平台，百度、友盟、阿里云 ARMS 等</li>\n<li>中阶：自研前端监控库，缺乏完整的监控体系</li>\n<li>高阶：自研前端监控平台，具备完整的监控体系</li>\n</ul>\n<h1 id=\"百度统计接入\"><a href=\"#百度统计接入\" class=\"headerlink\" title=\"百度统计接入\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b25namkuYmFpZHUuY29tLw==\">百度统计接入</span></h1><p><strong>流量分析免费，行为分析需要付费。</strong></p>\n<ol>\n<li>官网创建网站，设置域名和首页</li>\n<li>保证域名公共可读</li>\n<li>复制统计代码，添加到要跟踪的网页中（加入到 head 标签之前）</li>\n</ol>\n<p><strong>阿里云 ARM 和友盟分析方案较全，接入方案大致相同，但是当数据量较大时，有一定的成本，所以考虑自建前端统计系统。</strong></p>\n<p><strong>什么时候需要考虑自建前端监控系统？</strong></p>\n<ol>\n<li>不仅仅需要流量分析，还需要做行为分析</li>\n<li>自建成本小于或等于平台付费</li>\n<li>希望网站监控数据能存到自己数据库中，并且数据隐私化。</li>\n</ol>\n<h1 id=\"监控平台架构\"><a href=\"#监控平台架构\" class=\"headerlink\" title=\"监控平台架构\"></a>监控平台架构</h1><p><strong>前端监控平台的分层：</strong></p>\n<ul>\n<li><p>前端监控 JSSDK</p>\n<ul>\n<li>采集</li>\n<li>上报<ul>\n<li>默认上报：页面 PV、性能等</li>\n<li>手动上报：页面操作行为</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端监控 API 和大数据仓库</p>\n<ul>\n<li>接收上报的数据</li>\n<li>数据仓库：MaxCompute<ul>\n<li>数据查询</li>\n<li>数据存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端监控数据可视化</p>\n<ul>\n<li>日志大数据清洗</li>\n<li>大数据回流 RDS（非结构化数据 &#x3D;&gt; 结构化数据）</li>\n</ul>\n</li>\n</ul>\n<p><strong>监控平台架构说明：</strong></p>\n<p><img data-src=\"/images/Snipaste_2024-04-29_08-11-46.jpg\" alt=\"监控平台架构\"></p>\n<h2 id=\"JS-库的开发\"><a href=\"#JS-库的开发\" class=\"headerlink\" title=\"JS 库的开发\"></a>JS 库的开发</h2><h4 id=\"JS-SDK\"><a href=\"#JS-SDK\" class=\"headerlink\" title=\"JS SDK\"></a>JS SDK</h4><p>monitor.js：</p>\n<pre><code class=\"javascript\">function collect() &#123;\n  console.log(&quot;collect&quot;);\n&#125;\nfunction upload() &#123;\n  console.log(&quot;upload&quot;);\n&#125;\nwindow.testMonitor = &#123;\n  collect,\n  upload,\n&#125;;\n</code></pre>\n<p>上传到服务器，在需要监控的页面引入脚本。</p>\n<p><strong>一、直接引入脚本：</strong></p>\n<p>直接使用 script 标签引入在线地址。</p>\n<p><strong>二、异步加载（确保脚本加载完成后再使用 api）：</strong></p>\n<pre><code class=\"html\">&lt;script&gt;\n  (function()\n      const script = document.createElement(&#39;script&#39;);\n      script.src = &#39;https://imooc.youbaobao.xyz/imooc-cli-monitor.js&#39;\n      const body = document.body;\n      body.insertBefore(script,body.firstChild);\n      script.onload = function()&#123;\n      var event = new CustomEvent(&#39;onMonitorScriptLoad&#39;);\n      window.dispatchEvent(event);\n  )()\n&lt;/script&gt;\n&lt;script&gt;\n      window.addEventListener(&#39;onMonitorScriptLoad&#39;,function()&#123;\n      window.testMonitor.collect();\n      window.testMonitor.upload();\n  &#125;):\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"PV-埋点\"><a href=\"#PV-埋点\" class=\"headerlink\" title=\"PV 埋点\"></a>PV 埋点</h4><p><strong>一、分包便于代码书写和维护</strong></p>\n<p>假设将项目分为：index.js、collect.js 和 upload.js 三个 js 文件，分别用于整合、收集和上报。</p>\n<p><strong>二、设置页面基本信息</strong></p>\n<p>在 meta 标签中设置变量，假设为：test-app-id，在 body 标签中设置 test-page-id，此变量用于区分不同的站点。</p>\n<p><strong>三、collect.js</strong></p>\n<pre><code class=\"javascript\">import &#123; upload &#125; from &quot;./upload&quot;;\n//自定义一些钩子函数\nlet beforeCreateParams;\nlet beforeUpload;\nlet afterUpload;\nlet onError = (err) =&gt; &#123;\n  console.error(err);\n&#125;;\n\nexport function collect() &#123;\n  console.log(&quot;收集开始...&quot;);\n&#125;\n// 采集信息\nfunction collection(customData, eventType) &#123;\n  let appId, pageId, timeStamp, ua;\n  beforeCreateParams &amp;&amp; beforeCreateParams();\n  const metaList = document.getElementsByTagName(&quot;meta&quot;);\n  for (let i = 0; i &lt; metaList.length; i++) &#123;\n    const meta = metaList[i];\n    console.log(meta.getAttribute(&quot;test-app-id&quot;));\n    if (meta.getAttribute(&quot;test-app-id&quot;)) &#123;\n      appId = meta.getAttribute(&quot;test-app-id&quot;);\n    &#125;\n  &#125;\n  const body = document.body;\n  pageId = body.getAttribute(&quot;test-page-id&quot;);\n  if (!appId || !pageId) return;\n  timeStamp = new Date().getTime();\n  ua = window.navigator.userAgent;\n  console.log(appId, pageId, timeStamp, ua);\n  let data = `appId=$&#123;appId&#125;&amp;pageId=$&#123;pageId&#125;&amp;timeStamp=$&#123;timeStamp&#125;&amp;ua=$&#123;ua&#125;`;\n  if (beforeUpload) &#123;\n    data = beforeUpload(data); //允许定制数据\n  &#125;\n  //日志上报\n  // upload(&#123; appId,pageId,timeStamp,ua &#125;)  不常用\n  let url, uploadData;\n  try &#123;\n    data = &#123; ...customData, ...data &#125;;\n    const ret = upload(data, &#123; eventType &#125;);\n    url = ret.url;\n    uploadData = ret.data;\n  &#125; catch (e) &#123;\n    onError(e);\n  &#125; finally &#123;\n    afterUpload &amp;&amp; afterUpload(url, uploadData);\n  &#125;\n&#125;\n//发送PV日志\nexport function sendPV() &#123;\n  collection(&#123;&#125;, &quot;PV&quot;);\n&#125;\n// 上报曝光埋点\nexport function sendExp(data = &#123;&#125;) &#123;\n  collection(data, &quot;EXP&quot;);\n&#125;\n//注册钩子函数\nexport function registerBeforeCreateParams(fn) &#123;\n  beforeCreateParams = fn;\n&#125;\nexport function registerBeforeUpload(fn) &#123;\n  beforeUpload = fn;\n&#125;\nexport function registerAfterUpload(fn) &#123;\n  afterUpload = fn;\n&#125;\nexport function registerOnError(fn) &#123;\n  onError = fn;\n&#125;\nexport default &#123;&#125;;\n</code></pre>\n<p><strong>四、upload.js</strong></p>\n<pre><code class=\"javascript\">export function upload(data) &#123;\n  const img = new Image(); //利用image标签跨域特性\n  const &#123; eventType = &quot;PV&quot; &#125; = options;\n  const params = encodeURIComponent(data) + &quot;&amp;eventType=&quot; + eventType;\n  const src = &quot;http://dmqtest.com?data=&quot; + params;\n  console.log(params, src, eventType);\n  img.src = src;\n  img = null; //注意内存释放\n  return &#123;\n    url: src,\n    data: &#123;\n      params,\n    &#125;,\n  &#125;;\n&#125;\nexport default upload;\n</code></pre>\n<p><strong>五、index.js</strong></p>\n<pre><code>import &#123; sendPV , registerBeforeCreateParams,registerBeforeUpload,registerAfterUpload &#125; from &#39;./collect&#39;;\nimport &#123; upload &#125; from &#39;./upload&#39;;\nwindow.testMonitor = &#123;\n    upload,\n    sendPV,\n    registerBeforeCreateParams,\n    registerBeforeUpload,\n    registerAfterUpload,\n    registerOnError\n&#125;\n</code></pre>\n<p><strong>六、index.html</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; test-app-id=&quot;app123456&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;script src=&quot;https://dmqtest.com/index.js&quot;&gt;&lt;/script&gt;\n  &lt;body test-page-id=&quot;page123456&quot;&gt;\n    &lt;script&gt;\n      window.onload = function () &#123;\n        window.testMonitor.registerBeforeCreateParams(() =&gt; &#123;\n          console.log(&quot;创建之前&quot;);\n        &#125;);\n        window.testMonitor.registerBrforeUpload((params) =&gt; &#123;\n          return params + &quot;&amp;custom=1&quot;; //添加自定义数据\n        &#125;);\n        window.testMonitor.registerAfterUpload((url, data) =&gt; &#123;&#125;);\n        window.testMonitor.sendPV();\n      &#125;;\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h4><p>曝光埋点记录元素由不可变到可变的过程，需要浏览器 IntersectionObserver 这个 API 的支持。</p>\n<p><strong>浏览器 5 种 Observer：</strong></p>\n<ul>\n<li>MutationObserver（用于监听 DOM 树的变化，一般为属性、子节点的增删改）</li>\n<li>IntersectionObserver（用于监听一个元素和可视区域相交部分的比列，然后在可视比列到达某一阈值的时候触发回调）</li>\n<li>PerformanceObserver（用于检测性能度量事件，在浏览器的性能事件轴记录下一个新的 performance entries 的时候将会被通知）</li>\n<li>ResizeObserver（用于监听 DOM 的变化，一般为节点的出现和隐藏，节点大小的变化）</li>\n<li>ReportingObserver（用于监听过时的 api、浏览器的一些干预行为的预告）</li>\n</ul>\n<p><strong>IntersectionObserver：</strong></p>\n<p><strong>方法：</strong></p>\n<ul>\n<li><p>observe：开始监听一个目标元素</p>\n<p>语法：IntersectionObserver.disconnect();</p>\n</li>\n<li><p>disconnect：停止监听</p>\n<p>语法：IntersectionObserver.observe(targetElement);</p>\n</li>\n<li><p>takeRecords:返回所有观察目标的 IntersectionObserverEntry 对象数组。</p>\n<p>语法：intersectionObserverEntries &#x3D; intersectionObserver.takeRecords();</p>\n</li>\n<li><p>unobserve:使 IntersectionObserver 停止监听特定目标元素</p>\n<p>语法：IntersectionObserver.unobserve(targetElement);</p>\n</li>\n</ul>\n<p><strong>配置项：</strong></p>\n<ul>\n<li>targetElement：目标 DOM</li>\n<li>root：指定根目录，也就就是当目标元素显示在这个元素中时会触发监控回调</li>\n<li>rootMargin：类似于 css 的 margin，设定 root 元素的边框区域。</li>\n<li>threhold：阈值，决定了什么时候触发回调函数。</li>\n</ul>\n<p><strong>返回参数：</strong></p>\n<ul>\n<li>tIme:可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>\n<li>rootBounds:是在根元素矩形区域的信息</li>\n<li>intersectionRatio:目标元素的可见比例</li>\n<li>intersectionRect:目标元素与根元素交叉区域的信息</li>\n<li>isIntersecting:判断元素是否符合 options 中的可见条件</li>\n<li>boundingClientRect:目标元素的矩形区域的信息</li>\n<li>target:被观察的目标元素</li>\n</ul>\n<p><strong>upload.js 文件中添加：</strong></p>\n<pre><code class=\"javascript\">// ....省略\n// 上报曝光埋点\nexport function sendExp(data = &#123;&#125;) &#123;\n  collection(data, &quot;EXP&quot;);\n&#125;\n// 最后在index.js中暴露出去。\n</code></pre>\n<p><strong>collect.js 文件中添加：</strong></p>\n<pre><code class=\"javascript\">//....省略\nexport function collectAppear() &#123;\n  const appearEvent = new CustomEvent(&quot;onAppear&quot;);\n  const disappearEvent = new CustomEvent(&quot;onDisappear&quot;);\n  let ob;\n  if (window.testMonitorObserver) &#123;\n    ob = window.testMonitorObserver;\n  &#125; else &#123;\n    ob = new IntersectionObserver(function (e) &#123;\n      e.forEach((item) =&gt; &#123;\n        if (item.intersectionRatio &gt; 0) &#123;\n          console.log(item.target.className + &quot;appear&quot;);\n          item.target.dispatchEvent(appearEvent);\n        &#125; else &#123;\n          console.log(item.target.className + &quot;disappear&quot;);\n          item.target.dispatchEvent(disappearEvent);\n        &#125;\n      &#125;);\n    &#125;);\n  &#125;\n  let obList = [];\n  const appear = document.querySelectorAll(&quot;[appear]&quot;);\n  for (let i = 0; i &lt; appear.length; i++) &#123;\n    if (obList.includes(appear[i])) &#123;\n      ob.observe(appear[i]);\n      obList.push(appear[i]);\n    &#125;\n  &#125;\n  window.testMonitorObserver = ob; //存起来防止重复\n  window.monitorObserverList = obList;\n&#125;\n</code></pre>\n<p><strong>index.js 中使用：</strong></p>\n<pre><code class=\"javascript\">//...省略\n// import引入collectAppear函数。\nwindow.onload = function () &#123;\n  collectAppear();\n&#125;;\n</code></pre>\n<h4 id=\"点击埋点\"><a href=\"#点击埋点\" class=\"headerlink\" title=\"点击埋点\"></a><strong>点击埋点</strong></h4><p><strong>collect.js 中添加：</strong></p>\n<pre><code class=\"javascript\">//...省略\n//上报点击埋点\nexport function sendClick(data = &#123;&#125;) &#123;\n  collection(data, &quot;CLICK&quot;);\n&#125;\n//暴露出去，index.js导入该方法并暴露出去。\n</code></pre>\n<h4 id=\"自定义埋点\"><a href=\"#自定义埋点\" class=\"headerlink\" title=\"自定义埋点\"></a>自定义埋点</h4><p><strong>collect.js 中添加：</strong></p>\n<p>自定义埋点行为就直接在内部添加 CUSTOM 对应的处理逻辑，可以使用其他的 Observer 实现更多功能。</p>\n<pre><code class=\"javascript\">//...省略\n//上报自定义埋点\nexport function sendCustom(data = &#123;&#125;) &#123;\n  collection(data, &quot;CUSTOM&quot;);\n&#125;\n//暴露出去，index.js导入该方法并暴露出去。\n</code></pre>\n<h2 id=\"大数据平台开发\"><a href=\"#大数据平台开发\" class=\"headerlink\" title=\"大数据平台开发\"></a>大数据平台开发</h2><p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vemgvbWF4Y29tcHV0ZS8jOn46dGV4dD0lRTQlQkElOTElRTUlOEUlOUYlRTclOTQlOUYlRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUlRTglQUUlQTElRTclQUUlOTclRTYlOUMlOEQlRTUlOEElQTEsJTI4TWF4Q29tcHV0ZSUyOSVFNiU5OCVBRiVFNCVCOCU4MCVFNyVBNyU4RCVFNSVCRiVBQiVFOSU4MCU5RiVFMyU4MCU4MSVFNSVBRSU4QyVFNSU4NSVBOCVFNiU4OSU5OCVFNyVBRSVBMSVFNyU5QSU4NFRCJTJGUEIlRTclQkElQTclRTYlOTUlQjAlRTYlOEQlQUUlRTQlQkIlOTMlRTUlQkElOTMlRTglQTclQTMlRTUlODYlQjMlRTYlOTYlQjklRTYlQTElODglRTMlODAlODIlMjBNYXhDb21wdXRlJUU1JTkwJTkxJUU3JTk0JUE4JUU2JTg4JUI3JUU2JThGJTkwJUU0JUJFJTlCJUU0JUJBJTg2JUU1JUFFJThDJUU1JTk2JTg0JUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU1JUFGJUJDJUU1JTg1JUE1JUU2JTk2JUI5JUU2JUExJTg4JUU0JUJCJUE1JUU1JThGJThBJUU1JUE0JTlBJUU3JUE3JThEJUU3JUJCJThGJUU1JTg1JUI4JUU3JTlBJTg0JUU1JTg4JTg2JUU1JUI4JTgzJUU1JUJDJThGJUU4JUFFJUExJUU3JUFFJTk3JUU2JUE4JUExJUU1JTlFJThCJUVGJUJDJThDJUU4JTgzJUJEJUU1JUE0JTlGJUU2JTlCJUI0JUU1JUJGJUFCJUU5JTgwJTlGJUU3JTlBJTg0JUU4JUE3JUEzJUU1JTg2JUIzJUU3JTk0JUE4JUU2JTg4JUI3JUU2JUI1JUI3JUU5JTg3JThGJUU2JTk1JUIwJUU2JThEJUFFJUU4JUFFJUExJUU3JUFFJTk3JUU5JTk3JUFFJUU5JUEyJTk4JUVGJUJDJThDJUU2JTlDJTg5JUU2JTk1JTg4JUU5JTk5JThEJUU0JUJEJThFJUU0JUJDJTgxJUU0JUI4JTlBJUU2JTg4JTkwJUU2JTlDJUFDJUVGJUJDJThDJUU1JUI5JUI2JUU0JUJGJTlEJUU5JTlBJTlDJUU2JTk1JUIwJUU2JThEJUFFJUU1JUFFJTg5JUU1JTg1JUE4JUUzJTgwJTgy\">MaxCompute 阿里云原生大数据计算服务</span>：</strong></p>\n<p>MaxCompute 是基于数据分析场景的企业级 SaaS 模式云数据仓库，以 Serverless 架构提供快速、全托管的在线数据仓库服务，消除了传统数据平台在资源扩展性和弹性方面的限制，最小化用户运维投入。</p>\n<p><strong>使用：</strong></p>\n<ol>\n<li><p>使用 MaxCompute 创建数据库，在数据开发页面创建表进行记录前端监控数据</p>\n</li>\n<li><p>使用 py 脚本对接（暂时没有 js 包），需要安装 python 和 pip（包管理工具）</p>\n</li>\n<li><p>安装 pyodps：<code>pip install pyodps</code></p>\n</li>\n<li><p>connect.py 文件中写入示例：</p>\n<pre><code class=\"python\">from odps import ODPS;\n\nodps = ODPS(&#39;LTAI5tBDj3HajwRVhc6me5KR&#39;,&#39;DJqWAI1IWUBZnZGE#FKDSFJDEJLet&#39;,&#39;test_monitor&#39;,endpoint=&#39;https://service-cn-hangzhou.odps.aliyun-inc.com&#39;)\n\nresult = odps.executexecute_sql(&#39;select * from test_monitor where datetime=&quot;20240325&quot;&#39;)\n\nwith result.open_reader() as reader:\n    for record in reader:\n        print(record[0],record[1])\n# 打印表名\nfor table in odps.list_tables():\n    print(table)\ndata = [\n    [&#39;appid123&#39;,&#39;pageid123&#39;,&#39;123456&#39;,&#39;ua123&#39;,&#39;http://www.baidu.com&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;20240325&#39;,&#39;202403&#39;]\n]\n# 写入数据\nodps.write_table(&#39;test_table&#39;, data)\n# ....等等后续操作\n</code></pre>\n</li>\n</ol>\n<p><strong>前端监控平台可视化架构图：</strong></p>\n<p><img data-src=\"/images/Snipaste_2024-04-30_15-14-09.jpg\" alt=\"前端监控流程架构\"></p>\n","categories":["前端监控"],"tags":["前端监控"]},{"title":"容器化运维操作","url":"/2024/02/02/%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"5-6-容器化运维操作\"><a href=\"#5-6-容器化运维操作\" class=\"headerlink\" title=\"5-6 容器化运维操作\"></a>5-6 容器化运维操作</h1><p>日趋复杂的运维开发环境，对虚拟服务器及应用服务的要求更加的多元化。我们需要更加容易扩展、性能优越、方便监控的管理服务，容器化应用、容器化运维应运而生。</p>\n<p><strong>【知己知彼】你将在学习本课程中学习到：</strong></p>\n<ol>\n<li>理解&#x2F;安装docker容器技术</li>\n<li>秒级快速部署mysql、nginx、tomcat等服务</li>\n<li>使用容器技术发布nodejs应用</li>\n<li>…</li>\n</ol>\n<p><strong>【工欲善其事，必先利其器】你需要准备的环境（三选一）：</strong></p>\n<ul>\n<li>Linux环境(Centos 7以上&#x2F;Debian 8以上&#x2F;Ubuntu 16.04LTS以上版本)</li>\n<li>Windows 64位专业版&#x2F;企业版&#x2F;教育版(Build 15063以上)</li>\n<li>macOS Sierra 10.12以上的版本</li>\n</ul>\n<blockquote>\n<p>如果，你有了上面的环境，就可以很快速的跟着我们的内容快速学习。</p>\n</blockquote>\n<h2 id=\"容器和Docker\"><a href=\"#容器和Docker\" class=\"headerlink\" title=\"容器和Docker\"></a>容器和Docker</h2><h3 id=\"什么是容器化？\"><a href=\"#什么是容器化？\" class=\"headerlink\" title=\"什么是容器化？\"></a>什么是容器化？</h3><p>容器化是将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像的一种软件开发方法。</p>\n<p><img data-src=\"/./assets/docker-containerized-appliction-blue-border_2.png\" alt=\"docker-containerized-appliction-blue-border_2\"></p>\n<p>软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</p>\n<p>容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。因此，容器的占用比虚拟机 (VM) 映像小得多。</p>\n<p>容器化的特点：</p>\n<ul>\n<li>一致的运行环境</li>\n<li>可伸缩性</li>\n<li>更方便的移植</li>\n<li>隔离性</li>\n</ul>\n<h3 id=\"什么是Docker\"><a href=\"#什么是Docker\" class=\"headerlink\" title=\"什么是Docker?\"></a>什么是Docker?</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21vYnkvbW9ieQ==\">Docker</span>是用GO语言开发的应用容器引擎，基于容器化，沙箱机制的应用部署技术。可适用于自动化测试、打包，持续集成和发布应用程序等场景，包括阿里云，亚马逊在内的云计算服务商都采用了docker来打造serverless服务平台。它不仅仅可以部署项目，还可以用于数据库搭建，nginx服务搭建，nodejs、php等编程语言环境搭建。</p>\n<blockquote>\n<p>PS: docker现已改名为moby</p>\n</blockquote>\n<p>Docker中的三个<strong>重要概念</strong>：</p>\n<ul>\n<li><p>镜像(image)：分片的（只读）文件系统，由Dockerfile创建</p>\n<p>独立、易扩展、更效率</p>\n</li>\n<li><p>容器(container)：由Docker进程创建和管理的：文件系统 +  系统资源 + 网络配置 + 日志管理</p>\n<p>docker是docker镜像的运行环境，所以容器的概念就比较好理解了</p>\n</li>\n<li><p>仓库(registry)：用来远端存储docker镜像</p>\n<p>版本控制、变更管理、为持续集成与快速部署提供便利</p>\n</li>\n</ul>\n<h3 id=\"Docker-vs-虚拟机\"><a href=\"#Docker-vs-虚拟机\" class=\"headerlink\" title=\"Docker vs 虚拟机\"></a>Docker vs 虚拟机</h3><p><img data-src=\"/./assets/docker-containerized-and-vm-transparent-bg.png\" alt=\"docker-containerized-and-vm-transparent-bg\"></p>\n<ol>\n<li>容器是应用层的抽象，它将代码和依赖关系打包在一起。 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。 容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。</li>\n<li>虚拟机（VM）是物理硬件的抽象，将一台服务器转变为多台服务器。 管理程序允许多台VM在单台机器上运行。 每个VM都包含操作系统的完整副本，应用程序，必要的二进制文件和库 - 占用数十GB。 虚拟机也可能很慢启动。</li>\n</ol>\n<p><strong>总结一下：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">特性</th>\n<th align=\"left\">容器</th>\n<th align=\"left\">虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">启动</td>\n<td align=\"left\">秒级</td>\n<td align=\"left\">分钟级</td>\n</tr>\n<tr>\n<td align=\"left\">硬盘使用</td>\n<td align=\"left\">一般为 <code>MB</code></td>\n<td align=\"left\">一般为 <code>GB</code></td>\n</tr>\n<tr>\n<td align=\"left\">性能</td>\n<td align=\"left\">接近原生</td>\n<td align=\"left\">弱于</td>\n</tr>\n<tr>\n<td align=\"left\">系统支持量</td>\n<td align=\"left\">单机支持上千个容器</td>\n<td align=\"left\">一般几十个</td>\n</tr>\n<tr>\n<td align=\"left\">开发&#x2F;环境定制</td>\n<td align=\"left\">方便(命令行、面向对象式)</td>\n<td align=\"left\">进入虚拟机</td>\n</tr>\n</tbody></table>\n<p><strong>相同点：</strong></p>\n<ol>\n<li>文件隔离&#x2F;文件共享（沙箱）</li>\n<li>资源隔离</li>\n<li>网络隔离</li>\n<li>支持多种宿主环境（扩展）</li>\n<li>快照&#x2F;镜像（版本控制&#x2F;变更管理）</li>\n</ol>\n<p><strong>不同点：</strong></p>\n<ol>\n<li>不同的资源管理&#x2F;依赖&#x2F;&#x2F;释放（虚拟机占用更多的系统资源）</li>\n<li>不同的应用运行环境</li>\n<li>Docker是写时复制</li>\n<li>不同的日志方式(Docker收集日志，而虚拟机需要在虚拟系统里面看日志)</li>\n<li>不同的交互方式(Docker偏shell，虚拟机偏GUI)</li>\n</ol>\n<h3 id=\"Docker的工作原理-重点\"><a href=\"#Docker的工作原理-重点\" class=\"headerlink\" title=\"Docker的工作原理(重点)\"></a>Docker的工作原理(重点)</h3><p><img data-src=\"/./assets/work.png\" alt=\"work\"></p>\n<p>Docker是容器化部署技术，它主要作用在于通过运行容器来实现应用部署，而容器基于镜像运行。</p>\n<p>简单地说，就是将你的项目和依赖包(基础镜像)打成一个带有启动指令的项目镜像，然后在服务器创建一个容器，让镜像在容器内运行，从而实现项目的部署。</p>\n<p>服务器就是容器的宿主机，docker容器与宿主机之间是相互隔离的。</p>\n<p>Docker 的基础是Linux容器（LXC：Linux Containers）等技术。</p>\n<p><strong>一般情况下：</strong></p>\n<p>Linux(服务器) -&gt; tomcat安装 -&gt; Java依赖 -&gt; maven依赖 -&gt;放置在&#x2F;usr&#x2F;lib目录 -&gt; 配置tomcat端口&#x2F;目录 -&gt; 运行tomcat中的startup.sh脚本 -&gt; 配置网络、防火墙等(后续) -&gt; 服务启动</p>\n<p><strong>Docker：</strong></p>\n<p>使用基于java的tomcat镜像 -&gt; docker run -&gt; 指定端口&#x2F;挂载webapp目录 -&gt; 服务启动</p>\n<p>这其中，发生了什么？</p>\n<ol>\n<li><p>Docker会自己拉取镜像，若本地已经存在该镜像，则不用到网上去拉取</p>\n</li>\n<li><p>创建新的容器</p>\n</li>\n<li><p>分配文件系统并且挂着一个可读写的层，任何修改容器的操作都会被记录在这个读写层上，你可以保存这些修改成新的镜像，也可以选择不保存，那么下次运行改镜像的时候所有修改操作都会被消除</p>\n</li>\n<li><p>分配网络\\桥接接口，创建一个允许容器与本地主机通信的网络接口</p>\n</li>\n<li><p>设置ip地址，从池中寻找一个可用的ip地址附加到容器上，换句话说，localhost并不能访问到容器</p>\n</li>\n<li><p>运行你指定的程序</p>\n</li>\n<li><p>捕获并且提供应用输出，包括输入、输出、报错信息</p>\n</li>\n</ol>\n<p>Docker的价值：</p>\n<p>从应用架构角度：统一复杂的构建环境；</p>\n<p>从应用部署角度：解决依赖不同、构建麻烦的问题，结合自动化工具（如jenkins）提高效率。</p>\n<p>从集群管理角度：规范的服务<strong>调度</strong>，<strong>服务发现</strong>，<strong>负载均衡</strong></p>\n<h2 id=\"常见的应用场景介绍\"><a href=\"#常见的应用场景介绍\" class=\"headerlink\" title=\"常见的应用场景介绍\"></a>常见的应用场景介绍</h2><p>Docker提供了轻量级的虚拟化，相比于虚拟机，可以在同一台机器上创建更多数量的容器。它常见的应用场景：1. 快速部署；2. 隔离应用； 3. 提高开发效率； 4. 版本控制； 5. 简化配置，整合资源； </p>\n<h3 id=\"快速部署\"><a href=\"#快速部署\" class=\"headerlink\" title=\"快速部署\"></a>快速部署</h3><p>我们尝试着来部署一个mysql：</p>\n<pre><code class=\"bash\">docker run -d --name mysql-test -e MYSQL_ROOT_PASSWORD=123456 mysql\n</code></pre>\n<p><img data-src=\"/./assets/3.gif\" alt=\"3\"></p>\n<p>同样的道理，我们来部署一个nginx:</p>\n<p><img data-src=\"/./assets/4.gif\" alt=\"4\"></p>\n<p>注意：这里没有映射服务端口，所以在<code>80</code>端口是看不到<code>index.html</code>中的内容的。需要加入<code>-p</code>参数来映射端口！！</p>\n<pre><code class=\"bash\">docker run -d --name web -p 8000:80 -v $&#123;your_dir&#125;:/usr/share/nginx/html nginx\n</code></pre>\n<h3 id=\"隔离应用\"><a href=\"#隔离应用\" class=\"headerlink\" title=\"隔离应用\"></a>隔离应用</h3><p>我们可以同时跑两个mysql，两个nginx，指定不同的端口进行映射：</p>\n<p>把<code>mysql-test1</code>映射到<code>8001</code>端口，把<code>mysql-test2</code>映射到<code>8002</code>端口。</p>\n<pre><code class=\"bash\">docker run -d --name mysql-test1 -p 8001:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\ndocker run -d --name mysql-test2 -p 8002:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\n</code></pre>\n<p>把web1映射到8100端口，把web2映射到8200端口。</p>\n<pre><code class=\"bash\">docker run -d --name web1 -p 8100:80 -v $&#123;your_dir&#125;:/usr/share/nginx/html nginx\ndocker run -d --name web2 -p 8200:80 -v $&#123;your_dir&#125;:/usr/share/nginx/html nginx\n</code></pre>\n<h3 id=\"提高开发效率\"><a href=\"#提高开发效率\" class=\"headerlink\" title=\"提高开发效率\"></a>提高开发效率</h3><ol>\n<li><p>一致的运行环境</p>\n<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n</li>\n<li><p>更快速的启动时间</p>\n</li>\n</ol>\n<p>   传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>\n<ol start=\"3\">\n<li><p>更高效的复用系统资源</p>\n<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n</li>\n<li><p>仓库&#x2F;镜像机制</p>\n<p>使用仓库可以方便的在任何有docker进程的虚拟机&#x2F;服务器&#x2F;主机上运行docker应用，环境的统一，让它们的部署变的非常的简单。</p>\n</li>\n</ol>\n<h3 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h3><p>Docker容器还可以像git仓库一样，可以让你提交变更到Docker镜像中并通过不同的版本来管理它们，来看看下面的例子：</p>\n<p>我们之前创建了一个<code>mysql</code>，现在，我们使用<code>commit</code>命令就可以给它做一个快照，打上一个<code>tag</code>。</p>\n<p><img data-src=\"/./assets/5.gif\" alt=\"5\"></p>\n<p>在后面的课程中，我们会详细的介绍<a href=\"#Docker%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(%E9%87%8D%E7%82%B9)\">Docker的常见命令</a></p>\n<h3 id=\"DevOps流程\"><a href=\"#DevOps流程\" class=\"headerlink\" title=\"DevOps流程\"></a>DevOps流程</h3><p>对开发和运维（<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRGV2T3Bz\">DevOps</span>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>\n<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2UvaW1hZ2UvZG9ja2VyZmlsZQ==\">Dockerfile</span> 来进行镜像构建，并结合 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludW91c19pbnRlZ3JhdGlvbg==\">持续集成(Continuous Integration)</span> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludW91c19kZWxpdmVyeQ==\">持续部署(Continuous Delivery&#x2F;Deployment)</span> 系统进行自动部署。</p>\n<p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h2 id=\"使用Docker\"><a href=\"#使用Docker\" class=\"headerlink\" title=\"使用Docker\"></a>使用Docker</h2><h3 id=\"Docker如何进行安装\"><a href=\"#Docker如何进行安装\" class=\"headerlink\" title=\"Docker如何进行安装\"></a>Docker如何进行安装</h3><h4 id=\"关于系统需求-重点\"><a href=\"#关于系统需求-重点\" class=\"headerlink\" title=\"关于系统需求(重点)\"></a>关于系统需求(重点)</h4><ol>\n<li>平台类</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作系统</th>\n<th align=\"center\">x86_64</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci1tYWMvaW5zdGFsbC8=\">Docker Desktop for Mac (macOS)</span></td>\n<td align=\"center\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZG9ja2VyLWZvci13aW5kb3dzL2luc3RhbGwv\">Docker Desktop for Windows (Microsoft Windows 10)</span></td>\n<td align=\"center\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>服务器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">平台</th>\n<th align=\"left\">x86_64 &#x2F; amd64</th>\n<th align=\"left\">ARM</th>\n<th align=\"left\">ARM64 &#x2F; AARCH64</th>\n<th align=\"left\">IBM Power (ppc64le)</th>\n<th align=\"left\">IBM Z (s390x)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvY2VudG9zLw==\">CentOS</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvZGViaWFuLw==\">Debian</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvZmVkb3JhLw==\">Fedora</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/fedora/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/fedora/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vaW5zdGFsbC9saW51eC9kb2NrZXItY2UvdWJ1bnR1Lw==\">Ubuntu</span></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n<td align=\"left\"><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\"><img data-src=\"https://docs.docker.com/install/images/green-check.svg\" alt=\"yes\"></a></td>\n</tr>\n</tbody></table>\n<h4 id=\"Linux-重点\"><a href=\"#Linux-重点\" class=\"headerlink\" title=\"Linux(重点)\"></a>Linux(重点)</h4><p>对于中国用户：</p>\n<pre><code class=\"shell\">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n</code></pre>\n<p>对于国外vps：</p>\n<pre><code>curl -fsSL https://get.docker.com -o get-docker.sh\nsh get-docker.sh\n</code></pre>\n<blockquote>\n<p>脚本介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9kb2NrZXItaW5zdGFsbA==\">https://github.com/docker/docker-install</span></p>\n</blockquote>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>安装Docker的系统需求：</p>\n<ul>\n<li>系统版本：Windows 10 64bit: Pro, Enterprise or Education (Build 15063 or later).</li>\n<li>在BIOS中开启了虚拟化（virtualization），正常情况下会默认开启，去系统管理中看看有没有Hyper-v被安装了。</li>\n<li>CPU特性：SLAT-capable.</li>\n<li>4GB以上的内存</li>\n</ul>\n<blockquote>\n<p>如果不满足上面的需求，则需要使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vdG9vbGJveC9vdmVydmlldy8=\">Docker Toolbox</span>，相当于是运行了一个virtualbox的虚拟镜像。</p>\n</blockquote>\n<h4 id=\"MacOS\"><a href=\"#MacOS\" class=\"headerlink\" title=\"MacOS\"></a>MacOS</h4><p><strong>方法一官方<code>dmg</code>：</strong></p>\n<p>官方下载地址：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9lZGl0aW9ucy9jb21tdW5pdHkvZG9ja2VyLWNlLWRlc2t0b3AtbWFj\">Docker Descktop for Mac</span></p>\n<p>对系统的要求：</p>\n<blockquote>\n<p>Requires Apple Mac OS Sierra 10.12 or above. Download <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vdG9vbGJveC9vdmVydmlldy8=\">Docker Toolbox</span> for previous OS versions.</p>\n</blockquote>\n<p>只要系统是 Mac OS Sierra 10.12以上即可。</p>\n<p>下载完<code>Docker.dmg</code>安装包之后，双击即可以安装，可能需要系统管理员权限，输入密码即可。</p>\n<p>运行过后，小图标：</p>\n<p><img data-src=\"/./assets/2.gif\" alt=\"2\"></p>\n<p>安装完之后，在终端工具中，使用<code>docker version</code>来查看Docker版本。</p>\n<p><img data-src=\"/./assets/docker-version.jpg\" alt=\"docker-version\"></p>\n<p><strong>方法二brew cask：</strong></p>\n<pre><code class=\"shell\">brew update \n\nbrew cask install docker\n\n# 删除的方法, 还需要手动删除Docker.app\nbrew cask uninstall docker\n</code></pre>\n<p>上面的命令将会把Docker安装在<code>Applications</code>目录下。</p>\n<h3 id=\"Docker国内加速\"><a href=\"#Docker国内加速\" class=\"headerlink\" title=\"Docker国内加速\"></a>Docker国内加速</h3><ol>\n<li>Docker的Toolbox镜像站(推荐)，主要是针对低版本的windows与mac用户：</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9kb2NrZXItdG9vbGJveC8=\">http://mirrors.aliyun.com/docker-toolbox/</span></p>\n<ol start=\"2\">\n<li>Docker镜像加速，主要是对<code>docker pull</code>拉取镜像操作进行网络加速优化：</li>\n</ol>\n<p>需要注册阿里云的账号，登录<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20v\">容器Hub服务</span>，在左侧的加速器帮助页面就会显示为你独立分配的加速地址。</p>\n<p><img data-src=\"/./assets/image-20190524172015448.png\" alt=\"/images/image-20190524172015448\"></p>\n<h3 id=\"第一个Docker应用hello-world\"><a href=\"#第一个Docker应用hello-world\" class=\"headerlink\" title=\"第一个Docker应用hello world\"></a>第一个Docker应用hello world</h3><ol>\n<li><p>查看docker版本</p>\n</li>\n<li><p>运行第一个Docker应用</p>\n<p>使用<code>docker run</code>命令</p>\n</li>\n<li><p>查看容器运行状态</p>\n<p>使用<code>docker ps</code>命令来查看正在运行的容器的状态，<code>-a</code>参数来查看所有的已经运行的容器(无论是否停止)</p>\n</li>\n</ol>\n<p><img data-src=\"/./assets/1.gif\" alt=\"1\"></p>\n<h3 id=\"Docker常见命令-重点\"><a href=\"#Docker常见命令-重点\" class=\"headerlink\" title=\"Docker常见命令(重点)\"></a>Docker常见命令(重点)</h3><ul>\n<li><p>**创建<code>run</code>**，<code>-p</code> 映射宿主机的端口给镜像服务使用，<code>-v</code> 挂载宿主机的文件目录到镜像里面去，-it是提供交互式的终端工具，<code>-d</code> 是让镜像容器在后台去持续运行,<code>--name</code> 指定容器的名称，exec可以进入到容器里面去：</p>\n<pre><code>docker exec -it &lt;container_name&gt; /bin/bash\n\ndocker exec -it &lt;container_name&gt; /bin/sh\n</code></pre>\n</li>\n<li><p><strong>启动<code>start</code>&#x2F;停止<code>stop</code>&#x2F;重启<code>restart</code>&#x2F;删除已停止容器<code>rm</code></strong></p>\n</li>\n<li><p><strong>登录仓库<code>login</code>&#x2F;拉取镜像<code>pull</code>&#x2F;推送<code>push</code>&#x2F;提交镜像<code>commit</code>&#x2F;给指定容器标签<code>tag</code></strong></p>\n<p>docker hub上去注册我们的账号，才能使用login</p>\n<p>使用docker commit来给运行中的容器打tag:</p>\n<pre><code>docker commit &lt;container_id&gt; &lt;namespace&gt;/&lt;image_name&gt;:tag\n</code></pre>\n<pre><code>docker commit e12b80defe8c itcast/mysql\n</code></pre>\n<p>使用<code>pull</code>&#x2F;<code>push</code>命令来推送本地的镜像到远程仓库</p>\n<pre><code>docker pull/push &lt;namespace&gt;/&lt;image_name&gt;:tag\n</code></pre>\n</li>\n<li><p>查看所有本地镜像<code>images</code>&#x2F;删除本地镜像<code>rmi</code></p>\n<p>删除镜像之前，要停止<code>stop</code>并且删除<code>rm</code>运行中的容器。</p>\n</li>\n<li><p>查看容器服务打印的日志<code>logs</code>&#x2F;检阅容器<code>inspect</code>(更详细的容器信息，硬件&#x2F;网络&#x2F;版本等)&#x2F;进入容器<code>exec</code></p>\n</li>\n<li><p>查看版本<code>version</code>&#x2F;docker进程信息<code>info</code></p>\n</li>\n<li><p>查看命令帮助：</p>\n</li>\n</ul>\n<pre><code>docker &lt;run/pull&gt; --help\n</code></pre>\n<h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><h3 id=\"制作Docker镜像-重点\"><a href=\"#制作Docker镜像-重点\" class=\"headerlink\" title=\"制作Docker镜像(重点)\"></a>制作Docker镜像(重点)</h3><p>Dockerfile 是一个由一堆命令+参数构成的脚本，使用 <code>docker build</code> 即可执行脚本构建镜像，自动的去做一些事，主要用于进行持续集成。</p>\n<p>一般，Dockerfile 共包括四部分：</p>\n<ul>\n<li>基础镜像信息</li>\n<li>维护者信息</li>\n<li>镜像操作指令</li>\n<li>容器启动时执行指令</li>\n</ul>\n<p>当Node.js遇见Docker，下面介绍Docker在前端中的应用：</p>\n<p>一个简单的Koa应用：</p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\n// response\napp.use(ctx =&gt; &#123;\n  ctx.body = &#39;Hello Koa!!&#39;;\n&#125;);\n\napp.listen(3000);\n</code></pre>\n<p>Dockerfile示例：</p>\n<pre><code class=\"dockerfile\">FROM node:10\n\nLABEL maintainer=itheima@itcast.cn\n\n# 创建 app 目录\nWORKDIR /app\n\n# 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)\nCOPY [&quot;package.json&quot;,&quot;*.lock&quot;,&quot;./&quot;]\n\n# 打包 app 源码\n# 特别注意：要指定工作目录中的文件名\nCOPY src ./src\n\n# 使用.dockerignore文件，上面两个COPY合并成一个\n# COPY . .\n\n# 使用Yarn安装 app 依赖\n# 如果你需要构建生产环境下的代码，请使用：\n# --prod参数\nRUN yarn --prod --registry=https://registry.npm.taobao.org\n\n# 对外暴露端口 -p 4000:3000\nEXPOSE 3000\n\nCMD [ &quot;node&quot;, &quot;src/index.js&quot; ]\n</code></pre>\n<p>使用<code>docker build</code>打包：</p>\n<pre><code class=\"shell\">docker build -t $&#123;your_name&#125;/$&#123;image_name&#125;:$&#123;tag&#125; .\n</code></pre>\n<p>这里的<code>your_name</code>代表的是远程仓库中的用户名，或者仓库地址; <code>image_name</code>为镜像名称，<code>tag</code>是给镜像打的标签，用于版本控制。例如：</p>\n<pre><code class=\"shell\">docker build -t itheima/node-demo:1.0 .\n</code></pre>\n<p>打包过程：</p>\n<pre><code class=\"bash\">$ docker build -t itheima/node-demo:1.0 .\nSending build context to Docker daemon  17.92kB\nStep 1/8 : FROM node:10\n ---&gt; 5a401340b79f\nStep 2/8 : LABEL maintainer=itheima@itcast.cn\n ---&gt; Using cache\n ---&gt; dd01419f30d5\nStep 3/8 : WORKDIR /app\n ---&gt; Using cache\n ---&gt; bb9a44851ec9\nStep 4/8 : COPY . .\n ---&gt; Using cache\n ---&gt; b08ff37c5456\nStep 5/8 : RUN ls -la /app\n ---&gt; Using cache\n ---&gt; 4e0e57e807a1\nStep 6/8 : RUN yarn --prod --registry=https://registry.npm.taobao.org\n ---&gt; Using cache\n ---&gt; 96ab842b4766\nStep 7/8 : EXPOSE 3000\n ---&gt; Using cache\n ---&gt; 505dda4e680f\nStep 8/8 : CMD [ &quot;node&quot;, &quot;src/index.js&quot; ]\n ---&gt; Using cache\n ---&gt; f60e25a577de\nSuccessfully built f60e25a577de\nSuccessfully tagged itheima/node-demo:1.0\n</code></pre>\n<p><strong>回顾前面的知识：</strong></p>\n<p>如何使用？</p>\n<p>还记得<code>docker run</code>命令吗？</p>\n<pre><code class=\"bash\">docker run -d --name nodedemo -p 3000:3000 itheima/node-demo:1.0\n</code></pre>\n<p>然后使用<code>docker ps</code>来看运行状态</p>\n<pre><code class=\"bash\">$ docker run -d --name nodedemo -p 3000:3000 itheima/node-demo:1.0\nc863da9afea1558593843233aec08989184d8dafbb0f8443830d1e523104ab00\n$ docker ps\nCONTAINER ID        IMAGE                   COMMAND               CREATED             STATUS              PORTS                    NAMES\nc863da9afea1        itheima/node-demo:1.0   &quot;node src/index.js&quot;   2 seconds ago       Up 1 second         0.0.0.0:3000-&gt;3000/tcp   nodedemo\n</code></pre>\n<h3 id=\"Docker-compose介绍\"><a href=\"#Docker-compose介绍\" class=\"headerlink\" title=\"Docker-compose介绍\"></a>Docker-compose介绍</h3><p>通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p>\n<p><img data-src=\"/./assets/docker-compose.png\" alt=\"docker-compose\"></p>\n<p>Compose 中有两个重要的概念：</p>\n<ul>\n<li>服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li>\n</ul>\n<p>Docker Compose 是 Docker 的独立产品，因此需要安装 Docker 之后在单独安装 Docker Compose .</p>\n<p><strong>安装方法：</strong></p>\n<pre><code class=\"bash\">#下载\nsudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n#安装\nchmod +x /usr/local/bin/docker-compose\n#查看版本\ndocker-compose --version\n</code></pre>\n<p><strong>常见使用：</strong></p>\n<p>前面的例子，使用<code>docker-compose</code>改写：</p>\n<pre><code class=\"yaml\">version: &#39;3&#39;\nservices:\n  mysql:\n    image: mysql\n    container_name: test-mysql\n    ports:\n    - &quot;8000:3306&quot;\n    environment:\n    - MYSQL_ROOT_PASSWORD=123456\n</code></pre>\n<p>在此文件的当前目录下，使用<code>docker-compose up -d</code>来执行。</p>\n<p>生命周期管理：</p>\n<p>创建：<code>run</code>&#x2F;<code>up</code></p>\n<p>启动&#x2F;停止&#x2F;删除&#x2F;重启：<code>start/stop/rm/restart</code></p>\n<p>检视&#x2F;日志：<code>logs</code>&#x2F;<code>ps</code></p>\n<p>看两个个复杂的应用：</p>\n<p>搭建本地mongo + mongo-express服务</p>\n<pre><code class=\"yaml\">version: &#39;3.1&#39;\nservices:\n  mongo:\n    image: mongo\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: root\n      MONGO_INITDB_ROOT_PASSWORD: 123456\n\n  mongo-express:\n    image: mongo-express\n    restart: always\n    ports:\n      - 8081:8081\n    environment:\n      ME_CONFIG_MONGODB_ADMINUSERNAME: root\n      ME_CONFIG_MONGODB_ADMINPASSWORD: 123456\n</code></pre>\n<p>给公司搭建一个git服务器吧？！</p>\n<p>项目地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhbWVlcnNibi9kb2NrZXItZ2l0bGFi\">https://github.com/sameersbn/docker-gitlab</span></p>\n<p>推荐服务器配置：适用于10人的小团队~~~~</p>\n<p>2core</p>\n<p>2GB+2GB(swap) </p>\n<pre><code class=\"yaml\">version: &#39;2&#39;\n\nservices:\n  redis:\n    restart: always\n    image: sameersbn/redis:4.0.9-1\n    command:\n    - --loglevel warning\n    volumes:\n    - /srv/docker/gitlab/redis:/var/lib/redis:Z\n\n  postgresql:\n    restart: always\n    image: sameersbn/postgresql:10\n    volumes:\n    - /srv/docker/gitlab/postgresql:/var/lib/postgresql:Z\n    environment:\n    - DB_USER=gitlab\n    - DB_PASS=password\n    - DB_NAME=gitlabhq_production\n    - DB_EXTENSION=pg_trgm\n\n  gitlab:\n    restart: always\n    image: sameersbn/gitlab:11.11.0\n    depends_on:\n    - redis\n    - postgresql\n    ports:\n    - &quot;10080:80&quot;\n    - &quot;10022:22&quot;\n    volumes:\n    - /srv/docker/gitlab/gitlab:/home/git/data:Z\n    environment:\n    - DEBUG=false\n\n    - DB_ADAPTER=postgresql\n    - DB_HOST=postgresql\n    - DB_PORT=5432\n    - DB_USER=gitlab\n    - DB_PASS=password\n    - DB_NAME=gitlabhq_production\n\n    - REDIS_HOST=redis\n    - REDIS_PORT=6379\n\n    - TZ=Asia/Kolkata\n    - GITLAB_TIMEZONE=Kolkata\n\n    - GITLAB_HTTPS=false\n    - SSL_SELF_SIGNED=false\n\n    - GITLAB_HOST=localhost\n    - GITLAB_PORT=10080\n    - GITLAB_SSH_PORT=10022\n    - GITLAB_RELATIVE_URL_ROOT=\n    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string\n    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string\n    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string\n\n    - GITLAB_ROOT_PASSWORD=123456\n    - GITLAB_ROOT_EMAIL=itheima@itcast.cn\n...\n</code></pre>\n<p>docker-compose在前端里面的使用：</p>\n<p>Nodejs + mongodb + koa + vue的应用组合：</p>\n<p>特别注意：</p>\n<p>视频中，我们使用vue是在局部安装的，所以使用npx命令在进行创建。</p>\n<p>vue官网推荐大家进行全局安装:</p>\n<pre><code class=\"bash\">npm i -g @vue/cli\n\n# 然后使用\nvue create myproject\n</code></pre>\n<p> docker-compose.yml</p>\n<pre><code class=\"yaml\">version: &#39;3&#39;\nservices:\n  web:\n    image: web:1.0\n    ports:\n    - &quot;8080:80&quot;\n\n  server:\n    image: server:1.0\n    ports:\n    - &quot;3000:3000&quot;\n    depends_on:\n    - mongodb\n    links:\n    - mongodb:db\n\n  mongodb:\n    image: mongo\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: root\n      MONGO_INITDB_ROOT_PASSWORD: 123456\n</code></pre>\n<p><code>depends_on</code> 决定了容器加载的先后顺序，这里<code>mongdb</code>、<code>web</code>先加载，<code>mongdb</code>创建完成之后，再来创建<code>server</code>。</p>\n<h3 id=\"自学补充知识\"><a href=\"#自学补充知识\" class=\"headerlink\" title=\"自学补充知识\"></a>自学补充知识</h3><ol>\n<li>什么是Kubernetes?</li>\n</ol>\n<p>Kubernetes, 中文意思是舵手或导航员，它是一个容器集群管理系统，主要职责是容器编排（Container Orchestration）——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。</p>\n<p>文档: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLw==\">https://kubernetes.io/zh/</span></p>\n<p>集群相关：<span class=\"exturl\" data-url=\"aHR0cDovL21lc29zLmFwYWNoZS5vcmcv\">Mesos</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9zd2FybQ==\">Docker Swarm</span></p>\n<ol start=\"2\">\n<li>简单的DevOps流程介绍：</li>\n</ol>\n<p><img data-src=\"/./assets/devOps-8692746.jpeg\" alt=\"devOps\"></p>\n<p>参考链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDcwNDY1\">从一张图看Devops全流程</span></p>\n<ol start=\"3\">\n<li>Docker中的文件系统，深入理解原理：</li>\n</ol>\n<p><img data-src=\"/./assets/%E4%B8%80%E5%9B%BE%E7%9C%8B%E5%B0%BDDocker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png\" alt=\"一图看尽Docker容器文件系统\"></p>\n<ol start=\"4\">\n<li><p>Docker的一般开发流程介绍：</p>\n<ul>\n<li>寻找基础镜像</li>\n<li>基于基础镜像编写Dockerfile脚本</li>\n<li>根据Dockerfile脚本创建项目镜像</li>\n<li>将创建的镜像推送到docker仓库 (根据自身需要，可做可不做)</li>\n<li>基于项目镜像创建并运行docker容器 (实现最终部署)</li>\n</ul>\n<p>这里面如果一扩展，就变成了自动化开发流程，比如：加入版本控制git -&gt; 使用webhook -&gt; jenkins自动打包  -&gt; docker自动构建 -&gt; 推送镜像 -&gt; 生产环境部署</p>\n</li>\n</ol>\n<h2 id=\"课程资源\"><a href=\"#课程资源\" class=\"headerlink\" title=\"课程资源\"></a>课程资源</h2><p>Docker for Mac【系统：10.12以上】: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL21hYy9zdGFibGUvRG9ja2VyLmRtZw==\">https://download.docker.com/mac/stable/Docker.dmg</span></p>\n<p>Docker for Windows【系统：专业版及企业版】: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL3dpbi9zdGFibGUvRG9ja2VyJTIwZm9yJTIwV2luZG93cyUyMEluc3RhbGxlci5leGU=\">https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe</span></p>\n<p>Docker ToolBox for Mac【系统：10.10.3以上】: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL21hYy9zdGFibGUvRG9ja2VyVG9vbGJveC5wa2c=\">https://download.docker.com/mac/stable/DockerToolbox.pkg</span> </p>\n<p>Docker ToolBox for Windows【系统：windows7以上】：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5kb2NrZXIuY29tL3dpbi9zdGFibGUvRG9ja2VyVG9vbGJveC5leGU=\">https://download.docker.com/win/stable/DockerToolbox.exe</span></p>\n","categories":["容器化运维操作"],"tags":["容器化运维操作"]},{"title":"前端性能优化","url":"/2024/03/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"<h1 id=\"5-1-前端性能优化\"><a href=\"#5-1-前端性能优化\" class=\"headerlink\" title=\"5-1 前端性能优化\"></a>5-1 前端性能优化</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>任何小型企业，博主或成长型公司在网上出现时面临的最大挑战之一就是“页面加载时间”问题。除非您能确保尽可能快速无缝地加载每个页面，您才可以拥有世界上最好最引人注目的网站，否则您仍然无法赢得关注者的尊重和忠诚度。</p>\n<p>根据当今网络上的所有主要浏览器公司的说法，如果每个网站都想要排名靠前，表现良好并确保客户满意，那么每个网站都需要快。毕竟，如果您的网页加载速度很慢，那么您会立即增加客户开始在其他地方搜索信息，而不是坚持下去的风险。</p>\n<p>这也是为什么很多公司去找专门的技术人员来做 SEO（<strong>Search Engine Optimization</strong>），即搜索引擎优化。 因为，页面的加载会影响到爬虫的爬取，页面加载速度是一项非常重要的指标。况且，页面优化直接影响到了用户体验。所以学习前端性能优化势在必行。</p>\n<p><strong>经常有面试官会问：从用户输入浏览器输入 url 到页面最后呈现 有哪些过程？有什么办法能优化页面性能？</strong></p>\n<p>答案大致如下：</p>\n<ol>\n<li>用户输入 URL 地址</li>\n<li>浏览器解析 URL 解析出主机名</li>\n<li>浏览器将主机名转换成服务器 ip 地址（浏览器先查找本地 DNS 缓存列表 没有的话 再向浏览器默认的 DNS 服务器发送查询请求 同时缓存）</li>\n<li>浏览器将端口号从 URL 中解析出来</li>\n<li>浏览器建立一条与目标 Web 服务器的 TCP 连接（三次握手）</li>\n<li>浏览器向服务器发送一条 HTTP 请求报文</li>\n<li>服务器向浏览器返回一条 HTTP 响应报文</li>\n<li>关闭连接 浏览器解析文档</li>\n<li>如果文档中有资源 重复 6 7 8 动作 直至资源全部加载完毕</li>\n</ol>\n<p><img data-src=\"/images/image-20190619100048897.png\" alt=\"/images/image-20190619100048897\"></p>\n<p>再深一点层次：会问到<strong>渲染机制</strong>，重排、重绘</p>\n<p>重排：</p>\n<ol>\n<li><p>定义：DOM 结构中的各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为 reflow。</p>\n</li>\n<li><p>触发 Reflow：</p>\n<ul>\n<li>当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint</li>\n<li>当你移动 DOM 的位置，或是搞个动画的时候</li>\n<li>当你修改 CSS 样式的时候</li>\n<li>当你 Resize 窗口的时候(移动端没有这个问题)，或者是滚动的时候</li>\n<li>当你修改网页的</li>\n</ul>\n<blockquote>\n<p>最常问：如何减少 Reflow?或者避免 Reflow？</p>\n</blockquote>\n</li>\n</ol>\n<p>重绘：</p>\n<ol>\n<li><p>定义：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。</p>\n<blockquote>\n<p>页面要呈现的内容，通通都绘制到页面上。</p>\n</blockquote>\n</li>\n<li><p>触发 Repaint</p>\n<ul>\n<li>DOM 改动</li>\n<li>CSS 改动</li>\n</ul>\n<blockquote>\n<p>最常问：如何避免最小程序的 Repaint？</p>\n</blockquote>\n</li>\n</ol>\n<p>既然页面的性能优化这么重要，<strong>你知道有哪些原因是影响页面性能的？</strong>比如…</p>\n<ul>\n<li>HTTP 请求</li>\n<li>复杂的页面逻辑(JS 设计)</li>\n<li>重度的 DOM 操作</li>\n<li>服务端响应</li>\n<li>大量的数据</li>\n</ul>\n<p>…</p>\n<p><strong>有哪些办法可以加速我们的页面性能？比如…</strong></p>\n<ul>\n<li>资源压缩与合并（代码打包）</li>\n<li>异步加载</li>\n<li>CDN</li>\n<li>DNS 预解析</li>\n<li>缓存</li>\n</ul>\n<p>…</p>\n<p><strong>主要内容：</strong></p>\n<ul>\n<li>页面加载缓慢原因分析</li>\n<li>性能优化原则</li>\n<li>优化工具介绍</li>\n<li>浏览器的工作机制，了解一些基本常识的原理：<ol>\n<li>为什么要将 js 放到页脚部分</li>\n<li>引入样式的几种方式的权重</li>\n<li>css 属性书写顺序建议</li>\n<li>何种类型的 DOM 操作是耗费性能的</li>\n</ol>\n</li>\n</ul>\n<p><strong>收获</strong></p>\n<ul>\n<li>前端页面优化，为成为 SEO 路添砖加瓦</li>\n<li>写出优质代码，页面性能蹭蹭蹭的往上走</li>\n<li>面试如果提到页面优化，可以娓娓道来，牛皮吹的飞起…</li>\n<li>几种常见的页面优化工具的使用 PageSpeed，JSPerf</li>\n</ul>\n<p><strong>准备：</strong></p>\n<ul>\n<li>注册 github 账号</li>\n</ul>\n<h2 id=\"页面性能优化\"><a href=\"#页面性能优化\" class=\"headerlink\" title=\"页面性能优化\"></a>页面性能优化</h2><p>前端性能优化可以分为两大部分：浏览器部分、代码部分。</p>\n<p>浏览器部分又可以分为：</p>\n<ul>\n<li>网络层面</li>\n<li>浏览器渲染层面</li>\n<li>服务端层面</li>\n</ul>\n<p>代码部分又可以分为：</p>\n<ul>\n<li>构建层面</li>\n<li>编码层面</li>\n<li>机制(SSR，英文 Server Side Render：服务器端渲染)</li>\n<li>规范</li>\n</ul>\n<p>首先来看看浏览器部分：前端的页面主要在浏览器上运行着，那么我们追根溯源，从浏览器的原理开始，研究如何进行页面性能优化。</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 <span class=\"exturl\" data-url=\"aHR0cDovL2dzLnN0YXRjb3VudGVyLmNvbS8=\">StatCounter 浏览器统计数据</span>，目前（2019 年 6 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率 62.7%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p>\n<p><img data-src=\"/images/image-20190618165435861.png\" alt=\"/images/image-20190618165435861\"></p>\n<h4 id=\"浏览器的主要作用\"><a href=\"#浏览器的主要作用\" class=\"headerlink\" title=\"浏览器的主要作用\"></a>浏览器的主要作用</h4><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这些网络资源包括以下内容：</p>\n<ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript 的</li>\n<li>媒体（图片，视频等）</li>\n</ul>\n<p>也可以分为 HTML 文档(HTML&#x2F;CSS&#x2F;JS)、PDF、图片、视频和其他类型。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>\n<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>\n<ul>\n<li>用来输入 URI 的地址栏</li>\n<li>前进和后退按钮</li>\n<li>书签设置选项</li>\n<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>\n<li>用于返回主页的主页按钮</li>\n</ul>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。</p>\n<p><strong>有一些比较有趣的事情：</strong></p>\n<p>Safari 是乔布斯在 2003 年的 Macworld 大会发布的，9 年过去了，08 年才发展起来的 Chrome 用了不到 Safari 一半的时间远远把 Safari 甩在了后面，这让 Safari 情何以堪。</p>\n<p>两大浏览器都是基于苹果的布局引擎 Webkit，按道理 Safari 是占优势的，因为两者都分别是自己操作系统的默认浏览器，许多人就顺便使用了，懒得去下载别的浏览器。</p>\n<p>许多人可能会想，这还不简单，Chrome 运行于 Windows 操作系统，而 Safari 大部分时候都用于苹果自己的系统，Windows .VS. OS X，哪个使用人群广？很显然是前者，所以 Chrome 当然比 Safari 发真快，<strong>可是，实际上 Safari 要比 Chrome 更早登陆 Windows。</strong></p>\n<p>在 2007 年六月，Safari for Windows Beta 版就已经发布，正式版于 2008 年三月发布，而 Chrome 直到 2008 年的九月才发布，Chrome 只用了一年的时间就超过了 Safari。</p>\n<p>大量 Benchmark 测试表明 Chrome 不管在网页打开还是 JavaScript 表现方面，速度都最快。</p>\n<p>但是，当 Safari 发布 Windows 版的时候，测试结果也是一样的，不管在 Mac 还是 PC 上测试，那时候都是最快的，如果仅仅是因为速度，那么 Safari 在 2007 年六月的表现就应该和 chrome 在 2008 年九月的时候一样。</p>\n<p>难道 Chrome 胜在插件？也许，不过 Safari 在 2010 年年中的时候也有了许多插件，当然，Chrome 的插件质量更好更丰富，如果这也足够让 Safari 落后于 Chrome，那么开发商们可能早就将游戏植入 Chrome，而且，Firefox 也先于 Chrome 和 Safari 植入插件，现在不也败给了 Chrome 吗？</p>\n<p>主要原因：</p>\n<ol>\n<li>Safari 用起来不舒服，google 推广给力</li>\n<li>独特的用户体验(UI、交互、云、Google 全家桶)</li>\n</ol>\n<p><strong>那么 Safari 就一文不值了？</strong></p>\n<p>但是，Mac 上的用户使用 safari 更加的省电、省资源，稳定性会更好。<strong>插件不需要爬梯子！！！</strong>更低的学习成本。</p>\n<p><strong>IE(Internet Explorer)的黑历史：</strong></p>\n<p>IE 浏览器的开发应该是在 1994 年中开始的，那是我还在读大学。微软为了对抗当时的主流浏览器 NetScape，准备开发自己的浏览器并在 Windows 中默认捆绑销售。但是，留给微软的时间并不充裕，他们没时间从零开始，于是和 Spyglass 合作开发，于是，计算机历史上最著名也最臭名昭著的浏览器 IE 诞生了。因为强大的功能和捆绑策略，IE 迅速击败了 NetScape，成为浏览器市场的绝对霸主。</p>\n<p>在 2002 年，IE 已经拥有了 95%的市场份额，几乎打败了所有的竞争对手。大为僵，又不思进取，于是颠覆者前仆后继。Firefox 开始迅速崛起，Chrome 后来居上，反观 IE，出现了各种安全漏洞和兼容性问题。2006 年，IE 被评为“史上第八糟科技产品”。在相当长的时间里，<strong>IE 浏览器是前端程序员员的噩梦</strong>。</p>\n<p>带给我们的思考：</p>\n<ul>\n<li>软件迭代更新的重要性(居安思危)</li>\n<li>用户体验、用户感知的重要性(人性化产品)</li>\n<li>互联网时代，什么都是可以替代的</li>\n<li>分享、免费、共筑共赢才是互联网的精神</li>\n</ul>\n<h4 id=\"浏览器的组成结构\"><a href=\"#浏览器的组成结构\" class=\"headerlink\" title=\"浏览器的组成结构\"></a>浏览器的组成结构</h4><p><img data-src=\"/images/layers.png\" alt=\"img\"></p>\n<ol>\n<li><p><strong>用户界面（User Interface）</strong> - 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</p>\n</li>\n<li><p><strong>浏览器引擎（Browser engine）</strong> - 在用户界面和渲染引擎之间传送指令。</p>\n</li>\n<li><p><strong>渲染引擎（Rendering engine）</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</p>\n<blockquote>\n<p>也可以叫呈现引擎（Rendering Engine）或者布局引擎（Layout Engine）</p>\n</blockquote>\n<p>默认情况下，渲染引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>\n<p>浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种渲染引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>渲染引擎（开发语言）</th>\n<th>脚本引擎（开发语言）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Chrome</td>\n<td>Blink (c++)</td>\n<td>V8 (c++)</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td>Blink (c++)</td>\n<td>V8 (c++)</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Webkit (c++)</td>\n<td>JavaScript Core (nitro)</td>\n</tr>\n<tr>\n<td>FireFox</td>\n<td>Gecko (c++)</td>\n<td>SpiderMonkey (c&#x2F;c++)</td>\n</tr>\n<tr>\n<td>Edge</td>\n<td>EdgeHTML (c++)</td>\n<td>Chakra JavaScript Engine (c++)</td>\n</tr>\n<tr>\n<td>IE</td>\n<td>Trident (c++)</td>\n<td>Chakra JScript Engine (c++)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Firefox 在 2017 年启用了新的 web 引擎 Quantum，Quantum 以 Gecko 引擎为基础，同时利用了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvcnVzdA==\">Rust</span> 的良好并发性和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlcnZvL3NlcnZv\">Servo</span> 的高性能组件，为 Firefox 带来了更多的并行化和 GPU 运算，让 Firefox 更快更可靠。</p>\n<p>2015 年 3 月，微软将放弃自家 Edge：转而开发 Chromium 内核浏览器。</p>\n</blockquote>\n<p>它们的开发时间轴：</p>\n<p><img data-src=\"/images/image-20190618172835156.png\" alt=\"/images/image-20190618172835156\"></p>\n<p>WebKit 是一种开放源代码渲染引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 <span class=\"exturl\" data-url=\"aHR0cDovL3dlYmtpdC5vcmcv\">webkit.org</span></p>\n</li>\n<li><p><strong>网络（Networking）</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</p>\n</li>\n<li><p><strong>用户界面后端（UI Backend）</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</p>\n</li>\n<li><p><strong>JavaScript 解释器（JavaScript Interpreter）</strong>。用于解析和执行 JavaScript 代码，如 V8 引擎。</p>\n<p>JS 引擎线程负责解析 Javascript 脚本，运行代码。</p>\n<p><strong>JS 引擎一直等待任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中只有一个 JS 线程在运行</strong></p>\n</li>\n<li><p><strong>数据存储（Data Persistence）</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</p>\n</li>\n</ol>\n<h4 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h4><blockquote>\n<p>进程线程简单的理解：进程里面可以有多个线程，进程就是 QQ，线程就是会话。</p>\n</blockquote>\n<ul>\n<li>浏览器是多进程的</li>\n<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>\n<li>简单点理解，每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。</li>\n</ul>\n<p>浏览器里面的进程：</p>\n<ol>\n<li><p>Browser 进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p>\n<ul>\n<li>负责浏览器界面显示，与用户交互。如前进，后退等</li>\n<li>负责各个页面的管理，创建和销毁其他进程</li>\n<li>将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上</li>\n<li>网络资源的管理，下载等</li>\n</ul>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p>\n</li>\n<li><p>GPU 进程：最多一个，用于 3D 绘制等</p>\n</li>\n<li><p>渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）</p>\n<ul>\n<li>默认每个 Tab 页面一个进程，互不影响。</li>\n<li>主要作用为页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ol>\n<p>渲染进程是多线程的：</p>\n<ol>\n<li><p>GUI 渲染线程</p>\n<ul>\n<li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li>\n<li><strong>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</strong></li>\n<li>注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li>\n</ul>\n</li>\n<li><p>js 引擎线程</p>\n<ul>\n<li>也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）</li>\n<li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li>\n<li><strong>JS 引擎一直等待任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中只有一个 JS 线程在运行</strong></li>\n<li><strong>同样注意，GUI 渲染线程与 JS 引擎线程是互斥的。所以如果 JS 执行的时间过长，要放在 body 下面，否则就会导致页面渲染加载阻塞。</strong></li>\n</ul>\n</li>\n<li><p>事件触发线程</p>\n<ul>\n<li>管理着事件队列</li>\n<li>监听事件，符合条件时把回调函数放入事件队列中</li>\n</ul>\n</li>\n<li><p>定时触发器线程</p>\n<ul>\n<li>setInterval 与 setTimeout 在此线程中计时完毕后，把回调函数放入事件队列中</li>\n<li><strong>浏览器定时计数器并不是由 JavaScript 引擎计数的</strong>,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确），因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li>\n<li>注意，W3C 在 HTML 标准中规定，规定要求<strong>setTimeout 中低于 4ms 的时间间隔算为 4ms</strong>。</li>\n</ul>\n</li>\n<li><p>异步 http 请求线程</p>\n<ul>\n<li>检测到 XHR 对象状态变化时，将回调函数放入事件队列中</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n<p>了解 一下，执行线：</p>\n<p><img data-src=\"/images/image-20190619165952240.png\" alt=\"/images/image-20190619165952240\"></p>\n</li>\n</ol>\n<p><strong>渲染线程与 JS 引擎线程互斥</strong></p>\n<p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>\n<p>因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起， GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。</p>\n<p>举一个简单的例子：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n      // 页面上的hello world不会变成红色\n      document.getElementById(&quot;app&quot;).style.color = &quot;red&quot;;\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;hello world!&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><strong>JS 阻塞页面加载</strong></p>\n<p>从上述的互斥关系，可以推导出，JS 如果执行时间过长就会阻塞页面。</p>\n<p>譬如，假设 JS 引擎正在进行巨量的计算，此时就算 GUI 有更新，也会被保存到队列中，等待 JS 引擎空闲后执行。 然后，由于巨量计算，所以 JS 引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p>\n<p>所以，要尽量避免 JS 执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>\n<p>总结一下：</p>\n<ul>\n<li>css 加载不会阻塞 DOM 树解析（异步加载时 DOM 照常构建），但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）</li>\n<li>Javascript 阻塞 DOM 解析</li>\n</ul>\n<h4 id=\"浏览器的渲染机制\"><a href=\"#浏览器的渲染机制\" class=\"headerlink\" title=\"浏览器的渲染机制\"></a>浏览器的渲染机制</h4><p>对于渲染，我们首先需要了解一个概念：设备刷新率。</p>\n<p>设备刷新率是设备屏幕渲染的频率，通俗一点就是，把屏幕当作墙，设备刷新率就是多久重新粉刷一次墙面。基本我们平常接触的设备，如手机、电脑，它们的默认刷新频率都是 60FPS，也就是屏幕在 1s 内渲染 60 次，约 16.7ms 渲染一次屏幕。</p>\n<p>这就意味着，我们的浏览器最佳的渲染性能就是所有的操作在一帧 16.7ms 内完成，能否做到一帧内完成直接决定着渲染性，影响用户交互。</p>\n<p>渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的<strong>基本流程</strong>：</p>\n<p><img data-src=\"/images/flow.png\" alt=\"img\"></p>\n<p>渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI0RPTQ==\">DOM</span> 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI1JlbmRlcl90cmVlX2NvbnN0cnVjdGlvbg==\">呈现树</span>。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI2xheW91dA==\">布局</span>”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsvI1BhaW50aW5n\">绘制</span> - 渲染引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p>\n<blockquote>\n<p>那么我们知道了，CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。</p>\n</blockquote>\n<p>具体的流程：</p>\n<ul>\n<li>DOM 树与 CSSOM 树合并后形成渲染树。</li>\n<li>渲染树只包含渲染网页所需的节点。</li>\n<li>布局计算每个对象的精确位置和大小。</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。</li>\n</ul>\n<p><img data-src=\"/images/render-tree-construction.png\" alt=\"DOM CSSOM RenderTree\"></p>\n<blockquote>\n<p>请注意 <code>visibility: hidden</code> 与 <code>display: none</code> 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (<code>display: none</code>) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。</p>\n</blockquote>\n<p>我们以 webkit 的渲染作为示例：</p>\n<p><img data-src=\"/images/webkitflow.png\" alt=\"img\"></p>\n<p>我们可以使用调试工具来看一个真实的例子：</p>\n<p><img data-src=\"/images/image-20190618182337662.png\" alt=\"/images/image-20190618182337662\"></p>\n<p><code>script</code>标签的处理</p>\n<p>JS 可以操作 DOM 来修改 DOM 结构，可以操作 CSSOM 来修改节点样式，这就导致了浏览器在解析 HTML 时，一旦碰到<code>script</code>，就会立即停止 HTML 的解析（而 CSS 不会），执行 JS，再返还控制权。</p>\n<p>事实上，JS 执行前不仅仅是停止了 HTML 的解析，它还必须等待 CSS 的解析完成。当浏览器碰到<code>script</code>元素时，发现该元素前面的 CSS 还未解析完，就会等待 CSS 解析完成，再去执行 JS。</p>\n<p>JS 阻塞了 HTML 的解析，也阻塞了其后的 CSS 解析，整个解析进程必须等待 JS 的执行完成才能够继续，这就是所谓的 JS 阻塞页面。一个 script 标签，推迟了 DOM 的生成、CSSOM 的生成以及之后的所有渲染过程，从性能角度上讲，将<code>script</code>放在页面底部，也就合情合理了。</p>\n<p>简单来说：渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时渲染线程会被挂起（相当于被冻结了），渲染更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p>\n<p>总结一下：</p>\n<p>浏览器的渲染流程分为：</p>\n<ul>\n<li>DOM 树构建</li>\n<li>CSSOM 树构建</li>\n<li>RenderObject 树构建</li>\n<li>布局</li>\n<li>绘制</li>\n</ul>\n<h4 id=\"重排-reflow-与重绘-repaint\"><a href=\"#重排-reflow-与重绘-repaint\" class=\"headerlink\" title=\"重排 reflow 与重绘 repaint\"></a>重排 reflow 与重绘 repaint</h4><p><strong>重排 reflow</strong></p>\n<p>reflow 指的是重新计算页面布局。</p>\n<p>某个节点 reflow 时会重新计算节点的尺寸和位置，而且还有可能触发其子节点、祖先节点和页面上的其他节点 reflow。在这之后再触发一次 repaint。</p>\n<p>当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流,每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>\n<p>导致 reflow 的操作</p>\n<ul>\n<li>调整窗口大小</li>\n<li>改变字体</li>\n<li>增加或者移除样式表</li>\n<li>内容变化，比如用户在 input 框中输入文字</li>\n<li>激活 CSS 伪类，比如 :hover (IE 中为兄弟结点伪类的激活)</li>\n<li>操作 class 属性</li>\n<li>脚本操作 DOM</li>\n<li>计算 offsetWidth 和 offsetHeight 属性</li>\n<li>设置 style 属性的值</li>\n</ul>\n<p>触发页面重布局的一些 css 属性</p>\n<ul>\n<li>盒子模型相关属性会触发重布局<ul>\n<li><code>width</code></li>\n<li><code>height</code></li>\n<li><code>padding</code></li>\n<li><code>margin</code></li>\n<li><code>display</code></li>\n<li><code>border-width</code></li>\n<li><code>border</code></li>\n<li><code>min-height</code></li>\n</ul>\n</li>\n<li>定位属性及浮动也会触发重布局<ul>\n<li><code>top</code></li>\n<li><code>bottom</code></li>\n<li><code>left</code></li>\n<li><code>right</code></li>\n<li><code>position</code></li>\n<li><code>float</code></li>\n<li><code>clear</code></li>\n</ul>\n</li>\n<li>改变节点内部文字结构也会触发重布局<ul>\n<li><code>text-align</code></li>\n<li><code>overflow-y</code></li>\n<li><code>font-weight</code></li>\n<li><code>overflow</code></li>\n<li><code>font-family</code></li>\n<li><code>line-height</code></li>\n<li><code>vertical-align</code></li>\n<li><code>white-space</code></li>\n<li><code>font-size</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>重绘 repaint</strong></p>\n<p>repiant 或者 redraw 遍历所有的节点检测各节点的可见性、颜色、轮廓等可见的样式属性，然后根据检测的结果更新页面的响应部分。</p>\n<p>当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘</p>\n<p>只触发重绘不触发重排的一些 CSS 属性：</p>\n<ul>\n<li><code>color</code></li>\n<li><code>border-style</code>、<code>border-radius</code></li>\n<li><code>visibility</code></li>\n<li><code>text-decoration</code></li>\n<li><code>background</code>、<code>background-image</code>、<code>background-position</code>、<code>background-repeat</code>、<code>background-size</code></li>\n<li><code>outline</code>、<code>outline-color</code>、<code>outline-style</code>、<code>outline-width</code></li>\n<li><code>box-shadow</code></li>\n</ul>\n<p>我们来看一个例子：</p>\n<pre><code class=\"javascript\">var bstyle = document.body.style; // cache\n\nbstyle.padding = &quot;20px&quot;; // reflow, repaint\nbstyle.border = &quot;10px solid red&quot;; //  再一次的 reflow 和 repaint\n\nbstyle.color = &quot;blue&quot;; // repaint\nbstyle.backgroundColor = &quot;#fad&quot;; // repaint\n\nbstyle.fontSize = &quot;2em&quot;; // reflow, repaint\n\n// new DOM element - reflow, repaint\ndocument.body.appendChild(document.createTextNode(&quot;dude!&quot;));\n</code></pre>\n<p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就 reflow 或 repaint 一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是有些情况浏览器是不会这么做的，比如：resize 窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行 reflow。</p>\n<p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些 DOM 值：</p>\n<p><strong>减少重绘与重排：</strong></p>\n<p>重绘和回流在实际开发中是很难避免的，我们能做的就是尽量减少这种行为的发生。</p>\n<ul>\n<li><p>js 尽量少访问 dom 节点和 css 属性，尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面 reflow，可以先把该 dom 节点抽离到内存中进行复杂的操作然后再 display 到页面上。(虚拟 DOM)</p>\n</li>\n<li><p>减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</p>\n</li>\n<li><p>不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸</p>\n</li>\n<li><p>尽量通过 class 来设计元素样式，切忌用 style 多次操作单个属性</p>\n<pre><code class=\"javascript\">// bad\nvar left = 10,\n  top = 10;\nel.style.left = left + &quot;px&quot;;\nel.style.top = top + &quot;px&quot;;\n\n// Good\nel.className += &quot; theclassname&quot;;\n\n// Good\nel.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;\n</code></pre>\n</li>\n<li><p>尽可能的为产生动画的 HTML 元素使用 <code>fixed</code> 或 <code>absolute</code> 的 <code>position</code> ，那么修改他们的 CSS 是不会 Reflow 的。</p>\n</li>\n<li><p>img 标签要设置高宽，以减少重绘重排</p>\n</li>\n<li><p>把 DOM 离线后修改，如将一个 dom 脱离文档流，比如<code>display：none</code> ，再修改属性，这里只发生一次回流。</p>\n</li>\n<li><p>尽量用 <code>transform</code> 来做形变和位移，不会造成回流</p>\n</li>\n<li><p>权衡速度的平滑。比如实现一个动画，以 1 个像素为单位移动这样最平滑，但 reflow 就会过于频繁，CPU 很快就会被完全占用。如果以 3 个像素为单位移动就会好很多。</p>\n</li>\n<li><p>不要用 tables 布局的另一个原因就是 tables 中某个元素一旦触发 reflow 就会导致 table 里所有的其它元素 reflow。在适合用 table 的场合，可以设置 table-layout 为 auto 或 fixed，</p>\n</li>\n<li><p>避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</p>\n</li>\n</ul>\n<blockquote>\n<p>PS: display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</p>\n</blockquote>\n<p>总结一下：</p>\n<p>重排：元素的尺寸变了、位置变了</p>\n<p>重绘：元素的颜色、背景、边框、轮廓变了，但是，元素的几何尺寸没有变。</p>\n<p>Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。</p>\n<h3 id=\"页面加载缓慢的原因\"><a href=\"#页面加载缓慢的原因\" class=\"headerlink\" title=\"页面加载缓慢的原因\"></a>页面加载缓慢的原因</h3><p><img data-src=\"/images/browser-rendering.gif\" alt=\"browser-rendering\"></p>\n<p><img data-src=\"/images/backend-generation.gif\" alt=\"backend-generation\"></p>\n<p><img data-src=\"/images/wpo-front-backend.png\" alt=\"wpo-front-backend\"></p>\n<h4 id=\"浏览器部分\"><a href=\"#浏览器部分\" class=\"headerlink\" title=\"浏览器部分\"></a>浏览器部分</h4><ul>\n<li><p>网络层面</p>\n<ol>\n<li><p>过多的 HTTP 请求</p>\n<p>打开一个网页的时候，后台程序的响应并不所需太多时间，等待的时间主要花费在下载网页元素上了，即 HTML、CSS、JavaScript、Flash、图片等。据统计，每增加一个元素，网页载入的时间就会增加 25-40 毫秒（具体取决于用户的带宽情况）。</p>\n</li>\n<li><p>资源访问带宽小</p>\n<p>两方面，一方面是客户端的带宽，一方面是服务器端的带宽。</p>\n</li>\n<li><p>网页元素(图片、视频、样式)太大</p>\n</li>\n</ol>\n</li>\n<li><p>浏览器渲染层面</p>\n<ol>\n<li><p>渲染阻塞：</p>\n<p>浏览器想要渲染一个页面就必须先构建出<code>DOM</code>树与<code>CSSOM</code>树，如果<code>HTML</code>与<code>CSS</code>文件结构非常庞大与复杂，这显然会给页面加载速度带来严重影响。</p>\n<p>所谓渲染阻塞资源，即是对该资源发送请求后还需要先构建对应的<code>DOM</code>树或<code>CSSOM</code>树，这种行为显然会延迟渲染操作的开始时间。</p>\n<p>JS 阻塞与 CSS 阻塞：</p>\n<p><strong>HTML、CSS、JavaScript 都是会对渲染产生阻塞的资源，HTML 是必需的（没有 DOM 还谈何渲染），但还可以从 CSS 与 JavaScript 着手优化，尽可能地减少阻塞的产生。</strong></p>\n</li>\n<li><p>重复渲染</p>\n</li>\n<li><p>DNS 解析</p>\n</li>\n</ol>\n</li>\n<li><p>服务端层面</p>\n<ol>\n<li>硬件配置低：这个是双向的</li>\n<li>服务器软件，比如防火墙、内网策略等</li>\n<li>未对 Nginx 这类 web 服务器进行配置优化</li>\n<li>CPU 占满、数据库未优化</li>\n<li>代码问题，代码效率，代码性能</li>\n<li>包含了过多的分析类工具</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"代码部分\"><a href=\"#代码部分\" class=\"headerlink\" title=\"代码部分\"></a>代码部分</h4><ul>\n<li><p>构建层面</p>\n<p>未对代码进行打包、压缩、兼容性优化。</p>\n<p>未合并重复的请求、代码。</p>\n</li>\n<li><p>编码层面</p>\n<p>没有良好的编码习惯，错误的编排 JS 与 CSS</p>\n<p>for 循环、迭代、同步、重定向、阻塞请求</p>\n<p>未删除重复、无用的代码</p>\n<p>未对逻辑业务复杂的代码进行重构，了解设计模式，对业务进行疏理</p>\n</li>\n<li><p>机制(SSR，英文 Server Side Render：服务器端渲染)</p>\n<p>未加入 Async 异步机制</p>\n<p>未思考页面加载、用户体验</p>\n</li>\n<li><p>规范</p>\n<p>CSS 规范</p>\n<p>HTML 规范&#x2F;HTML5 规范</p>\n<p>Airbnb 代码规范等。</p>\n</li>\n</ul>\n<h3 id=\"优化原则\"><a href=\"#优化原则\" class=\"headerlink\" title=\"优化原则\"></a>优化原则</h3><h4 id=\"尽量减少-HTTP-请求\"><a href=\"#尽量减少-HTTP-请求\" class=\"headerlink\" title=\"尽量减少 HTTP 请求\"></a>尽量减少 HTTP 请求</h4><p>在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。</p>\n<p>一个正常 HTTP 请求的流程简述：如在浏览器中输入”<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy54eHh4eHguY29t\">www.xxxxxx.com&quot;并按下回车，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。</span></p>\n<p>而当我们请求的网页文件中有很多图片、CSS、JS 甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个 HTTP 请求都会对服务器和浏览器产生性能负担。</p>\n<p>网速相同的条件下，下载一个 100KB 的图片比下载两个 50KB 的图片要耗费的网络资源更多。所以，请减少 HTTP 请求。</p>\n<p><strong>具体的方法：</strong></p>\n<ol>\n<li><p>组合文件，优化图片，使用 sprites 设计风格: 将背景图片合并成一个文件，通过<code>background-image</code> 和 <code>background-position</code> 控制显示；</p>\n<p>确保您的图像不大于它们所需的图像，它们采用正确的文件格式（PNG 通常更适用于少于 16 种颜色的图形，而 JPEG 通常更适合照片）并且它们是针对 Web 压缩的。</p>\n<p>使用 CSS sprites 在网站上经常使用的图像创建模板，如按钮和图标。CSS sprites 将您的图像组合成一个大图像，一次加载所有（这意味着更少的 HTTP 请求），然后只显示您想要显示的部分。这意味着您通过不让用户等待加载多个图像来节省加载时间。</p>\n<p>有一些在线工具：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zcHJpdGVjb3cuY29tLw==\">Sprite Cow</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3ByaXRlYm94Lm5ldC8=\">Spritebox</span></li>\n</ul>\n</li>\n<li><p>肉联图片，使用<code>data:URL</code>方案将图像数据嵌入实际页面中。这可以增加 HTML 文档的大小。将内嵌图像组合到（缓存的）样式表中是一种减少 HTTP 请求并避免增加页面大小的方法。</p>\n</li>\n<li><p>简化页面的设计</p>\n</li>\n</ol>\n<h4 id=\"使用内容传送网络-CDN\"><a href=\"#使用内容传送网络-CDN\" class=\"headerlink\" title=\"使用内容传送网络 CDN\"></a>使用内容传送网络 CDN</h4><p>内容分发网络（CDN），也称为内容传送网络，是用于分发传送内容的负载的服务器网络。从本质上讲，您网站的副本存储在多个地理位置不同的数据中心，以便用户可以更快，更可靠地访问您的网站。</p>\n<p>对于初创公司和私人网站来说，CDN 服务的成本可能过高，但随着您的目标受众变得越来越大并变得更加全球化，CDN 对于实现快速响应时间是必要的。</p>\n<p>请记住，最终用户响应时间的 80-90％用于下载页面中的所有组件：图像，样式表，脚本，Flash 等。这是<em>Performance Golden Rule</em>。而不是从重新设计应用程序架构的艰巨任务开始，最好首先分散您的静态内容。这不仅可以大大缩短响应时间，而且由于内容交付网络，它更容易实现。</p>\n<p>内容传送网络（CDN）是分布在多个位置的 Web 服务器的集合，以更有效地向用户传送内容。选择用于向特定用户传送内容的服务器通常基于网络接近度的度量。例如，选择具有最少网络跳数的服务器或具有最快响应时间的服务器。</p>\n<blockquote>\n<p>CDN 服务商有很多，这里就不再多说：专门做 CDN 服务器的蓝讯、网宿、帝联、快网，还有阿里云、腾讯云、华为云等。国外如<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ha2FtYWkuY29tLw==\">Akamai Technologies</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5lZGdlY2FzdC5jb20v\">EdgeCast</span>或<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZXZlbDMuY29tL2luZGV4LmNmbT9wYWdlSUQ9MzY=\">level3</span></p>\n</blockquote>\n<p>除了去购买一些 CDN 服务商的服务以外，对于大多数开发者，可以使用公共 CDN 网络上的资源，如以下的方式去使用 CDN 加速：</p>\n<pre><code class=\"html\">&lt;!-- google --&gt;\n&lt;script\n  type=&quot;text/javascript&quot;\n  src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js&quot;\n&gt;&lt;/script&gt;\n\n&lt;!-- cdnjs --&gt;\n&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n&lt;!-- qiniu cloud --&gt;\n&lt;script src=&quot;https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n&lt;!-- other cdn --&gt;\n&lt;script\n  crossorigin=&quot;anonymous&quot;\n  integrity=&quot;sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh&quot;\n  src=&quot;https://lib.baomitu.com/jquery/3.4.1/jquery.min.js&quot;\n&gt;&lt;/script&gt;\n</code></pre>\n<h4 id=\"避免空-src-或者是-href-值\"><a href=\"#避免空-src-或者是-href-值\" class=\"headerlink\" title=\"避免空 src 或者是 href 值\"></a>避免空 src 或者是 href 值</h4><p>空的 src 和 href 都会导致多余的 HTTP 请求，虽然不影响加载时间，但是会对服务器产生不必要的流量和压力。浏览器仍然会向服务器发起一个 HTTP 请求：</p>\n<ul>\n<li>IE 向页面所在的目录发送请求</li>\n<li>Safari、Chrome、Firefox 向页面本身发送请求</li>\n<li>Opera 不执行任何操作</li>\n</ul>\n<p>空的 src 的 image 严重的以至于影响整个网站的用户体验，空 <code>src</code> 产生请求的后果不容小憩：</p>\n<ul>\n<li>给服务器造成意外的流量负担，尤其时日 PV 较大时；</li>\n<li>浪费服务器计算资源；</li>\n<li>可能产生报错。</li>\n</ul>\n<p>有两种形式：</p>\n<ol>\n<li><p>HTML 形式</p>\n<pre><code class=\"html\">&lt;img src=&quot;&quot; /&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n</code></pre>\n</li>\n<li><p>JavaScript 形式</p>\n<pre><code class=\"javascript\">var img = new Image();\nimg.src = &quot;&quot;;\n</code></pre>\n</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>删除空的<code>src</code>和<code>href</code>标签</li>\n<li>给<code>a</code>标签的<code>href</code>属性，连接到实际的页面：</li>\n</ol>\n<pre><code class=\"html\">&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;#nogo&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;##&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;###&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;void(0);&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;void(0)&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;;&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n</code></pre>\n<ol start=\"3\">\n<li>禁止跳转，添加<code>cursor:pointer</code>样式</li>\n</ol>\n<pre><code class=\"html\">&lt;style&gt;\n  a &#123;\n    cursor: pointer;\n  &#125;\n&lt;/style&gt;\n&lt;a&gt;点击一&lt;/a&gt;\n&lt;a onclick=&quot;doSomething()&quot;&gt;点击二&lt;/a&gt;\n</code></pre>\n<ol start=\"4\">\n<li>给<code>a</code> 标签创建一个带有描述信息的<code>href</code> 属性，并监控<code>click</code>事件调用<code>preventDefault()</code>函数。</li>\n</ol>\n<pre><code class=\"html\">&lt;a href=&quot;#Something_De scriptive&quot; id=&quot;my_id&quot;&gt;Trigger&lt;/a&gt;\n&lt;script&gt;\n  $(&quot;#my_id&quot;).click(function (e) &#123;\n    e.preventDefault(); //取消单击事件的默认动作以阻止链接的跳转。\n    //  其他的代码\n  &#125;);\n&lt;/script&gt;\n</code></pre>\n<p>优点：</p>\n<ul>\n<li>让<code>&lt;a&gt;</code>够响应键盘事件并获得焦点（从而屏幕阅读器能够读出背后的内容，增强可访问性）</li>\n<li>优雅降级，在网络连接很差，还没有加载到 CSS 的时候，<code>&lt;a&gt;</code>依然有手型与正常的 link 样式。</li>\n</ul>\n<h4 id=\"gzip-的组件\"><a href=\"#gzip-的组件\" class=\"headerlink\" title=\"gzip 的组件\"></a>gzip 的组件</h4><p>所有现代浏览器都支持 <code>gzip</code> 压缩并会为所有 HTTP 请求自动协商此类压缩。启用 <code>gzip</code> 压缩可大幅缩减所传输的响应的大小（最多可缩减 90%），从而显著缩短下载相应资源所需的时间、减少客户端的流量消耗并加快网页的首次呈现速度。</p>\n<p>从 HTTP &#x2F; 1.1 开始，Web 客户端表示支持使用 HTTP 请求中的 Accept-Encoding 标头进行压缩。</p>\n<pre><code>Accept-Encoding：gzip，deflate\n</code></pre>\n<p>压缩包括 XML 和 JSON 在内的任何文本响应都是值得的。不应对图像和 PDF 文件进行 gzip 压缩，因为它们已经过压缩。试图对它们进行 gzip 不仅会浪费 CPU，还可能会增加文件大小。</p>\n<p>比如，在 nginx 中开启 gzip 压缩：</p>\n<pre><code class=\"bash\"># 开启gzip\ngzip on;\n# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\ngzip_min_length 1k;\n# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\ngzip_comp_level 2;\n# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;\n# 是否在http header中添加Vary: Accept-Encoding，建议开启\ngzip_vary on;\n# 禁用IE 6 gzip\ngzip_disable &quot;MSIE [1-6]\\.&quot;;\n</code></pre>\n<p>其他 web 容器启动 gzip 的方法：</p>\n<ul>\n<li>Apache：使用 <span class=\"exturl\" data-url=\"aHR0cDovL2h0dHBkLmFwYWNoZS5vcmcvZG9jcy9jdXJyZW50L21vZC9tb2RfZGVmbGF0ZS5odG1s\">mod_deflate</span></li>\n<li>Nginx：使用 <span class=\"exturl\" data-url=\"aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfZ3ppcF9tb2R1bGUuaHRtbA==\">ngx_http_gzip_module</span></li>\n<li>IIS：<span class=\"exturl\" data-url=\"aHR0cDovL3RlY2huZXQubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjNzcxMDAzKHY9V1MuMTApLmFzcHg=\">配置 HTTP 压缩功能</span></li>\n</ul>\n<h4 id=\"CSS-放在顶部，JS-放在底部\"><a href=\"#CSS-放在顶部，JS-放在底部\" class=\"headerlink\" title=\"CSS 放在顶部，JS 放在底部\"></a>CSS 放在顶部，JS 放在底部</h4><p>把 Javascript 脚本在底部，删除阻止渲染的 JavaScript<br>在 HTML 文件<code>&lt;body&gt;</code>中指定外部样式表和内联样式块可能对浏览器的渲染性能产生不利影响。</p>\n<ol>\n<li>浏览器阻塞渲染网页直到所有外部的样式表都已被下载。</li>\n<li>（用<code>&lt;style&gt;</code>标记指定的）内联样式块可能会导致 reflows 和页面跳动。<br>因此，把外部样式表和内联样式块放在页面的<code>&lt;head&gt;</code>中是很重要的。通过确保样式表首先被下载和解析，可以让浏览器逐步渲染页面。</li>\n</ol>\n<p>具体做法：</p>\n<ul>\n<li><p>将内联样式块和<code>&lt;link&gt;</code>元素从页面<code>&lt;body&gt;</code>移动到页面<code>&lt;head&gt;</code>中。</p>\n<p>HTML 4.01 规范（第 12.3 节）规定，始终把使用<code>&lt;link&gt;</code>标签的外部样式表放在<code>&lt;head&gt;</code>部分里，还要确保您指定的样式有正确的顺序。</p>\n</li>\n<li><p>把<code>&lt;style&gt;</code>区块放在<code>&lt;head&gt;</code>部分里。</p>\n</li>\n<li><p>使用 css 媒体类型</p>\n</li>\n</ul>\n<p>如果可以让<code>CSS</code>资源只在特定条件下使用，这样这些资源就可以在首次加载时先不进行构建<code>CSSOM</code>树，只有在符合特定条件时，才会让浏览器进行阻塞渲染然后构建<code>CSSOM</code>树。</p>\n<p><code>CSS</code>的媒体查询正是用来实现这个功能的，它由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。</p>\n<pre><code class=\"html\">&lt;!-- 没有使用媒体查询，这个css资源会阻塞渲染  --&gt;\n&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;\n&lt;!-- all是默认类型，它和不设置媒体查询的效果是一样的 --&gt;\n&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; media=&quot;all&quot; /&gt;\n&lt;!-- 动态媒体查询， 将在网页加载时计算。\n根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。--&gt;\n&lt;link href=&quot;portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation:portrait&quot; /&gt;\n&lt;!-- 只在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。 --&gt;\n&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; /&gt;\n</code></pre>\n<p>使用媒体查询可以让 CSS 资源不在首次加载中阻塞渲染，但不管是哪种 CSS 资源它们的下载请求都不会被忽略，浏览器仍然会先下载 CSS 文件。</p>\n<p><strong>把 Javascript 脚本在底部，删除阻止渲染的 JavaScript</strong></p>\n<p>浏览器必须通过在呈现页面之前解析 HTML 来构建 DOM 树。如果您的浏览器在此过程中遇到脚本，则必须先停止并执行它，然后才能继续。</p>\n<p>具体做法：</p>\n<p>将脚本定义或引用放置到<code>&lt;body&gt;</code>底部。<br><code>&lt;script defer=&quot;defer&quot;&gt;</code> defer 属性规定是否对脚本执行进行延迟， 脚本将在页面完成解析时执行。</p>\n<p><img data-src=\"/images/bVcQV0.jpeg\" alt=\"请输入图片描述\"></p>\n<p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>\n<p>此图告诉我们以下几个要点：</p>\n<ol>\n<li><code>defer</code>和 <code>async</code> 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>\n<li>它俩的差别在于脚本下载完之后何时执行，显然 <code>defer</code>*是最接近我们对于应用脚本加载和执行的要求的</li>\n<li>关于 <code>defer</code>，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>\n<li><code>async</code> 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>\n<li>仔细想想，<code>async</code>对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>\n</ol>\n<h4 id=\"减少-DNS-查找\"><a href=\"#减少-DNS-查找\" class=\"headerlink\" title=\"减少 DNS 查找\"></a>减少 DNS 查找</h4><p>用户访问网站的过程如下：</p>\n<ol>\n<li><p>在地址栏输入网站地址，如<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbS8=\">www.example.com</span>;</p>\n</li>\n<li><p>本地 DNS 得到这个请求，查询本地 DNS 缓存，如果有这条记录，则直接返回对应的 IP；否则，请求网络上的 DNS 服务器，得到相应的 IP，返回给客户机，并缓存这条记录；</p>\n</li>\n<li><p>浏览器向得到的 IP 发起建立连接请求，得到响应后建立连接，请求数据；</p>\n</li>\n<li><p>Server 端计算所需数据，并返回给 client 端；</p>\n</li>\n<li><p>client 端，即浏览器，解析数据并显示在浏览器窗口中，至此，请求完成。</p>\n</li>\n</ol>\n<p>在 一次请求中，DNS 解析可以占到请求时间的三分之一左右（这点有待验证），所以如果可以缩短 DNS 解析时间，就可以加快页面的打开速度。</p>\n<p>缩短 DNS 解析的 方法可以<strong>通过延长 DNS 缓存的时间</strong>，<strong>选用更快的 DNS Server</strong>，<strong>减少域名总数</strong>（例如原来有 5 个 img server，分别为 img1.xxx.com 至 img5.xxx.com，则现在可以减少到 3 个）等等，但是减少域名个数又会降低资源并行下载的数量， 因为同一域名最多可以并行下载两个资源，所以这里需要一个折衷方案，作者的建议就是将资源分布在大于等于 2 但小于等于 4 个域名上（这个也有待验证，例如针 对多大的系统选用多少个域名是最合理的等）。</p>\n<p><strong>使用 DNS 预解析</strong></p>\n<p>这里会有一些兼容性问题，可以参见：<span class=\"exturl\" data-url=\"aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWxpbmstcmVsLWRucy1wcmVmZXRjaA==\">http://caniuse.com/#feat=link-rel-dns-prefetch</span></p>\n<p><img data-src=\"/images/sdfdsf.png\" alt=\"sdfdsf\"></p>\n<p>在网页体验中我们常会遇到这种情况，即在调用百度联盟、谷歌联盟以及当前网页所在域名外的域名文件时会遇到请求延时非常严重的情况。那么有没有方法去解决这种请求严重延时的现象呢？</p>\n<p>一般来说这种延时的原因不会是对方网站带宽或者负载的原因，那么到底是什么导致了这种情况呢。湛蓝试着进行推测，假设是 DNS 的问题，因为 DNS 解析速度很可能是造成资源延时的最大原因。在页面 header 中添加了以下代码（用以 DNS 预解析）：</p>\n<pre><code class=\"html\">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;\n\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://nsclick.baidu.com&quot; /&gt;\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://hm.baidu.com&quot; /&gt;\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://eiv.baidu.com&quot; /&gt;\n</code></pre>\n<p>dns-prefetch 需慎用，多页面重复 DNS 预解析会增加重复 DNS 查询次数。</p>\n<p>使用场景：</p>\n<ol>\n<li>新用户访问，后端可以通过 Cookie 判断是否为首次进入站点，对于这类用户，DNS Prefetch 可以比较明显地提升访问速度</li>\n<li>登录页，提前在页面上进行下一跳页用到资源的 DNS Prefetch</li>\n<li>页面中的静态资源在不同的 domain 下，如 CSS、JS、图片等文件</li>\n<li>电商网站的商品页大量载入不同 domain 下的商品图，如淘宝</li>\n<li>手机网页</li>\n<li>大型网站</li>\n<li>js 或服务端重定向</li>\n</ol>\n<blockquote>\n<p>Chrome 中的一些指令：</p>\n<ul>\n<li><code>chrome://histograms/DNS.PrefetchQueue</code>：查看队列状态</li>\n<li><code>chrome://histograms/DNS</code>：查看从浏览器启动到上一页的 DNS 记录</li>\n<li><code>chrome://dns</code>：查看个域名 DNS 统计</li>\n<li><code>chrome://net-internals/#dns</code>：清除 host 缓存</li>\n</ul>\n</blockquote>\n<h4 id=\"压缩资源\"><a href=\"#压缩资源\" class=\"headerlink\" title=\"压缩资源\"></a>压缩资源</h4><ul>\n<li><p>压缩 js，css，image</p>\n<p><strong>通过对外部资源进行压缩可以大幅度地减少浏览器需要下载的资源量，它会减少关键路径长度与关键字节，使页面的加载速度变得更快。</strong></p>\n<p><strong>对数据进行压缩其实就是使用更少的位数来对数据进行重编码</strong>。如今有非常多的压缩算法，且每一个的作用领域也各不相同，它们的复杂度也不相同，不过在这里我不会讲压缩算法的细节，感兴趣的朋友可以自己 Google。</p>\n<p>在对<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>这些文件进行压缩之前，还需要先进行一次冗余压缩。<strong>所谓冗余压缩，就是去除多余的字符，例如注释、空格符和换行符</strong>。这些字符对于程序员是有用的，毕竟没有格式化的代码可读性是非常恐怖的，但它们对于浏览器是没有任何意义的，去除这些冗余可以减少文件的数据量。</p>\n<p>小图片采用 base64 的格式，直接嵌入代码中，可以帮我们减少 http 请求，但是同样，这个会造成我们代码的提及变大。请求的速度会减慢，这个需要平衡。</p>\n<p>常用工具：webpack，gulp</p>\n<blockquote>\n<p>浏览器接收到服务器返回的 HTML、CSS 和 JavaScript 字节数据并对其进行解析和转变成像素的渲染过程被称为<code>关键渲染路径</code>。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。</p>\n</blockquote>\n</li>\n<li><p>删除重复的脚本，类似<code>tree-shaking</code></p>\n<p>在一个页面中重复引用一个脚本可能存在的问题：浏览器会重复下载并执行脚本文件。</p>\n</li>\n<li><p>使用合适大小的图片</p>\n<p>如果你只需要一个小图，就不要传一个大图。例如你实际需要显示的是一个 60x60 的头像，就不要传一个 100x100 的然后再通过设置宽高将它缩小为 60x60 的。原因很简单，这样会消耗不必要的带宽和系统资源。</p>\n</li>\n<li><p>减少 DOM 元素的数量</p>\n<p>复杂页面意味着要下载更多字节，这也意味着 JavaScript 中的 DOM 访问速度更慢。如果您想要添加事件处理程序，例如，在页面上循环 500 或 5000 个 DOM 元素，则会有所不同。</p>\n</li>\n<li><p>使用异步加载，async、defer</p>\n<blockquote>\n<p>服务端渲染也是一种减少浏览器资源消耗，减少页面重排重绘，也是一种现行 MVVM 框架单页应用最主要的 SEO 优化手段。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"避免-3xx-x2F-4xx\"><a href=\"#避免-3xx-x2F-4xx\" class=\"headerlink\" title=\"避免 3xx&#x2F;4xx\"></a>避免 3xx&#x2F;4xx</h4><p><strong>避免重定向</strong></p>\n<p>3xx 是重定向相关的 HTTP 响应代码</p>\n<p>重定向的意思是，用户的原始请求（例如请求 A）被重定向到其他的请求（例如请求 B）。</p>\n<p>每次页面重定向到另一个页面时，您的访问者都会面临等待 HTTP 请求 - 响应周期完成的额外时间。例如，如果移动重定向模式如下所示：</p>\n<p><code>example.com</code> - &gt; <code>www.example.com</code> - &gt; <code>m.example.com</code> - &gt; <code>m.example.com/home</code>，这两个额外重定向中的每一个都会使您的页面成为可能加载速度慢。</p>\n<p>HTTP 重定向通过 <code>301</code>&#x2F;<code>302</code> 状态码实现。</p>\n<pre><code>HTTP/1.1 301 Moved Permanently\nLocation: http://example.com/newuri\nContent-Type: text/html\n</code></pre>\n<p><code>301 Moved Permanently</code>，这个状态码标识用户所请求的资源被移动到了另外的位置，客户端接收到此响应后，需要发起另外一个请求去下载所需的资源。</p>\n<p><code>302 Found</code>，这个状态码标识用户所请求的资源被找到了，但不在原始位置，服务器会回复其他的一个位置，客户端收到此响应后，也需要发起另外一个请求去下载所需的资源。</p>\n<p>客户端收到服务器的重定向响应后，会根据响应头中 <code>Location</code> 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</p>\n<p>有时重定向无法避免，在糟糕也比抛出 <code>404</code> 好。虽然通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldGFfcmVmcmVzaA==\">HTML meta refresh</span> 和 JavaScript 也能实现，但首选 HTTP <code>3xx</code> 跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。</p>\n<p><strong>常见的优化办法：</strong></p>\n<ul>\n<li><p>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加 <code>/</code> 但未添加。比如，访问 <code>http://astrology.yahoo.com/astrology</code> 将被 301 重定向到 <code>http://astrology.yahoo.com/astrology/</code>（注意末尾的 <code>/</code>）。如果使用 Apache，可以通过 <code>Alias</code> 或 <code>mod_rewrite</code> 或 <code>DirectorySlash</code> 解决这个问题。</p>\n</li>\n<li><p>网站域名变更：CNAME 结合 <code>Alias</code> 或 <code>mod_rewrite</code> 或者其他服务器类似功能实现跳转。</p>\n</li>\n<li><p>在定义链接地址的 href 属性的时候，尽量使用最完整的、直接的地址。例如：<br>使用 <code>www.cnblogs.com</code> 而不是<code>cnblogs.com</code><br>使用<code>cn.bing.com</code>而不是<code>bing.com</code><br>使用<code>www.google.com.hk</code>而不是<code>google.com</code><br>使用<code>www.mysite.com/products/</code>而不是<code>www.mysite.com/products</code></p>\n</li>\n</ul>\n<p><strong>避免 404 浏览器找不到资源的情况发生</strong></p>\n<p>发出 HTTP 请求并获得无用的响应（即 404 Not Found）是完全没必要的。特别糟糕的是当外部 JavaScript 的链接错误并且结果是 404 时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析 404 响应主体，就像它是 JavaScript 代码一样，这样就带来的性能的浪费。</p>\n<p><strong>404 的影响：</strong></p>\n<p>有时候，404 错误发生了，用户可能根本没有感觉到。例如</p>\n<ul>\n<li>例如请求 favicon.ico 文件，或者请求了某个不存在的脚本文件、样式表、图片文件，页面还是会按照正常的方式进行呈现。</li>\n<li>丢失的脚本文件、样式表、图片文件，会导致页面的某些行为、界面效果出现异常（也可能不是很明显）</li>\n<li>最大的问题可能是性能方面的影响。尤其是如果请求一个不存在的脚本文件，因为浏览器在请求脚本文件的时候，即便是返回 404，它也会尝试去按照 Javascript 的方式解析响应中的内容。这无疑会增加很多处理的时间，而因为该文件不存在，所以这些都是无用功。</li>\n</ul>\n<p>看得到的影响：</p>\n<ul>\n<li>如果用户请求的某个页面不存在，那么他将收到明确的回应</li>\n<li>默认情况下，他将收到一个标准的错误页面（请注意：不少用户会被这个页面吓到）</li>\n</ul>\n<p><strong>常见的优化办法：</strong></p>\n<p>404 意味着 Not Found，意思是说未找到资源。既然如此，那么至少会有两种原因导致 404 错误：</p>\n<ul>\n<li>该资源按理说是要有，但我们没有提供。用户按照正常的方式来请求，所以资源找不到。<ul>\n<li>为网站提供 favicon.ico 这种经常可能会被忽略的资源</li>\n<li>使用一些检查工具：比如 Link checker</li>\n</ul>\n</li>\n<li>该资源本来就不存在，用户按照不正常的方式来请求，当然还是找不到。<ul>\n<li>避免用户收藏绝对地址，给后期更新带来隐患。可以使用地址 Rewrite 来重写，或者在设计阶段定义一些灵活友好的地址</li>\n<li>使用 Routing 技术，配置路由规则。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AJAX-优化\"><a href=\"#AJAX-优化\" class=\"headerlink\" title=\"AJAX 优化\"></a>AJAX 优化</h4><p><strong>使 Ajax 可缓存</strong></p>\n<p>AJAX&#x3D;Asynchronous JavaScript And XML，AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p>\n<p>由于 AJAX 其实也是需要发起请求，然后服务器执行，并将结果（通常是 JSON 格式的）发送给浏览器进行最后的呈现或者处理，所以对于网站设计优化的角度而言，我们同样需要考虑对这些请求，是否可以尽可能的利用到缓存的功能来提高性能。</p>\n<p>对于 AJAX 而言，有一些特殊性，并不是所有的 AJAX 请求都是可以缓存的。</p>\n<ol>\n<li><code>POST</code>的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码 200。（这里可以优化的是，服务器端对数据进行缓存，以便提高处理速度）</li>\n<li><code>GET</code>的请求，是可以（并且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一地址的 AJAX 请求，不会重复再服务器执行，而是返回 304。</li>\n</ol>\n<p>有的时候，我们可能希望<code>GET</code>请求不被缓存，有几种做法来达到这样的目的。</p>\n<ol>\n<li>每次调用的时候，请求不同的地址（可以在原始地址后面添加一个随机的号码）。</li>\n<li>如果你所使用的是 jquery 的话，则可以考虑禁用 AJAX 的缓存。</li>\n</ol>\n<pre><code class=\"javascript\">$.ajaxSetup(&#123; cache: false &#125;);\n</code></pre>\n<p>axios 中</p>\n<pre><code class=\"javascript\">var config = &#123;\n  headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Cache-Control&quot;: &quot;no-cache&quot; &#125;,\n&#125;;\n\naxios.get(&quot;/post&quot;, config);\n</code></pre>\n<p><strong>使用 GET 的 Ajax 请求</strong></p>\n<p>在使用 XMLHttpRequest（目前的 AJAX 都是基于它实现的）的时候，浏览器中的 POST 实现为两步走的过程，首先发送头部信息，然后再发送数据。但如果是使用 GET 的话，就只有一个 TCP 的包发送出去（除非有大量的 Cookie），这样无疑可以提高性能。</p>\n<p>但是 get 有容量限制，大于 2K(对 get 的限制 IE 是 2K，firefox、chrome 是 4K)的内容只能用 post。</p>\n<h4 id=\"Cookie-优化\"><a href=\"#Cookie-优化\" class=\"headerlink\" title=\"Cookie 优化\"></a>Cookie 优化</h4><ul>\n<li><p>减小 cookie 大小</p>\n<p>减小 cookie 的大小，因为在发请求时浏览器会将 cookie 信息发送到 server 端，所以应该只在 cookie 中存必要的信息且越长度越小越好。在 写 cookie 的时候要记得给 cookie 设置一个合理的过期时间及域</p>\n</li>\n<li><p>对一些静态资源不需要使用 cookie 的单独设置域</p>\n<p>当浏览器发出静态图像请求并将 cookie 与请求一起发送时，服务器对这些 cookie 没有任何用处。因此，他们只会毫无理由地创建网络流量。您应该确保使用无 cookie 请求请求静态组件。创建一个子域并在那里托管所有静态组件。</p>\n<p>如果您的域名是<code>www.example.org</code>，您可以托管您的静态组件<code>static.example.org</code>。但是，如果您已经在顶级域上设置了 cookie <code>example.org</code>而不是<code>www.example.org</code>，则所有请求都 <code>static.example.org</code>将包含这些 cookie。在这种情况下，您可以购买一个全新的域，在那里托管您的静态组件，并保持此域无 cookie。雅虎 用途<code>yimg.com</code>，YouTube 使用<code>ytimg.com</code>，亚马逊使用<code>images-amazon.com</code>等。</p>\n<p>在无 cookie 域上托管静态组件的另一个好处是，某些代理可能拒绝缓存使用 cookie 请求的组件。在相关说明中，如果您想知道是否应该使用<code>example.org</code>或<code>www.example.org</code>作为主页，请考虑 cookie 的影响。</p>\n<blockquote>\n<p>省略 www 会让您别无选择，只能写入 cookie <code>*.example.org</code>，因此出于性能原因，最好使用 www 子域并将 cookie 写入该子域。</p>\n</blockquote>\n</li>\n</ul>\n<p>归类一下：</p>\n<ul>\n<li>去除不必要的 Cookie；</li>\n<li>尽量压缩 Cookie 大小；</li>\n<li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li>\n<li>设置合适的过期时间。</li>\n</ul>\n<h4 id=\"利用缓存\"><a href=\"#利用缓存\" class=\"headerlink\" title=\"利用缓存\"></a>利用缓存</h4><p>浏览器会缓存大量信息（样式表，图像，JavaScript 文件等），以便当访问者返回您的站点时，浏览器不必重新加载整个页面。然后设置“expires”标题，以表示希望缓存该信息的时间。在许多情况下，除非您的网站设计经常更改，否则一年是合理的时间段。</p>\n<p><strong>利用浏览器缓存 ，为链接或者资源，添加 Expires 或 Cache-Control 头</strong></p>\n<ul>\n<li>对于静态组件：通过设置远期未来<code>Expires</code>标头实现“永不过期”策略</li>\n<li>对于动态组件：使用适当的<code>Cache-Control</code>标头来帮助浏览器处理条件请求</li>\n</ul>\n<p>格式：</p>\n<pre><code class=\"bash\">Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date\n# e.g.\nExpires: Thu, 01 Dec 1994 16:00:00 GMT\n#（必须是GMT格式）\n</code></pre>\n<p>通过 HTTP 的 META 设置 expires 和 cache-control</p>\n<pre><code class=\"html\">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot; /&gt;\n&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Mon, 01 Aug 2019 00:00:00 GMT&quot; /&gt;\n</code></pre>\n<p>上述设置仅为举例，实际使用其一即可。这样写的话仅对该网页有效，对网页中的图片或其他请求无效，并不会做任何<code>cache</code>。<br>这样客户端的请求就多了，尽管只是检查<code>Last-modified</code>状态的东西，但是请求一多对浏览速度必定有影响。</p>\n<p><code>Cache-Control</code> 的参数包括:</p>\n<ul>\n<li><strong>max-age&#x3D;</strong>[单位：秒 seconds] — 设置缓存最大的有效时间. 类似于 <code>Expires</code>, 但是这个参数定义的是时间大小（比如：60）而不是确定的时间点.单位是[秒 seconds].</li>\n<li><strong>s-maxage&#x3D;</strong>[单位：秒 seconds] — 类似于 <code>max-age</code>, 但是它只用于公享缓存 (e.g., proxy) .</li>\n<li><strong>public</strong> — 响应会被缓存，并且在多用户间共享。正常情况, 如果要求 <span class=\"exturl\" data-url=\"aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzIwNzY0MDguaHRt\">HTTP 认证</span>,响应会自动设置为 private.</li>\n<li><strong>private</strong> — 响应只能够作为私有的缓存(e.g., 在一个浏览器中)，不能再用户间共享。</li>\n<li><strong>no-cache</strong> — 响应不会被缓存,而是实时向服务器端请求资源。这一点很有用，这对保证<span class=\"exturl\" data-url=\"aHR0cDovL2JhaWtlLmJhaWR1LmNvbS92aWV3LzIwNzY0MDguaHRt\">HTTP 认证</span>能够严格地禁止缓存以保证安全性很有用（这是指页面与 public 结合使用的情况下）.既没有牺牲缓存的效率，又能保证安全。</li>\n<li><strong>no-store</strong> — 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</li>\n<li><strong>must-revalidate</strong> — 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</li>\n<li><strong>proxy-revalidate</strong> — 类似于 <code>must-revalidate</code>,但不适用于代理缓存.</li>\n</ul>\n<p><strong>把 css 与 js 使用外联的方式进行使用</strong></p>\n<p>建议将 css 和 js 以外联方式引用以充分利用<code>cache</code>，只有一个例外就是针对首页，首页可以采用内联来减少 http 请求数，加快页面显示速度，文中说首 页内联的原因是首页被人们访问的次数不会太多，而且样式一般比较特殊，不像其它页面一样有相同的页面模板（因为就有相同的样式部分），所以首页的样式可以 内联。并且应该在首页加载完成之后，再在后台动态加载后续页面的 css 和 js，以提高后续页面的访问速度。</p>\n<p>如果站点上的用户每个会话有多个页面查看，并且您的许多页面重复使用相同的脚本和样式表，则缓存的外部文件可能会带来更大的潜在好处。</p>\n<blockquote>\n<p>对于现在的单页面的应用，更适合于动态加载的方案</p>\n</blockquote>\n<p><strong>缓存 favicon.ico，并设置最好小于 1k</strong></p>\n<p>favicon.ico 是一个保留在服务器根目录中的图片，为了减轻拥有 favicon.ico 的带来的性能问题，请确保：</p>\n<ul>\n<li>优化它的大小，最好不到 1K。</li>\n<li>设置 Expires 标头，使其缓存。</li>\n</ul>\n<p><strong>配置的 ETag</strong></p>\n<p>ETag，全程为：<code>Entity Tag</code>，意思是实体标签，它属于 HTTP 协议的一部分，也就是所有的 Web 服务器都应该支持这个特性。它的作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）请求的时候，比较 ETag 如果一致，则表示该资源并没有被修改过，客户端（浏览器）可以使用自己缓存的版本，避免重复下载。<br>它比 last-modified date 更具有弹性，例如某个文件在 1 秒内修改了 10 次，Etag 可以综合 Inode(文件的索引节点(inode)数)，MTime(修改时间)和 Size 来精准的进行判断，避开 UNIX 记录 MTime 只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用 ETags 减少 Web 应用带宽和负载。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">响应标</th>\n<th align=\"left\">优势 和特点</th>\n<th align=\"left\">劣势 和可能的问题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Expires</td>\n<td align=\"left\">- HTTP 1.0 就有，简单易用。 - 服务器通过这个 Header 告诉浏览器，某资源直到某个时间才会过期，所以在没有过期之前，浏览器就直接使用本地的缓存了。</td>\n<td align=\"left\">- 因为这是时间是由服务器发送的（UTC），但如果服务器时间和客户端事件存在不一致，可能会有些问题。 - 可能存在版本的问题，因为如果在到期之前修改过了，客户端是不会知道的。 - Cache-Control 中的 max-age 可以实现类似的效果，但更加好，因为 max-age 是一个以秒为单位的时间数，而不是具体的时间，所以不存在上面提到的第一个问题。</td>\n</tr>\n<tr>\n<td align=\"left\">Cache-Contro</td>\n<td align=\"left\">- 服务器通过一个 Header（Last-Modified）告诉浏览器，某资源最后修改的时间。 - 浏览器在请求的时候，包含一个 Header（If-Modified-Since）,然后服务器可以进行比较，如果在该时间后没有修改过，则返回 304。 - 它比 Expires 多很多选项设置</td>\n<td align=\"left\">- Last-Modified 也是一个时间，但该时间只能精确到秒，如果在同一个秒中有多次修改（这个在现在的环境下应该确实是可能的），则可能会发生问题。</td>\n</tr>\n<tr>\n<td align=\"left\">ETag</td>\n<td align=\"left\">- 可以更加精确地判断资源是否被修改，因为它不是一个时间值，而是对时间经过处理的一个长整型数值（当然具体算法我们目前还不得而知）。 - 浏览器发起新请求时需要包含 If-None-Match。</td>\n<td align=\"left\">- 如果部署在服务器场环境中，配置不当的话，可能每个服务器会对相同的资源生成不一样的 ETag，这样就增加了重复下载的可能性。</td>\n</tr>\n</tbody></table>\n<p>我们来看一个真实的例子：</p>\n<p><img data-src=\"/images/image-20190619145105413.png\" alt=\"/images/image-20190619145105413\"></p>\n<p>其他的一些缓存使用：</p>\n<ul>\n<li>使用本地缓存，缓存部分常用用户数据、公开数据</li>\n<li>缓存机制设计：缓存+过期时间</li>\n</ul>\n<p>总结一下：</p>\n<ul>\n<li>添加 Expires 或 Cache-Control</li>\n<li>Etag</li>\n<li>缓存 favicon.ico</li>\n<li>外联 js&#x2F;css</li>\n</ul>\n<h4 id=\"缩短服务器响应时间\"><a href=\"#缩短服务器响应时间\" class=\"headerlink\" title=\"缩短服务器响应时间\"></a>缩短服务器响应时间</h4><p>服务器响应时间受到访问流量，每个页面使用的资源，服务器使用的软件以及硬件本身的影响。要改善服务器响应时间，请查找性能瓶颈，如慢速数据库查询，慢速路由或缺少足够的内存并修复它们。最佳服务器响应时间低于 200 毫秒。</p>\n<p>很多潜在因素都可能会延缓服务器响应，例如缓慢的应用逻辑、缓慢的数据库查询、缓慢的路由、框架、库、资源 CPU 不足或内存不足。您需要充分考虑所有这些因素，才能改善服务器的响应用时。 若想找出服务器响应用时过长的原因，首先要进行衡量。然后，准备好相关数据，并参阅有关如何解决该问题的相应指导。当解决问题后，您必须继续衡量服务器响应用时，并设法应对任何会在将来出现的性能瓶颈问题。</p>\n<ol>\n<li><strong>收集并检查</strong>现有性能和数据。若无可用内容，请使用自动化的网络应用监测解决方案（市面上有托管的开源版本，适用于大多数平台）进行评估，或添加自定义的方法。</li>\n<li><strong>找出并修复</strong>首要的性能瓶颈问题。如果 z 您使用的是热门网页框架或内容管理平台，请参阅与性能优化最佳做法相关的文档。</li>\n<li><strong>监测并提醒</strong>任何会在将来出现的性能衰退问题！</li>\n</ol>\n<blockquote>\n<p>通常来说，服务器的响应时间由数据库的问题居多，还有错误的程序设计(比如：烂用 for 循环去查数据库)。</p>\n</blockquote>\n<h3 id=\"优化工具\"><a href=\"#优化工具\" class=\"headerlink\" title=\"优化工具\"></a>优化工具</h3><h4 id=\"Google-Page-Speed\"><a href=\"#Google-Page-Speed\" class=\"headerlink\" title=\"Google Page Speed\"></a>Google Page Speed</h4><p>Google Page Speed 以帮助开发人员和网站所有者确保他们的网页尽可能顺畅，快速地运行。</p>\n<p><strong>Google Page Speed 特点：</strong></p>\n<ul>\n<li>在 CSS 方面更加注重细节，对于 CSS 选择器，Google Page Speed 提供了大量有用的建议</li>\n<li>页面速度活动功能类似于加载计时器评估，但它实时提供图表，因此可以在任何给定时间准确查看网站上发生的情况。</li>\n<li>自动优化：使用 PageSpeed 模块，可以将 Google 与您的 Nginx 或 Apache 网站服务器集成，以自动优化您的网站。</li>\n<li>优化库集成：可以找到 PageSpeed 模块背后优化建议，允许设计和构建自己的工具。</li>\n</ul>\n<p>对于某些人来说，Google Page Speed 将是显而易见的选择，因为它可以与其他对维护网站性能至关重要的 Google 工具一起使用，例如 Google Analytics。</p>\n<h4 id=\"JsPerf-amp-Benchmark-js\"><a href=\"#JsPerf-amp-Benchmark-js\" class=\"headerlink\" title=\"JsPerf &amp; Benchmark.js\"></a>JsPerf &amp; Benchmark.js</h4><p>经常看到项目中有一个 benchmark 的文件夹，那么这个 benchmark 是干嘛用的？</p>\n<p>JsPerf 在线：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc3BlcmYuY29tLw==\">https://jsperf.com/</span></p>\n<p>JsPerf Github 地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2pzcGVyZi9qc3BlcmYuY29t\">https://github.com/jsperf/jsperf.com</span></p>\n<p>Benchmark.js 网址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2JlbmNobWFyay5qcw==\">https://github.com/bestiejs/benchmark.js</span></p>\n<p>BenchMark.js 可以本地安装，而 JsPerf.js 是线上使用的。</p>\n<p>HTML 中引入：</p>\n<pre><code class=\"html\">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>或者使用<code>npm</code>:</p>\n<pre><code class=\"bash\">$ &#123;sudo -H&#125; npm i -g npm\n$ npm i --save benchmark\n</code></pre>\n<p>下面是一个具体的用例：</p>\n<p>Reg vs IndexOf</p>\n<pre><code class=\"javascript\">var suite = new Benchmark.Suite();\n\n// add tests\nsuite\n  .add(&quot;RegExp#test&quot;, function () &#123;\n    /o/.test(&quot;Hello World!&quot;);\n  &#125;)\n  .add(&quot;String#indexOf&quot;, function () &#123;\n    &quot;Hello World!&quot;.indexOf(&quot;o&quot;) &gt; -1;\n  &#125;)\n  // add listeners\n  .on(&quot;cycle&quot;, function (event) &#123;\n    console.log(String(event.target));\n  &#125;)\n  .on(&quot;complete&quot;, function () &#123;\n    console.log(&quot;Fastest is &quot; + this.filter(&quot;fastest&quot;).map(&quot;name&quot;));\n  &#125;)\n  // run async\n  .run(&#123; async: true &#125;);\n\n// logs:\n// =&gt; RegExp#test x 4,161,532 +-0.99% (59 cycles)\n// =&gt; String#indexOf x 6,139,623 +-1.00% (131 cycles)\n// =&gt; Fastest is String#indexOf\n</code></pre>\n<p>再来看一个 call 与 apply 的对比：</p>\n<pre><code class=\"javascript\">var Benchmark = require(&quot;benchmark&quot;);\nvar suite = new Benchmark.Suite();\nvar arr1 = function (str) &#123;\n  return [].slice.apply(str);\n&#125;;\nvar str2 = function (str) &#123;\n  return [].slice.call(str);\n&#125;;\n// 添加测试\nsuite\n  .add(&quot;arr1&quot;, function () &#123;\n    arr1(&quot;test&quot;);\n  &#125;)\n  .add(&quot;str2&quot;, function () &#123;\n    str2(&quot;test&quot;);\n  &#125;)\n  // add listeners\n  .on(&quot;cycle&quot;, function (event) &#123;\n    console.log(String(event.target));\n  &#125;)\n  .on(&quot;complete&quot;, function () &#123;\n    console.log(&quot;Fastest is &quot; + this.filter(&quot;fastest&quot;).pluck(&quot;name&quot;));\n  &#125;)\n  // run async\n  .run(&#123; async: true &#125;);\n</code></pre>\n<p>benckmark 是对 js 运行能效的一个对比测试，让你能够知道自己的 JS 代码中与其他方案对比的时候，是否有优化的空间。当然，这些新的方案，需要自己去编写去测试。同样，也可以在 JsPerf 的官网上去看其他的测试结果。</p>\n<p>执行办法 ：</p>\n<pre><code class=\"javascript\">npm init -y\n\nnpm install -S benchmark\n\ntouch test.js //Linux\n\nnode test.js\n</code></pre>\n<h2 id=\"代码优化——写出优质的代码\"><a href=\"#代码优化——写出优质的代码\" class=\"headerlink\" title=\"代码优化——写出优质的代码\"></a>代码优化——写出优质的代码</h2><p>命题很大，但是我们要简化来谈一下。</p>\n<p>代码优化，先要写出优质的代码，有几点原则：</p>\n<ul>\n<li>使用辅助应用对代码进行检查，Eslint 等</li>\n<li>使用预编译工具，如 less，sass，stylus。</li>\n<li>使用官方的开发规范：命名规范、注释、使用规范、文档规范</li>\n<li>写出逻辑上易于阅读的代码：设计模式、代码结构、文档编排(目录结构)</li>\n<li>代码审查</li>\n<li>单元测试</li>\n<li>异常与错误机制</li>\n</ul>\n<p>之后就是练习与阅读，阅读别人的代码，学习别人的精华，了解别人代码中的缺点。使用 JsPerf 或者 benchemark 去对比优化性能。</p>\n<p>前端代码规范：Airbnb，github，Google，腾讯，阿里等。</p>\n<h2 id=\"JsPerf\"><a href=\"#JsPerf\" class=\"headerlink\" title=\"JsPerf\"></a>JsPerf</h2><h3 id=\"JsPerf-使用简介\"><a href=\"#JsPerf-使用简介\" class=\"headerlink\" title=\"JsPerf 使用简介\"></a>JsPerf 使用简介</h3><h4 id=\"线上使用方案\"><a href=\"#线上使用方案\" class=\"headerlink\" title=\"线上使用方案\"></a>线上使用方案</h4><p>需要使用 Github 进行登录：</p>\n<p><img data-src=\"/images/image-20190618210408261.png\" alt=\"/images/image-20190618210408261\"></p>\n<p>点击<code>Login with Github to Create Test Cases</code>:</p>\n<p><img data-src=\"/images/image-20190619103010414.png\" alt=\"/images/image-20190619103010414\"></p>\n<p>登录之后，进入授权页面：</p>\n<p><img data-src=\"/images/image-20190619103140822.png\" alt=\"/images/image-20190619103140822\"></p>\n<p>登录过后，就可以创建自己的测试用例啦：</p>\n<p>\u0001<img data-src=\"/images/image-20190619143549467.png\" alt=\"/images/image-20190619143549467\"></p>\n<h4 id=\"线下使用方案：\"><a href=\"#线下使用方案：\" class=\"headerlink\" title=\"线下使用方案：\"></a>线下使用方案：</h4><p>环境准备：</p>\n<ul>\n<li>Mysql</li>\n<li>Nodejs</li>\n</ul>\n<p>创建过程：</p>\n<ol>\n<li><p>安装 Mysql</p>\n<pre><code class=\"bash\">mysql -uroot -e &quot;CREATE DATABASE jsperf; GRANT ALL ON jsperf.* TO &#39;jsuser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;jspass&#39;; FLUSH PRIVILEGES;&quot;\n</code></pre>\n</li>\n<li><p>在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYnJvd3NlcnNjb3BlLm9yZy8=\">Browserscope.org</span> 注册一个 API key ，在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYnJvd3NlcnNjb3BlLm9yZy91c2VyL3NldHRpbmdz\">the settings page</span>页面中.</p>\n</li>\n<li><p>注册一个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2FwcGxpY2F0aW9ucy9uZXc=\">new OAuth GitHub application</span>. 使用 callback URL 留空. 复制 “Client ID” 和 “Client Secret”到 github 的页面上。</p>\n</li>\n<li><p>使用<code>npm install</code>安装</p>\n</li>\n<li><p>配置<code>.env</code>的文件</p>\n</li>\n</ol>\n<pre><code class=\"bash\">NODE_ENV=development\n# from Prerequisites step 1\nMYSQL_USER=jsuser\nMYSQL_PASSWORD=jspass\nMYSQL_DATABASE=jsperf\n# from Prerequisites step 2\nBROWSERSCOPE=\n# from Prerequisites step 3\nGITHUB_CLIENT_ID=\nGITHUB_CLIENT_SECRET=\nGITHUB_CALLBACK=http://localhost:3000\n\nBELL_COOKIE_PASS=password-should-be-32-characters\nCOOKIE_PASS=password-should-be-32-characters\n\n# customizable but not recommended for local development\n# SCHEME=http\n# DOMAIN=localhost\n# PORT=3000\n# MYSQL_HOST=localhost\n# MYSQL_PORT=3306\n# LOGGLY_TOKEN=\n# LOGGLY_SUBDOMAIN=\n# REDIS_HOST=\n# REDIS_PORT=\n# REDIS_PASSWORD=\n</code></pre>\n<ol start=\"6\">\n<li>运行<code>npm start</code></li>\n</ol>\n<h3 id=\"代码示例-for-vs-foreach\"><a href=\"#代码示例-for-vs-foreach\" class=\"headerlink\" title=\"代码示例 for vs foreach\"></a>代码示例 for vs foreach</h3><p>我们对比一下 for 与 foreach</p>\n<p><img data-src=\"/images/screencapture-jsperf-2019-06-18-21_15_29.png\" alt=\"screencapture-jsperf-2019-06-18-21_15_29\"></p>\n<p>测试过程：</p>\n<p><img data-src=\"/images/image-20190618211820471.png\" alt=\"/images/image-20190618211820471\"></p>\n<p>测试结果：</p>\n<p><img data-src=\"/images/image-20190618211915799.png\" alt=\"/images/image-20190618211915799\"></p>\n<p>这里有一个更全面的对比结果：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc3BlcmYuY29tL2Zvci12cy1mb3JlYWNoLzc1\">https://jsperf.com/for-vs-foreach/75</span></p>\n<p><img data-src=\"/images/image-20190618213130251.png\" alt=\"/images/image-20190618213130251\"></p>\n<p><img data-src=\"/images/image-20190618213201840.png\" alt=\"/images/image-20190618213201840\"></p>\n<p>还有一些比较有意思的测试：</p>\n<p>可以通过浏览：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc3BlcmYuY29tL3BvcHVsYXI=\">https://jsperf.com/popular</span>进行查看</p>\n<p><img data-src=\"/images/image-20190619143653346.png\" alt=\"/images/image-20190619143653346\"></p>\n<h3 id=\"前端项目优化实践\"><a href=\"#前端项目优化实践\" class=\"headerlink\" title=\"前端项目优化实践\"></a>前端项目优化实践</h3><p>我们来对比下 Date()与 Moment()中的 format</p>\n<pre><code class=\"javascript\">const Benchmark = require(&quot;benchmark&quot;);\nconst moment = require(&quot;moment&quot;);\n\nDate.prototype.Format = function (fmt) &#123;\n  var o = &#123;\n    &quot;M+&quot;: this.getMonth() + 1, //月份\n    &quot;d+&quot;: this.getDate(), //日\n    &quot;h+&quot;: this.getHours(), //小时\n    &quot;m+&quot;: this.getMinutes(), //分\n    &quot;s+&quot;: this.getSeconds(), //秒\n    &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度\n    S: this.getMilliseconds(), //毫秒\n  &#125;;\n  if (/(y+)/.test(fmt))\n    fmt = fmt.replace(\n      RegExp.$1,\n      (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)\n    );\n  for (var k in o) &#123;\n    if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))\n      fmt = fmt.replace(\n        RegExp.$1,\n        RegExp.$1.length == 1 ? o[k] : (&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)\n      );\n  &#125;\n  return fmt;\n&#125;;\n\nvar suite = new Benchmark.Suite();\n\n// add tests\nsuite\n  .add(&quot;Date format&quot;, function () &#123;\n    console.log(new Date().Format(&quot;yyyy-MM-dd hh:mm:ss&quot;));\n  &#125;)\n  .add(&quot;Moment format&quot;, function () &#123;\n    console.log(moment().format(&quot;YYYY-MM-DD HH:mm:ss&quot;));\n  &#125;)\n  // add listeners\n  .on(&quot;cycle&quot;, function (event) &#123;\n    console.log(String(event.target));\n  &#125;)\n  .on(&quot;complete&quot;, function () &#123;\n    console.log(&quot;Fastest is &quot; + this.filter(&quot;fastest&quot;).map(&quot;name&quot;));\n  &#125;)\n  // run async\n  .run(&#123; async: true &#125;);\n</code></pre>\n<p>输出结果 ：</p>\n<pre><code class=\"bash\">Moment format x 73,570 ops/sec ±4.93% (82 runs sampled)\nFastest is Moment format\n</code></pre>\n<h2 id=\"PageSpeed\"><a href=\"#PageSpeed\" class=\"headerlink\" title=\"PageSpeed\"></a>PageSpeed</h2><h3 id=\"PageSpeed-简介\"><a href=\"#PageSpeed-简介\" class=\"headerlink\" title=\"PageSpeed 简介\"></a>PageSpeed 简介</h3><p>PageSpeed Insights 的 Chrome 扩展是由谷歌官方开发的一款可以分析页面载入的各个方面，包括资源、网络、DOM 以及时间线等等信息的插件，也提供在线访问方式。</p>\n<h4 id=\"使用Google-PageSpeed-Insights\"><a href=\"#使用Google-PageSpeed-Insights\" class=\"headerlink\" title=\"使用Google PageSpeed Insights\"></a>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==\">Google PageSpeed Insights</span></h4><p>打开<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw==\">https://developers.google.com/speed/pagespeed/insights/</span></p>\n<p>输入需要分析的网址即可，这里面需要注意必须在公网可以访问到网址。</p>\n<p><img data-src=\"/images/image-20190619212956061.png\" alt=\"/images/image-20190619212956061\"></p>\n<h4 id=\"使用-Chrome-插件-x2F-Mozila-插件\"><a href=\"#使用-Chrome-插件-x2F-Mozila-插件\" class=\"headerlink\" title=\"使用 Chrome 插件&#x2F;Mozila 插件\"></a>使用 Chrome 插件&#x2F;Mozila 插件</h4><p><img data-src=\"/images/image-20190619203556941.png\" alt=\"/images/image-20190619203556941\"></p>\n<p>下载安装办法：</p>\n<ol>\n<li><p>使用插件 ID:<code>djfpadpbeemogokhllpiakdeadpoclan</code> 到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWUtZXh0ZW5zaW9uLWRvd25sb2FkZXIuY29tLyVFNiU5RCVBNSVFNCVCOCU4QiVFOCVCRCVCRA==\">https://chrome-extension-downloader.com/来下载</span></p>\n<p>打开：<span class=\"exturl\" data-url=\"Y2hyb21lOi8vZXh0ZW5zaW9ucy8=\">chrome:&#x2F;&#x2F;extensions&#x2F;</span></p>\n<p>把<code>ctx</code>文件拖进去</p>\n</li>\n<li><p>如果有梯子，那么直接在商店里面搜索</p>\n</li>\n</ol>\n<p>插件使用：</p>\n<p><img data-src=\"/images/image-20190619212836235.png\" alt=\"/images/image-20190619212836235\"></p>\n<h3 id=\"前端项目优化实践-1\"><a href=\"#前端项目优化实践-1\" class=\"headerlink\" title=\"前端项目优化实践\"></a>前端项目优化实践</h3><h2 id=\"补充学习\"><a href=\"#补充学习\" class=\"headerlink\" title=\"补充学习\"></a>补充学习</h2><h3 id=\"编码、解码形成-DOM-树的过程\"><a href=\"#编码、解码形成-DOM-树的过程\" class=\"headerlink\" title=\"编码、解码形成 DOM 树的过程\"></a>编码、解码形成 DOM 树的过程</h3><p>浏览器从网络或硬盘中获得<code>HTML</code>字节数据后会经过一个流程将字节解析为<code>DOM</code>树：</p>\n<ul>\n<li>编码： <strong>先将 HTML 的原始字节数据转换为文件指定编码的字符。</strong></li>\n<li>令牌化： 然后<strong>浏览器会根据 HTML 规范来将字符串转换成各种令牌</strong>（如<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>这样的标签以及标签中的字符串和属性等都会被转化为令牌，每个令牌具有特殊含义和一组规则）。令牌记录了标签的开始与结束，通过这个特性可以轻松判断一个标签是否为子标签（假设有<code>&lt;html&gt;</code>与<code>&lt;body&gt;</code>两个标签，当<code>&lt;html&gt;</code>标签的令牌还未遇到它的结束令牌<code>&lt;/html&gt;</code>就遇见了<code>&lt;body&gt;</code>标签令牌，那么<code>&lt;body&gt;</code>就是<code>&lt;html&gt;</code>的子标签）。</li>\n<li>生成对象： <strong>接下来每个令牌都会被转换成定义其属性和规则的对象（这个对象就是节点对象）。</strong></li>\n<li>构建完毕： <strong>DOM 树构建完成，整个对象集合就像是一棵树形结构</strong>。可能有人会疑惑为什么<code>DOM</code>是一个树形结构，这是因为标签之间含有复杂的父子关系，树形结构正好可以诠释这个关系（<code>CSSOS</code>同理，层叠样式也含有父子关系。例如： <code>div p &#123;font-size: 18px&#125;</code>，会先寻找所有<code>p</code>标签并判断它的父标签是否为<code>div</code>之后才会决定要不要采用这个样式进行渲染）。</li>\n</ul>\n<p>整个<code>DOM</code>树的构建过程其实就是： <strong>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型</strong>，下面将通过一个示例<code>HTML</code>代码与配图更形象地解释这个过程。</p>\n<p>如下面的这段 HTML</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;\n    &lt;title&gt;Critical Path&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot; /&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img data-src=\"/images/63503acbly1fk2te7tuh0j20nv0dbjtl.jpg\" alt=\"DOM Rendering\"></p>\n<h3 id=\"优化工作清单\"><a href=\"#优化工作清单\" class=\"headerlink\" title=\"优化工作清单\"></a>优化工作清单</h3><p>当小伙伴们出现了页面性能问题时，或者在设计我们的应用之前，就可以参考如下的条目进行快速检查。</p>\n<ul>\n<li>页面内容<ul>\n<li>减少 HTTP 请求数</li>\n<li>减少 DNS 查询</li>\n<li>避免重定向</li>\n<li>缓存 Ajax 请求</li>\n<li>延迟加载</li>\n<li>预先加载</li>\n<li>减少 DOM 元素数量</li>\n<li>划分内容到不同域名</li>\n<li>尽量减少 iframe 使用</li>\n<li>避免 404 错误</li>\n</ul>\n</li>\n<li>服务器<ul>\n<li>使用 CDN</li>\n<li>添加 Expires 或 Cache-Control 响应头</li>\n<li>启用 Gzip</li>\n<li>配置 Etag</li>\n<li>尽早输出缓冲</li>\n<li>Ajax 请求使用 GET 方法</li>\n<li>避免图片 src 为空</li>\n</ul>\n</li>\n<li>Cookie<ul>\n<li>减少 Cookie 大小</li>\n<li>静态资源使用无 Cookie 域名</li>\n</ul>\n</li>\n<li>CSS<ul>\n<li>把样式表放在 <code>&lt;head&gt;</code> 中</li>\n<li>不要使用 CSS 表达式</li>\n<li>使用 <code>link</code> 替代 <code>@import</code></li>\n<li>不要使用 filter</li>\n</ul>\n</li>\n<li>JavaScript<ul>\n<li>把脚本放在页面底部</li>\n<li>使用外部 JavaScript 和 CSS</li>\n<li>压缩 JavaScript 和 CSS</li>\n<li>移除重复脚本</li>\n<li>减少 DOM 操作</li>\n<li>使用高效的事件处理</li>\n</ul>\n</li>\n<li>图片<ul>\n<li>优化图片</li>\n<li>优化 CSS Sprite</li>\n<li>不要在 HTML 中缩放图片</li>\n<li>使用体积小、可缓存的 favicon.ico</li>\n</ul>\n</li>\n<li>移动端<ul>\n<li>保持单个文件小于 25 KB</li>\n<li>打包内容为分段（multipart）文档</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化关键渲染路径\"><a href=\"#优化关键渲染路径\" class=\"headerlink\" title=\"优化关键渲染路径\"></a>优化关键渲染路径</h3><p>假设有一个<code>HTML</code>页面，它只引入了一个<code>CSS</code>外部文件：</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot; /&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>它的关键渲染路径如下：</p>\n<p><img data-src=\"/images/63503acbly1fk56dzdbn9j20nr068dga.jpg\" alt=\"img\"></p>\n<p>首先浏览器要先对服务器发送请求获得<code>HTML</code>文件，得到<code>HTML</code>文件后开始构建<code>DOM</code>树，在遇见<code>&lt;link&gt;</code>标签时浏览器需要向服务器再次发出请求来获得<code>CSS</code>文件，然后则是继续构建<code>DOM</code>树和<code>CSSOM</code>树，浏览器合并出渲染树，根据渲染树进行布局计算，执行绘制操作，页面渲染完成。</p>\n<p>有以下几个用于描述关键渲染路径性能的词汇：</p>\n<ul>\n<li>关键资源：可能阻塞网页首次渲染的资源（上图中为 2 个，<code>HTML</code>文件与外部<code>CSS</code>文件<code>style.css</code>）。</li>\n<li>关键路径长度： 获取关键资源所需的往返次数或总时间（上图为 2 次或以上，一次获取<code>HTML</code>文件，一次获取<code>CSS</code>文件，这个次数基于<code>TCP</code>协议的最大拥塞窗口，一个文件不一定能在一次连接内传输完毕）。</li>\n<li>关键字节：所有关键资源文件大小的总和（上图为<code>9KB</code>）。</li>\n</ul>\n<p>接下来，案例代码的需求发生了变化，它新增了一个<code>JavaScript</code>文件。</p>\n<pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><a href=\"http://wx1.sinaimg.cn/large/63503acbly1fk56e0i20xj20or06ygmi.jpg\"><img data-src=\"http://wx1.sinaimg.cn/large/63503acbly1fk56e0i20xj20or06ygmi.jpg\" alt=\"img\"></a></p>\n<p><code>JavaScript</code>文件阻塞了<code>DOM</code>树的构建，并且在执行<code>JavaScript</code>脚本时还需要先等待构建<code>CSSOM</code>树，上图的关键渲染路径特性如下：</p>\n<ul>\n<li>关键资源： 3（<code>HTML</code>、<code>style.css</code>、<code>app.js</code>）</li>\n<li>关键路径长度： 2 或以上（浏览器会在一次连接中一起下载<code>style.css</code>和<code>app.js</code>）</li>\n<li>关键字节：11KB</li>\n</ul>\n<p>现在，我们要优化关键渲染路径，首先将<code>&lt;script&gt;</code>标签添加异步属性<code>async</code>，这样浏览器的<code>HTML</code>解析器就不会阻塞这个<code>JavaScript</code>文件了。</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot; /&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img data-src=\"/images/63503acbly1fk56e0sokqj20oj074ab1.jpg\" alt=\"img\"></p>\n<ul>\n<li>关键资源：2（<code>app.js</code>为异步加载，不会成为阻塞渲染的资源）</li>\n<li>关键路径长度： 2 或以上</li>\n<li>关键字节： 9KB（<code>app.js</code>不再是关键资源，所以没有算上它的大小）</li>\n</ul>\n<p>接下来对<code>CSS</code>进行优化，比如添加上媒体查询。</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot; /&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img data-src=\"/images/63503acbly1fk56e15x4jj20ny082mxu.jpg\" alt=\"img\"></p>\n<ul>\n<li>关键资源：1（<code>app.js</code>为异步加载，<code>style.css</code>只有在打印时才会使用，所以只剩下<code>HTML</code>一个关键资源，也就是说当<code>DOM</code>树构建完毕，浏览器就会开始进行渲染）</li>\n<li>关键路径长度：1 或以上</li>\n<li>关键字节：5KB</li>\n</ul>\n<p><strong>优化关键渲染路径就是在对关键资源、关键路径长度和关键字节进行优化</strong>。关键资源越少，浏览器在渲染前的准备工作就越少；同样，关键路径长度和关键字节关系到浏览器下载资源的效率，它们越少，浏览器下载资源的速度就越快。</p>\n<h3 id=\"其他-JS-在线测试网站\"><a href=\"#其他-JS-在线测试网站\" class=\"headerlink\" title=\"其他 JS 在线测试网站 \u0010\"></a>其他 JS 在线测试网站 \u0010</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qc2JlbmNoLm1lLw==\">jsbench.me</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2pzYmVuLmNoLw==\">jsben.ch</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWFzdXJldGhhdC5uZXQv\">measurethat.net</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWdldGVzdC5vcmcv\">webpagetest.org</span></li>\n</ul>\n<h1 id=\"性能优化之35条雅虎军规\"><a href=\"#性能优化之35条雅虎军规\" class=\"headerlink\" title=\"性能优化之35条雅虎军规\"></a>性能优化之35条雅虎军规</h1><ul>\n<li>尽量减少 HTTP 请求个数——须权衡</li>\n<li>使用 CDN（内容分发网络）</li>\n<li>为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性</li>\n<li>避免空的 src 和 href</li>\n<li>使用 gzip 压缩内容</li>\n<li>把 CSS 放到顶部</li>\n<li>把 JS 放到底部</li>\n<li>避免使用 CSS 表达式</li>\n<li>将 CSS 和 JS 放到外部文件中</li>\n<li>减少 DNS 查找次数</li>\n<li>精简 CSS 和 JS</li>\n<li>避免跳转</li>\n<li>剔除重复的 JS 和 CSS</li>\n<li>配置 ETags</li>\n<li>使 AJAX 可缓存</li>\n<li>尽早刷新输出缓冲</li>\n<li>使用 GET 来完成 AJAX 请求</li>\n<li>延迟加载</li>\n<li>预加载</li>\n<li>减少 DOM 元素个数</li>\n<li>根据域名划分页面内容</li>\n<li>尽量减少 iframe 的个数</li>\n<li>避免 404</li>\n<li>减少 Cookie 的大小</li>\n<li>使用无 cookie 的域</li>\n<li>减少 DOM 访问</li>\n<li>开发智能事件处理程序 (事件代理)</li>\n<li>用 <link> 代替 @import</li>\n<li>避免使用滤镜</li>\n<li>优化图像</li>\n<li>优化 CSS Sprite</li>\n<li>不要在 HTML 中缩放图像——须权衡</li>\n<li>favicon.ico要小而且可缓存</li>\n<li>保持单个内容小于25K</li>\n<li>打包组件成复合文本</li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsv\">浏览器的工作原理：新式网络浏览器幕后揭秘</span> <strong>强烈推荐</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wZXJmb3JtYW5jZS9jcml0aWNhbC1yZW5kZXJpbmctcGF0aC9yZW5kZXItdHJlZS1jb25zdHJ1Y3Rpb24=\">渲染树构建、布局及绘制</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3ouY29tL2Jsb2cvaW1wcm92aW5nLXNlYXJjaC1yYW5rLWJ5LW9wdGltaXppbmcteW91ci10aW1lLXRvLWZpcnN0LWJ5dGU=\">优化第一个字节的时间</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6Y3N1L2FydGljbGUvZGV0YWlscy83Mjg2MTg5MQ==\">TCP 的三次握手与四次挥手（详解+动图）</span>推荐</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMTIvMDIvcGVyZm9ybWFuY2UtdHVubmluZy5odG1s\">常见性能优化策略的总结</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb3ouY29tL2xlYXJuL3Nlby9wYWdlLXNwZWVk\">Page Speed</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzAxMWUwYzUxODgyNTJlYTY2YWZkZmEjaGVhZGluZy02OA==\">web 性能优化篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTk2NmJkMTZmYjlhMDYzNTE3MmE1MGE=\">2018 前端性能优化清单</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ2Y2JhZWU1MWQ0NTNmNDU2MTJhMmM=\">（译）2019 年前端性能优化清单 — 上篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ3MWVhZmYyNjVkYTYxNmQ1NDdjOGM=\">（译）2019 年前端性能优化清单 — 中篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ3M2NkYWU1MWQ0NTUxOGQ0NzAxZmY=\">（译）2019 年前端性能优化清单 — 下篇</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvZG9jcy9pbnNpZ2h0cy9ydWxlcw==\">PageSpeed Insights 规则</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zeWx2YW5hc3N1bi5naXRodWIuaW8vMjAxNy8xMC8wMy8yMDE3LTEwLTAzLUJyb3dzZXJDcml0aWNhbFJlbmRlcmluZ1BhdGgv\">浏览器渲染过程与性能优化</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yNjhjN2YzZGQ3YTY=\">如何提升 CSS 选择器性能</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbC5jbi9hcmNoaXZlcy85NTE3\">前端性能优化：2018 年 JavaScript 开销及优化工具和方法</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTY1NDdkMGYyNjVkYTNlMjgzYTFkZjc=\">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</span>推荐</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWFkODZjMTZmMjY1ZGE1MDVhNzdkY2E0\">彻底理解浏览器的缓存机制</span> 推荐 2</li>\n</ol>\n","categories":["前端性能优化"],"tags":["性能优化"]},{"title":"底层杂记与工具库函数","url":"/2023/06/02/%E5%BA%95%E5%B1%82%E6%9D%82%E8%AE%B0/","content":"<h2 id=\"NaN历史遗留问题\"><a href=\"#NaN历史遗留问题\" class=\"headerlink\" title=\"NaN历史遗留问题\"></a>NaN历史遗留问题</h2><p>由于历史遗留问题，NaN的内部做了hash处理，使得每一次NaN返回的结果都不同。</p>\n<pre><code class=\"javascript\">NaN === NaN //false;\nObject.is(NaN,NaN) //true\n//除此之外，延申:\n+0 === -0 //返回true\nObject.is(+0 , -0) //返回false\n</code></pre>\n<h2 id=\"null的历史遗留问题\"><a href=\"#null的历史遗留问题\" class=\"headerlink\" title=\"null的历史遗留问题\"></a>null的历史遗留问题</h2><p>null的本质其实是0,代表为空,而undefined的本质是一个特殊的对象,代表从未赋值过.</p>\n<pre><code class=\"javascript\">Number(null); //0\nNumber(undefined); //NaN\n\n12+null; //12\n12+undefined; //NaN\n\n//跟数字比较会更加明显\n-5&lt;null; //true——null是0，-5&lt;0\n\n-5&lt;undefined;  //false\n-5&gt;undefined;  //false\n-5==undefined; //false\n//undefined就不是数字，跟数字没有可比性\ntypeof null  //object\n</code></pre>\n<blockquote>\n<p>但是JS作者认为null表示的是一个空对象,因此在JS底层将null标记为了对象类型,因此就有: typeof null返回”object”,并且将undefined标记为了’undefined’特殊类型</p>\n</blockquote>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>构造函数的prototype（原型对象）就是其实例的原型（_<em>proto</em> _）*-*</p>\n<pre><code class=\"javascript\">new Object().__proto__===Object.prototype\n</code></pre>\n<p>【原型链图解】<br><img data-src=\"/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"javascript\">obj.__proto__------Object.prototype-------null\nfunc.__proto__--------Function.prototype-------Object.prototype----------null\n（其中：func.__proto__.__proto__ === Object.prototype   ； func也是Object的实例（instanceof））\narr.__proto__ -------------Array.prototype---------Object.prototype---------null\n</code></pre>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A8.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX3ByZWNlZGVuY2U=\">运算符优先级</span></h2><h2 id=\"产品上线流程\"><a href=\"#产品上线流程\" class=\"headerlink\" title=\"产品上线流程\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTk3MDUyMDE=\">产品上线流程</span></h2><h1 id=\"plop-js-微型生成器框架\"><a href=\"#plop-js-微型生成器框架\" class=\"headerlink\" title=\"plop.js:微型生成器框架\"></a>plop.js:微型生成器框架</h1><p>plop.js可以通过命令行生成，处理文件模板代码等</p>\n<h1 id=\"JS中字符串的存储\"><a href=\"#JS中字符串的存储\" class=\"headerlink\" title=\"JS中字符串的存储:\"></a>JS中字符串的存储:</h1><p>JS字符串以Unicode编码的方式进行存储，当声明一个字符串并赋值给一个变量时，js引擎会为该字符串创建一个对象，并将字符串的内容存储在对象内部的属性中，这个对象被称为字符串对象，然而为了提高性能和减少内存的占用，当字符串是常量时，JS引擎会将其存储在一个字符串字面量池中，而不是每一次都创建新的字符串对象。当对字符串执行修改操作时，实际上是创建了一个新的字符串对象，并将修改之后的字符串存储在新的对象中，原始字符串不变。</p>\n<h1 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob:\"></a>Blob:</h1><p><strong>Blob（Binary Large Object）对象是 JavaScript 中用来表示二进制数据的对象，通常用于存储和操作文件或其他类型的二进制数据。Blob 对象可以表示大型数据对象，比如图像、视频、音频文件等。</strong></p>\n<p><strong>Blob 对象通常由两部分组成：数据和数据的类型。数据部分包含实际的二进制数据，而类型部分描述了数据的 MIME 类型，例如 “image&#x2F;png” 或 “application&#x2F;pdf”。</strong></p>\n<p><strong>Blob 对象可以通过 <code>new Blob()</code> 构造函数创建，传入一个数组作为参数，数组中包含要存储的二进制数据。另外，你还可以通过传入一个可选的对象参数，来指定数据的 MIME 类型。例如：</strong></p>\n<pre><code class=\"javascript\">javascriptCopy Codevar binaryData = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; // 用十六进制表示的字符串 &quot;Hello&quot;\nvar blob = new Blob([binaryData], &#123; type: &quot;text/plain&quot; &#125;);\n</code></pre>\n<p><strong>在上面的例子中，我们使用 <code>new Blob()</code> 创建了一个包含 “Hello” 文本数据的 Blob 对象，并指定了它的 MIME 类型为 “text&#x2F;plain”。</strong></p>\n<p><strong>Blob 对象可以被用于多种用途，比如：</strong></p>\n<ol>\n<li><strong>通过 URL.createObjectURL() 方法创建一个临时的 URL，用于在页面中显示或下载文件,一般配置a标签（download属性）。</strong></li>\n<li><strong>作为 XMLHttpRequest 的响应数据类型，用于接收和处理文件或二进制数据。</strong></li>\n<li><strong>作为 FormData 对象的值，用于将二进制数据发送到服务器。</strong></li>\n</ol>\n<p><strong>总之，Blob 对象在 JavaScript 中提供了一种方便的方式来处理和操作二进制数据，特别适合于文件操作和网络通信中的数据传输</strong></p>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer:\"></a>ArrayBuffer:</h1><p><strong>ArrayBuffer 是 JavaScript 中用于表示通用的固定长度的二进制数据缓冲区的对象。它可以在内存中分配一块连续的内存空间，用于存储二进制数据。</strong></p>\n<p><strong>ArrayBuffer 对象本身只是一个占用了一定字节数的内存块，它没有提供直接的方法来读取或写入数据。为了操作 ArrayBuffer 中的数据，我们需要使用不同的视图（如 TypedArray 或 DataView）来读取、写入和操作底层的二进制数据。</strong></p>\n<p><strong>在内存中，ArrayBuffer 对象以连续的字节序列表示。这意味着存储在 ArrayBuffer 中的数据是紧密排列的，没有额外的空隙或填充。每个字节都有一个唯一的地址，我们可以通过偏移量来访问和操作特定位置的字节。</strong></p>\n<p>以下是一个示例，展示了如何创建和使用 ArrayBuffer：</p>\n<pre><code class=\"javascript\">javascriptCopy Code// 创建一个包含 16 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(16);\n\n// 使用一个 Int32Array 视图来读取和写入数据\nconst int32Array = new Int32Array(buffer);\n\n// 写入数据\nint32Array[0] = 42;\nint32Array[1] = 99;\n\n// 读取数据\nconsole.log(int32Array[0]); // 输出 42\nconsole.log(int32Array[1]); // 输出 99\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 16 字节的 ArrayBuffer。然后，我们使用 Int32Array 视图来操作这个 ArrayBuffer，将数据写入到数组中，并通过下标直接访问和读取数据。在内存中，这些数据被紧密排列在连续的字节中。</p>\n<p><strong>需要注意的是，ArrayBuffer 的长度是固定的，一旦分配了特定大小的内存空间，就无法改变它的大小。如果我们需要更改数据的长度，我们需要创建一个新的 ArrayBuffer，并将旧数据拷贝到新的 ArrayBuffer 中。</strong></p>\n<p>总之，ArrayBuffer 提供了一种在 JavaScript 中操作底层二进制数据的机制，它在内存中以连续的字节序列表示，可以用于存储和操作各种类型的二进制数据。</p>\n<h1 id=\"DataView视图：\"><a href=\"#DataView视图：\" class=\"headerlink\" title=\"DataView视图：\"></a>DataView视图：</h1><p>DataView 是 JavaScript 中的一个类型化数组视图，用于以不同的字节序（如大端序或小端序）和不同的数据类型（如整数、浮点数等）来读取和写入 ArrayBuffer 中的二进制数据。与 TypedArray 不同，DataView 可以指定任意的字节偏移量和长度，可以更加灵活地操作二进制数据。</p>\n<p>以下是一个使用 DataView 读取 ArrayBuffer 中的二进制数据的示例：</p>\n<pre><code class=\"javascript\">javascriptCopy Code// 创建一个包含 8 字节的 ArrayBuffer\nconst buffer = new ArrayBuffer(8);\n\n// 使用一个 DataView 视图来读取和写入数据\nconst dataView = new DataView(buffer);\n\n// 写入数据\ndataView.setInt16(0, 42); // 在第 1 和第 2 个字节中写入 42\ndataView.setInt32(2, -100); // 在第 3 到第 6 个字节中写入 -100\n\n// 读取数据\nconsole.log(dataView.getInt16(0)); // 输出 42\nconsole.log(dataView.getInt32(2)); // 输出 -100\n</code></pre>\n<p>在上述示例中，我们创建了一个长度为 8 字节的 ArrayBuffer。然后，我们使用一个 DataView 视图来操作这个 ArrayBuffer，分别在前两个字节和后四个字节中写入两个不同的数据，然后通过 DataView 的方法来读取这些数据。</p>\n<p>需要注意的是，DataView 的方法名都以数据类型名称开头，并以字节偏移量作为第一个参数。例如，<code>setInt16(offset, value)</code> 方法将一个 16 位整数值写入到指定偏移量处，而 <code>getInt32(offset)</code> 方法则从指定偏移量处读取一个 32 位整数值。这些方法还可以接受一个可选的第二个参数，用于指定字节序，以帮助正确地解释二进制数据。</p>\n<p>总之，DataView 提供了一种灵活和可定制的方式来读取和写入 ArrayBuffer 中的二进制数据，可以指定不同的字节序和数据类型，并支持任意偏移量和长度。</p>\n<h1 id=\"JS中类型化数组（typed-array）：\"><a href=\"#JS中类型化数组（typed-array）：\" class=\"headerlink\" title=\"JS中类型化数组（typed array）：\"></a>JS中类型化数组（typed array）：</h1><p><strong>JavaScript 的类型化数组是一种特殊的数组，可以存储和操作固定类型的数据，如整数、浮点数、字节等。相比于普通的 JavaScript 数组，类型化数组有以下几个优点：</strong></p>\n<ol>\n<li><strong>更加高效：类型化数组在内存中是连续存储的，这意味着它们可以更快地被读取和写入。此外，它们还允许我们直接访问底层的二进制数据，而不需要进行类型转换或拷贝操作。</strong></li>\n<li><strong>更加节省空间：由于类型化数组只能存储固定类型的数据，因此它们使用的内存空间可以更加紧凑。例如，使用 Int8Array 数组可以将每个元素压缩为 1 个字节，而使用普通的 JavaScript 数组则需要至少 8 个字节来存储一个数字。</strong></li>\n<li><strong>更加易于处理二进制数据：类型化数组可以帮助我们更加方便地处理二进制数据，如音频、视频、图像等。这些数据通常以二进制格式存储，而类型化数组可以直接读取和操作这些数据，而不需要进行复杂的解析和转换操作。</strong></li>\n</ol>\n<p><strong>总之，类型化数组可以带来更高效、更紧凑、更直接的二进制数据处理体验，是 JavaScript 中处理二进制数据时非常有用的工具。虽然普通的 JavaScript 数组也可以存储二进制数据，但它们没有类型化数组那样的高效和直接性。因此，在需要处理大量二进制数据时，使用类型化数组会更加合适。</strong></p>\n<h5 id=\"Int8Array\"><a href=\"#Int8Array\" class=\"headerlink\" title=\"Int8Array:\"></a>Int8Array:</h5><p>①只能存储8位有符号整数（-128到127），②使用固定大小的内存来存储数据，每个元素占用一个字节（8位）③元素连续存储</p>\n<pre><code class=\"javascript\">// 以长度参数构造对象\nvar int8 = new Int8Array(2);\nint8[0] = 42;\nconsole.log(int8[0]); // 42\nconsole.log(int8.length); // 2\nconsole.log(int8.BYTES_PER_ELEMENT); // 数组所占用的字节数\n// 以数组构造对象\nvar arr = new Int8Array([21, 31]);\nconsole.log(arr[1]); // 31\n// 从另一数组构造对象\nvar x = new Int8Array([21, 31]);\nvar y = new Int8Array(x);\nconsole.log(y[0]); // 21\n// 从 ArrayBuffer 构造对象\nvar buffer = new ArrayBuffer(8);\nvar z = new Int8Array(buffer, 1, 4);\n</code></pre>\n<h5 id=\"还有：Uint8Array等类型\"><a href=\"#还有：Uint8Array等类型\" class=\"headerlink\" title=\"还有：Uint8Array等类型\"></a>还有：Uint8Array等类型</h5><h3 id=\"forEach的回调函数中不传参数\"><a href=\"#forEach的回调函数中不传参数\" class=\"headerlink\" title=\"forEach的回调函数中不传参数\"></a>forEach的回调函数中不传参数</h3><pre><code class=\"javascript\">const dfs = function(root)&#123;\n    console.log(root.val,&#39;还好&#39;);\n    root.children.forEach(dfs);//forEach回调不传参数，默认传的参数就是item项\n&#125;\n</code></pre>\n<p>forEach回调函数中不传参数，默认将item项作为变量进行传递</p>\n<h2 id=\"不常见html标签：\"><a href=\"#不常见html标签：\" class=\"headerlink\" title=\"不常见html标签：\"></a>不常见html标签：</h2><p>dialog弹窗</p>\n<p><img data-src=\"/images/image-20240122101335456.png\" alt=\"/images/image-20240122101335456\"></p>\n<p>details详细</p>\n<p><img data-src=\"/images/image-20240122101339487.png\" alt=\"/images/image-20240122101339487\"></p>\n<p>刻度尺</p>\n<p><img data-src=\"/images/image-20240122101344976.png\" alt=\"/images/image-20240122101344976\"></p>\n<p>进度条</p>\n<p><img data-src=\"/images/image-20240122101352284.png\" alt=\"/images/image-20240122101352284\"></p>\n<p>时间</p>\n<p><img data-src=\"/images/image-20240122101359606.png\" alt=\"/images/image-20240122101359606\"></p>\n<p>高亮文本</p>\n<p><img data-src=\"/images/image-20240122102818128.png\" alt=\"/images/image-20240122102818128\"></p>\n<p>注解发音</p>\n<p><img data-src=\"/images/image-20240122102837759.png\" alt=\"/images/image-20240122102837759\"></p>\n<p>数据列表</p>\n<p><img data-src=\"/images/image-20240122102908520.png\" alt=\"/images/image-20240122102908520\"></p>\n<p>上标，下标</p>\n<p><img data-src=\"/images/image-20240122102926938.png\" alt=\"/images/image-20240122102926938\"></p>\n<p>虚线标识的</p>\n<p><img data-src=\"/images/image-20240122102943236.png\" alt=\"/images/image-20240122102943236\"></p>\n<p>地图标签</p>\n<p><img data-src=\"/images/image-20240122103024494.png\" alt=\"/images/image-20240122103024494\"></p>\n<h1 id=\"vue3中通过位运算进行类型判断\"><a href=\"#vue3中通过位运算进行类型判断\" class=\"headerlink\" title=\"vue3中通过位运算进行类型判断\"></a>vue3中通过位运算进行类型判断</h1><p>性能提高，可读性减小：</p>\n<ol>\n<li>快速判断：位运算是底层的二进制操作，比起其他逻辑运算符，如逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code>，位运算更加高效。在某些场景下，使用位运算可以对多个类型进行快速判断，避免了复杂的条件判断和函数调用。</li>\n<li>位运算的特性：位运算的特性使得它可以用较少的存储空间表示和处理多个状态或标志位。通过将多个类型的判断压缩到一个整数中，可以节省内存空间，并且减少了不必要的变量声明和赋值操作，从而提升了性能。</li>\n</ol>\n<h1 id=\"自增运算在属性中的运用\"><a href=\"#自增运算在属性中的运用\" class=\"headerlink\" title=\"自增运算在属性中的运用\"></a>自增运算在属性中的运用</h1><pre><code class=\"javascript\">let a = [1,2]\nlet index = 0\na[index++]=a[index] \n//相当于a[1]=a[0],自增运算符优先级大于赋值运算符，代码可以拆分为：\n//左边=a[index] index++ 左边=a[index](第二次index自增过了)\nconsole.log(a);\n</code></pre>\n<h1 id=\"类的私有属性\"><a href=\"#类的私有属性\" class=\"headerlink\" title=\"类的私有属性\"></a>类的私有属性</h1><p><strong>js中可以通过#标识私有属性，但是不是全部的js运行环境都支持。</strong></p>\n<p><strong>ts中通过private关键字来标识私有属性，可以通过ts转为兼容性代码。</strong></p>\n<pre><code class=\"javascript\">class ClassWithPrivateField &#123;\n    #pricateField;\n    constructor()&#123;\n        this.#pricateField=1\n    &#125;\n  &#125;\n  const aaa = new ClassWithPrivateField()\n  console.log(aaa.#pricateField); //报错：属性在类的外部不可访问\n</code></pre>\n<h1 id=\"图片上传：\"><a href=\"#图片上传：\" class=\"headerlink\" title=\"图片上传：\"></a>图片上传：</h1><p><strong>input标签中file（accetp接受类型） 、</strong></p>\n<p><strong>fileList（change事件的e.target.files[0]） 、</strong></p>\n<p><strong>Blob（二进制格式数据）、</strong></p>\n<p><strong>FileReader（将文本文件file转为字符串或者URL）、</strong></p>\n<p><strong>URL scheme 、</strong></p>\n<p><strong>拖拽事件：dragenter、dragover、drop</strong></p>\n<h1 id=\"将字符串转换为二进制形式\"><a href=\"#将字符串转换为二进制形式\" class=\"headerlink\" title=\"将字符串转换为二进制形式\"></a>将字符串转换为二进制形式</h1><pre><code class=\"javascript\">    function toBianary(str)&#123;\n        let res = &#39;&#39;;\n        for(let i=0;i&lt;str.length;i++)&#123;\n            let charCode = str.charCodeAt(i);\n            let binaryCharCode = charCode.toString(2);\n            res += binaryCharCode.padStart(8,&#39;0&#39;);\n        &#125;\n        return res;\n    &#125;\n</code></pre>\n","categories":["底层杂记","工具函数"],"tags":["底层杂记","工具函数"]},{"title":"微前端","url":"/2024/05/24/%E5%BE%AE%E5%89%8D%E7%AB%AF/","content":"<h1 id=\"微前端\"><a href=\"#微前端\" class=\"headerlink\" title=\"微前端\"></a>微前端</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，这样才能确保微应用真正具备独立开发、独立运行的能力（防止巨石应用）</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>微前端按业务功能将一整块前端应用分解成一系列更小的、更内聚的微前端应用，同时通过明确的交互协议来管理这些应用间的依赖关系，实现不同业务的解耦合。并将每个前端应用交给独立团队负责，各自独立开发、独立部署、充分利用并行性。</p>\n<ul>\n<li>微前端是一种架构风格，monorepo是一种开发策略，模块联邦是一种打包和部署方式<ul>\n<li>微前端将大型的前端应用分解成一组小的、独立的前端服务，每一个小的前端服务可以由不同的团队独立开发、部署和维护。微前端的目标是提高大型前端项目的可维护性、可扩展性和灵活性</li>\n<li>monorepo是一种开发策略（技巧），它将多个项目或服务的代码放在一个单一的版本控制系统仓库中，有助于简化依赖管理、代码共享和团队协作。对于工具库能更好的暴露单独模块。</li>\n<li>模块联邦是Webpack5引入的一个特性，允许将多个Webpack项目远程接入、联合起来，形成一个单一的应用，每个模块可以独立开发和部署，同时共享彼此的代码，模块联邦是一种新的打包和部署前端应用的方式。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"微前端应用\"><a href=\"#微前端应用\" class=\"headerlink\" title=\"微前端应用\"></a>微前端应用</h1><h2 id=\"EMP\"><a href=\"#EMP\" class=\"headerlink\" title=\"EMP\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbXAyLm5ldGxpZnkuYXBwLw==\">EMP</span></h2><p>模块联邦技术，微前端构建方案，是基于 webpack 5 module federation 的微前端方案。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>webpack 联邦编译可以保证所有子应用依赖解耦；</li>\n<li>应用间去中心化的调用、共享模块；</li>\n<li>模块远程 ts 支持；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>对 webpack 强依赖，老旧项目不友好；</li>\n<li>没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；</li>\n<li>子应用保活、多应用激活无法实现；</li>\n<li>主、子应用的路由可能发生冲突；</li>\n</ol>\n<p>底层原理 这个东西有点类似于拆包，也可以叫模块共享，例如React有个模块可以共享给Vue项目用Vue2的组件可以共享给Vue3用。</p>\n<h2 id=\"single-spa\"><a href=\"#single-spa\" class=\"headerlink\" title=\"single-spa\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1oYW5zLnNpbmdsZS1zcGEuanMub3JnL2RvY3MvZ2V0dGluZy1zdGFydGVkLW92ZXJ2aWV3\">single-spa</span></h2><p>single-spa是微前端的基础框架，乾坤框架就是基于single-spa来实现的，在single-spa的基础上做了一层封装，也解决了single-spa的一些缺陷。</p>\n<p><strong>原理</strong></p>\n<ol>\n<li>single-spa原理是通过网络请求请求到文件资源（使用import导入语法时，需要在importmap中注册包名称和地址）</li>\n<li>对于样式隔离，single-spa推荐的方法有：Scoped CSS和shadow DOM</li>\n</ol>\n<p><strong>分析</strong></p>\n<p>single-spa实现了一个微前端框架需要具备的各种功能，但是实现的又不够彻底，遗留了很多需要解决的问题。</p>\n<h2 id=\"乾坤\"><a href=\"#乾坤\" class=\"headerlink\" title=\"乾坤\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vcWlhbmt1bi51bWlqcy5vcmcvemgv\">乾坤</span></h2><p>乾坤是在single-spa的基础之上进行的进一步封装</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li>\n<li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；</li>\n<li>做了静态资源预加载能力；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li>\n<li>css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li>\n<li>无法同时激活多个子应用，也不支持子应用保活；</li>\n<li>无法支持 vite 等 esmodule 脚本运行；</li>\n</ol>\n<h2 id=\"无界\"><a href=\"#无界\" class=\"headerlink\" title=\"无界\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vd3VqaWUtbWljcm8uZ2l0aHViLmlvL2RvYy9hcGkvYnVzLmh0bWw=\">无界</span></h2><p><strong>特点</strong></p>\n<ol>\n<li>接入简单只需要四五行代码</li>\n<li>不需要针对vite额外处理</li>\n<li>预加载</li>\n<li>应用保活机制</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>隔离js使用一个空的iframe进行隔离</li>\n<li>子应用axios需要自行适配</li>\n<li>iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从’about:blank’初始化为主应用的host，这个采用的计时器去等待的不是很悠亚。</li>\n</ol>\n<p>底层原理 使用shadowDom 隔离css，js使用空的iframe隔离，通讯使用的是proxy</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>无界的原理就是使用开启影子dom来进行样式的隔离，通过使用attachShadow方法开启影子dom（继承HTMLElement），获得的shadow影子dom添加template（无界的初始模板）为子元素，这样就进行了样式隔离，最后通过window.customElement.define注册dom元素wu-jie，使用标签即可。</p>\n<p>index.js：</p>\n<pre><code class=\"javascript\">window.onload = () =&gt; &#123;\n    class WuJie extends HTMLElement &#123;\n        constructor() &#123;\n            super()\n            this.init()\n            this.getAttr(&#39;url&#39;)\n        &#125;\n        init() &#123;\n          const shadow =  this.attachShadow(&#123; mode: &quot;open&quot; &#125;) //开启影子dom 也就是样式隔离\n          const template = document.querySelector(&#39;#wu-jie&#39;) as HTMLTemplateElement\n          console.log(template);\n          shadow.appendChild(template.content.cloneNode(true))\n        &#125;\n        getAttr (str:string) &#123;\n           console.log(&#39;获取参数&#39;,this.getAttribute(str));\n        &#125;\n        //生命周期自动触发有东西插入\n        connectedCallback () &#123;\n           console.log(&#39;类似于vue 的mounted&#39;);\n        &#125;\n        //生命周期卸载\n        disconnectedCallback () &#123;\n              console.log(&#39;类似于vue 的destory&#39;);\n        &#125;\n        //跟watch类似\n        attributeChangedCallback (name:any, oldVal:any, newVal:any) &#123;\n            console.log(&#39;跟vue 的watch 类似 有属性发生变化自动触发&#39;);\n        &#125;\n    &#125;\n    window.customElements.define(&#39;wu-jie&#39;, WuJie)\n&#125;\n</code></pre>\n<p>index.html：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!--外层写一个div测试隔离--&gt;\n    &lt;div&gt;我是div&lt;/div&gt;\n    &lt;wu-jie url=&quot;xxxxxx&quot;&gt;&lt;/wu-jie&gt;\n    &lt;template id=&quot;wu-jie&quot;&gt;\n       &lt;!--div的样式是作用于全局的--&gt;\n        &lt;style&gt;\n            div &#123;\n                background: red;\n            &#125;\n        &lt;/style&gt;\n         &lt;div&gt;\n            样式隔离的\n         &lt;/div&gt;\n    &lt;/template&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h4><p>使用：</p>\n<p>需要从wujie的实例导出<code>preloadApp</code>,参数跟<code>startApp</code> 一致，预加载必须开启exec选项</p>\n<pre><code class=\"javascript\">preloadApp(&#123; name: &quot;vue3&quot;, url: &quot;http://127.0.0.1:5174/&quot;, exec: true &#125;)\npreloadApp(&#123; name: &quot;react&quot;, url: &quot;http://127.0.0.1:5175/&quot;, exec: true &#125;)\n</code></pre>\n<ul>\n<li>exec代表是否进行预加载，默认值是true</li>\n<li>js的执行模式，由于子应用的执行会阻塞主应用的渲染线程，当设置为true时js采取类似于react fiber的模式方式间断执行，每个js文件的执行都包裹在<code>requestidlecallback</code>中，每执行一个js文件后就可以返回去响应外部的输入，不会造成浏览器渲染和加载之间的冲突从而造成卡顿，但是这个颗粒度是js文件，所以应该保证js文件不应过大。</li>\n</ul>\n<p>浏览器一帧之内要做的事情：</p>\n<ul>\n<li>处理用于输入（事件）</li>\n<li>执行定时任务</li>\n<li>执行requestAnimationFrame</li>\n<li>执行dom的回流和重绘</li>\n<li>计算更新涂层的更新指令</li>\n<li>绘制指令合并主线程，如果有空余时间执行requestidlecallbask</li>\n</ul>\n<p>react也有该机制 但是react并没有用 <code>requestidlecallback</code>，说是这个东西经过测试可能会超过16ms，超过16ms绘制就会看起来很卡 所以react16是用的 <code>requestAnimationFrame + postMessage</code> 实现的那为什么不用<code>setTimeOut</code> setTimeOut 及时为0 也会有一个最小毫秒延迟4ms，所以是用了postMessage，react18又换成了<code>MessageChannel</code> 实现了队列方式去执行任务。</p>\n<h2 id=\"micro-app\"><a href=\"#micro-app\" class=\"headerlink\" title=\"micro-app\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vemVyb2luZy5qZC5jb20vbWljcm8tYXBwL2RvY3MuaHRtbCUyMy8=\">micro-app</span></h2><p>micro-app 是基于 webcomponent + qiankun sandbox 的微前端方案。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li>使用 webcomponet 加载子应用相比 single-spa 这种注册监听方案更加优雅；</li>\n<li>复用经过大量项目验证过 qiankun 的沙箱机制也使得框架更加可靠；</li>\n<li>组件式的 api 更加符合使用习惯，支持子应用保活；</li>\n<li>降低子应用改造的成本，提供静态资源预加载能力；</li>\n</ol>\n<p><strong>不足</strong></p>\n<ol>\n<li>css 沙箱依然无法绝对的隔离，js 沙箱做全局变量查找缓存，性能有所优化；</li>\n<li>支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；</li>\n<li>对于不支持 webcompnent 的浏览器没有做降级处理；</li>\n</ol>\n<p>底层原理 js隔离跟qiankun类似也是使用proxy + with，css隔离自定义前缀类似于scoped</p>\n<h1 id=\"模块联邦\"><a href=\"#模块联邦\" class=\"headerlink\" title=\"模块联邦\"></a>模块联邦</h1><p>模块联邦是跟<code>webpack5</code>强耦合的，是基于webpack5内置插件的 无须安装</p>\n<p>它相当于是一个去中心化技术，它可以让多个独立构建的应用之间，动态的调用彼此的模块。这种运行机制，可以让我们轻松的拆分应用，真正做到跨应用的模块共享。</p>\n<p>配置过程就是在webpack.config.js中配置ModuleFederationPlugin插件，打完包之后观察会发现其实就是import函数动态加载，使用模块联邦的好处就在于之前当多个项目共有的模块改变时，每一个项目都需要重新install一下，而使用模块联邦之后，就相当于动态导入，免去了重新install的过程（由项目的克隆转为类似软链接的过程）。</p>\n","categories":["微前端"],"tags":["微前端"]},{"title":"性能指标","url":"/2024/05/11/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","content":"<h1 id=\"常见浏览器性能指标\"><a href=\"#常见浏览器性能指标\" class=\"headerlink\" title=\"常见浏览器性能指标\"></a>常见浏览器性能指标</h1><h1 id=\"TTFB-Time-To-First-Byte\"><a href=\"#TTFB-Time-To-First-Byte\" class=\"headerlink\" title=\"TTFB(Time To First Byte)\"></a>TTFB(Time To First Byte)</h1><p>发出页面请求到接收到应答数据第一个字节的时间总和，包含了：</p>\n<ol>\n<li>DNS解析时间</li>\n<li>TCP链接时间</li>\n<li>发送HTTP请求时间</li>\n<li>获得响应消息第一个字节的时间。</li>\n</ol>\n<h1 id=\"FP（First-Paint）\"><a href=\"#FP（First-Paint）\" class=\"headerlink\" title=\"FP（First Paint）\"></a><strong>FP</strong>（First Paint）</h1><p>首次绘制时间，这个指标用于记录页面第一次绘制像素的时间。</p>\n<h1 id=\"FCP（First-Contentful-Paint）\"><a href=\"#FCP（First-Contentful-Paint）\" class=\"headerlink\" title=\"FCP（First Contentful Paint）\"></a><strong>FCP</strong>（First Contentful Paint）</h1><p>首次内容绘制时间，这个指标用于记录页面首次绘制文本、图片、非空白 Canvas 或 SVG 的时间。</p>\n<h1 id=\"LCP（Largest-Contentful-Paint）\"><a href=\"#LCP（Largest-Contentful-Paint）\" class=\"headerlink\" title=\"LCP（Largest Contentful Paint）\"></a><strong>LCP</strong>（Largest Contentful Paint）</h1><p>最大内容绘制时间，用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。</p>\n<h1 id=\"CLS（Cumulative-Layout-Shift）\"><a href=\"#CLS（Cumulative-Layout-Shift）\" class=\"headerlink\" title=\"CLS（Cumulative Layout Shift）\"></a><strong>CLS</strong>（Cumulative Layout Shift）</h1><p>累计位移偏移，记录了页面上非预期的位移波动。计算方式为：位移影响的面积 * 位移距离。</p>\n<h1 id=\"TTI（Time-to-Interactive）\"><a href=\"#TTI（Time-to-Interactive）\" class=\"headerlink\" title=\"TTI（Time to Interactive）\"></a><strong>TTI</strong>（Time to Interactive）</h1><p>首次可交互时间。这个指标计算过程略微复杂，它需要满足以下几个条件：</p>\n<ol>\n<li>从 FCP 指标后开始计算；</li>\n<li>持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求；</li>\n<li>往前回溯至 5 秒前的最后一个长任务结束的时间。</li>\n</ol>\n<h1 id=\"FID（First-Input-Delay）\"><a href=\"#FID（First-Input-Delay）\" class=\"headerlink\" title=\"FID（First Input Delay）\"></a><strong>FID</strong>（First Input Delay）</h1><p>首次输入延迟时间，记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。</p>\n<h1 id=\"TBT（Total-Blocking-Time）\"><a href=\"#TBT（Total-Blocking-Time）\" class=\"headerlink\" title=\"TBT（Total Blocking Time）\"></a><strong>TBT</strong>（Total Blocking Time）</h1><p>阻塞总时间，记录在 FCP 到 TTI 之间所有长任务的阻塞时间总和。</p>\n","categories":["性能优化"],"tags":["性能指标"]},{"title":"常见开源协议","url":"/2023/02/02/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/","content":"<h1 id=\"常见的开源协议\"><a href=\"#常见的开源协议\" class=\"headerlink\" title=\"常见的开源协议\"></a>常见的开源协议</h1><h3 id=\"1：Apache-License-2-0\"><a href=\"#1：Apache-License-2-0\" class=\"headerlink\" title=\"1：Apache License 2.0\"></a>1：Apache License 2.0</h3><p>这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布（作为开源或商业软件）。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>在代码中保留作者提供的协议和版权信息</li>\n<li>如果修改了代码，则必须在被修改的文件中进行说明。</li>\n</ol>\n<ul>\n<li>允许的权利<br> 商用、分发、修改、专利授权、私用<br> 、附加协议</li>\n<li>禁止项</li>\n</ul>\n<ol>\n<li>禁止因使用等造成影响责任承担、也就是说免责申明</li>\n<li>不能使用相应的商标。</li>\n</ol>\n<p><strong>提示：商业软件可以使用，也可以修改使用Apache协议的代码。</strong></p>\n<h3 id=\"2：GPLv3\"><a href=\"#2：GPLv3\" class=\"headerlink\" title=\"2：GPLv3\"></a>2：GPLv3</h3><p>此协议是应用最为广泛的开源协议，拥有较强的版权自由要求,也赋予和保证了开源项目开发者广泛的权利。基本上，它允许用户合法复制，分发和修改软件，但衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>修改后的源码也需要公开</li>\n<li>版权及协议也要于此协议一致</li>\n<li>修改后，需要在相应的文件做说明，</li>\n</ol>\n<ul>\n<li>允许<br> 商用，分发，修改，专利授权，私用</li>\n<li>禁止</li>\n</ul>\n<ol>\n<li>禁止因使用等造成影响责任承担、也就是说免责申明</li>\n<li>静止在软件分发传播过程中附加上原来没有的协议条款等</li>\n</ol>\n<p><strong>提示：商业软件不能使用GPL协议的代码。</strong></p>\n<h3 id=\"3：LGPL\"><a href=\"#3：LGPL\" class=\"headerlink\" title=\"3：LGPL\"></a>3：LGPL</h3><p>其主要用于一些代码库，LGPL比起GPL它授予的权限较少，LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。因此使用LGPL协议的开源代码可以被商业软件作为<strong>类库引用</strong>并发布和销售。注意是以类库的形式使用，也就是说如果修改了源代码的话则也必须使用LGPL协议贡献源码出来。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>公开使用了LGPL部分的代码，其余部分不需要公开。</li>\n<li>可以库引用的方式用于商业软件。</li>\n<li>在代码中保留作者提供的协议和版权信息</li>\n</ol>\n<ul>\n<li>允许<br> 商用、分发、修改、专利授权、私用、附加协议</li>\n<li>禁止<br> 禁止承担责任，(免责申明)、</li>\n</ul>\n<p><strong>提示：商业软件可以使用，但不能修改LGPL协议的代码。</strong></p>\n<p><strong>GPL&#x2F;LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</strong></p>\n<h3 id=\"4：MIT\"><a href=\"#4：MIT\" class=\"headerlink\" title=\"4：MIT\"></a>4：MIT</h3><p>宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用,也就是原作者只想保留版权,而无任何其他了限制,而你必须在发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。</p>\n<ul>\n<li>要求<br> 在代码中保留作者提供的协议和版权信息</li>\n<li>允许<br> 商用、分发、修改、私用、附加协议</li>\n<li>禁止<br> 禁止承担责任，(免责申明)</li>\n</ul>\n<p><strong>提示：商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。</strong></p>\n<h3 id=\"5：BSD\"><a href=\"#5：BSD\" class=\"headerlink\" title=\"5：BSD\"></a>5：BSD</h3><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。与MIT协议只存在细微差异。差别为MIT可以使用原名称进行宣传，而BSD不可以。</p>\n<ul>\n<li>要求<br> 在代码中保留作者提供的协议和版权信息</li>\n<li>允许<br> 商用、分发、修改、私用、附加协议</li>\n<li>禁止<br> 禁止承担责任，(免责申明)</li>\n</ul>\n<p><strong>提示：商业软件可以使用，也可以修改使用BSD协议的代码。</strong></p>\n<h3 id=\"6：Mozilla-2-0\"><a href=\"#6：Mozilla-2-0\" class=\"headerlink\" title=\"6：Mozilla 2.0\"></a>6：Mozilla 2.0</h3><p>是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点，允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，它要求基于这种软件得修改无偿贡献版权给该软件。</p>\n<ul>\n<li>要求</li>\n</ul>\n<ol>\n<li>公开源代码</li>\n<li>在代码中保留作者提供的协议和版权信息</li>\n</ol>\n<ul>\n<li>允许<br> 商用、分发、修改、专利授权、私用、附加协议</li>\n<li>禁止</li>\n</ul>\n<ol>\n<li>禁止承担责任，(免责申明)</li>\n<li>禁止使用商标</li>\n</ol>\n<p><strong>提示：商业软件可以使用，也可以修改MPL协议的代码，但修改后的代码版权归软件的发起者。</strong></p>\n","categories":["开源协议"],"tags":["开源协议"]},{"title":"手写题","url":"/2023/06/02/%E6%89%8B%E5%86%99%E9%A2%98/","content":"<h1 id=\"new关键字\"><a href=\"#new关键字\" class=\"headerlink\" title=\"new关键字\"></a>new关键字</h1><p><strong>new关键字实现分为三步：</strong></p>\n<p>1、根据构造函数的原型创建新的对象<br>2、执行构造函数，绑定this指向为新对象，传入参数<br>3、返回执行后的结果</p>\n<pre><code class=\"javascript\">function myNew(constructor,...args)&#123;\n    //创建对象，原型为构造函数的原型对象\n    const obj = Object.create(constructor.prototype);\n    //执行构造函数，传入创建的对象和参数\n    const res = constructor.apply(obj,args); //注意apply方法是函数对象的方法，普通对象不可用\n    return (res &amp;&amp; typeof res === &#39;object&#39;)?res:obj;    \n&#125;\nfunction A ()&#123;\n    this.name=&#39;sdjf&#39;\n&#125;\nconst ab = myNew(A)\nconsole.log(ab);\n</code></pre>\n<h1 id=\"手写class\"><a href=\"#手写class\" class=\"headerlink\" title=\"手写class\"></a>手写class</h1><pre><code class=\"javascript\">function Example(name) &#123;\n    if(!new.target) throw new TypeError(&quot;该函数应该使用new来调用&quot;);\n    this.name = name\n&#125;\nObject.definePropertie(Example.prototype,&quot;init&quot;,&#123;\n    enumerable:false,\n    value: function () &#123;\n        &#39;use strict&#39;;\n        if(new.target) throw new Error(&quot;init函数不能使用new来调用&quot;);\n        let fn = function () &#123;\n            console.log(this.name);\n        &#125;\n        fn.call(this);\n    &#125;\n&#125;)\n</code></pre>\n<h1 id=\"闭包的简单使用\"><a href=\"#闭包的简单使用\" class=\"headerlink\" title=\"闭包的简单使用\"></a>闭包的简单使用</h1><pre><code class=\"javascript\">//闭包隐藏数据,只提供API操作\nfunction createCache() &#123;\n  const cache = &#123;&#125;;\n  return &#123;\n    get(key)&#123;\n      return cache[key]\n    &#125;,\n    set(key,val)&#123;\n      cache[key] = val;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h1 id=\"判断数据类型\"><a href=\"#判断数据类型\" class=\"headerlink\" title=\"判断数据类型\"></a>判断数据类型</h1><pre><code class=\"javascript\">function myTypeOf(obj) &#123;\n   // 使用toString\n       const typeMap = &#123;\n           &quot;[object Object]&quot;: &quot;Object&quot;,\n           &quot;[object Array]&quot;: &quot;Array&quot;,\n           &quot;[object String]&quot;: &quot;String&quot;,\n           &quot;[object Number]&quot;: &quot;Number&quot;,\n           &quot;[object Boolean]&quot;: &quot;Boolean&quot;,\n           &quot;[object Function]&quot;: &quot;Function&quot;,\n           &quot;[object Null]&quot;: &quot;Null&quot;, // 注意这里是 &quot;Null&quot; 而不是 &quot;null&quot;\n           &quot;[object Undefined]&quot;: &quot;Undefined&quot;, // 注意这里是 &quot;Undefined&quot; 而不是 &quot;undefined&quot;\n           &quot;[object Symbol]&quot;: &quot;Symbol&quot;,\n           &quot;[object BigInt]&quot;: &quot;BigInt&quot;\n       &#125;;\n   return typeMap[Object.prototype.toString.call(obj)];\n   // 或者根据类型进行判断\n   switch (typeof obj) &#123;\n       case &quot;object&quot;:\n           if(Array.isArray(obj)) return &quot;Array&quot;\n           if(obj === &quot;null&quot;) return &quot;null&quot;;\n           return &quot;Object&quot;;\n       case &quot;number&quot;:\n           return &quot;Number&quot;;\n       case &quot;string&quot;:\n           return &quot;String&quot;;\n       case &quot;undefined&quot;:\n           return &quot;undefined&quot;;\n       case &quot;bigint&quot;:\n           return &quot;BigInt&quot;;\n       case &quot;boolean&quot;:\n           return &quot;Boolean&quot;;\n       case &quot;function&quot;:\n           return &quot;Function&quot;;\n       case &quot;symbol&quot;:\n           return &quot;Symbol&quot;;\n       default:\n           return &quot;unknown&quot;\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h1><pre><code class=\"javascript\">function unique(arr) &#123;\n   return new Array(...new Set(arr))\n&#125;\n</code></pre>\n<h1 id=\"数组扁平化-扁平一层\"><a href=\"#数组扁平化-扁平一层\" class=\"headerlink\" title=\"数组扁平化(扁平一层)\"></a>数组扁平化(扁平一层)</h1><pre><code class=\"javascript\">function arrFlat(arr) &#123;\n   if(arr.flat)&#123;\n     return arr.flat(); //Array.flat方法默认扁平一层\n   &#125;\n   // 兼容es5版本：\n   const res = [];\n   arr.forEach(item=&gt;&#123;\n       if(Array.isArray(item)) res.push(...item);\n       else res.push(item) \n   &#125;)\n   return res;\n&#125;\n</code></pre>\n<h1 id=\"手写对象的-Symbol-iterator-迭代器协议（普通对象不内置迭代器）\"><a href=\"#手写对象的-Symbol-iterator-迭代器协议（普通对象不内置迭代器）\" class=\"headerlink\" title=\"手写对象的[Symbol.iterator]迭代器协议（普通对象不内置迭代器）\"></a>手写对象的[Symbol.iterator]迭代器协议（普通对象不内置迭代器）</h1><pre><code class=\"javascript\"> // 内置迭代器的异质对象有：Array，String，Set，Map\nSymbol.myIterator = Symbol(&#39;myIterator&#39;);\nObject.prototype[Symbol.myIterator] = function () &#123;\n   const iterKeys = Object.keys(this);\n   let iterIndex = 0;\n   return &#123;\n       next: ()=&gt; &#123;\n           if (iterIndex &lt; iterKeys.length) &#123;\n               return &#123;\n                   value: this[iterKeys[iterIndex++]],\n                   done: false\n               &#125;;\n           &#125; else &#123;\n               return &#123;\n                   value: undefined,\n                   done: true\n               &#125;;\n           &#125;\n       &#125;\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"手写for-of循环（for-of便利前提是对象内置迭代器）\"><a href=\"#手写for-of循环（for-of便利前提是对象内置迭代器）\" class=\"headerlink\" title=\"手写for of循环（for of便利前提是对象内置迭代器）\"></a>手写for of循环（for of便利前提是对象内置迭代器）</h1><pre><code class=\"javascript\">function myForOf(obj,fn) &#123;\n   if(!obj[Symbol.iterator]) throw new TypeError(&#39;obj不存在迭代器&#39;)\n   const myIterator = obj[Symbol.iterator]();\n   let cur = myIterator.next();\n   while (!cur.done) &#123;\n       fn(cur.value);\n       cur = myIterator.next();\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"手写for-in循环（for-in的前提是对象属性可被枚举，Object-keys也是）\"><a href=\"#手写for-in循环（for-in的前提是对象属性可被枚举，Object-keys也是）\" class=\"headerlink\" title=\"手写for in循环（for in的前提是对象属性可被枚举，Object.keys也是）\"></a>手写for in循环（for in的前提是对象属性可被枚举，Object.keys也是）</h1><pre><code class=\"javascript\">function myForIn(obj,fn) &#123;\n   const keys = Object.keys(obj);\n   keys.forEach(item=&gt;&#123;\n       fn(&#123;[item]:obj[item]&#125;);\n   &#125;)\n&#125;\n</code></pre>\n<h1 id=\"浅拷贝，返回新的对象，丢失原型链\"><a href=\"#浅拷贝，返回新的对象，丢失原型链\" class=\"headerlink\" title=\"浅拷贝，返回新的对象，丢失原型链\"></a>浅拷贝，返回新的对象，丢失原型链</h1><pre><code class=\"javascript\">function shallowClone(objLike) &#123;\n   if(typeof objLike !== &#39;object&#39;) return objLike;\n   const res = Array.isArray(objLike)?[]:&#123;&#125;;\n   for(let item in objLike)&#123;\n       if(objLike.hasOwnProperty(item))&#123;\n           res[item] = objLike[item];\n       &#125;\n   &#125;\n   return res;\n&#125;\n</code></pre>\n<h1 id=\"手写深拷贝\"><a href=\"#手写深拷贝\" class=\"headerlink\" title=\"手写深拷贝\"></a>手写深拷贝</h1><pre><code class=\"javascript\">// 是否是对象类型\nconst isObject = (obj) =&gt; typeof obj === &#39;object&#39; || typeof obj === &#39;function&#39; &amp;&amp; obj !== null;\nfunction deepClone(target,map = new WeakMap()) &#123;\n   if(structuredClone) return structuredClone(target);\n   // 兼容structuredClone,因为要进行递归处理，所以需要增加默认参数\n   if(map.get(target)) return target;\n   let constructor = target.constructor; //获取到constructor\n   // 如果是日期或者正则，就新创建一个实例\n   if(/^(RegExp|Date)$/i.test(constructor.name))&#123;\n       return new constructor(target);\n   &#125;\n   if(isObject(target))&#123;\n       map.set(target,true);\n       const cloneTarget = Array.isArray(target) ? []:&#123;&#125;;\n       for(let prop in target)&#123;\n           if(target.hasOwnProperty(prop))&#123;\n               cloneTarget[prop] = deepClone(target[prop],map);\n           &#125;\n       &#125;\n       return cloneTarget;\n   &#125;else &#123;\n       return target;\n   &#125;\n&#125;\n// &gt; 注意：1、原型链不能形成闭环（报错），2、__proto__的值只能是对象或者null，3、一个对象只能又一个[[Prorotype]]，4、__proto__是内部[[Prototype]]的getter/setter。\n</code></pre>\n<h1 id=\"手写全局事件总线\"><a href=\"#手写全局事件总线\" class=\"headerlink\" title=\"手写全局事件总线\"></a>手写全局事件总线</h1><pre><code class=\"javascript\">class EventEmitter&#123;\n   #cache = &#123;&#125;;\n   constructor()&#123;&#125;\n   on(name,fn)&#123;\n       if(this.#cache[name])&#123;\n           this.#cache[name].push(fn);\n       &#125;else&#123;\n           this.#cache[name] = [fn]\n       &#125;\n   &#125;\n   off(name,fn)&#123;\n       if(!this.#cache[name]) return;\n       this.#cache[name] = this.#cache[name].filter(item=&gt;&#123;\n          return item !== fn;\n       &#125;)\n   &#125;\n   emit(name)&#123;\n       this.#cache[name].forEach(item=&gt;&#123;\n           item();\n       &#125;)\n   &#125;\n&#125;\n// 复习CustomEvent、Event和EventTarget（dispatchEvent和addEventListener）\nconst sayHiEvent = new CustomEvent(&#39;sayHi&#39;,&#123;\n   detail:&#123;\n       name:&quot;sayHi事件&quot;\n   &#125;\n&#125;)\nconst eventTarget = new EventTarget();\neventTarget.addEventListener(&#39;sayHi&#39;,(e)=&gt;&#123;\n   console.log(e.detail,&#39;e.detail&#39;);\n&#125;)\n// eventTarget.dispatchEvent(sayHiEvent)\n\n//深度思考：为什么eventTarget使用dispatchEvent时，要传入Event事件，而不是type类型？\n//因为一个DOM同一事件不能重复，并且同一事件类型一般要创建很多个事件（用于不同的DOM，因此不能复用同一事件），此时用类型很难对其标识\n</code></pre>\n<h1 id=\"遍历输出构造类\"><a href=\"#遍历输出构造类\" class=\"headerlink\" title=\"遍历输出构造类\"></a>遍历输出构造类</h1><pre><code class=\"javascript\">function consoClass(classFn) &#123;\n   let a = Object.getPrototypeOf(classFn);\n   while (a !== null) &#123;\n       console.log(a);\n       a = Object.getPrototypeOf(a);\n   &#125;\n&#125;\n// HTMLElement--Element--Node--EventTarget--Object--null\nconsoClass(HTMLElement)\n</code></pre>\n<h1 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h1><pre><code class=\"javascript\">const imgList = [...document.querySelectorAll(&quot;image&quot;)];\nconst imgLength = imgList.length;\nconst imgLazyLoad = (function () &#123;\n   let count = 0;\n   return function () &#123;\n       let deleteIndexList = [];\n       //遍历图片列表\n       imgList.forEach((item,index)=&gt;&#123;\n           let rect = item.getBoundingClientRect();\n           // 如果rect.top小于window.innerHeight，代表以及进入视野之内\n           if(rect.top &lt; 0)&#123;\n               item.src = item.dataset.src;\n               deleteIndexList.push(index);\n           &#125;\n       &#125;)\n       imgList = imgList.filter((item,index)=&gt;!deleteIndexList.includes(index));\n   &#125;\n&#125;)()\n\ndocument.addEventListener(&quot;scroll&quot;,imgLazyLoad);\n</code></pre>\n<h1 id=\"函数防抖（多次执行，重新计时）\"><a href=\"#函数防抖（多次执行，重新计时）\" class=\"headerlink\" title=\"函数防抖（多次执行，重新计时）\"></a>函数防抖（多次执行，重新计时）</h1><pre><code class=\"javascript\">function debounce(fn,time) &#123;\n   let timer = null;\n   return function () &#123;\n       const bindFn = fn.bind(this,...arguments)\n       clearTimeout(timer);\n       setTimeout(() =&gt; &#123;\n           bindFn();\n       &#125;, time);\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"函数节流（固定时间只执行一次）\"><a href=\"#函数节流（固定时间只执行一次）\" class=\"headerlink\" title=\"函数节流（固定时间只执行一次）\"></a>函数节流（固定时间只执行一次）</h1><pre><code class=\"javascript\">function th(fn,time) &#123;\n   let timer = null;\n   return function () &#123;\n       if(timer) return;\n       const bindFn = fn.bind(this,...arguments)\n       timer = setTimeout(() =&gt; &#123;\n           bindFn();\n           clearTimeout(timer);\n       &#125;, time);\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"函数柯里化\"><a href=\"#函数柯里化\" class=\"headerlink\" title=\"函数柯里化\"></a>函数柯里化</h1><pre><code class=\"javascript\">function curry(fn) &#123;\n   //将fn函数进行柯里化\n   return function curried(...args) &#123;\n       if(args.length &gt;= fn.length)&#123;\n           return fn.apply(this,args);\n       &#125;else&#123;\n           return function (...args2) &#123;\n               return curried.apply(this,args.concat(args2))\n           &#125;\n       &#125;\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"函数偏函数化\"><a href=\"#函数偏函数化\" class=\"headerlink\" title=\"函数偏函数化\"></a>函数偏函数化</h1><pre><code class=\"javascript\">function partial(fn,...args) &#123;\n   return (...arg) =&gt; &#123;\n       return fn(...args,...arg);\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"使用jsonp进行跨域get请求\"><a href=\"#使用jsonp进行跨域get请求\" class=\"headerlink\" title=\"使用jsonp进行跨域get请求\"></a>使用jsonp进行跨域get请求</h1><pre><code class=\"javascript\">const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123;\n   const generateUrl = () =&gt; &#123;\n       let dataSrc = &#39;&#39;\n       for (let key in params) &#123;\n           if (params.hasOwnProperty(key)) &#123;\n               dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`\n           &#125;\n       &#125;\n       dataSrc += `callback=$&#123;callbackName&#125;`\n       return `$&#123;url&#125;?$&#123;dataSrc&#125;`\n   &#125;\n   return new Promise((resolve, reject) =&gt; &#123;\n       const scriptEle = document.createElement(&#39;script&#39;)\n       scriptEle.src = generateUrl()\n       document.body.appendChild(scriptEle)\n       window[callbackName] = data =&gt; &#123;\n           resolve(data)\n           document.removeChild(scriptEle)\n       &#125;\n   &#125;)\n&#125;\n</code></pre>\n<h1 id=\"AJAX封装get请求JSON数据\"><a href=\"#AJAX封装get请求JSON数据\" class=\"headerlink\" title=\"AJAX封装get请求JSON数据\"></a>AJAX封装get请求JSON数据</h1><pre><code class=\"javascript\">\nfunction getJSON(url) &#123;\n   return new Promise((resolve,reject)=&gt;&#123;\n       const xhr = new XMLHttpRequest();\n       xhr.open(&quot;GET&quot;,url,false);\n       xhr.setRequestHeader(&quot;Accept&quot;,&quot;application/json&quot;);\n       xhr.onreadystatechange = function () &#123;\n           if(xhr.status !== 4) return;\n           if(xhr.status === 200 || xhr.status === 304) &#123;\n               resolve(xhr.responseText);\n           &#125;else &#123;\n               reject(new Error(xhr.responseText));\n           &#125;\n       &#125;\n       xhr.send();\n   &#125;)\n&#125;\n</code></pre>\n<h1 id=\"实现forEach\"><a href=\"#实现forEach\" class=\"headerlink\" title=\"实现forEach\"></a>实现forEach</h1><pre><code class=\"javascript\">Array.prototype.myForEach = function (callback,thisArg) &#123;\n   if(this === null) throw new TypeError(&quot;this is null or not defined&quot;);\n   // 如果回调不是函数\n   if(typeof  callback !== &#39;function&#39;) throw new TypeError(callback + &quot;is not a function&quot;);\n   const superThis = Object(this); //将this进行兼容，确保不是null或undefined\n   const len = superThis.length &gt;&gt;&gt; 0; //确保该函数的参数是正整数或0\n   let k = 0;\n   while (k &lt; len) &#123; //当k小于0进行遍历\n       if(k in superThis)&#123;\n           callback.call(thisArg,superThis[k],k,superThis);\n       &#125;\n       k++;\n   &#125;\n&#125;\n</code></pre>\n<h1 id=\"实现map\"><a href=\"#实现map\" class=\"headerlink\" title=\"实现map\"></a>实现map</h1><pre><code class=\"javascript\">Array.prototype.myMap = function (callback,thisArg) &#123;\n   if(this.null) throw new TypeError(&quot;this is null or defined&quot;);\n   if(typeof callback !== &quot;function&quot;) throw new TypeError(callback.name + &quot;is not a function&quot;);\n   const thisObj = Object(this); //保证thisObj不是null或undefined，使用Object可以传入数组，使用Array需要列出来\n   const len = thisObj.length &gt;&gt;&gt; 0; //无符号右移0，内部全部流程：valueOf、toString、Number，然后无符号左移（去小数）\n   let k =0;res = []\n   while (k &lt; len) &#123;\n       if(k in thisObj)&#123;\n           res[k]=callback.call(thisArg,thisObj[k],k,thisObj);\n       &#125;\n       k++;\n   &#125;\n   return res;\n&#125;\n</code></pre>\n<h1 id=\"实现filter\"><a href=\"#实现filter\" class=\"headerlink\" title=\"实现filter\"></a>实现filter</h1><pre><code class=\"javascript\">\nArray.prototype.myFilter = function (callback,thisArg) &#123;\n   if(this == null) return new TypeError(&quot;this is null or undefined&quot;)\n   if(typeof callback !== &quot;function&quot;) return new TypeError(callback.name + &quot;is not a function&quot;)\n   // 处理filter\n   const thisObj = Object(this);\n   const len = thisObj.length &gt;&gt;&gt; 0;\n   let res = [],k = 0;\n   while (k &lt; len) &#123;\n       if(k in thisObj)&#123;\n           if(callback.call(thisArg,thisObj[k],k,thisObj))&#123;\n               res.push(thisObj[k]);\n           &#125;\n       &#125;\n       k++;\n   &#125;\n   return res;\n&#125;\n</code></pre>\n<h1 id=\"实现some\"><a href=\"#实现some\" class=\"headerlink\" title=\"实现some\"></a>实现some</h1><pre><code class=\"javascript\">Array.prototype.mySome = function (callback,thisArg) &#123;\n   if(this == null) return new TypeError(&quot;this is null or undefined&quot;);\n   if(typeof callback !== &quot;function&quot;) return new TypeError(callback.name + &quot;is not a function&quot;)\n   const thisObj = Object(this);\n   let len = thisObj.length,k = 0;    \n   while (k &lt; len) &#123;\n       if(k in thisObj)&#123;\n           if(callback.call(thisArg,thisObj[k],k,thisObj))&#123;\n               return true;\n           &#125;\n       &#125;\n       k++;\n   &#125;\n   return false;\n&#125;\n</code></pre>\n<h1 id=\"实现reduce\"><a href=\"#实现reduce\" class=\"headerlink\" title=\"实现reduce\"></a>实现reduce</h1><pre><code class=\"javascript\">Array.prototype.myReduce = function (callback,initialValue) &#123;\n   if(this == null) return new TypeError(&quot;this is null or undefined&quot;);\n   if(typeof callback !== &quot;function&quot;) return TypeError(callback.name + &quot;is not a function&quot;);\n   const thisObj = Object(this); //防止null或者undefined\n   const len = thisObj.length;\n   let res,k=0;\n   while (k &lt; len) &#123;\n       if(k in thisObj)&#123;\n           //进行执行\n           initialValue = callback(initialValue,thisObj[k]);\n       &#125;\n       k++;\n   &#125;\n   return initialValue;\n&#125;\n</code></pre>\n<h1 id=\"手写call、apply-和-bind\"><a href=\"#手写call、apply-和-bind\" class=\"headerlink\" title=\"手写call、apply 和 bind\"></a>手写call、apply 和 bind</h1><pre><code class=\"javascript\">Function.prototype.myCall = function (thisContext) &#123;\n    // 将this（函数），绑定this,传入参数\n    thisContext = thisContext || window; //this默认为window\n    const fn = Symbol(thisContext);\n    thisContext[fn] = this; //将this函数挂载到thisContext环境中\n    let args = [...arguments].slice(1);\n    thisContext[fn](...args); //用对象[属性]的方式使用函数（绑定this）\n    delete thisContext[fn]; //最后删除属性\n&#125;\n//小结：使用call绑定this的关键就在于：将this（也就是函数）挂载到thisContext（需要绑定的this上），使用对象[属性]的方式进行执行，从而自动绑定this\n\nFunction.prototype.myApply = function (thisContext) &#123;\n    const fn = Symbol(&quot;myApply&quot;);\n    // 将fn绑定到黄经中\n    thisContext[fn] = this;\n    //执行\n    const args = [...arguments].slice(1);\n    thisContext[fn](args);\n    delete thisContext[fn]; //删除属性之后，垃圾回收机制自动回收fn\n&#125;\n\nFunction.prototype.myBind = function (thisContext) &#123;\n    // 函数绑定\n    //返会一个函数,绑定this指向，到固定的函数上\n    const thisFn = this;\n    const arg = [...arguments].slice(1); //保存传入的参数\n    return function () &#123;\n        const newArg = [...arguments];\n        return thisFn.apply(thisContext,[...arg,...newArg])\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><pre><code class=\"javascript\">\nfunction myInstanceOf(left,right) &#123;\n    //判断left是不是right的子类，遍历left的原型链，看是否有right\n    if(typeof left !== &quot;object&quot;) throw new TypeError(&quot;Left-hand side of myInstanceOf is not an object&quot;);\n    if(typeof right !== &quot;object&quot;) throw new TypeError(&quot;Right-hand side of myInstanceOf is not an object&quot;);\n    while (Object.getPrototypeOf(left)) &#123;\n        left = Object.getPrototypeOf(left);\n        if(left === Object.getPrototypeOf(right))&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h1 id=\"实现Object-create\"><a href=\"#实现Object-create\" class=\"headerlink\" title=\"实现Object.create\"></a>实现Object.create</h1><pre><code class=\"javascript\">// 参数一：proto 二：属性对象\nObject.myCreate = function (proto,propertyObj) &#123;\n    if(typeof proto !== &quot;object&quot; &amp;&amp; typeof proto !== &quot;function&quot;)&#123;\n        throw new TypeError(&quot;object prototype may not be an object or null&quot;)\n    &#125;\n    if(propertyObj === null)&#123;\n        new TypeError(&quot;Cannot convert undefined or null to object&quot;);\n    &#125;\n    function F() &#123;&#125;\n    F.prototype = proto;\n    const obj = new F();\n    if(propertyObj !== undefined)&#123;\n        Object.defineProperties(obj,propertyObj)\n    &#125;\n    //模拟Object.create(null)\n    if(proto === null)&#123;\n        obj.__proto__ = null;\n    &#125;\n    return obj;\n&#125;\n</code></pre>\n<h1 id=\"实现Object-assign\"><a href=\"#实现Object-assign\" class=\"headerlink\" title=\"实现Object.assign\"></a>实现Object.assign</h1><pre><code class=\"javascript\">Object.myAssign = function (target,...source) &#123;\n    if(target == null)&#123;\n        throw new TypeError(&quot;Cannot convert undefined or null to object&quot;)\n    &#125;\n    // 确保是一个对象类型\n    let resObj = Object(target);\n    source.forEach(item=&gt;&#123;\n        if(item != null)&#123;\n            //如果key属性是在\n            for(let key in item)&#123;\n                //如果key是原型上的方法\n                if(item.hasOwnProperty(key))&#123;\n                    resObj[key] = item[key];\n                &#125;\n            &#125;\n        &#125;\n    &#125;)\n    return resObj;\n&#125;\n</code></pre>\n<h1 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h1><pre><code class=\"javascript\">const PENDING = Symbol.for(&#39;pending&#39;);\nconst FULFILLED = Symbol.for(&#39;fulfilled&#39;);\nconst REJECTED = Symbol.for(&#39;rejected&#39;);\nconst resolvemyPromise = (myPromise2, x, resolve, reject) =&gt; &#123;\n  if (myPromise2 === x) &#123;\n    return reject(\n      new TypeError(&quot;Chaining cycle detected for myPromise #&lt;myPromise&gt;&quot;)\n    );\n  &#125;\n  let called;\n  if ((typeof x === &quot;object&quot; &amp;&amp; x != null) || typeof x === &quot;function&quot;) &#123;\n    try &#123;\n      let then = x.then;\n      if (typeof then === &quot;function&quot;) &#123;\n        then.call(\n          x,\n          (y) =&gt; &#123;\n            if (called) return;\n            called = true;\n            resolvemyPromise(myPromise2, y, resolve, reject);\n          &#125;,\n          (r) =&gt; &#123;\n            if (called) return;\n            called = true;\n            reject(r);\n          &#125;\n        );\n      &#125; else &#123;\n        resolve(x);\n      &#125;\n    &#125; catch (e) &#123;\n      if (called) return;\n      called = true;\n      reject(e);\n    &#125;\n  &#125; else &#123;\n    resolve(x);\n  &#125;\n&#125;;\nclass myPromise &#123;\n  constructor(executor) &#123;\n    this.status = PENDING; //状态\n    this.value = undefined; //值\n    this.reason = undefined; //原因\n    this.onResolvedCallbacks = []; //成功回调数组\n    this.onRejectedCallbacks = []; //失败回调数组\n    let resolve = (value) =&gt; &#123;\n      if (value instanceof myPromise) &#123;\n        return value.then(resolve, reject);\n      &#125;\n      if (this.status === PENDING) &#123;\n        this.status = FULFILLED;\n        this.value = value;\n        this.onResolvedCallbacks.forEach((fn) =&gt; fn());\n      &#125;\n    &#125;;\n    let reject = (reason) =&gt; &#123;\n      if (this.status === PENDING) &#123;\n        this.status = REJECTED;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach((fn) =&gt; fn());\n      &#125;\n    &#125;;\n    try &#123;\n      executor(resolve, reject);\n    &#125; catch (error) &#123;\n      reject(error);\n    &#125;\n  &#125;\n  then(onFulfilled, onRejected) &#123;\n    onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (v) =&gt; v;\n    onRejected =\n      typeof onRejected === &quot;function&quot;\n        ? onRejected\n        : (err) =&gt; &#123;\n            throw err;\n          &#125;;\n    return new myPromise((resolve, reject) =&gt; &#123;\n      if (this.status === FULFILLED) &#123;\n        setTimeout(() =&gt; &#123;\n          try &#123;\n            let x = onFulfilled(this.value);\n            resolvemyPromise(myPromise2, x, resolve, reject);\n          &#125; catch (e) &#123;\n            reject(e);\n          &#125;\n        &#125;, 0);\n      &#125;\n      if (this.status === REJECTED) &#123;\n        setTimeout(() =&gt; &#123;\n          try &#123;\n            let x = onRejected(this.reason);\n            resolvemyPromise(myPromise2, x, resolve, reject);\n          &#125; catch (e) &#123;\n            reject(e);\n          &#125;\n        &#125;, 0);\n      &#125;\n      if (this.status === PENDING) &#123;\n        this.onResolvedCallbacks.push(() =&gt; &#123;\n          setTimeout(() =&gt; &#123;\n            try &#123;\n              let x = onFulfilled(this.value);\n              resolvemyPromise(myPromise2, x, resolve, reject);\n            &#125; catch (e) &#123;\n              reject(e);\n            &#125;\n          &#125;, 0);\n        &#125;);\n        this.onRejectedCallbacks.push(() =&gt; &#123;\n          setTimeout(() =&gt; &#123;\n            try &#123;\n              let x = onRejected(this.reason);\n              resolvemyPromise(myPromise2, x, resolve, reject);\n            &#125; catch (e) &#123;\n              reject(e);\n            &#125;\n          &#125;, 0);\n        &#125;);\n      &#125;\n    &#125;);\n  &#125;\n  catch(errCallback) &#123;\n    return this.then(null, errCallback);\n  &#125;\n  finally(callback) &#123;\n    return this.then(\n      (value) =&gt; &#123;\n        return myPromise.resolve(callback()).then(() =&gt; value);\n      &#125;,\n      (reason) =&gt; &#123;\n        return myPromise.resolve(callback()).then(() =&gt; &#123;\n          throw reason;\n        &#125;);\n      &#125;\n    );\n  &#125;\n  static resolve(data) &#123;\n    return new myPromise((resolve, reject) =&gt; &#123;\n      resolve(data);\n    &#125;);\n  &#125;\n  static reject(reason) &#123;\n    return new myPromise((resolve, reject) =&gt; &#123;\n      reject(reason);\n    &#125;);\n  &#125;\n  static all(values) &#123;\n    if (!Array.isArray(values)) &#123;\n      const type = typeof values;\n      return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`);\n    &#125;\n    return new myPromise((resolve, reject) =&gt; &#123;\n      let resultArr = [];\n      let orderIndex = 0;\n      const processResultByKey = (value, index) =&gt; &#123;\n        resultArr[index] = value;\n        if (++orderIndex === values.length) &#123;\n          resolve(resultArr);\n        &#125;\n      &#125;;\n      for (let i = 0; i &lt; values.length; i++) &#123;\n        let value = values[i];\n        if (value &amp;&amp; typeof value.then === &quot;function&quot;) &#123;\n          value.then((value) =&gt; &#123;\n            processResultByKey(value, i);\n          &#125;, reject);\n        &#125; else &#123;\n          processResultByKey(value, i);\n        &#125;\n      &#125;\n    &#125;);\n  &#125;\n  static race(myPromises) &#123;\n    return new myPromise((resolve, reject) =&gt; &#123;\n      for (let i = 0; i &lt; myPromises.length; i++) &#123;\n        let val = myPromises[i];\n        if (val &amp;&amp; typeof val.then === &quot;function&quot;) &#123;\n          val.then(resolve, reject);\n        &#125; else &#123;\n          resolve(val);\n        &#125;\n      &#125;\n    &#125;);\n  &#125;\n&#125;\nmyPromise.defer = myPromise.deferred = function () &#123;\n  let dtd = &#123;&#125;;\n  dtd.myPromise = new myPromise((resolve, reject) =&gt; &#123;\n    dtd.resolve = resolve;\n    dtd.reject = reject;\n  &#125;);\n  return dtd;\n&#125;;\nexport default MyPromise;\n</code></pre>\n<h1 id=\"vue3封装debounce\"><a href=\"#vue3封装debounce\" class=\"headerlink\" title=\"vue3封装debounce\"></a>vue3封装debounce</h1><pre><code class=\"javascript\">// 定义一个返回懒执行响应式数据的函数\nfunction useDebouncedRef(value,delay=200)&#123;\n    let timeout;\n    return customRef((track,trigger)=&gt;&#123;\n      return &#123;\n        get()&#123;\n          track();\n          return value;\n        &#125;,\n        set(newValue)&#123;\n          clearTimeout(timeout);\n          timeout = setTimeout(()=&gt;&#123;\n            value = newValue\n            trigger();\n          &#125;,delay)\n        &#125;\n      &#125;\n    &#125;)\n&#125;\n</code></pre>\n","categories":["手写题"],"tags":["手写题","手写源码"]},{"title":"数据库","url":"/2023/12/02/%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p><strong>数据库是用来组织存储和管理数据的仓库</strong></p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><h4 id=\"关系型\"><a href=\"#关系型\" class=\"headerlink\" title=\"关系型\"></a>关系型</h4><p><strong>（传统型、关系型、SQL数据库）</strong></p>\n<p>①MySQL数据库（目前使用最广泛，流行度最高的开源免费数据库）</p>\n<p>②Oracle数据库（收费）</p>\n<p>③SQL  Server数据库（收费）</p>\n<h4 id=\"非关系型\"><a href=\"#非关系型\" class=\"headerlink\" title=\"非关系型\"></a>非关系型</h4><p><strong>（新型、非关系型、NoSQL数据库）</strong></p>\n<p>④Mongodb 数据库 （一定程度上弥补了传统型数据库的缺陷）</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><p>1、MySQL是关系型数据库，而mongodb是非关系型数据库；<br>2、MySQL中支持多种引擎，不同引擎有不同的存储方式，而mongodb以类JSON的文档的格式存储；<br>3、MySQL使用传统SQL语句进行查询，而mongodb有自己的<code>查询方式</code>（<code>类似JavaScript的函数</code>）；<br>4、<code>MySQL占用空间小</code>，支持join，而mongodb占用空间大，不支持join。</p>\n<p><strong>对比：</strong></p>\n<table>\n<thead>\n<tr>\n<th>数据库</th>\n<th>MongoDB</th>\n<th>MySQL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库模型</td>\n<td>非关系型</td>\n<td>关系型</td>\n</tr>\n<tr>\n<td>存储方式</td>\n<td>以类JSON的文档的格式存储</td>\n<td>不同引擎有不同的存储方式</td>\n</tr>\n<tr>\n<td>查询语句</td>\n<td>MongoDB查询方式（类似JavaScript的函数）</td>\n<td>SQL语句</td>\n</tr>\n<tr>\n<td>数据处理方式</td>\n<td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td>\n<td>不同引擎有自己的特点</td>\n</tr>\n<tr>\n<td>成熟度</td>\n<td>新兴数据库，成熟度较低</td>\n<td>成熟度高</td>\n</tr>\n<tr>\n<td>广泛度</td>\n<td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td>\n<td>开源数据库，市场份额不断增长</td>\n</tr>\n<tr>\n<td>事务性</td>\n<td>仅支持单文档事务操作，弱一致性</td>\n<td>支持事务操作</td>\n</tr>\n<tr>\n<td>占用空间</td>\n<td>占用空间大</td>\n<td>占用空间小</td>\n</tr>\n<tr>\n<td>join操作</td>\n<td>MongoDB没有join</td>\n<td>MySQL支持join</td>\n</tr>\n</tbody></table>\n<h1 id=\"四、MySQL数据库\"><a href=\"#四、MySQL数据库\" class=\"headerlink\" title=\"四、MySQL数据库\"></a>四、MySQL数据库</h1><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><h4 id=\"数据组织结构\"><a href=\"#数据组织结构\" class=\"headerlink\" title=\"数据组织结构\"></a>数据组织结构</h4><p>数据库（database）、数据表(table)、数据行(row）、字段(field)</p>\n<h4 id=\"库、表、行、字段\"><a href=\"#库、表、行、字段\" class=\"headerlink\" title=\"库、表、行、字段\"></a>库、表、行、字段</h4><p>①一般每个项目都对应独立的数据库  ②不同数据要存储到不同的表中  ③存储信息由字段决定</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><strong>MySQL Server 和MySQLWorkbench软件</strong></p>\n<p>①MySQL Server:提供数据存储和服务的软件     ②MySQLWorkbench可视化管理MySQL</p>\n<h3 id=\"MySQLWorkbench\"><a href=\"#MySQLWorkbench\" class=\"headerlink\" title=\"MySQLWorkbench\"></a>MySQLWorkbench</h3><p><strong>用MySQLWorkbench管理数据库：</strong></p>\n<p><strong>（1）创建数据库、创建数据表、设置字段（MySQLWorkbench中）</strong></p>\n<p><strong>设置字段的唯一标识：</strong></p>\n<p>①PK      (Primary Key主键、唯一标识)   </p>\n<p>②NN      (Not Null值不为空)   </p>\n<p>③UQ      (Unique值唯一)   </p>\n<p>④AI        (Auto Increment值自动增长)</p>\n<p>⑤设置默认值</p>\n<p><strong>（2）向数据库中写入数据</strong></p>\n<p>①右键table –&gt; Select Rows - Limit 1000 (设置AI和默认值的字段不必完全填写)</p>\n<h3 id=\"SQL语言\"><a href=\"#SQL语言\" class=\"headerlink\" title=\"SQL语言\"></a>SQL语言</h3><h6 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h6><p>①SQL是结构化查询语言，专门用来访问和处理数据库的编程语言，能够让我们以编程的形式，操作数据库里面的数据</p>\n<p>②SQL是一门数据库编程语言，用SQL语言编写出的代码叫做SQL语句，SQL只能在关系型数据库中使用，非关系型（mongodb）不支持</p>\n<p>③SQL能查询数据，插入数据，跟新数据，删除数据，创建数据库，在数据库中创建表，数据库中创建存储过程、视图等</p>\n<h6 id=\"SQL语法\"><a href=\"#SQL语法\" class=\"headerlink\" title=\"SQL语法\"></a>SQL语法</h6><p><strong>（关键字大小写相同，&lt;&gt; 和 !&#x3D;  都表示不等于）</strong></p>\n<p>①查询数据</p>\n<pre><code class=\"mysql\">select   *  from  表名称                              //指定表中，查询所有数据\nselect   列名称1 , 名称2   from   表名称               //指定表中，查询指定列（字段） 的数据\n</code></pre>\n<p>②数据表中插入新的数据行</p>\n<pre><code class=\"mysql\">insert  into  表名 （列1  ,  列2.....） values  (值1  ,  值2 ,.......)      //指定表中，插入指定的数据\n</code></pre>\n<p>③修改（更新）表中的数据</p>\n<pre><code class=\"mysql\">update 表名称 set 列名称  =  新值 where 列名称 = 指定值   //指定表中，更新某一列的指定值为新值（不加where更新全部）\nupdate  表名称  set  列名称  = 新值  ,  列名称2 = 新值   where   列名称 = 指定     //指定表中，更新指定一行中多列\n</code></pre>\n<p>④删除表中数据</p>\n<pre><code class=\"mysql\">delete  from  表名  where  列名称  =  指定值     //删除指定行数据\n</code></pre>\n<p>⑤运算符</p>\n<p>!&#x3D;  和 &lt;&gt;表示不等于  、 and  相当于&amp;&amp; 、 or  相当于 ||</p>\n<p>⑥order  by 子句（对结果集进行排序）</p>\n<p>默认升序(  asc  )对记录进行排序，降序需要使用 desc  关键字 </p>\n<pre><code class=\"mysql\">例如： select * from  表名称  order  by  status  desc       //降序\nselect * from  表名称  order  by  status  desc , id  asc     //多重排序（status降序，id升序）\n</code></pre>\n<p>⑦count(*)      (统计查询结果的总数据条数)</p>\n<pre><code class=\"mysql\">例如： select  count(*)  from  表名称  where  status  =  0     //统计表中status为0的数据条数\n</code></pre>\n<p>⑧使用AS为列设置别名</p>\n<pre><code class=\"mysql\">例如： select count(*) AS  total  from  users  where  status  =  0    //设置统计表中数据条数的列名为total\n</code></pre>\n<h3 id=\"项目中使用\"><a href=\"#项目中使用\" class=\"headerlink\" title=\"项目中使用\"></a>项目中使用</h3><p>（1）、安装MySQL数据库的第三方模块(mysql)</p>\n<pre><code class=\"bash\">npm  install  mysql\n</code></pre>\n<p>（2）、通过mysql模块配置并连接到MySQL数据库</p>\n<pre><code class=\"mysql\">const  mysql  = require(&#39;mysql&#39;) ;         //导入mysql模块\nconst   db  =  mysql.createPool(&#123;          //建立与MySQL数据库的连接\nhost:&#39;127.0.0.1&#39;  , user:&#39;root&#39;  , password:&#39;dmq0216&#39;  , database:&#39;mydb01&#39; //连接数据库ip，登录账号和密码、连接待操作的数据库\n&#125;)\n</code></pre>\n<p>（3）通过mysql模块执行SQL语句</p>\n<h6 id=\"测试mysql模块\"><a href=\"#测试mysql模块\" class=\"headerlink\" title=\"测试mysql模块\"></a>测试mysql模块</h6><pre><code class=\"mysql\">db.query(&#39;select  1&#39; ,(err,result)=&gt;&#123;         \nif(err)  return  console.log(err.message)\nconsole.log(result)\n&#125;)\n</code></pre>\n<h6 id=\"查询所有数据\"><a href=\"#查询所有数据\" class=\"headerlink\" title=\"查询所有数据\"></a>查询所有数据</h6><p> <strong>（执行select语句查询到的是数组）</strong></p>\n<pre><code class=\"mysql\">db.query(&#39;select * from users&#39; ,(err,result)=&gt;&#123;         \nif(err)  return  console.log(err.message)\nconsole.log(result)\n&#125;)\n</code></pre>\n<h6 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h6><p><strong>(  用（？，？）符进行占位  )</strong></p>\n<pre><code class=\"mysql\">const  user  =  &#123; username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;\nconst  sqlStr &#39;insert  into  users  ( username , password ) values ( ? , ? )&#39;\ndb.query(sqlStr , [user.username , user.password ] , (err , result) =&gt; &#123;\nif(err) return console.log(err.message)\nif( result.affectedRows === 1 )&#123;  console.log(&#39;插入数据成功&#39;  )  &#125;\n&#125;)\n</code></pre>\n<p>或  便捷方式：</p>\n<pre><code class=\"mysql\">const  user  =  &#123; username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;\nconst  sqlStr &#39;insert  into  users  set ?&#39;\ndb.query(sqlStr , user , (err , result) =&gt; &#123;\nif(err) return console.log(err.message)\nif( result.affectedRows === 1 )&#123;  console.log(&#39;插入数据成功&#39;  )  &#125;\n&#125;)\n</code></pre>\n<h6 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h6><p><strong>（使用？占位符）</strong></p>\n<pre><code class=\"mysql\">const  user  =  &#123;id=6, username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;\nconst  sqlStr &#39;update users set username=? , password=? where id=?&#39;\ndb.query(sqlStr , user.username , user.password , user.id, (err , result) =&gt; &#123;\nif(err) return console.log(err.message)\nif( result.affectedRows === 1 )&#123;  console.log(&#39;更新数据成功&#39;  )  &#125;\n&#125;)\n</code></pre>\n<p>或   便捷方式：</p>\n<pre><code class=\"mysql\">const  user  =  &#123;id=6 , username:&#39;Spider-Man&#39; , password:&#39;dmq0216&#39; &#125;\nconst  sqlStr &#39;update users set ? where id=?&#39;\ndb.query(sqlStr , [ user , user.id ], (err , result) =&gt; &#123;\n  if(err) return console.log(err.message)\n  if( result.affectedRows === 1 )&#123;  console.log(&#39;更新数据成功&#39;  )  &#125;\n&#125;)\n</code></pre>\n<h6 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h6><p><strong>（ 推荐使用id ）</strong></p>\n<pre><code class=\"mysql\">const  sqlStr &#39; delete from users where id=? &#39;\ndb.query(sqlStr , 6 , (err , result) =&gt; &#123;\nif(err) return console.log(err.message)\nif( result.affectedRows === 1 )&#123;  console.log(&#39;删除数据成功&#39;  )  &#125;\n&#125;)\n</code></pre>\n<p>标记删除   （为了考虑安全性：在表中设置类似于status的状态字段，标记当前数据是否被删除，实际上是update语句）</p>\n<pre><code class=\"mysql\">db.query(&#39;update users set status=1 where id=?&#39;, 6 , (err , result) =&gt; &#123;\nif(err) return console.log(err.message)\nif( result.affectedRows === 1 )&#123;  console.log(&#39;删除数据成功&#39;  )  &#125;\n&#125;)\n</code></pre>\n<h3 id=\"5、MySQL-ORM\"><a href=\"#5、MySQL-ORM\" class=\"headerlink\" title=\"5、MySQL ORM\"></a>5、MySQL ORM</h3><h5 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h5><p>在Node.js项目中，数据库操作是常见的任务之一。而MySQL作为一种广泛使用的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC9teXNxbC5odG1s\">关系型数据库</span>，与Node.js的集成具有重要意义。为了简化数据库操作和提高开发效率，我们可以使用ORM（对象关系映射）框架。ORM框架能够将数据库表映射为JavaScript对象，使得<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC94bHkuaHRtbA==\">开发者</span>可以使用面向对象的方式进行数据库操作。</p>\n<h5 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h5><p><strong>一、ORM框架的优势</strong></p>\n<ol>\n<li><strong>简化数据库操作</strong>：ORM框架提供了丰富的API，使得开发者无需编写繁琐的SQL语句即可完成数据库操作。</li>\n<li><strong>提高开发效率</strong>：ORM框架通常提供了自动化的数据映射、关联查询、事务管理等功能，可以大大提高开发效率。</li>\n<li><strong>增强代码可维护性</strong>：使用ORM框架可以使得代码更加清晰、易于维护，降低因数据库变更导致的代码修改成本。</li>\n</ol>\n<p><strong>二、ORM框架选择标准</strong></p>\n<ol>\n<li><strong>兼容性</strong>：确保所选ORM框架与Node.js和MySQL版本兼容。</li>\n<li><strong>性能</strong>：考虑ORM框架的性能表现，包括查询速度、内存消耗等。</li>\n<li><strong>社区支持</strong>：选择有良好社区支持和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC9kb2MuaHRtbA==\">文档</span>完善的ORM框架，便于解决问题和学习。</li>\n<li><strong>扩展性</strong>：考虑ORM框架是否支持自定义查询、关联查询等高级功能。</li>\n</ol>\n<h5 id=\"常见框架\"><a href=\"#常见框架\" class=\"headerlink\" title=\"常见框架\"></a>常见框架</h5><p><strong>三、常见的Node.js ORM框架</strong></p>\n<ul>\n<li><strong>Sequelize</strong>：一款基于Promise的Node.js ORM框架，支持多种数据库，包括MySQL。</li>\n<li><strong>TypeORM</strong>：一个面向TypeScript和JavaScript（ES5，ES6，ES7，ES8）的ORM框架，可以在NodeJS、Cordova、PhoneGap、Ionic、Browser和Cordova中使用。</li>\n<li><strong>Objection.js</strong>：一个基于SQL查询生成器的ORM库，专为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC9wb3N0Z3Jlc3FsLmh0bWw=\">PostgreSQL</span>和MySQL设计。</li>\n</ul>\n<h5 id=\"项目中使用-1\"><a href=\"#项目中使用-1\" class=\"headerlink\" title=\"项目中使用\"></a>项目中使用</h5><p><strong>实践：使用Sequelize进行Node.js与MySQL的集成</strong></p>\n<ol>\n<li><strong>安装依赖</strong>：</li>\n</ol>\n<pre><code class=\"mysql\">npm install mysql sequelize\n</code></pre>\n<ol>\n<li><strong>配置数据库连接</strong>：</li>\n</ol>\n<pre><code class=\"mysql\">const &#123; Sequelize &#125; = require(&#39;sequelize&#39;);const sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, &#123;  host: &#39;localhost&#39;,  dialect: &#39;mysql&#39;&#125;);\n</code></pre>\n<ol>\n<li><strong>定义模型</strong>：</li>\n</ol>\n<pre><code class=\"mysql\">const User = sequelize.define(&#39;user&#39;, &#123;  username: &#123;    type: Sequelize.STRING,    allowNull: false  &#125;,  password: &#123;    type: Sequelize.STRING,    allowNull: false  &#125;&#125;);\n</code></pre>\n<ol>\n<li><strong>执行数据库操作</strong>：</li>\n</ol>\n<pre><code class=\"mysql\">// 创建记录const user = await User.create(&#123; username: &#39;alice&#39;, password: &#39;123456&#39; &#125;);// 查询记录const users = await User.findAll();// 更新记录await user.update(&#123; password: &#39;newpassword&#39; &#125;);// 删除记录await user.destroy();\n</code></pre>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>通过ORM框架，我们可以更加便捷地在Node.js项目中与MySQL数据库进行交互。在选择ORM框架时，需要考虑兼容性、性能、社区支持和扩展性等因素。实践中，我们可以使用Sequelize等成熟的ORM框架来简化数据库操作，提高开发效率。当然，ORM框架并非银弹，对于复杂的查询和性能要求较高的场景，我们仍然需要编写原生的SQL语句。</p>\n<h1 id=\"五、Mongodb数据库\"><a href=\"#五、Mongodb数据库\" class=\"headerlink\" title=\"五、Mongodb数据库\"></a>五、Mongodb数据库</h1><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h5 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h5><ul>\n<li><p>MongoDB是一个基于分布式文件存储的数据库，官方地址为<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tb25nb2RiLmNvbS8=\">http://www.mongodb.com/</span></p>\n</li>\n<li><p>数据库是按照数据结构来组织、存储和管理数据的应用程序</p>\n</li>\n</ul>\n<p>数据库的主要作用就是管理数据，对数据进行增、删、改、查</p>\n<ul>\n<li><p>相比于纯文件管理数据，数据库管理数据的特点：①速度更快②扩展性更强③安全性更高</p>\n</li>\n<li><p>语法与javascript相似，容易上手</p>\n</li>\n</ul>\n<h5 id=\"三个概念\"><a href=\"#三个概念\" class=\"headerlink\" title=\"三个概念\"></a>三个概念</h5><ul>\n<li><p>数据库（database）</p>\n</li>\n<li><p>集合（collection）</p>\n</li>\n<li><p>文档（document）</p>\n</li>\n</ul>\n<h5 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h5><ul>\n<li><p>MongoDB安装，与创建默认文件（ c：&#x2F;data&#x2F;db ）</p>\n</li>\n<li><p>文件中打开cmd，输入命令mongod，启动数据库服务（端口号为27017）</p>\n</li>\n<li><p>文件中新开cmd，输入命令mongo , 请求数据库服务，输入命令show dbs显示数据库信息</p>\n</li>\n<li><p>配置文件环境变量，以方便全局使用</p>\n</li>\n<li><p>全局命令：mongo使用数据库、mongoose启动数据库服务</p>\n</li>\n</ul>\n<h5 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h5><p>（1）   数据库命令：</p>\n<pre><code class=\"mysql\">show dbs              查看当前数据库下有哪些服务\nuse 库名             切换到指定的数据库下，没有则创建\ndb                 显示当前所在的数据库\nuse 库名\nswitched to db 库名          转到那个数据库\ndb.dropDatabase()           删除当前数据库\n</code></pre>\n<p>（2）   集合命令</p>\n<pre><code class=\"mysql\">db.createCollection()           创建集合\nshow collections             显示当前数据库中的所在\ndb.集合名.drop()             删除某个集合\ndb.集合名.renameCollection(‘newName’)   重命名集合\n</code></pre>\n<p>（3）   文档命令</p>\n<pre><code class=\"mysql\">db.集合名.insert(&#123;文档对象&#125;)              插入文档\ndb.集合名.find(&#123;查询条件&#125;)               查询文档\ndb.集合名.update(&#123;查询条件&#125;，&#123;新的文档内容&#125;)     更新新的文档（属性全部更新）\ndb.集合名.update(&#123;name:’张三’&#125;,&#123;$set:&#123;age:19&#125;&#125;)     更新文档（部分更新）\ndb.集合名.remove(&#123;查询条件&#125;)\n</code></pre>\n<h5 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h5><p>（1）   新增：用户注册、发布视频、发布商品、发布评论等</p>\n<p>（2）   删除：删除评论、删除商品、删除文章等</p>\n<p>（3）   更新：更新个人信息、修改商品价格等</p>\n<p>（4）   查询：商品列表、朋友圈列表等</p>\n<h2 id=\"Mongoose（DOM）\"><a href=\"#Mongoose（DOM）\" class=\"headerlink\" title=\"Mongoose（DOM）\"></a>Mongoose（DOM）</h2><p><strong>文档对象模型链接mongdb数据库</strong></p>\n<h5 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h5><p>mongoose文档对象模型库，官网：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tb25nb29zZWpzLm5ldC8=\">http://www.mongoosejs.net/</span></p>\n<h5 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p> (<strong>发送请求服务时必须确保数据库服务启动中</strong>)</p>\n<p>1 项目初始化  </p>\n<pre><code class=\"bash\">npm init\n</code></pre>\n<p>2 安装 mongoose</p>\n<pre><code class=\"bash\">npm i mongoose@6.8.0\n</code></pre>\n<p>3 导入 mongoose</p>\n<pre><code class=\"mysql\">const mongoose = require(&#39;mongoose&#39;);\n</code></pre>\n<p>设置取消部分提示</p>\n<pre><code class=\"mysql\">mongoose.set(&#39;strictQuery&#39;, true);\n</code></pre>\n<p>4 连接 mongodb数据库服务</p>\n<pre><code class=\"mysql\">mongoose.connect(&#39;mongodb://127.0.0.1:27017/bilibili&#39;);\n</code></pre>\n<p>(协议名称:&#x2F;&#x2F;ip地址:端口号&#x2F;数据库名称)</p>\n<p>5 设置回调</p>\n<p>设置连接成功的回调</p>\n<pre><code class=\"mysql\">mongoose.connection.once(&#39;open&#39;, () =&gt; &#123;\n  // 连接成功的处理代码\n&#125;);\n</code></pre>\n<p>   6 创建文档的结构对象</p>\n<p>  设置集合中文档的属性以及属性值的类型</p>\n<pre><code class=\"javascript\">let BookSchema =new mongoose.Schema(&#123;\n  name: String,\n  author: String,\n  price: Number,\n  ishot: Boolean\n&#125;);\n</code></pre>\n<p> 7创建模型对象  对文档操作的封装对象 (mongoose.model(‘<strong>集合名称</strong>‘,<strong>结构对象</strong>))</p>\n<pre><code class=\"javascript\">  let BookModel = mongoose.model(&#39;books&#39;, BookSchema);\n</code></pre>\n<p> 8 文档中新增内容</p>\n<pre><code class=\"javascript\">BookModel.create(&#123;\n    name: &#39;西游记&#39;,\n    author: &#39;吴承恩&#39;,\n    price: 20,\n   ishot: true\n  &#125;,((err, data) =&gt; &#123;\n    if (err) &#123;\n     console.log(err);\n      return;\n    &#125; console.log(data);\n  &#125;))\n  // 关闭数据库连接(项目运行时不使用)\n   mongoose.disconnect();\n//设置连接错误的回调\nmongoose.connection.on(&#39;error&#39;, () =&gt; &#123;\n  console.log(&#39;连接失败&#39;);\n&#125;);\n//设置连接关闭的回调\nmongoose.connection.on(&#39;close&#39;, () =&gt; &#123;\n  console.log(&#39;连接关闭&#39;);\n&#125;);\n// 手动关闭mongodb的连接\n setTimeout(() =&gt; &#123;\n   mongoose.disconnect();\n &#125;, 2000);\n</code></pre>\n<h5 id=\"字段类型\"><a href=\"#字段类型\" class=\"headerlink\" title=\"字段类型\"></a>字段类型</h5><p><strong>（在new的mongoose.Schema和创建的mongoose.model.create中注册和写入）</strong></p>\n<p>（1）   String类型（字符串）</p>\n<p>（2）   Number类型（数字）</p>\n<p>（3）   Boolean类型（布尔值）</p>\n<p>（4）   Array类型（数组，也可以用[ ]来标识）</p>\n<p>（5）   Date类型（日期）</p>\n<p>（6）   Buffer类型（Buffer对象）</p>\n<p>（7）   Mixed类型（任意对象，需要使用mongoose.Schema.Types.Mixed指定）</p>\n<p>（8）   Objectld类型（对象ID，需要使用mongoose.Schema.Types.Objected指定）</p>\n<p>（9）   Decimal128类型（高精度数字，需要使用mongoose.Schema.Types.Decimal128指定）  </p>\n<h5 id=\"字段值验证\"><a href=\"#字段值验证\" class=\"headerlink\" title=\"字段值验证\"></a>字段值验证</h5><p><strong>（对文档属性的值进行校验，校验通过的值才会被存入数据库，在创建文档结构对象中操作）</strong></p>\n<p>（1）   例如给数据库文档中的name属性添加字段</p>\n<pre><code class=\"javascript\"> name: &#123;\n      type: String,\n      //必填项\n      required: true,\n     //默认值\n      default: &#39;西游记&#39;,\n     //枚举值,设置后只能设置在枚举项内的值\n      enum: [&#39;言情&#39;, &#39;城市&#39;, &#39;志怪&#39;, &#39;恐怖&#39;],\n      //唯一值,设置为独一无二的值(在集合里面不能重复)\n      unique: true \n    &#125;,\n</code></pre>\n<h5 id=\"删除数据-1\"><a href=\"#删除数据-1\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h5><p>(1)  删除单条文档数据</p>\n<pre><code class=\"javascript\">// 9删除单条文档\n  BookModel.deleteOne(&#123; _id: &#39;647ec30caecaf3c1f3724a84&#39; &#125;, ((err, data) =&gt; &#123;\n    if(err) &#123;\n      console.log(&#39;删除失败&#39;);\n      return;\n    &#125; console.log(data);\n  &#125;))\n</code></pre>\n<p>（2）   批量删除文档数据</p>\n<pre><code class=\"javascript\">// 10批量删除\n  BookModel.deleteMany(&#123; ishot: true &#125;, (err, data) =&gt;&#123;\n    if(err) &#123;\n      console.log(&#39;删除失败&#39;);\n      return;\n    &#125; console.log(data);\n  &#125;);\n</code></pre>\n<h5 id=\"更新数据-1\"><a href=\"#更新数据-1\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h5><pre><code class=\"javascript\">// 更新单条文档数据\nBookModel.updateOne(&#123; name: &#39;西游记&#39; &#125;, &#123; price: 5 &#125;, (err,data)=&gt;&#123;\n    if(err) &#123;\n      console.log(&#39;更新失败&#39;);\n      return;\n    &#125; console.log(data);\n  &#125;)\n\n// 更新多条文档数据\nBookModel.updateMany(&#123; name: &#39;西游记&#39; &#125;, &#123; ishot: false &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;更新失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n</code></pre>\n<h5 id=\"读取文档\"><a href=\"#读取文档\" class=\"headerlink\" title=\"读取文档\"></a>读取文档</h5><pre><code class=\"javascript\">// （1） 获取单条文档数据\nBookModel.findOne(&#123; price: &#39;5&#39; &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// 根据id获取单条数据\nBookModel.findOne(&#123; &#39;647f11344d39a14410f61725&#39; &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// （2） 获得多条文档数据\nBookModel.find(&#123; name: &#39;西游记&#39; &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n// （*）不加条件时获取全部文档数据\n</code></pre>\n<h5 id=\"条件控制\"><a href=\"#条件控制\" class=\"headerlink\" title=\"条件控制\"></a>条件控制</h5><pre><code class=\"javascript\">// （1） 运算符：\n// &gt;使用 $gt\n// &lt;使用 $lt\n// &gt;=使用 $gte\n// &lt;=使用 $lte\n// !==使用 $ne\n\n// 14 读取多条文档数据\nBookModel.find(&#123; name: &#39;西游记&#39; &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// (2) 日志运算\n// $or逻辑或的情况\n// db.students.find(&#123;$or:[&#123;age:18&#125;,&#123;age:24&#125;]&#125;) ;\n// $and逻辑与的情况\n// db.students.find(&#123;$and:[&#123;age:&#123;$lt:20&#125;&#125;,&#123;age:&#123;$gt:15&#125;&#125;]&#125;) ;\n\nBookModel.find(&#123;$or:[&#123;author:&#39;曹雪芹&#39;&#125;,&#123;author:&#39;余华&#39;&#125;]&#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// （3） 正则匹配（条件中可以使用js的正则语法，通过正则进行模糊查询）\n\n// 普通正则表达式：\nBookModel.find(&#123; name: /三/ &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// 使用变量的正则表达式\nBookModel.find(&#123; name: new RegExp(&#39;三&#39;) &#125;, (err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n</code></pre>\n<h5 id=\"个性化读取\"><a href=\"#个性化读取\" class=\"headerlink\" title=\"个性化读取\"></a>个性化读取</h5><pre><code class=\"javascript\">// （1） select做字段的筛选（0表示不要的字段，1表示要的字段）\nBookModel.find().select(&#123; name: 1, author: 1 &#125;).exec((err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// （2） sort进行数据排序（1是升序，-1是倒序）\nBookModel.find().sort(&#123; price: -1 &#125;).exec((err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// （3） limit进行数据截取，skip进行第几个数据开始取\nBookModel.skip(3).limit(3).exec((err, data) =&gt; &#123;\n  if (err) &#123;\n    console.log(&#39;读取失败&#39;);\n    return;\n  &#125;\n  console.log(data);\n&#125;);\n\n// （*）注意多个属性之间可以复用\nBookModel.find()\n  .select(&#123; name: 1, price: 1 &#125;)\n  .sort(&#123; price: -1 &#125;)\n  .skip(3)\n  .limit(3)\n  .exec((err, data) =&gt; &#123;\n    if (err) &#123;\n      console.log(&#39;读取失败&#39;);\n      return;\n    &#125;\n    console.log(data);\n  &#125;);\n</code></pre>\n<h5 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h5><p>一、代码模块化</p>\n<p>（1）   db.js中创建模块</p>\n<pre><code class=\"javascript\">module.exports = function (success, error) &#123;\n  // 导入 mongoose\n  const mongoose = require(&#39;mongoose&#39;);\n  // 设置取消部分提示\n  mongoose.set(&#39;strictQuery&#39;, true);\n  // 连接 mongodb 数据库服务\n  mongoose.connect(&#39;mongodb://127.0.0.1:27017/bilibili&#39;);\n  // 设置连接成功的回调\n  mongoose.connection.once(&#39;open&#39;, () =&gt; &#123;\n    success();\n  &#125;);\n  // 设置连接错误的回调\n  mongoose.connection.on(&#39;error&#39;, () =&gt; &#123;\n    error();\n  &#125;);\n  // 设置连接关闭的回调\n  mongoose.connection.on(&#39;close&#39;, () =&gt; &#123;\n    console.log(&#39;连接关闭&#39;);\n  &#125;);\n&#125;\n// BookModel中创建模块\nconst mongoose = require(&#39;mongoose&#39;);\n\n// 创建文档的结构对象\n// 设置集合中文档的属性以及属性值的类型\nlet BookSchema = new mongoose.Schema(&#123;\n  name: &#123;\n    type: String,\n    // 必填项\n    required: true,\n    // 默认值\n    default: &#39;西游记&#39;,\n    // 枚举值,设置后只能设置在枚举项内的值\n    // enum: [&#39;言情&#39;, &#39;城市&#39;, &#39;志怪&#39;, &#39;恐怖&#39;],\n    // 唯一值,设置为独一无二的值(在集合里面不能重复)\n    // unique: true\n  &#125;,\n  author: String,\n  price: Number,\n  ishot: Boolean,\n  tags: Array,\n  pubtime: Date\n&#125;);\n// 创建模型对象 对文档操作的封装对象 (mongoose.model(&#39;集合名称&#39;,结构对象))\nlet BookModel = mongoose.model(&#39;books&#39;, BookSchema);\n// 暴露模型对象\nmodule.exports = BookModel;\n</code></pre>\n<p>（3）   index文件中引用模块</p>\n<pre><code class=\"javascript\">//导入db文件\nconst db=require(&#39;./db/db&#39;);\n//导入monfoose\nconst mongoose=require(&#39;mongoose&#39;);\n//导入BookModel\nconst BookModel **=** require(&#39;./models/BookModel&#39;);\n//调用函数\ndb(()=&gt;&#123;\n   // 8文档中新增内容\n   BookModel.create(&#123;\n     name: &#39;西游记&#39;,\n     author: &#39;吴承恩&#39;,\n     price: 20,\n     ishot: true\n   &#125;,((err,data)=&gt;&#123;\n     if(err) &#123;\n       console.log(err);\n       return;\n     &#125; console.log(data);\n   &#125;))\n&#125;, ()=&gt;&#123;\n  console.log(&#39;连接失败&#39;);\n&#125;);\n</code></pre>\n<p>二、配置文件模块化</p>\n<p>（1）config.js中暴露模块</p>\n<pre><code class=\"javascript\">//配置文件\nmodule.exports=&#123;\n  DBHOST: &#39;127.0.0.1&#39;,\n  DBPORT: 27017,\n  DBNAME: &#39;bilibili&#39;\n&#125;\n</code></pre>\n<p>（2）db.js中使用模块</p>\n<p>导入配置文件</p>\n<pre><code class=\"javascript\">  const &#123;DBHOST,DBPORT,DBNAME&#125;=require(&#39;../config/config.js&#39;);\n</code></pre>\n<p>连接 mongodb数据库服务</p>\n<pre><code class=\"javascript\">  mongoose.connect(`mongodb://$&#123;DBHOST&#125;:$&#123;DBPORT&#125;/$&#123;DBNAME&#125;`);\n</code></pre>\n<h5 id=\"图形化工具\"><a href=\"#图形化工具\" class=\"headerlink\" title=\"图形化工具\"></a>图形化工具</h5><p><strong>（Robo3T和navicate）</strong></p>\n<p><strong>作用</strong>：代替mongo命令进行操作数据库，便于操作mongod数据库服务启动再去进行操作</p>\n<h1 id=\"六、CouchDB数据库\"><a href=\"#六、CouchDB数据库\" class=\"headerlink\" title=\"六、CouchDB数据库\"></a>六、CouchDB数据库</h1><h3 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li><p>CouchDB数据常用作npm等<strong>包管理仓库的数据库</strong></p>\n</li>\n<li><p>CounchDB数据库和mongodb数据库一样都支持文档存储，是典型的<strong>NOSQL数据库</strong></p>\n</li>\n<li><p>CouchDB数据库使用分布式架构，可以简单地将<strong>数据复制到多个服务器上</strong>，并且能<strong>自动进行同步</strong>，适合处理分布式数据和离线应用</p>\n</li>\n<li><p>CouchDB倾向于<strong>提供强一致性</strong>，使用MVCC（多版本并发控制）来处理并发写操作，并在复制和同步时保持一致性</p>\n</li>\n<li><p>CouchDB非常<strong>适合于离线应用程序</strong>，用户可以继续使用并修改数据，当网络重新连接时，数据会自动同步。</p>\n</li>\n<li><p>CouchDB是一个<strong>RESTful数据库</strong>，其操作完全走HTTP协议。</p>\n</li>\n</ul>\n<h3 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>选择CouchDB还是MongoDB取决于具体的应用需求和场景：</p>\n<ul>\n<li>如果需要一个支持强一致性、适合离线应用、并且需要在多个设备之间同步数据的数据库，<strong>CouchDB可能是更好的选择</strong>。</li>\n<li>如果需要高性能、灵活的文档模型、丰富的查询语言、并且需要支持大规模数据集的水平扩展，<strong>MongoDB可能是更好的选择</strong>。</li>\n</ul>\n","categories":["数据库"],"tags":["数据库"]},{"title":"本地预览图片","url":"/2024/03/29/%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87/","content":"<h1 id=\"图片上传预览\"><a href=\"#图片上传预览\" class=\"headerlink\" title=\"图片上传预览\"></a>图片上传预览</h1><p>业务中经常有上传图片的需求在，有时我们需要去尽快预览要上传的图片，此时会有两种常见的方法：</p>\n<h3 id=\"URL-createObjectURL\"><a href=\"#URL-createObjectURL\" class=\"headerlink\" title=\"URL.createObjectURL\"></a>URL.createObjectURL</h3><p>直接返回，同步执行，会为图片文件创建一个地址，存储在document中，并且不会被垃圾回收机制所回收。清除方式只有unload事件或revokeObjectURL进行手动清除。</p>\n<h3 id=\"FileReader-readAsDataURL\"><a href=\"#FileReader-readAsDataURL\" class=\"headerlink\" title=\"FileReader.readAsDataURL\"></a>FileReader.readAsDataURL</h3><p>通过回调的形式返回，异步执行，将图片文件转为base64格式，可以通过链接形式直接引用，会依据垃圾回收机制进行回收，<br>2</p>\n","categories":["业务处理"],"tags":["业务","图片"]},{"title":"最大安全数与最大安全整数","url":"/2023/12/21/%E6%9C%80%E5%A4%A7%E5%AE%89%E5%85%A8%E6%95%B0/","content":"<h1 id=\"Number-MAX-VALUE最大数\"><a href=\"#Number-MAX-VALUE最大数\" class=\"headerlink\" title=\"Number.MAX_VALUE最大数\"></a>Number.MAX_VALUE最大数</h1><p>Number.MAX_VALUE 静态数据属性表示在 JavaScript 中可表示的最大数值，数值为：2的1024次方 - 1，或大约 1.7976931348623157E+308。<br>（原因是由于：一个字节（byte）8比特（bit），但是数字类型占用一个字节，JS最大用1kb（1024个字节）来存储number）<br>大于最大数的数据会被返回:Infinity</p>\n<h1 id=\"Number-MAX-SAFE-INTEGER最大安全整数\"><a href=\"#Number-MAX-SAFE-INTEGER最大安全整数\" class=\"headerlink\" title=\"Number.MAX_SAFE_INTEGER最大安全整数\"></a>Number.MAX_SAFE_INTEGER最大安全整数</h1><p>Number.MAX_SAFE_INTEGER为：（253 – 1），表示能够一对一匹配到浮点数的最大整数。</p>\n<p>对于更大的整数，请考虑使用 BigInt。</p>\n<p>双精度浮点格式只有 52 位用于表示尾数，因此它只能安全地表示介于 -(253 – 1) 和 253 – 1 之间的整数。本文中，“安全”指的是能够精确表示整数并正确比较它们。例如，Number.MAX_SAFE_INTEGER + 1 &#x3D;&#x3D;&#x3D; Number.MAX_SAFE_INTEGER + 2 的结果将为真，这在数学上是不正确的。有关更多信息，请参阅 Number.isSafeInteger()。</p>\n<p>由于 MAX_SAFE_INTEGER 是 Number 的静态属性，你应该始终将其使用为 Number.MAX_SAFE_INTEGER，而不是一个数字值的属性。</p>\n","categories":["JS"],"tags":["JS","最大安全数","最大安全整数"]},{"title":"持续集成与持续部署","url":"/2024/02/03/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/","content":"<h1 id=\"5-4-持续集成与持续部署\"><a href=\"#5-4-持续集成与持续部署\" class=\"headerlink\" title=\"5-4 持续集成与持续部署\"></a>5-4 持续集成与持续部署</h1><p><strong>传统的开发过程中的坑：</strong></p>\n<ul>\n<li>BUG 总是在最后才发现</li>\n<li>越到项目后期，加班越严重</li>\n<li>交付无法保障</li>\n<li>变更频繁导致效率低下</li>\n<li>无效的等待多，用户满足度低</li>\n</ul>\n<p><img data-src=\"/images/1460000014924499.png\" alt=\"img\"></p>\n<p><strong>你有没有想过&#x2F;用过？当你哪一天…</strong></p>\n<ul>\n<li>不用为开发&#x2F;测试环境不一致而苦恼</li>\n<li>不用麻烦运维人员帮忙调试环境</li>\n<li>不用手动进行测试，模拟环境中进行自测</li>\n<li>不用手动发布、部署，自动化实现发布部署</li>\n<li>不用管开发&#x2F;测试环境，只用专注代码的开发？</li>\n</ul>\n<p><strong>持续集成解决了什么问题？</strong></p>\n<ul>\n<li>提高软件质量</li>\n<li>效率迭代</li>\n<li>便捷部署</li>\n<li>快速交付、便于管理</li>\n</ul>\n<p><strong>介绍：</strong></p>\n<ul>\n<li><p>什么是 CI&#x2F;CD</p>\n</li>\n<li><p>介绍 CI&#x2F;CD 流程</p>\n</li>\n<li><p>前端项目：结合 CI&#x2F;CD 流程，实现快速迭代</p>\n</li>\n<li><p>Docker 的使用，Jenkins+gitlab+nodejs 自动化项目</p>\n</li>\n<li><p>持续集成工具介绍：Jenkins、Travis CI、Circle CI</p>\n</li>\n</ul>\n<p><strong>环境准备：</strong></p>\n<ul>\n<li>Linux 服务器(Centos 7.6&#x2F;Ubuntu 16.04LTS)</li>\n<li>VSCode+插件 Dockerfile</li>\n<li>注册 github 账号</li>\n</ul>\n<h2 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h2><h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><p><strong>集成，就是一些孤立的事物或元素通过某种方式集中在一起，产生联系，从而构成一个有机整体的过程</strong>。知识经济的社会，集成已经成了很重要的一个名词。各行各业基本都会用到集成。比如汽车行业，那么复杂的一台跑车愣是通过一大堆零件组装起来。对于这些传统行业，它们在研发成功以后，可以通过流水线的方法批量生产进行集成。而在软件行业中，集成并不是一个简单的“搬箱子”的过程。因为软件工业是一个知识生产活动，其内在逻辑非常复杂，需求又很难一次性确定，完成的产品与最初的设计往往相差很远。敏捷宣言中就有一条是说响应变化重于遵循计划。而且由于软件行业的迅猛发展，软件变的越来越复杂，单靠个人是根本无法完成。大型软件为了重用及解耦，往往还需要分成好几个模块，这样集成就成了软件开发中不可或缺的一部分。</p>\n<p>持续，不言而喻，就是指<strong>长期的对项目代码进行集成。</strong></p>\n<h4 id=\"持续集成-1\"><a href=\"#持续集成-1\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h4><p>持续集成（英文：Continuous Integration，简称 CI）</p>\n<p>在软件工程中，持续集成是指将所有开发者工作副本每天多次合并到主干的做法。</p>\n<blockquote>\n<p>Grady Booch 在 1991 年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。</p>\n<p>在《持续集成》一书中，对持续集成的定义如下：<code>持续集成</code>是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次,也可以多次。每次集成会经过自动构建(包括自动测试)的检验，以尽快发现集成错误。自从在团队中引入这样的实践之后，<code>Martin Fowler</code>发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。</p>\n</blockquote>\n<p><img data-src=\"/images/c5c8e6f40c7c133e22402c00bb7e1a25_hd.jpg\" alt=\"img\"></p>\n<p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p>\n<p>对于一天需要集成多少次数，并没有一个明确的定义。一般就是按照自己项目的实际需要来设置一定的频率，少则可能几次，多则可能达几十次。可以设置按照代码的变更来触发集成，或者设置一个固定时间周期来集成，也可以手工点击集成的按钮来“一键集成”。</p>\n<h4 id=\"持续交付\"><a href=\"#持续交付\" class=\"headerlink\" title=\"持续交付\"></a>持续交付</h4><p>持续交付（英文：Continuous Delivery，简称 CD）</p>\n<p>完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>\n<p><img data-src=\"/images/db7198e3c39e4656e18efcb4bd1b20b1_hd.jpg\" alt=\"img\"></p>\n<p>在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p>\n<p>比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续<code>手动</code>部署到生产环境中。</p>\n<h4 id=\"持续部署\"><a href=\"#持续部署\" class=\"headerlink\" title=\"持续部署\"></a>持续部署</h4><p>持续部署（英文：Continuous Deployment，简称 CD）</p>\n<p>对于一个成熟的 CI&#x2F;CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p>\n<p><img data-src=\"/images/f96f19e4d567aad5006d841963a86e41_hd.jpg\" alt=\"img\"></p>\n<p>实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI&#x2F;CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI&#x2F;CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p>\n<p>持续部署则是在持续交付的基础上，把部署到生产环境的过程<code>自动化</code>。</p>\n<h3 id=\"持续集成组成要素\"><a href=\"#持续集成组成要素\" class=\"headerlink\" title=\"持续集成组成要素\"></a>持续集成组成要素</h3><p><strong>一个最小化的持续集成系统需要包含以下几个要素：</strong></p>\n<ol>\n<li><strong>版本管理系统：</strong>项目的源代码需要托管到适合的版本管理系统中，一般我们使用 git 作为版本控制库，版本管理软件可以使用 github、<code>gitlab</code>、stash 等。</li>\n<li><strong>构建脚本&amp;工具：</strong>每个项目都需要有构建脚本来实现对整个项目的自动化构建。比如 Java 的项目就可以使用 gradle 作为构建工具。通过构建工具实现对编译、静态扫描、运行测试、样式检查、打包、发布等活动串起来，可以通过命令行自动执行。</li>\n<li><strong>CI 服务器：</strong>CI 服务器可以检测项目中的代码变动，并及时的通过构建机器运行构建脚本，并将集成结果通过某种方式反馈给团队成员。</li>\n</ol>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><p>打包平台</p>\n<p>常见的打包，Java 应用（Gradle&#x2F;Maven）、Nodejs 前端应用(npm&#x2F;yarn)</p>\n<p>移动端打包：Android&#x2F;iOS</p>\n</li>\n<li><p>测试平台</p>\n<p>接口测试</p>\n<p>自动化测试 Robotium、Testlink</p>\n<p>单元测试 junit</p>\n<p>性能测试 Jmeter</p>\n</li>\n<li><p>自动部署</p>\n<p>FTP</p>\n<p>Shell</p>\n<p>Tomcat&#x2F;Dokcer</p>\n<p>Kubernetes&#x2F;Rancher&#x2F;Cluster</p>\n</li>\n<li><p>持续集成</p>\n<p>Git: gitlab github gitee 等</p>\n<p>Jenkins&#x2F;TravisCi&#x2F;CircleCI</p>\n<p>Docker</p>\n</li>\n</ul>\n<h3 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h3><h4 id=\"传统的工作流\"><a href=\"#传统的工作流\" class=\"headerlink\" title=\"传统的工作流\"></a>传统的工作流</h4><p>参与人员：开发、项目经理、测试</p>\n<p>主要流程：</p>\n<ul>\n<li>项目一开始是先划分好模块，<code>分配模块</code>给相应的开发人员；</li>\n<li>开发人员<code>开发好</code>一个模块就进行<code>单元测试</code>；</li>\n<li>等所有的模块都开发完成之后，由项目经理对<code>所有代码进行集成</code>；</li>\n<li>集成后的项目由项目经理<code>部署到测试服务器</code>上，被交由测试人员进行集成测试；</li>\n<li>测试过程中出现 Bug 就提把问题<code>记录</code>进行 <code>Bug</code> 列表中；</li>\n<li><code>项目经理分配 Bug</code> 给相应的责任人进行修改；</li>\n<li>修改完成后，项目经理<code>再次</code>对项目进行集成，并<code>部署</code>到测试服务器上；</li>\n<li>测试人员在下一次的集成测试中进行<code>回归测试</code>；</li>\n<li>通过通过之后就<code>部署到生产环境</code>中；</li>\n<li>如果测试不通过，则重复上述“分配 Bug -&gt; 修改 Bug -&gt; 集成代码 -&gt; 部署到测试服务器上 -&gt; 集成测试”工作。</li>\n</ul>\n<blockquote>\n<p>这也是传统的瀑布式开发模型，请参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vLU9ZSy9hcmNoaXZlLzIwMTIvMTAvMDgvMjcxNDY2OS5odG1s\">软件开发模式对比(瀑布、迭代、螺旋、敏捷)</span></p>\n</blockquote>\n<p>带来的问题：</p>\n<ol>\n<li><p><strong>重复性劳动，无效的等待变多</strong></p>\n<p>重复的进行发布部署。</p>\n<p>流程上：有可能开发在等集成其他人的模块；测试人员在等待开发人员修复 Bug；产品经理在等待新版本上线好给客户做演示；项目经理在等待其他人提交代码。不管怎么样，等待意味低效。</p>\n<p>自动化部署工作可以解放了集成、测试、部署等重复性劳动，而且机器集成的频率明显可以比手工的高很多。</p>\n</li>\n<li><p><strong>很晚才发现缺陷，并且难以修复</strong>。</p>\n<p>实践证明，缺陷发现的越晚，需要修复的时间和精力也就越大。从上一个可工作的软件到发现缺陷之间可能存在很多次提交，而要从这些提交中找出问题并修复的成本会很大，因为开发人员需要回忆每个提交的上下文来评估影响点。</p>\n</li>\n<li><p><strong>低品质的软件，软件交付时机无法保障</strong></p>\n<p>由于集成时每次包含的代码很多，所以大家的关注点主要都是如何保证编译通过、自动化测试通过，而往往很容易忽略代码是否遵守了编码规范、是否包含有重复代码、是否有重构的空间等问题。而这些问题又反过来会影响今后的开发和集成，久而久之集成变得越来越困难，软件的质量可想而知。</p>\n</li>\n<li><p><strong>项目缺少可见性</strong></p>\n<p>某些项目，程序会经常需要变更，特别是敏捷开发的实践者。由于产品经理在与客户交流过程中，往往实际的软件就是最好的原型，所以软件会被当作原型作为跟客户交流的工具。当然，客户最希望的当然是客户的想法能够马上反映到原型上，这会导致程序会经常被修改的。那么也就意味着“分配 Bug -&gt; 修改 Bug -&gt; 集成代码 -&gt; 部署到测试服务器上 -&gt; 集成测试”工作无形又爆增了。</p>\n</li>\n</ol>\n<h4 id=\"常见的工作流\"><a href=\"#常见的工作流\" class=\"headerlink\" title=\"常见的工作流\"></a>常见的工作流</h4><p><img data-src=\"/images/DevOps.png\" alt=\"DevOps\"></p>\n<p>该系统的各个组成部分是按如下顺序来发挥作用的：</p>\n<ol>\n<li><p>开发者检入代码到源代码仓库。</p>\n</li>\n<li><p>CI 系统会为每一个项目创建了一个单独的工作区。当预设或请求一次新的构建时，它将把源代码仓库的源码存放到对应的工作区。</p>\n</li>\n<li><p>CI 系统会在对应的工作区内执行构建过程。</p>\n</li>\n<li><p>配置如果存在）构建完成后，CI 系统会在一个新的构件中执行定义的一套测试。完成后触发通知(Email,RSS 等等)给相关的当事人。</p>\n</li>\n<li><p>配置如果存在）如果构建成功，这个构件会被打包并转移到一个部署目标(如应用服务器)或存储为软件仓库中的一个新版本。软件仓库可以是 CI 系统的一部分，也可以是一个外部的仓库，诸如一个文件服务器或者像 Java.net、SourceForge 之类的网站。</p>\n</li>\n<li><p>CI 系统通常会根据请求发起相应的操作，诸如即时构建、生成报告，或者检索一些构建好的构件。</p>\n</li>\n</ol>\n<blockquote>\n<p>“You build it, you run it”，这是 Amazon 一年可以完成 5000 万次部署，平均每个工程师每天部署超过 50 次的核心秘籍。</p>\n</blockquote>\n<h4 id=\"解决的问题\"><a href=\"#解决的问题\" class=\"headerlink\" title=\"解决的问题\"></a>解决的问题</h4><ul>\n<li><p>高效率</p>\n<p>高效率的发布，避免了重复性的劳动；</p>\n<p>更快的修复 BUG，更快的交付成果，减少了等待时间。</p>\n</li>\n<li><p>高质量</p>\n<p>只有在完成集成测试、系统测试后，才能得到可用的软件，整个过程中只有最后时刻才能拿到可运行软件。集成活动不一定在一个标准的构建机器上生成，而是在某个开发人员的机器上构建的，那么可能存在在其他机器上无法运行的问题。</p>\n<p>人与机器的一个最大的区别是，在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。所以，当我们搭建完成集成服务器后，以后的事就交给集成服务器来打理吧。</p>\n</li>\n<li><p>高产出</p>\n<p>快速开发和上市一个新产品，并快速取得预期的投资回报是每个企业孜孜以求的目标。</p>\n<p>便捷的部署+项目的可预期，使得团队的开发变成了一种开心的事情。</p>\n<p>持续集成可以让你在任何时间发布可以部署的软件。在外界看来，这是持续集成最明显的好处，对客户来说，可以部署的软件产品是最实际的资产。利用持续集成，你可以经常对源代码进行一些小改动，并将这些改动和其他代码进行集成。</p>\n</li>\n</ul>\n<h4 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h4><ol>\n<li><p>思维转变后，新技术抵触</p>\n<ul>\n<li>无法接受新事物：不管怎么样，求稳心态的人还是多。总是有人认为老的技术代表稳定，新的事物往往会带来问题。</li>\n<li>认为手工集成也没有多少工作量：不是所有的人都参与到了整个持续集成的环节，所以没有办法认识到问题全貌。</li>\n</ul>\n<p><strong>针对这个问题，可以通过设置一定的持续集成技术培训、宣讲得到改观</strong></p>\n</li>\n<li><p>管理层的抵触</p>\n<ul>\n<li>培训持续集成需要投入资金啊，没钱。</li>\n<li>持续集成服务器要增加软硬件成本啊，没钱。</li>\n<li>开发人员领了那么高的工资，多干活多加班应该啊。</li>\n</ul>\n<p><strong>针对这一点，可以从开发人员的成本和持续集成的投入（软硬件）的成本上两者做下估算。</strong></p>\n<blockquote>\n<p>硬件参考：</p>\n<p>Jenkins 主服务器一般 2C4G，slave 服务器根据生产需要进行选购。</p>\n<p>git 服务器一般 2C4G(10 人团队)</p>\n<p>Docker 服务器 8C32G(Rancher + harbor)</p>\n</blockquote>\n</li>\n<li><p>生产环境的复杂</p>\n<ul>\n<li>比如部署的生成环境是在政务外网，无法从互联网直接访问等。</li>\n<li>构建效率低下，任务多</li>\n</ul>\n<p>目前，这个是最麻烦的，还在研究中。初步设想是让政务外网开辟一个白名单，给持续集成服务器设置一个单独的通道。只是思路，未验证。</p>\n</li>\n</ol>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h4><p>实施持续集成的开发人员可以尽早并经常提交。这允许他们尽早发现冲突。并且，如果存在任何问题，则使用较小的提交可以更轻松地对代码进行故障排除。每天或甚至更频繁地提交软件对于持续集成是必要的，但还不够。</p>\n<p>要成功使用持续集成，团队必须：</p>\n<ul>\n<li><p>使测试成为开发过程中不可或缺的一部分。应该在创建代码时编写测试。</p>\n<p>公司成功持续整合所需的最重要因素是严格的测试文化。为了将新代码自信地集成到主线中，团队需要确信代码是健全的。这是通过测试来实现的，这应该定期进行。工程师应该在开发每个功能时编写测试。</p>\n</li>\n<li><p>确保测试环境反映生产一致。</p>\n<p>为了支持您严格的测试文化，测试环境必须反映生产环境。否则，您无法保证您正在测试的内容将在生产中起作用。这意味着测试环境应使用相同版本的数据库，Web 服务器配置，工件等。</p>\n</li>\n<li><p>使用编码最佳实践，例如结对编程。</p>\n<p>软件开发的另一个最佳实践是在编码期间进行配对。对于更复杂的功能，团队在编写单行代码之前讨论体系结构方法。在将任何代码合并到生产环境之前，其他开发人员始终会检查代码。这有助于确保使用编码最佳实践，代码不会与其他开发人员正在处理的现有代码或代码冲突，并且新功能是可扩展的。</p>\n<blockquote>\n<p><strong>Pair programming</strong> is an <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWdpbGVfc29mdHdhcmVfZGV2ZWxvcG1lbnQ=\">agile software development</span> technique in which two <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcHV0ZXJfcHJvZ3JhbW1lcg==\">programmers</span> work together at one workstation. One, the <em>driver</em>, writes <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU291cmNlX2NvZGU=\">code</span> while the other, the <em>observer</em> or <em>navigator</em>,[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFpcl9wcm9ncmFtbWluZyNjaXRlX25vdGUtMQ==\">1]</span> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29kZV9yZXZpZXc=\">reviews</span> each line of code as it is typed in. The two programmers switch roles frequently.</p>\n<p>While reviewing, the observer also considers the “strategic” direction of the work, coming up with ideas for improvements and likely future problems to address. This is intended to free the driver to focus all of their attention on the “tactical” aspects of completing the current task, using the observer as a safety net and guide.</p>\n</blockquote>\n</li>\n<li><p>自动化部署工作流程。</p>\n<p>最后，为确保整个软件开发流程快速高效，构建需要快速，部署工作流程应自动化。代码构建的每一分钟都浪费了一分钟。通过自动化部署工作流程，团队可以更快地将完成的代码生成。因为，毕竟，如果没有接触到客户，那么快速开发软件有什么意义呢？</p>\n</li>\n</ul>\n<h3 id=\"效率工具对比\"><a href=\"#效率工具对比\" class=\"headerlink\" title=\"效率工具对比\"></a>效率工具对比</h3><p>![img](&#x2F;Users&#x2F;Shared&#x2F;Target&#x2F;5-4 持续集成与持续部署&#x2F;resource&#x2F;assets&#x2F;CICD-resource.png)</p>\n<p><a href=\"#%E5%A4%8D%E6%9D%82%E7%9A%84DevOps%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7\">点击查看</a>效率工具</p>\n<p><strong>1. Jenkins</strong></p>\n<blockquote>\n<p>Jenkins，原名 Hudson，2011 年改为现在的名字，它 是一个开源的实现持续集成的软件工具。官方网站：<span class=\"exturl\" data-url=\"aHR0cDovL2plbmtpbnMtY2kub3JnLw==\">http://jenkins-ci.org/</span>。</p>\n<p>Jenkins 能实时<strong>监控集成中存在的错误</strong>，提供<strong>详细的日志文件和提醒</strong>功能，还能用图表的形式形象地展示<strong>项目构建的趋势和稳定性</strong>。</p>\n</blockquote>\n<p><strong>Jenkins 特点:</strong></p>\n<ul>\n<li><strong>易安装</strong>：Jenkins 是一个独立的基于 Java 的程序，随时可以运行，包含 Windows，Mac OS X 和其他类 Unix 操作系统的软件包。仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库；</li>\n<li><strong>易配置</strong>：提供友好的 GUI 配置界面；</li>\n<li><strong>变更支持</strong>：Jenkins 能从代码仓库（Subversion&#x2F;CVS）中获取并产生代码更新列表并输出到编译输出信息中；</li>\n<li><strong>支持永久链接</strong>：用户是通过 web 来访问 Jenkins 的，而这些 web 页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接；</li>\n<li><strong>集成 E-Mail&#x2F;RSS&#x2F;IM：</strong>当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）；</li>\n<li><strong>JUnit&#x2F;TestNG 测试报告</strong>：也就是用以图表等形式提供详细的测试报表功能；</li>\n<li><strong>支持分布式构建</strong>：Jenkins 可以把<strong>集成构建等工作分发到多台计算机中完成</strong>；</li>\n<li><strong>文件指纹信息</strong>：Jenkins 会保存哪次集成构建产生了哪些 jars 文件，哪一次集成构建使用了哪个版本的 jars 文件等构建记录；</li>\n<li><strong>支持第三方插件</strong>：使得 Jenkins 变得越来越强大；凭借更新中心中的数百个插件，Jenkins 几乎集成了持续集成和持续交付工具链中的所有工具。</li>\n<li><strong>Rest API</strong> - 可以访问控制您获取的数据量，获取&#x2F;更新 config.xml，删除作业，检索所有构建，获取&#x2F;更新作业说明，执行构建，禁用&#x2F;启用作业</li>\n</ul>\n<p><strong>Jenkins 优点：</strong></p>\n<ul>\n<li>价格（免费）</li>\n<li>定制</li>\n<li>插件系统</li>\n<li>完全控制系统</li>\n</ul>\n<p><strong>Jenkins 缺点：</strong></p>\n<ul>\n<li>需要专用服务器（或多个服务器）。这导致额外的费用。对于服务器本身，DevOps 等…</li>\n<li>配置&#x2F;定制所需的时间</li>\n</ul>\n<p><strong>2. Travis CI</strong></p>\n<p><strong>Travis CI</strong>是一个托管的持续集成服务，用于构建和测试在 GitHub 上托管的软件项目。</p>\n<blockquote>\n<p><strong>Travis CI</strong> is a hosted continuous integration service used to build and test software projects hosted at GitHub</p>\n</blockquote>\n<p><strong>Travis CI 的特点：</strong></p>\n<ul>\n<li><p>基于云：TravisCI 是一个<strong>基于云</strong>的系统 - 不需要专用服务器，您无需管理它。</p>\n</li>\n<li><p>支持 Docker 运行测试</p>\n</li>\n<li><p>使用 YAML 文件进行配置</p>\n</li>\n<li><p>可选择 Linux 和 Mac OSX 上同时运行测试</p>\n</li>\n<li><p>开箱即用的支持的语言</p>\n<p>Android，C，C＃，C ++，Clojure，Crystal，D，Dart，Erlang，Elixir，F＃，Go，Groovy，Haskell，Haxe，Java，JavaScript（使用 Node.js），Julia，Objective-C，Perl，Perl6， PHP，Python，R，Ruby，Rust，Scala，Smalltalk，Visual Basic</p>\n</li>\n<li><p><strong>支持多环境构建矩阵</strong>：如 Python 2.7 , 3.4, 3.5 + Django 1.8, 1.9, 1.10</p>\n<p>构建矩阵是一种工具，可以使用不同版本的语言和包运行测试。您可以以不同的方式自定义它。例如，某些环境的失败可以触发通知但不会使所有构建失败（这对包的开发版本有帮助）</p>\n</li>\n</ul>\n<p><strong>Travis CI 优点：</strong></p>\n<ul>\n<li>开箱即用构建矩阵</li>\n<li>快速启动</li>\n<li>轻量级 YAML 配置</li>\n<li>开源项目的免费计划</li>\n<li>无需专用服务器</li>\n</ul>\n<p><strong>Travis CI 缺点：</strong></p>\n<ul>\n<li>与 CircleCI 相比，价格更高，没有免费的企业计划</li>\n<li>定制（对于某些你需要第三方的东西）</li>\n</ul>\n<p><strong>3. Circle CI</strong></p>\n<p>在 GitHub 或 Bitbucket 上的软件存储库被授权并作为项目添加到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20v\">circleci.com 之后</span>，每个代码更改都会在干净的容器或 VM 中触发自动化测试。</p>\n<p>CircleCI 在 2017 年被 Forrester 评为持续集成领导者，并被命名为多个最佳 DevOps 工具列表。CircleCI 成立于 2011 年，总部位于旧金山，拥有全球性的远程员工队伍，由 Scale Venture Partners，DFJ，Baseline Ventures，Top Tier Capital，Industry Ventures，Heavybit 和 Harrison Metal Capital 提供风险投资。</p>\n<p><strong>Circle CI 的特点：</strong></p>\n<ul>\n<li><strong>云&amp;本地化</strong>：CircleCI 是一个<strong>基于云</strong>的系统 - 不需要专用服务器，您无需管理它。 但是，它还<strong>提供了一个本地解决方案</strong>，允许您在私有云或数据中心中运行它。</li>\n<li><strong>商业&amp;免费</strong>：即使是商业帐户，它也<strong>有免费计划</strong></li>\n<li><strong>Rest API</strong> - 您可以访问项目，构建和工件（artifacts）。构建的结果将是工件或工件组。 工件可以是已编译的应用程序或可执行文件（例如，android APK）或元数据（例如，关于测试&#96;成功的信息）</li>\n<li><strong>按需安装</strong>：CircleCI 缓存<strong>必要的安装</strong>（requirements installation）。 它会检查第三方依赖项，而不是持续安装所需的环境</li>\n<li><strong>SSH 模式</strong>：您可以触发<strong>SSH 模式</strong>访问容器并进行自己的调查（如果出现任何问题）</li>\n<li><strong>最小化配置</strong>：这是一个完整的开箱即用解决方案，需要<strong>最少的配置\\调整</strong></li>\n</ul>\n<p><strong>CircleCI 优点：</strong></p>\n<ul>\n<li>快速启动</li>\n<li>CircleCI 有一个免费的企业项目计划</li>\n<li>这很容易，也很快开始</li>\n<li>轻量级，易读的 YAML 配置</li>\n<li>您不需要任何专用服务器来运行 CircleCI</li>\n</ul>\n<p><strong>CircleCI 缺点：</strong></p>\n<ul>\n<li><p>CircleCI 仅支持 2 个版本的 Ubuntu 免费（12.04 和 14.04）和 MacOS 作为付费部分</p>\n</li>\n<li><p>尽管 CircleCI 可以使用并运行所有语言，但 tt 仅支持“开箱即用”的以下编程语言：Go（Golang），Haskell，Java，PHP，Python，Ruby &#x2F; Rails，Scala</p>\n</li>\n<li><p>如果您想进行自定义，可能会出现一些问题：您可能需要一些第三方软件来进行这些调整</p>\n</li>\n<li><p>此外，虽然作为基于云的系统是一方的优势，它也可以停止支持任何软件，你将无法阻止</p>\n</li>\n</ul>\n<p>总结一下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Jenkins</th>\n<th>Travis CI</th>\n<th>Circle CI</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>本地部署</td>\n<td>支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>REST API</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>配置</td>\n<td>复杂，高度可配置</td>\n<td>YAML 文件</td>\n<td>YAML 文件</td>\n</tr>\n<tr>\n<td>按需安装</td>\n<td>是</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>跨平台支持</td>\n<td>是</td>\n<td>Linux + MacOS</td>\n<td>Linux + MacOS(付费)</td>\n</tr>\n<tr>\n<td>多服务器</td>\n<td>是</td>\n<td>按需</td>\n<td>否</td>\n</tr>\n<tr>\n<td>快速构建</td>\n<td>手动配置复杂</td>\n<td>快(需要写配置文件)</td>\n<td>最快</td>\n</tr>\n<tr>\n<td>基本环境</td>\n<td>Java</td>\n<td>云环境</td>\n<td>云环境</td>\n</tr>\n<tr>\n<td>费用</td>\n<td>免费</td>\n<td>特定免费(69$&#x2F;c)</td>\n<td>特定免费(50$&#x2F;c)</td>\n</tr>\n</tbody></table>\n<p>Travis CI 的价格（非常感人）：</p>\n<p><img data-src=\"/images/image-20190611100501785.png\" alt=\"/images/image-20190611100501785\"></p>\n<p>CirCle CI 的价格：</p>\n<p><img data-src=\"/images/image-20190611100534676.png\" alt=\"/images/image-20190611100534676\"></p>\n<p>其他的一些持续集成的工具：CruiseControl，TeamCity，Continuum 等</p>\n<ul>\n<li>AnthillPro：商业的构建管理服务器，提供 C 功能</li>\n<li>Bamboo：商业的 CI 服务器，对于开源项目免费</li>\n<li>Build Forge：多功能商业构建管理工具，特点：高性能、分布式构建</li>\n<li>Cruise Control：基于 java 实现的持续集成构建工具</li>\n<li>CruiseControl.NET：基于 C#实现的持续集成构建工具</li>\n<li>Lunt build：开源的自动化构建工具</li>\n<li>Para Build：商业的自动化软件构建管理服务器</li>\n</ul>\n<h2 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h2><h3 id=\"使用简介\"><a href=\"#使用简介\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h3><p>Jenkins 是开源 CI&amp;CD 软件领导者， 提供超过 1000 个插件来支持构建、部署、自动化， 满足任何项目的需要。</p>\n<p><img data-src=\"/images/image-20190611103941326.png\" alt=\"/images/image-20190611103941326\"></p>\n<p>相关概念：</p>\n<ul>\n<li><p>流水线：<strong>Jenkins Pipeline</strong>（或简称为 “Pipeline”）是一套插件，将持续交付的实现和实施集成到 Jenkins 中。</p>\n<p>Jenkins Pipeline 提供了一套可扩展的工具，用于将“简单到复杂”的交付流程实现为“持续交付即代码”。Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 <code>Jenkinsfile</code> ）中，该文件可以被放入项目的源代码控制库中。</p>\n</li>\n<li><p>节点：节点是一个机器，主要用于执行 jenkins 任务</p>\n</li>\n<li><p>阶段：定义不同的执行任务，比如：构建、测试、发布(部署)</p>\n</li>\n<li><p>步骤：相当于告诉 Jenkins 现在要做些什么，比如 shell 命令。</p>\n</li>\n</ul>\n<p><img data-src=\"/images/image-20190611163108298.png\" alt=\"/images/image-20190611163108298\"></p>\n<p>Jenkins 的界面</p>\n<p><img data-src=\"/images/image-20190611163727975.png\" alt=\"/images/image-20190611163727975\"></p>\n<p>任务详情页面</p>\n<p><img data-src=\"/images/image-20190611163855257.png\" alt=\"/images/image-20190611163855257\"></p>\n<p>Jenkins 任务日志</p>\n<h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h3><ol>\n<li><p>环境要求</p>\n<ul>\n<li>机器要求：<ul>\n<li>256 MB 内存，建议大于 512 MB</li>\n<li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）</li>\n</ul>\n</li>\n<li>需要安装以下软件：<ul>\n<li>Java 8 ( JRE 或者 JDK 都可以)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=\">Docker</span> （导航到网站顶部的 Get Docker 链接以访问适合您平台的 Docker 下载）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常规安装</p>\n<ul>\n<li><p>安装 JDK</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvamRrOC1kb3dubG9hZHMtMjEzMzE1MS5odG1s\">官方地址</span></p>\n<p>下载对应的操作系统的 JDK，然后解压进行安装。以 Linux 为例：</p>\n<p>下载最新版本，上传到 Linux 服务器</p>\n<pre><code class=\"bash\"># 上传到 /opt/jdk8目录下\n\n# tar解压JDK安装包\nmkdir -p /opt/jdk8\ntar zxvf jdk-8u211-linux-x64.tar.gz -C /opt/jdk8 --strip-components 1\n\n# vi /etc/profile\nexport JAVA_HOME=/opt/jdk8\nexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre\nexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib\nexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n</code></pre>\n</li>\n<li><p>安装 Jenkins</p>\n<p>下载 Jenkins 最新的 war 包：<span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuamVua2lucy5pby93YXItc3RhYmxlL2xhdGVzdC9qZW5raW5zLndhcg==\">Latest</span></p>\n<pre><code class=\"bash\">mkdir -p /opt/jenkins &amp;&amp; cd /opt/jenkins\n\nwget -O /opt/jenkins/jenkins.war http://mirrors.jenkins.io/war-stable/latest/jenkins.war\n\njava -jar jenkins.war --httpPort=8080\n</code></pre>\n<p>就嗯可以打开，<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwLw==\">http://localhost:8080</span> 了</p>\n<p>注意一段这样的话：</p>\n<pre><code class=\"bash\">*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n63196690ae7d47c49506480ee0e1af4a\n\nThis may also be found at: /root/.jenkins/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n</code></pre>\n<p>这里的<code>63196690ae7d47c49506480ee0e1af4a</code>就是初始的安装的管理员密码。</p>\n</li>\n</ul>\n</li>\n<li><p>使用 Docker 安装</p>\n<ul>\n<li><p>安装 Docker</p>\n<pre><code class=\"bash\"># From https://get.docker.com:\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsh get-docker.sh\n\n#From https://test.docker.com:\ncurl -fsSL https://test.docker.com -o test-docker.sh\nsh test-docker.sh\n\n# From the source repo (This will install latest from the test channel):\nsh install.sh\n</code></pre>\n</li>\n<li><p>配置 Docker 镜像加速，使用阿里云<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jci5jb25zb2xlLmFsaXl1bi5jb20vP3NwbT1hMmM0ZS4xMTE1Mzk0MC5ibG9nY29udDI5OTQxLjkuNTIwMjdlMjl3Mmp2OVA=\">容器加速服务</span></p>\n<p>左侧的加速器帮助页面就会显示为你独立分配的加速地址</p>\n<pre><code class=\"bash\">例如：\n公网Mirror：[系统分配前缀].mirror.aliyuncs.com\n</code></pre>\n<p>使用配置文件 <code>/etc/docker/daemon.json</code>（没有时新建该文件）</p>\n<pre><code class=\"bash\">&#123;\n    &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]\n&#125;\n</code></pre>\n<p>重启 Docker Daemon 就可以了</p>\n<pre><code class=\"bash\">systemctl daemon-reload\nsystemctl restart docker\n</code></pre>\n<p><code>docker ps</code> 查看容器运行状态</p>\n<p><code>docker logs 容器ID/容器名称</code> 查看管理员初始密码</p>\n</li>\n<li><p>安装 Docker-compose.yml 文件(可选)</p>\n<p><strong>安装方法：</strong></p>\n<pre><code class=\"bash\">#下载\nsudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n#安装\nchmod +x /usr/local/bin/docker-compose\n#查看版本\ndocker-compose --version\n</code></pre>\n</li>\n<li><p>安装 Jenkins</p>\n<p><strong>版本选择：</strong></p>\n<p>Jenkins: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2plbmtpbnMvamVua2lucy8=\">https://hub.docker.com/r/jenkins/jenkins/</span></p>\n<p>Jenkins with Blue Ocean: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2plbmtpbnNjaS9ibHVlb2NlYW4=\">https://hub.docker.com/r/jenkinsci/blueocean</span></p>\n<blockquote>\n<p>Blue Ocean 重新思考 Jenkins 的用户体验，从头开始设计<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZW5raW5zLmlvL3poL2RvYy9ib29rL3BpcGVsaW5lLw==\">Jenkins Pipeline</span>, 但仍然与自由式作业兼容，Blue Ocean 减少了混乱而且进一步明确了团队中每个成员 Blue Ocean 的主要特性包括：</p>\n<ul>\n<li>持续交付(CD)Pipeline 的 <strong>复杂可视化</strong> ，可以让您快速直观地理解管道状态。</li>\n<li><strong>Pipeline 编辑器</strong> - 引导用户通过直观的、可视化的过程来创建 Pipeline，从而使 Pipeline 的创建变得平易近人。</li>\n<li><strong>个性化</strong> 以适应团队中每个成员不同角色的需求。</li>\n<li>在需要干预和&#x2F;或出现问题时 <strong>精确定位</strong> 。 Blue Ocean 展示 Pipeline 中需要关注的地方， 简化异常处理，提高生产力</li>\n<li><strong>本地集成分支和合并请求</strong>, 在与 GitHub 和 Bitbucket 中的其他人协作编码时实现最大程度的开发人员生产力。****</li>\n</ul>\n</blockquote>\n<p><strong>安装命令：</strong></p>\n<pre><code class=\"bash\"># Jenkins\ndocker run \\\n  -itd \\\n  -u root \\\n  -p 8080:8080 \\\n  -v jenkins-data:/var/jenkins_home \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v /usr/bin/docker:/usr/bin/docker \\\n  --name jenkins-master \\\n  jenkins/jenkins\n\n# Jenkins blueocean\ndocker run \\\n  -itd \\\n  -u root \\\n  -p 8080:8080 \\\n  -v jenkins-data:/var/jenkins_home \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v /usr/bin/docker:/usr/bin/docker \\\n  --name jenkins-master \\\n  jenkinsci/blueocean\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>配置 Jenkins 插件加速</p>\n<p>进入 jenkins 系统管理-&gt;插件管理中-&gt;高级选项卡-&gt;升级站点，使用清华源：</p>\n<pre><code class=\"html\">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/current/update-center.json\n</code></pre>\n<p><img data-src=\"/images/70.png\" alt=\"ç³»ç»ç®¡ç\"></p>\n<p><img data-src=\"/images/70-20190611152837311.png\" alt=\"æä»¶ç®¡ç\"></p>\n<p>关于官方所有的镜像列表：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuamVua2lucy1jaS5vcmcvc3RhdHVzLmh0bWw=\">http://mirrors.jenkins-ci.org/status.html</span></p>\n</li>\n<li><p>环境配置</p>\n<ul>\n<li>Jenkins 的 URL 路径</li>\n<li>全局工具的配置：Docker, JDK(JAVA)…</li>\n</ul>\n</li>\n<li><p>用户权限配置</p>\n<ul>\n<li>矩阵权限的配置</li>\n<li>添加管理员用户所有的权限</li>\n<li>添加<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmplbmtpbnMtY2kub3JnL2Rpc3BsYXkvSkVOS0lOUy9BdXRob3JpemUrUHJvamVjdCtwbHVnaW4=\">Authorize Project</span>插件，并且在系统管理中进行配置。配置逻辑，就给用户当前项目的矩阵权限！</li>\n</ul>\n</li>\n<li><p>与 gitlab 进行联接</p>\n<ul>\n<li>设置一个 SSH Key，方便 Jenkins 去拉取 Gitlab 中的项目</li>\n<li>GItlab 项目中去配置 SSH Key 的 Deploy 权限。<code>Settings -&gt; Repository -&gt; Deploy keys -&gt; Public Deploy Keys</code></li>\n<li>Jenkins 添加 SSH 的私钥</li>\n</ul>\n<p>这样就完成了 Jenkins 可以访问 gitlab 的联接的过程。</p>\n<p>Jenkins 层面，需要去安装 Gitlab 相关插件。</p>\n</li>\n</ol>\n<h3 id=\"插件介绍\"><a href=\"#插件介绍\" class=\"headerlink\" title=\"插件介绍\"></a>插件介绍</h3><ul>\n<li><p>Publish over SSH</p>\n<p>这个是一个远程 Shell 工具，可以远程去执行一些 shell 命令</p>\n</li>\n<li><p>HTTP Request Plugin</p>\n<p>跨平台调用，在构建前后可以通过该插件以 http 形式调用各种 api 接口实现和内部系统的联动</p>\n</li>\n<li><p>Publish Over FTP</p>\n<p>用于远程使用 FTP 发布，比较合适于静态资源的发布。</p>\n<p><img data-src=\"/images/20181225153134962.jpeg\" alt=\"img\"></p>\n</li>\n<li><p>Performance Plugin</p>\n</li>\n</ul>\n<p>​ 该插件可以读取和解析测试框架输出的报告，并且在 Jenkins 上绘制性能和稳定性相关的图表。Performance Plugin 支持的测试框架有 JUnit、JMeter, Twitter 的 Lago 和 Taurus。下图是该插件输出的示例图：</p>\n<p><img data-src=\"/images/3dee2f58ccdf7cf25fa86074c5485184a9f.jpg\" alt=\"img\"></p>\n<p>​ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbHVnaW5zLmplbmtpbnMuaW8vcGVyZm9ybWFuY2U=\">https://plugins.jenkins.io/performance</span></p>\n<ul>\n<li>Gitlab Merge Request Builder Plugin</li>\n</ul>\n<p>​ Gitlab Merge Request Builder Plugin 可以方便的自动发起代码审查，它在创建 pull request 的时候，会自动带上关联任务的运行结果，以方便代码审查着确认改动的正确性。</p>\n<p>​ 同时，这款插件还支持自动合并，既在代码审查通过后自动合并该 pull request 内容。</p>\n<p>​ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RpbW9scy9qZW5raW5zLWdpdGxhYi1tZXJnZS1yZXF1ZXN0LWJ1aWxkZXItcGx1Z2lu\">https://github.com/timols/jenkins-gitlab-merge-request-builder-plugin</span></p>\n<ul>\n<li>JIRA Plugin</li>\n</ul>\n<p>​ JIRA Plugin 可以让 Jenkins 任务和 JIRA 集成起来，这样项目管理者可以通过 JIRA 了解项目进度，开发者也可以通过该插件直接更改 JIRA 上的 issue 状态。</p>\n<p>​ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbHVnaW5zLmplbmtpbnMuaW8vamlyYQ==\">https://plugins.jenkins.io/jira</span></p>\n<ul>\n<li>Kubernetes Plugin</li>\n</ul>\n<p>​ 和最近大热的容器编排框架 Kubernetes 集成当然不能落下了。另外，Jenkins 对执行机的管理一直比较弱，无法做到快速的扩容和缩容。Kubernetes Plugin 通过引入 Kubernetes 的容器编排能力，让 Jenkins 执行机运行在 Kubernetes 环境中。</p>\n<p>​ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plbmtpbnNjaS9rdWJlcm5ldGVzLXBsdWdpbg==\">https://github.com/jenkinsci/kubernetes-plugin</span></p>\n<ul>\n<li>Build Pipeline plugin</li>\n</ul>\n<p>​ 对一个系统的持续集成会包含很多个方面，如果将它们都杂糅在一个 Jenkins 任务中，会提高排查成本，也不利于整个持续集成的运作。Build Pipeline plugin 可以让项目管理员针对系统持续集成步骤设置一系列关联的任务，任务之间可以设置不同的触发条件，以确认何时需要人工介入。该插件可以让整个持续集成流程变得非常直观：</p>\n<p><img data-src=\"https://oscimg.oschina.net/oscnet/abf7ec185c847b72cd61181562f940557a2.jpg\" alt=\"img\"></p>\n<p>​ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plbmtpbnNjaS9idWlsZC1waXBlbGluZS1wbHVnaW4=\">https://github.com/jenkinsci/build-pipeline-plugin</span></p>\n<h3 id=\"配置自动化任务\"><a href=\"#配置自动化任务\" class=\"headerlink\" title=\"配置自动化任务\"></a>配置自动化任务</h3><p>两种执行方法：</p>\n<ol>\n<li>配置自由风格的项目</li>\n<li>配置 Pipeline 使用 Jenkinsfile</li>\n</ol>\n<p>需要注意的地方</p>\n<ul>\n<li><p>SSH 插件：</p>\n<p>SSH</p>\n<p>SSH Agent</p>\n<p>SSH Pipeline Steps</p>\n<p>Publish Over SSH</p>\n</li>\n<li><p>git 相关插件：</p>\n<p>Gitlab</p>\n<p>Github</p>\n</li>\n<li><p>管理员界面配置：</p>\n<p><code>Settings -&gt; network -&gt; Outbound requests</code></p>\n<p>Allow requests to the local network from hooks and services 进行勾选</p>\n</li>\n</ul>\n<p>其他的一些用法：</p>\n<ul>\n<li>使用 Jenkins 配合 Docker Hub，把前端代码打包成镜像，再远程部署</li>\n<li>Jenkins 配合自建 Docker 容器服务，把前端代码打包，使用 Kubernetes 进行发布。</li>\n<li>使用 Docker 进行远程发布(远程服务器上有 Docker 服务，并且设置了远程连接)</li>\n</ul>\n<h2 id=\"TravisCI\"><a href=\"#TravisCI\" class=\"headerlink\" title=\"TravisCI\"></a>TravisCI</h2><h3 id=\"使用简介-1\"><a href=\"#使用简介-1\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h3><p>Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。</p>\n<blockquote>\n<ul>\n<li>拥有 GitHub 帐号</li>\n<li>该帐号下面有一个项目</li>\n<li>该项目里面有可运行的代码</li>\n<li>该项目还包含构建或测试脚本</li>\n</ul>\n</blockquote>\n<p>Travis 简单的使用步骤:</p>\n<ul>\n<li>github 授权及面板</li>\n<li>获取 github 的 Tokens</li>\n<li>配置项目.travis.yml<ul>\n<li>Node 项目</li>\n<li>Script 脚本</li>\n<li>部署到 github pages</li>\n<li>钩子用法</li>\n</ul>\n</li>\n<li>其他</li>\n</ul>\n<p><strong>github 授权及面板</strong></p>\n<p>首先，访问官方网站 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kub3JnLw==\">travis-ci.org</span>，点击右上角的个人头像，使用 Github 账户登入 Travis CI。</p>\n<p>会进入到授权页面，这里跟微博、QQ 是一回事，主要是读取你的用户信息。</p>\n<p><img data-src=\"/images/image-20190612205411602.png\" alt=\"/images/image-20190612205411602\"></p>\n<p>这里第二步在，<code>Dashboard</code>这个选项卡中，点击<code>Activate</code>这个按钮</p>\n<p><img data-src=\"/images/image-20190612212459194.png\" alt=\"/images/image-20190612212459194\"></p>\n<p>完了之后，Dashboard 会列出所有 Github 中有<code>.travis.yml</code>配置文件的仓库：</p>\n<p><img data-src=\"/images/image-20190612212731186.png\" alt=\"/images/image-20190612212731186\"></p>\n<p>Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。</p>\n<p><img data-src=\"/images/image-20190612213022380.png\" alt=\"/images/image-20190612213022380\"></p>\n<ul>\n<li><p><code>Settings</code>中用于配置项目的构建条件</p>\n<p><img data-src=\"/images/image-20190612214434173.png\" alt=\"/images/image-20190612214434173\"></p>\n</li>\n<li><p><code>Requests</code>可以查看构建记录</p>\n<p><img data-src=\"/images/image-20190612214519926.png\" alt=\"/images/image-20190612214519926\"></p>\n</li>\n<li><p><code>Caches</code>主要是缓存文件</p>\n</li>\n<li><p><code>Trigger build</code>手动触发构建</p>\n</li>\n</ul>\n<p><strong>获取 github 的 token</strong></p>\n<p>在 settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token</p>\n<p><img data-src=\"/images/image-20190612225000955.png\" alt=\"/images/image-20190612225000955\"></p>\n<p><strong>配置项目的.travis.yml 文件</strong></p>\n<ul>\n<li><p>设置项目语言</p>\n<pre><code class=\"yaml\">language: node_js\nnode_js:\n  - &quot;10&quot;\n</code></pre>\n</li>\n<li><p>Script 脚本</p>\n<p>Travis 的运行流程很简单，任何项目都会经过两个阶段。</p>\n<blockquote>\n<ul>\n<li>install 阶段：安装依赖</li>\n<li>script 阶段：运行脚本</li>\n</ul>\n</blockquote>\n<p>配置文件：</p>\n<pre><code class=\"yaml\"># S: Build Lifecycle\ninstall:\n  - yarn install\n\n// 钩子方法\nbefore_script:\n\n# 无其他依赖项所以执行npm run build 构建就行了\nscript:\n  - npm run build\n</code></pre>\n<p>如果不需要安装，即跳过安装阶段，就直接设为<code>true</code>。</p>\n<pre><code class=\"javascript\">install: true;\n</code></pre>\n<p><code>script</code>字段用来指定构建或测试脚本。</p>\n<pre><code class=\"javascript\">script: bundle exec thor build\n</code></pre>\n<p>如果有多个脚本，可以写成下面的形式。</p>\n<pre><code class=\"javascript\">script: -command1 - command2;\n</code></pre>\n</li>\n<li><p>部署到 github pages</p>\n<pre><code class=\"yaml\">deploy:\n    # 其他的一些配置项，可以参考：https://docs.travis-ci.com/user/deployment/pages/\n  provider: pages\n  skip_cleanup: true\n  local_dir: dist/\n  github_token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable\n  keep_history: false\n  on:\n    branch: master\n</code></pre>\n</li>\n<li><p>钩子用法</p>\n<p>Travis 为上面这些阶段提供了 7 个钩子。</p>\n<ul>\n<li>before_install：install 阶段之前执行</li>\n<li>before_script：script 阶段之前执行</li>\n<li>after_failure：script 阶段失败时执行</li>\n<li>after_success：script 阶段成功时执行</li>\n<li>before_deploy：deploy 步骤之前执行</li>\n<li>after_deploy：deploy 步骤之后执行</li>\n<li>after_script：script 阶段之后执行</li>\n</ul>\n<p>完整的生命周期，从开始到结束是下面的流程。</p>\n<ol>\n<li>before_install</li>\n<li>install</li>\n<li>before_script</li>\n<li>script</li>\n<li>after<em>success or after</em>failure</li>\n<li>[OPTIONAL] before_deploy</li>\n<li>[OPTIONAL] deploy</li>\n<li>[OPTIONAL] after_deploy</li>\n<li>after_script</li>\n</ol>\n</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZG9tZW5pYy9lYzhiMGZjOGFiNDVmMzk0MDNkZA==\">Auto-deploying built products to gh-pages with Travis</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vbmNsZXRvbS5pby8yMDE2L3RyYXZpcy1zc2gtZGVwbG95Lw==\">SSH deploys with Travis CI</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMTIvdHJhdmlzX2NpX3R1dG9yaWFsLmh0bWw=\">持续集成服务 Travis CI 教程</span></li>\n</ul>\n<h3 id=\"配置-Node-js-应用\"><a href=\"#配置-Node-js-应用\" class=\"headerlink\" title=\"配置 Node.js 应用\"></a>配置 Node.js 应用</h3><p>配置一个 Vue 实例并发布到 github pages</p>\n<p>.travis.yml 文件：</p>\n<pre><code class=\"yaml\">language: node_js\nnode_js:\n  - &quot;10&quot;\n\n# Travis-CI Caching\ncache:\n  directories:\n    - node_modules\n\n# S: Build Lifecycle\ninstall:\n  - yarn install\n\nbefore_script:\n\n# 无其他依赖项所以执行npm run build 构建就行了\nscript:\n  - npm run build\n\ndeploy:\n    # 其他的一些配置项，可以参考：https://docs.travis-ci.com/user/deployment/pages/\n  provider: pages\n  skip_cleanup: true\n  local_dir: dist/\n  github_token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable\n  keep_history: false\n  on:\n    branch: master\n</code></pre>\n<h2 id=\"CircleCI\"><a href=\"#CircleCI\" class=\"headerlink\" title=\"CircleCI\"></a>CircleCI</h2><h3 id=\"使用简介-2\"><a href=\"#使用简介-2\" class=\"headerlink\" title=\"使用简介\"></a>使用简介</h3><ol>\n<li><p>注册 CircleCI</p>\n<p>打开 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20v\">CircleCI</span> 官方网站，使用您的 GitHub 帐户登录。</p>\n<p><img data-src=\"/images/image-20190613093550553.png\" alt=\"/images/image-20190613093550553\"></p>\n<p>进行授权：</p>\n<p><img data-src=\"/images/image-20190613093732415.png\" alt=\"/images/image-20190613093732415\"></p>\n</li>\n<li><p>启动存储库</p>\n</li>\n</ol>\n<p>检查要在 CircleCI 上管理的存储库的开关按钮。</p>\n<p><img data-src=\"/images/image-20190613094115350.png\" alt=\"/images/image-20190613094115350\"></p>\n<ol start=\"3\">\n<li><p>编写 config.yml</p>\n<pre><code class=\"yaml\">version: 2\njobs:\n  build:\n    docker:\n      ...\n    branches:\n      ...\n    steps:\n      ...\n        environment:\n            ...\n</code></pre>\n<p>官方参考文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20vZG9jcy8yLjAvY29uZmlndXJhdGlvbi1yZWZlcmVuY2UvI3ZlcnNpb24=\">https://circleci.com/docs/2.0/configuration-reference/#version</span></p>\n<p>来看一个完事版的配置</p>\n<pre><code class=\"yaml\">version: 2\njobs:\n  build:\n    docker:\n      - image: ubuntu:14.04\n\n      - image: mongo:2.6.8\n        command: [mongod, --smallfiles]\n\n      - image: postgres:9.4.1\n        # some containers require setting environment variables\n        environment:\n          POSTGRES_USER: root\n\n      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673\n\n      - image: rabbitmq:3.5.4\n\n    environment:\n      TEST_REPORTS: /tmp/test-reports\n\n    working_directory: ~/my-project\n\n    steps:\n      - checkout\n\n      - run:\n          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts\n\n      # Create Postgres users and database\n      # Note the YAML heredoc &#39;|&#39; for nicer formatting\n      - run: |\n          sudo -u root createuser -h localhost --superuser ubuntu &amp;&amp;\n          sudo createdb -h localhost test_db\n\n      - restore_cache:\n          keys:\n            - v1-my-project-&#123;&#123; checksum \"project.clj\" &#125;&#125;\n            - v1-my-project-\n\n      - run:\n          environment:\n            SSH_TARGET: &quot;localhost&quot;\n            TEST_ENV: &quot;linux&quot;\n          command: |\n            set -xu\n            mkdir -p $&#123;TEST_REPORTS&#125;\n            run-tests.sh\n            cp out/tests/*.xml $&#123;TEST_REPORTS&#125;\n\n      - run: |\n          set -xu\n          mkdir -p /tmp/artifacts\n          create_jars.sh $&#123;CIRCLE_BUILD_NUM&#125;\n          cp *.jar /tmp/artifacts\n\n      - save_cache:\n          key: v1-my-project-&#123;&#123; checksum \"project.clj\" &#125;&#125;\n          paths:\n            - ~/.m2\n\n      # Save artifacts\n      - store_artifacts:\n          path: /tmp/artifacts\n          destination: build\n\n      # Upload test results\n      - store_test_results:\n          path: /tmp/test-reports\n\n  deploy-stage:\n    docker:\n      - image: ubuntu:14.04\n    working_directory: /tmp/my-project\n    steps:\n      - run:\n          name: Deploy if tests pass and branch is Staging\n          command: ansible-playbook site.yml -i staging\n\n  deploy-prod:\n    docker:\n      - image: ubuntu:14.04\n    working_directory: /tmp/my-project\n    steps:\n      - run:\n          name: Deploy if tests pass and branch is Master\n          command: ansible-playbook site.yml -i production\n\nworkflows:\n  version: 2\n  build-deploy:\n    jobs:\n      - build:\n          filters:\n            branches:\n              ignore:\n                - develop\n                - /feature-.*/\n      - deploy-stage:\n          requires:\n            - build\n          filters:\n            branches:\n              only: staging\n      - deploy-prod:\n          requires:\n            - build\n          filters:\n            branches:\n              only: master\n</code></pre>\n</li>\n<li><p>设置&#x2F;查看任务</p>\n<p><img data-src=\"/images/image-20190613093327981.png\" alt=\"/images/image-20190613093327981\"></p>\n</li>\n</ol>\n<h3 id=\"配置-Node-js-应用-1\"><a href=\"#配置-Node-js-应用-1\" class=\"headerlink\" title=\"配置 Node.js 应用\"></a>配置 Node.js 应用</h3><p><code>.circleci/config.yml</code>配置文件</p>\n<pre><code class=\"yaml\">version: 2\njobs:\n  build:\n    docker:\n      - image: circleci/node:10\n    branches:\n      only:\n        - master\n    steps:\n      - add_ssh_keys:\n          fingerprints:\n            - &quot;c5:20:8e:79:81:19:fd:c1:6c:c4:fb:41:58:92:9d:4f&quot;\n      - checkout\n      - restore_cache:\n          keys:\n            # fallback to using the latest cache if no exact match is found\n            - dependencies-\n      - run:\n          name: Install\n          command: yarn install\n      - save_cache:\n          paths:\n            - node_modules\n          key: dependencies-\n      - run:\n          name: build github pages\n          command: yarn build\n      - run:\n          name: Prepare shell commands\n          command: chmod +x scripts/deploy.sh\n      - run:\n          name: Run deploy scripts\n          command: ./scripts/deploy.sh\n</code></pre>\n<p>这里以发布到 github page 为示例：</p>\n<p>deploy.sh 文件的内容：</p>\n<pre><code class=\"bash\">#!/bin/sh\n# ideas used from https://gist.github.com/motemen/8595451\n\n# Based on https://github.com/eldarlabs/ghpages-deploy-script/blob/master/scripts/deploy-ghpages.sh\n# Used with their MIT license https://github.com/eldarlabs/ghpages-deploy-script/blob/master/LICENSE\n\n# abort the script if there is a non-zero error\nset -e\n\n# show where we are on the machine\npwd\nremote=$(git config remote.origin.url)\n\necho &#39;remote is: &#39;$remote\n\n# make a directory to put the gp-pages branch\nmkdir gh-pages-branch\ncd gh-pages-branch\n# now lets setup a new repo so we can update the gh-pages branch\ngit config --global user.email &quot;$GH_EMAIL&quot; &gt; /dev/null 2&gt;&amp;1\ngit config --global user.name &quot;$GH_NAME&quot; &gt; /dev/null 2&gt;&amp;1\ngit init\ngit remote add --fetch origin &quot;$remote&quot;\n\necho &#39;email is: &#39;$GH_EMAIL\necho &#39;name is: &#39;$GH_NAME\necho &#39;sitesource is: &#39;$siteSource\n\n# switch into the the gh-pages branch\nif git rev-parse --verify origin/gh-pages &gt; /dev/null 2&gt;&amp;1\nthen\n    git checkout gh-pages\n    # delete any old site as we are going to replace it\n    # Note: this explodes if there aren&#39;t any, so moving it here for now\n    git rm -rf .\nelse\n    git checkout --orphan gh-pages\nfi\n\n# copy over or recompile the new site\ncp -a &quot;../$&#123;siteSource&#125;/.&quot; .\n\nls -la\n\n# stage any changes and new files\ngit add -A\n# now commit, ignoring branch gh-pages doesn&#39;t seem to work, so trying skip\ngit commit --allow-empty -m &quot;Deploy to GitHub pages [ci skip]&quot;\n# and push, but send any output to /dev/null to hide anything sensitive\ngit push --force --quiet origin gh-pages\n# go back to where we started and remove the gh-pages git repo we made and used\n# for deployment\ncd ..\nrm -rf gh-pages-branch\n\necho &quot;Finished Deployment!&quot;\n</code></pre>\n<p>说明：</p>\n<p><strong>&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 的含义</strong></p>\n<p><strong>文件描述符</strong></p>\n<p>当执行 shell 命令时，会默认打开 3 个文件，每个文件有对应的文件描述符来方便我们使用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">文件描述符</th>\n<th align=\"left\">默认情况</th>\n<th align=\"left\">对应文件句柄位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">标准输入（standard input）</td>\n<td align=\"left\">0</td>\n<td align=\"left\">从键盘获得输入</td>\n<td align=\"left\">&#x2F;proc&#x2F;slef&#x2F;fd&#x2F;0</td>\n</tr>\n<tr>\n<td align=\"left\">标准输出（standard output）</td>\n<td align=\"left\">1</td>\n<td align=\"left\">输出到屏幕（即控制台）</td>\n<td align=\"left\">&#x2F;proc&#x2F;slef&#x2F;fd&#x2F;1</td>\n</tr>\n<tr>\n<td align=\"left\">错误输出（error output）</td>\n<td align=\"left\">2</td>\n<td align=\"left\">输出到屏幕（即控制台）</td>\n<td align=\"left\">&#x2F;proc&#x2F;slef&#x2F;fd&#x2F;2</td>\n</tr>\n</tbody></table>\n<p><code>&gt;</code> 代表重定向到哪里?</p>\n<p>例如：<code>echo &quot;123&quot; &gt; /home/123.txt</code><br><code>1</code> 表示<code>stdout</code>标准输出，系统默认值是<code>1</code>，所以<code>&gt;/dev/null</code>等同于<code>1&gt;/dev/null</code><br><code>2</code> 表示<code>stderr</code>标准错误<br><code>&amp;</code> 表示等同于的意思，<code>2&gt;&amp;1</code>，表示<code>2</code>的输出重定向等同于<code>1</code></p>\n<p>参考资料：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGlueXdhbi9wLzYwMjU0NjguaHRtbA==\">Shell 脚本———— &#x2F;dev&#x2F;null 2&gt;&amp;1 详解</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2t5ZWNoaW5hL2FydGljbGUvZGV0YWlscy81NDU4MjE0Ng==\">shell 中&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0aG9tZXIvYXJ0aWNsZS9kZXRhaWxzLzkyODgzNTM=\">Linux Shell 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 含义</span></p>\n<h2 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h2><h3 id=\"自动化流程的发展趋势\"><a href=\"#自动化流程的发展趋势\" class=\"headerlink\" title=\"自动化流程的发展趋势\"></a>自动化流程的发展趋势</h3><ol>\n<li><p>集中化</p>\n<p>以集群为基础，服务采用 Saas 方式进行交付。所有折构建、测试、发布全集中进行管理。</p>\n</li>\n<li><p>微服务+无服务的应用模式</p>\n<p>应用程序执行环境的管理被新的编程模型和平台取代后，团队的交付生产率得到了进一步的提升。一方面它免去了很多环境管理的工作，包括设备、网络、主机以及对应的软件和配置工作，使得软件运行时环境更加稳定。另一方面，它大大降低了团队采用 DevOps 的技术门槛。</p>\n<p><strong>无服务器风格的架构（Serverless architecture）</strong>把 DevOps 技术在微服务领域的应用推向极致。当应用程序执行环境的管理被新的编程模型和平台取代后，团队的交付生产率得到了进一步的提升。一方面它免去了很多环境管理的工作，包括设备、网络、主机以及对应的软件和配置工作，使得软件运行时环境更加稳定。另一方面，它大大降低了团队采用 DevOps 的技术门槛。</p>\n<p>在微服务端到端交付流程上，Netflix 开源了自家的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zcGlubmFrZXIuaW8v\">Spinnaker</span>，Netflix 作为微服务实践的先锋，不断推出新的开源工具来弥补社区中微服务技术和最佳实践的缺失。而<span class=\"exturl\" data-url=\"aHR0cDovL3Byb2plY3RzLnNwcmluZy5pby9zcHJpbmctY2xvdWQv\">Spring Cloud</span>则为开发者提供了一系列工具，以便他们在所熟悉的 Spring 技术栈下使用这些服务协调技术(coordination techniques)，如服务发现、负载均衡、熔断和健康检查。</p>\n</li>\n<li><p>人工智能领域的应用</p>\n<p>DevOps 的最早实践来自于互联网企业的 Web 应用，相应的思想被引入企业级应用并促进了一系列工具的发展。在人工智能领域，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcv\">TensorFlow</span>就是这样一个例子，它可以有多种 DevOps 友好的安装和部署方式 ，例如采用 Docker 进行部署。</p>\n<p>随着 Python 在大数据、人工智能、区块链、微服务以及 Docker 中的发展，可以预见 Python 在日后的领域仍然会发挥重要的作用。</p>\n</li>\n<li><p>安全推动 DevOps 的发展</p>\n<p>全是 DevOps 永远绕不开的话题，也往往是新技术在传统行业（例如金融和电信）应用中的最大阻碍。一方面，组织结构的转型迫使企业要打破原先的部门墙，这意味着很多原先的控制流程不再适用。另一方面，由于大量的 DevOps 技术来源于开源社区，缺乏强大技术实力的企业在应用相关技术时不免会有所担忧。</p>\n</li>\n<li><p>Windows 平台下.net 的技术潜力巨大</p>\n<p>长期以来，Windows 和.NET 平台下的 DevOps 一直都是一个被低估的领域。一方面，社区缺乏对 Windows Server 平台的兴趣。另一方面，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tdW5pdHkuc3BpY2V3b3Jrcy5jb20vbmV0d29ya2luZy9hcnRpY2xlcy8yNDYyLXNlcnZlci12aXJ0dWFsaXphdGlvbi1hbmQtb3MtdHJlbmRz\">Windows Server 却有接近 90%的市场占用率</span>，在 Web 服务器领域则有<span class=\"exturl\" data-url=\"aHR0cHM6Ly93M3RlY2hzLmNvbS90ZWNobm9sb2dpZXMvb3ZlcnZpZXcvb3BlcmF0aW5nX3N5c3RlbS9hbGw=\">33.5%的市场占有率</span>。</p>\n</li>\n<li><p>非功能性自动化测试工具逐渐完善</p>\n<p>自动化测试水平往往是衡量 DevOps 技术能力高低的重要指标，尤其是针对生产环境应用程序的非功能性自动化测试工具。一直以来，技术雷达都在尝试从不同的角度宣扬自动化测试的重要性，从软件的开发阶段延展到了整个应用生命周期甚至整体 IT 资产的管理上。</p>\n</li>\n</ol>\n<h3 id=\"复杂的-DevOps-相关工具\"><a href=\"#复杂的-DevOps-相关工具\" class=\"headerlink\" title=\"复杂的 DevOps 相关工具\"></a>复杂的 DevOps 相关工具</h3><p><img data-src=\"/images/devops-hero-1-87966cfbc9c5713ae047551c7b22985c.png\" alt=\"DevOps\"></p>\n<h3 id=\"Jenkins-的一些应用场景\"><a href=\"#Jenkins-的一些应用场景\" class=\"headerlink\" title=\"Jenkins 的一些应用场景\"></a>Jenkins 的一些应用场景</h3><p>打包平台：</p>\n<p>使用 Jenkins 搭建 iOS&#x2F;Android</p>\n<p>测试平台：</p>\n<p>jenkins + python + selenium</p>\n<p>Jmeter+maven+Jenkins 构建云性能测试平台</p>\n<p>Jenkins+PMD 构建自动化静态代码检测</p>\n<p>使用 jenkins+Emma 统计</p>\n<p>客户端单元测试覆盖率</p>\n<p>Jenkins+Ant+Java+Junit+SVN 执行 junit 单元测试</p>\n<p>jenkins+ant+jmeter 搭建持续集成的接口测试平台</p>\n<p>自动部署：</p>\n<p>Jenkins+GitLab+蒲公英+FTP</p>\n<p>jenkins 结合 ansible 用 shell 实现自动化部署和回滚</p>\n<p>持续集成：</p>\n<p>Tomcat+Sonar 搭建持续集成环境</p>\n<p>Maven+Nexus+Jenkins+git&#x2F;SVN</p>\n<h3 id=\"Jenkins-的-Docker-compose-yml-创建文件\"><a href=\"#Jenkins-的-Docker-compose-yml-创建文件\" class=\"headerlink\" title=\"Jenkins 的 Docker-compose.yml 创建文件\"></a>Jenkins 的 Docker-compose.yml 创建文件</h3><pre><code class=\"bash\">version: &#39;3&#39;\nservices:\n  jenkins:\n    container_name: &#39;jenkins&#39;\n    image: jenkins/jenkins\n    restart: always\n    user: jenkins:&lt;这里填Docker用户组的ID，见下面&gt;\n    ports:\n    - &quot;8080:8080&quot;\n    - &quot;50000:50000&quot;\n    volumes:\n    - /home/jenkins/data:/var/jenkins_home\n    - /usr/bin/docker:/usr/bin/docker\n    - /var/run/docker.sock:/var/run/docker.sock\n</code></pre>\n<p>上面的脚本使用注意：</p>\n<ol>\n<li><p>创建本地 jenkins 数据目录</p>\n<pre><code class=\"bash\">mkdir -p /home/jenkins\n</code></pre>\n</li>\n<li><p>查看 docker 用户组的 ID</p>\n<pre><code class=\"bash\">cat /etc/group |grep docker\n</code></pre>\n</li>\n<li><p>执行<code>docker-compose up -d</code></p>\n</li>\n</ol>\n<h3 id=\"gitlab-的-docker-启动配置文件\"><a href=\"#gitlab-的-docker-启动配置文件\" class=\"headerlink\" title=\"gitlab 的 docker 启动配置文件\"></a>gitlab 的 docker 启动配置文件</h3><p>项目地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NhbWVlcnNibi9kb2NrZXItZ2l0bGFi\">https://github.com/sameersbn/docker-gitlab</span></p>\n<pre><code class=\"yaml\">version: &quot;2&quot;\n\nservices:\n  redis:\n    restart: always\n    image: sameersbn/redis:4.0.9-1\n    command:\n      - --loglevel warning\n    volumes:\n      - /srv/docker/gitlab/redis:/var/lib/redis:Z\n\n  postgresql:\n    restart: always\n    image: sameersbn/postgresql:10\n    volumes:\n      - /srv/docker/gitlab/postgresql:/var/lib/postgresql:Z\n    environment:\n      - DB_USER=gitlab\n      - DB_PASS=password\n      - DB_NAME=gitlabhq_production\n      - DB_EXTENSION=pg_trgm\n\n  gitlab:\n    restart: always\n    image: sameersbn/gitlab:11.11.2\n    depends_on:\n      - redis\n      - postgresql\n    ports:\n      - &quot;10080:80&quot;\n      - &quot;10022:22&quot;\n    volumes:\n      - /srv/docker/gitlab/gitlab:/home/git/data:Z\n    environment:\n      - DEBUG=false\n\n      - DB_ADAPTER=postgresql\n      - DB_HOST=postgresql\n      - DB_PORT=5432\n      - DB_USER=gitlab\n      - DB_PASS=password\n      - DB_NAME=gitlabhq_production\n\n      - REDIS_HOST=redis\n      - REDIS_PORT=6379\n\n      - TZ=Asia/Kolkata\n      - GITLAB_TIMEZONE=Kolkata\n\n      - GITLAB_HTTPS=false\n      - SSL_SELF_SIGNED=false\n\n      # 这里修改成服务器的IP或者域名\n      - GITLAB_HOST=localhost\n      - GITLAB_PORT=10080\n      - GITLAB_SSH_PORT=10022\n      - GITLAB_RELATIVE_URL_ROOT=\n      - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string\n      - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string\n      - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string\n\n      # 这里给一个长度大于8的密码\n      - GITLAB_ROOT_PASSWORD=12345678\n      - GITLAB_ROOT_EMAIL=itheima@itcast.cn\n\n      - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true\n      - GITLAB_NOTIFY_PUSHER=false\n\n      - GITLAB_EMAIL=notifications@example.com\n      - GITLAB_EMAIL_REPLY_TO=noreply@example.com\n      - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com\n\n      - GITLAB_BACKUP_SCHEDULE=daily\n      - GITLAB_BACKUP_TIME=01:00\n\n      - SMTP_ENABLED=false\n      - SMTP_DOMAIN=www.example.com\n      - SMTP_HOST=smtp.gmail.com\n      - SMTP_PORT=587\n      - SMTP_USER=mailer@example.com\n      - SMTP_PASS=password\n      - SMTP_STARTTLS=true\n      - SMTP_AUTHENTICATION=login\n\n      - IMAP_ENABLED=false\n      - IMAP_HOST=imap.gmail.com\n      - IMAP_PORT=993\n      - IMAP_USER=mailer@example.com\n      - IMAP_PASS=password\n      - IMAP_SSL=true\n      - IMAP_STARTTLS=false\n\n      - OAUTH_ENABLED=false\n      - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=\n      - OAUTH_ALLOW_SSO=\n      - OAUTH_BLOCK_AUTO_CREATED_USERS=true\n      - OAUTH_AUTO_LINK_LDAP_USER=false\n      - OAUTH_AUTO_LINK_SAML_USER=false\n      - OAUTH_EXTERNAL_PROVIDERS=\n\n      - OAUTH_CAS3_LABEL=cas3\n      - OAUTH_CAS3_SERVER=\n      - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false\n      - OAUTH_CAS3_LOGIN_URL=/cas/login\n      - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate\n      - OAUTH_CAS3_LOGOUT_URL=/cas/logout\n\n      - OAUTH_GOOGLE_API_KEY=\n      - OAUTH_GOOGLE_APP_SECRET=\n      - OAUTH_GOOGLE_RESTRICT_DOMAIN=\n\n      - OAUTH_FACEBOOK_API_KEY=\n      - OAUTH_FACEBOOK_APP_SECRET=\n\n      - OAUTH_TWITTER_API_KEY=\n      - OAUTH_TWITTER_APP_SECRET=\n\n      - OAUTH_GITHUB_API_KEY=\n      - OAUTH_GITHUB_APP_SECRET=\n      - OAUTH_GITHUB_URL=\n      - OAUTH_GITHUB_VERIFY_SSL=\n\n      - OAUTH_GITLAB_API_KEY=\n      - OAUTH_GITLAB_APP_SECRET=\n\n      - OAUTH_BITBUCKET_API_KEY=\n      - OAUTH_BITBUCKET_APP_SECRET=\n\n      - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=\n      - OAUTH_SAML_IDP_CERT_FINGERPRINT=\n      - OAUTH_SAML_IDP_SSO_TARGET_URL=\n      - OAUTH_SAML_ISSUER=\n      - OAUTH_SAML_LABEL=&quot;Our SAML Provider&quot;\n      - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient\n      - OAUTH_SAML_GROUPS_ATTRIBUTE=\n      - OAUTH_SAML_EXTERNAL_GROUPS=\n      - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=\n      - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=\n      - OAUTH_SAML_ATTRIBUTE_STATEMENTS_USERNAME=\n      - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=\n      - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=\n\n      - OAUTH_CROWD_SERVER_URL=\n      - OAUTH_CROWD_APP_NAME=\n      - OAUTH_CROWD_APP_PASSWORD=\n\n      - OAUTH_AUTH0_CLIENT_ID=\n      - OAUTH_AUTH0_CLIENT_SECRET=\n      - OAUTH_AUTH0_DOMAIN=\n\n      - OAUTH_AZURE_API_KEY=\n      - OAUTH_AZURE_API_SECRET=\n      - OAUTH_AZURE_TENANT_ID=\n</code></pre>\n","categories":["持续集成与部署"],"tags":["持续集成","持续部署"]},{"title":"复杂业务部署与优化","url":"/2024/04/12/%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/","content":"<h1 id=\"软件生命周期：\"><a href=\"#软件生命周期：\" class=\"headerlink\" title=\"软件生命周期：\"></a>软件生命周期：</h1><p><img data-src=\"/images/Snipaste_2024-04-16_12-54-33.jpg\" alt=\"/images/Snipaste_2024-04-16_12-54-33.jpg\"></p>\n<h1 id=\"架构流程图\"><a href=\"#架构流程图\" class=\"headerlink\" title=\"架构流程图\"></a>架构流程图</h1><p><img data-src=\"/images/Snipaste_2024-04-17_12-16-04.jpg\" alt=\"/images/Snipaste_2024-04-17_12-16-04.jpg\"></p>\n<h1 id=\"复杂项目通用方案\"><a href=\"#复杂项目通用方案\" class=\"headerlink\" title=\"复杂项目通用方案\"></a>复杂项目通用方案</h1><h4 id=\"业务的复杂度\"><a href=\"#业务的复杂度\" class=\"headerlink\" title=\"业务的复杂度\"></a>业务的复杂度</h4><ul>\n<li>交互的复杂性</li>\n<li>数据结构和状态的复杂性</li>\n<li>多项目互相依赖的复杂性</li>\n<li>打包</li>\n<li>性能优化</li>\n<li>第三方库的使用和调研以及二次开发</li>\n</ul>\n<h4 id=\"流程的复杂度\"><a href=\"#流程的复杂度\" class=\"headerlink\" title=\"流程的复杂度\"></a>流程的复杂度</h4><ul>\n<li>git flow</li>\n<li>lint工具</li>\n<li>单元测试</li>\n<li>commit信息</li>\n<li>PR revirew</li>\n<li>CI &#x2F; CD</li>\n</ul>\n<h1 id=\"CI-x2F-CD的概念\"><a href=\"#CI-x2F-CD的概念\" class=\"headerlink\" title=\"CI &#x2F; CD的概念\"></a>CI &#x2F; CD的概念</h1><p>业务组件库的开发和发布是随着一些列任务进化的：</p>\n<ul>\n<li>本地commit钩子函数完成commit验证</li>\n<li>代码push到远端之后</li>\n<li>跑特定的test（不仅仅是本机的unit test，也可能有时间很长的E2E test）</li>\n<li>test通过之后检查是否有新的tag，如果有就自动publish一个新的版本</li>\n<li>甚至还有更多，自动部署文档站点等等。</li>\n</ul>\n<p>这些任务如果手动操作，就费时费力，所以需要自动化进行。</p>\n<h4 id=\"CI（Continuous-integration）持续集成\"><a href=\"#CI（Continuous-integration）持续集成\" class=\"headerlink\" title=\"CI（Continuous integration）持续集成\"></a>CI（Continuous integration）持续集成</h4><p>持续集成是指频繁地将代码集成到主干，一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。</p>\n<p>作用有：</p>\n<ul>\n<li>快速发现错误</li>\n<li>防止分支大幅偏离主干</li>\n</ul>\n<p>持续集成的目的就是让产品可以快速迭代，同时保持高质量。</p>\n<h4 id=\"CD（Continuous-Delivery）持续交付\"><a href=\"#CD（Continuous-Delivery）持续交付\" class=\"headerlink\" title=\"CD（Continuous Delivery）持续交付\"></a>CD（Continuous Delivery）持续交付</h4><p>持续交付是指频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</p>\n<h4 id=\"CD（Continuous-Deployment）持续部署\"><a href=\"#CD（Continuous-Deployment）持续部署\" class=\"headerlink\" title=\"CD（Continuous Deployment）持续部署\"></a>CD（Continuous Deployment）持续部署</h4><p>持续部署是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p>\n<h4 id=\"CI-x2F-CD两大服务：\"><a href=\"#CI-x2F-CD两大服务：\" class=\"headerlink\" title=\"CI &#x2F; CD两大服务：\"></a>CI &#x2F; CD两大服务：</h4><ul>\n<li>github actions</li>\n<li>travis-ci</li>\n</ul>\n<h1 id=\"列表排序解决方案\"><a href=\"#列表排序解决方案\" class=\"headerlink\" title=\"列表排序解决方案\"></a>列表排序解决方案</h1><p>列表排序原理：</p>\n<pre><code class=\"javascript\">&lt;template&gt;\n    &lt;div&gt;\n      &lt;ul class=&quot;ul&quot; @drop=&quot;onDrop&quot;&gt;\n        &lt;li \n            v-for=&quot;(item,index) in list&quot; \n            :data-index=&quot;index&quot; \n            :key=&quot;item.id&quot; \n            @dragover=&quot;onDragover($event,index)&quot; \n            @dragstartart=&quot;dragstart($event,index)&quot; \n            @dragenter=&quot;dragenter($event,index)&quot; \n            draggable=&quot;true&quot; \n            :class=&quot;[item.id==currentLi?&#39;glost&#39;:&#39;&#39;]&quot;\n        &gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n/*eslint-disable*/\nimport &#123; ref &#125; from &quot;vue&quot;;\nimport &#123;arrayMoveImmutable&#125; from &#39;array-move&#39;;\nlet currentLi = ref(1);\nlet index = ref(1);\nconst list = ref(\n  [\n  &#123;id:1,name:&#39;列表1&#39;&#125;,\n  &#123;id:2,name:&#39;列表2&#39;&#125;,\n  &#123;id:3,name:&#39;列表3&#39;&#125;,\n  &#123;id:4,name:&#39;列表4&#39;&#125;,\n  &#123;id:5,name:&#39;列表5&#39;&#125;,\n]\n)\nconst dragstart = (e,inde)=&gt;&#123;\n  currentLi.value = inde;\n&#125;\nconst dragenter = (e,ind)=&gt;&#123;\n  if(ind != currentLi.value)&#123;\n      list.value = arrayMoveImmutable(list.value,ind,currentLi.value)\n      currentLi.value = ind;\n  &#125;\n&#125;\nconst onDrop = (e)=&gt;&#123;\n  console.log(e.target.dataset.index,&#39;drop&#39;);\n  list.value = arrayMoveImmutable(list.value,index.value,currentLi.value)\n  console.log(list.value);\n&#125;\nconst onDragover = (e,inde)=&gt;&#123;\n  e.preventDefault();\n  index.value = inde;\n&#125;\n&lt;/script&gt;\n\n&lt;style  scoped&gt;\n.ul&gt;li&#123;\n  width: 100%;\n  height: 50px;\n  border: 1px solid red;\n&#125;\n.glost&#123;\n  box-shadow: 10px 10px 3px 3px gray;\n&#125;\n&lt;/style&gt;\n</code></pre>\n<p>列表排序常用工具包：</p>\n<ul>\n<li>vue-draggable</li>\n<li>sortable.js</li>\n<li>array-move.js</li>\n</ul>\n<h1 id=\"拖动改变位置原理\"><a href=\"#拖动改变位置原理\" class=\"headerlink\" title=\"拖动改变位置原理\"></a>拖动改变位置原理</h1><p>通过监听mousedown和mousemove事件，用element.getBoundingClientRect方法获得x和y，left和top等属性，改变对应元素的top和left属性。</p>\n<h1 id=\"拖动改变大小原理\"><a href=\"#拖动改变大小原理\" class=\"headerlink\" title=\"拖动改变大小原理\"></a>拖动改变大小原理</h1><p> 设置边框元素，边框元素的四个角添加圆点元素，监听mousedown事件和mousemove事件，并将最新的坐标赋值给元素的尺寸大小。</p>\n<h1 id=\"快捷键实现原理\"><a href=\"#快捷键实现原理\" class=\"headerlink\" title=\"快捷键实现原理\"></a>快捷键实现原理</h1><p>好用的快捷键第三方库：Hotkeys.js</p>\n<p>事件原理：keydown事件的监听，通过event.key判断是那个快捷键，从而执行对应的操作。</p>\n<h1 id=\"撤销重做原理\"><a href=\"#撤销重做原理\" class=\"headerlink\" title=\"撤销重做原理\"></a>撤销重做原理</h1><p>维护一个固定长度的histories数组和historyIndex指针，每次修改的时候添加一条记录（标识操作类型和数据）。回滚时改变historyIndex指针。</p>\n<h1 id=\"右键菜单原理\"><a href=\"#右键菜单原理\" class=\"headerlink\" title=\"右键菜单原理\"></a>右键菜单原理</h1><p>在需要显示的区域拦截默认的右键点击事件，判断是否点击在组件元素上（通过event.target），显示一个自定义菜单，其中包括操作项，显示在鼠标的位置（event.clientX和event.clientY），点击完成操作，通过display:none隐藏。</p>\n<h1 id=\"自动保存实现方案\"><a href=\"#自动保存实现方案\" class=\"headerlink\" title=\"自动保存实现方案\"></a>自动保存实现方案</h1><ul>\n<li>定时保存（语雀）</li>\n<li>实时保存（石墨）</li>\n</ul>\n<p>实现原理：添加isDrity字段标记数据是否有修改，当修改时将isDirty设置为true，根据isDIrty的值设置定时器，定时触发保存逻辑。</p>\n<h1 id=\"DOM元素截图实现方案\"><a href=\"#DOM元素截图实现方案\" class=\"headerlink\" title=\"DOM元素截图实现方案\"></a>DOM元素截图实现方案</h1><p>工具包：html2canvas</p>\n<p>实现原理：</p>\n<p>根据DOM元素的styles样式，通过svg的foreignObject元素引入XML命名空间的元素，然后创建一个image标签，将svg通过url.createObjectURL方法创建一个路径赋值给一个image标签的src属性，通过canvas画笔 的drawImage方法将image图片绘制到canvas画布上。</p>\n<p>实现流程：</p>\n<ul>\n<li>style设置DOM样式</li>\n<li>svg引入DOM</li>\n<li>createObjectURL创建url路径</li>\n<li>将url复制到image标签的src</li>\n<li>canvas的drawImage将image图片绘制到canvas画布上</li>\n</ul>\n<pre><code class=\"javascript\">const data =\n&quot;&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39;width=&#39;400px&#39;height=&#39;40\n&quot;&lt;foreignabject width=&#39;100%&#39;height=&#39;100%&#39;&gt;&quot;+\n&quot;&lt;div xmlns=&#39;http://ww.w3.org/1999/xhtml&#39;&gt;&quot;\nelement.innerHTML+\n&quot;&lt;/div&gt;&quot;+\n&quot;&lt;/foreignobject&gt;&quot; +\n&quot;&lt;/svg&gt;&quot;\n\nconst svg = new Blob([data],&#123;type:&quot;image/svg+xml;charset=utf-8&quot;&#125;);\nconst url = URL.createobjectURL(svg)\nconst image = new Image()\nimage.src = url\nimage.addEventListener(&#39;load&#39;,()=&gt;&#123;\n    const ctx =anvas.getContext(&#39;2d&#39;);\n    if (ctx)&#123;\n    ctx.drawImage(image,0,0)\n    &#125;\n&#125;)\n</code></pre>\n<h1 id=\"二维码生成方案\"><a href=\"#二维码生成方案\" class=\"headerlink\" title=\"二维码生成方案\"></a>二维码生成方案</h1><ul>\n<li>工具包：node-qrcode</li>\n<li>ts项目中需要安装额外的定义文件。</li>\n</ul>\n<p>简单原理：将数据变为二进制，然后通过canvas将二进制变为图像。</p>\n<pre><code class=\"html\">&lt;body&gt;\n  &lt;canvas id=&quot;qrcode&quot; width=&quot;128&quot; height=&quot;128&quot;&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    //将字符串转为二进制形式\n    function toBianary(str)&#123;\n        let res = &#39;&#39;;\n        for(let i=0;i&lt;str.length;i++)&#123;\n            let charCode = str.charCodeAt(i);\n            let binaryCharCode = charCode.toString(2);\n            res += binaryCharCode.padStart(8,&#39;0&#39;);\n        &#125;\n        return res;\n    &#125;\n    //绘制\n    function drawQRCode(text, canvas) &#123;\n      var context = canvas.getContext(&quot;2d&quot;);\n      // 绘制黑白像素点\n      for (var i = 0; i &lt; text.length; i++) &#123;\n        var row = Math.floor(i / canvas.width);\n        var col = i % canvas.width;\n        var color = text.charAt(i) === &quot;1&quot; ? &quot;#000000&quot; : &quot;#FFFFFF&quot;;\n        context.fillStyle = color; \n        context.fillRect(col, row, 1, 1);\n      &#125;\n    &#125;\n    var qrcodeCanvas = document.getElementById(&quot;qrcode&quot;);\n    drawQRCode(toBianary(&#39;https://dmqweb.cn&#39;), qrcodeCanvas); // 示例：绘制一个简单的二维码\n  &lt;/script&gt;\n</code></pre>\n<h1 id=\"复制功能实现原理\"><a href=\"#复制功能实现原理\" class=\"headerlink\" title=\"复制功能实现原理\"></a>复制功能实现原理</h1><ul>\n<li>工具包：clipboard.js</li>\n<li>自带type定义文件</li>\n</ul>\n<p>实现原理：</p>\n<p>方案一：document.execCommand()方法。内置一系列功能，包括复制文本（但<strong>前提是需要选中文本</strong>），可以使用不可见元素迂回。</p>\n<p>方案二：Clipboard API（ navigator.clipboard ），但是对于<strong>浏览器兼容性有待加强。</strong></p>\n<h1 id=\"下载文件原理\"><a href=\"#下载文件原理\" class=\"headerlink\" title=\"下载文件原理\"></a>下载文件原理</h1><ul>\n<li>工具包：FileSaver.js（小文件）</li>\n<li>StreamSaver.js（大文件）</li>\n</ul>\n<p>方案一：超链接a标签添加download属性，属性值为文件名，rel属性设置打开页面的具体实现细节。（但前提是<strong>href属性为当前同源情况下</strong>。）</p>\n<p>方案二：通过axios请求到图片地址，通过URL.createObjectURL创建为一个与document相绑定的地址，赋值给a标签即可。（不要忘记使用URL.revokeObjectURL将创建的地址移除。）</p>\n<p>方案三：通过FileReader.readAsDataURL，创建一个FileReader实例，使用readAsDataURL读取对象返回一段base64格式的字符串，监听reader实例的onload事件，创建a标签将reader.result赋值给a标签的href属性。</p>\n<pre><code class=\"javascript\">downloadFile:function(data,fileName)&#123;\n   const reader = new FileReader()\n   // 传入被读取的blob对象\n   reader.readAsDataURL(data)\n   // 读取完成的回调事件\n   reader.onload = (e) =&gt; &#123;\n       let a = document.createElement(&#39;a&#39;)\n       a.download = fileName\n       a.style.display = &#39;none&#39;\n       // 生成的base64编码\n       let url = reader.result\n       a.href = url\n       document.body.appendChild(a)\n       a.click()\n       document.body.removeChild(a)\n   &#125;\n&#125;\n</code></pre>\n<p>终极解决方案：由于通过URL.createObjectURL和FileReader都会先将数据保存到内存中，业务中经常需要后端验证token之后才能拿到文件，不能直接使用a标签。因此实际中可以先发送ajax请求验证token，验证之后颁发一个过期时间短的cookie，之后使用a标签进行下载即可。但是同样会受到a标签download属性跨域请求的限制。</p>\n<h1 id=\"应用部署的流程\"><a href=\"#应用部署的流程\" class=\"headerlink\" title=\"应用部署的流程\"></a>应用部署的流程</h1><p><strong>构建</strong><br>Javascript语言本身是不需要编译的。<br>但是现代的前端项目使用的语言和或者的模块系统都无法在浏览器中使用，都需要使用特定的<br>bundler将源代码最终转换为浏览器支持的 Javascript代码。<br><strong>不同的环境:</strong><br>开发环境(development) ：本地的测试环境<br>测试环境(test或者staging）：线上的测试环境</p>\n<p>生产环境（production)：线上的生产环境</p>\n<p><strong>生产和开发环境的区别</strong><br>开发环境会添加丰富的错误提示，可以使用mock server或者本地后端环境添加各种便利的功能-比如hot reload,自动刷新，不太关心静态资源的大小，最好提供最丰富的调试信息(sourcemap)等。</p>\n<p><strong>生产环境</strong></p>\n<ul>\n<li>稳定是最重要的原则</li>\n<li>速度是第一要务</li>\n</ul>\n<p><strong>生产环境和测试环境的区别</strong></p>\n<ul>\n<li>高度相似</li>\n<li>使用的后端服务不一样</li>\n</ul>\n<p><strong>环境变量设置（按优先级）</strong></p>\n<ul>\n<li>跨平台设置环境变量工具包：cross-env</li>\n<li>命令中添加环境变量（平台限制）</li>\n<li>环境变量文件中配置</li>\n</ul>\n<p><strong>在项目根目录中放置下列文件来指定环境变量</strong></p>\n<ul>\n<li>.env                                        #在所有的环境中被载入</li>\n<li>.env.local                             #在所有的环境中被载入，但会被git忽略</li>\n<li>env.[mode]                         #只在指定的模式中被载入</li>\n<li>env.[mode].local             #只在指定的模式中被载入，但会被git忽略</li>\n</ul>\n<h1 id=\"webpack构建优化\"><a href=\"#webpack构建优化\" class=\"headerlink\" title=\"webpack构建优化\"></a>webpack构建优化</h1><h3 id=\"Bundler：\"><a href=\"#Bundler：\" class=\"headerlink\" title=\"Bundler：\"></a>Bundler：</h3><ul>\n<li><p>将浏览器不支持的模块进行编译，转换，</p>\n</li>\n<li><p>合并最后生成的代码可以在浏览器端良好的运行的工具。</p>\n</li>\n</ul>\n<h3 id=\"Loaders：\"><a href=\"#Loaders：\" class=\"headerlink\" title=\"Loaders：\"></a><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvbG9hZGVycy8=\">Loaders</span>：</strong></h3><p>loader用于对模块的源代码进行转换。loader可以使你在import或”Ioad(加载)”模块时预处理文件。<br><strong>多个Loader</strong><br>module.rules允许你在webpack配置中指定多个loader。这种方式是展示loader的一种简明方式，并且有助于使代码变得简洁和易于维护。</p>\n<p><strong>webpack中loader配置：</strong></p>\n<pre><code class=\"javascripton\">const path = require(&#39;path&#39;)\nmodule.exports = &#123;\n    entry:&#39;./main.js&#39;,\n    output:&#123;\n        path:path.resolve(dirname,&#39;dist&#39;),\n        filename:bundle.js&#39;,\n    &#125;\n&#125;,\nmodule:&#123;\n    rules:[\n    &#123;\n        test:/\\.css$/,\n        use: [\n            loader:&#39;style-loader&#39;&#125;,   //先写的loader后执行。\n            loader:&#39;css-loader&#39;&#125;\n        ]\n    &#125;]\n  &#125;\n&#125;\n</code></pre>\n<h6 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h6><p><strong>webpack中loader原理：</strong></p>\n<p> 在webpack.config.js的module字段的rules数组中进行配置：添加一个对象标识一个独立的匹配项，test字段使用正则表示匹配的文件名，use数组表示对应文件需要执行的loader，webpack在打包时会<strong>将文件内容传入并执行对应的loader</strong>（是一个函数），<strong>执行loader函数后会将函数返回值包装成一个新的函数</strong>，因此webpack中的loader通常需要进行两次module.exports。</p>\n<pre><code class=\"javascript\">//手写一个md文件的loader\nconst marked = require(&#39;marked&#39;);  //第三方库，用于将md转为html\nconst utils = require(&#39;loader-utils&#39;)  //官方库，用于获取用户配置loader时传入的参数\nconst markdownLoader = (source) =&gt; &#123;\n    const options = utils.getOptions(this);\n    const html = marked(source , options);\n    return  `module.exports = $&#123;JSON.stringify(html)&#125;`;\n&#125;\nmodule.exports = markdownLoader;\n</code></pre>\n<p>配置：</p>\n<pre><code class=\"javascript\">const path = require(&#39;path&#39;)\nmodule.exports = &#123;\n    entry:&#39;./main.js&#39;,\n    output:&#123;\n        path:path.resolve(dirname,&#39;dist&#39;),\n        filename:bundle.js&#39;,\n    &#125;\n&#125;,\nmodule:&#123;\n    rules:[\n    &#123;\n        test:/\\.css$/,\n        use: [\n            &#123; loader:&#39;style-loader&#39; &#125;,   //先写的loader后执行。\n            &#123; loader:&#39;css-loader&#39; &#125;\n        ]\n    &#125;,\n    &#123;\n        test:/\\.md$/,\n        use: [\n            &#123; loader: &#39;./markdonwn-loader&#39;,options:&#123; headerIds:false &#125; &#125; //其中options是给loader函数传入的第二个参数，loader中可以使用loader-utils官方三方库进行接受\n        ]\n    &#125;]\n  &#125;\n&#125;\n</code></pre>\n<p><strong>多个Loader串联</strong><br>最后的loader最早调用，将会传入原始资源内容。<br>第一个loader最后调用，期望值是传出JavaScript和source map(可选)。<br>中间的loader执行时，会传入前一个loader传出的结果。<br><strong>将markdown转换为html:turndown</strong><br>地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIub20vZG9tY2hyaXN0aWUvdHVybmRvd24=\">https://github.om/domchristie/turndown</span></p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins:\"></a><strong>plugins:</strong></h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvcGx1Z2lucy8=\">https://webpack.docschina.org/concepts/plugins/</span><br>插件是webpack的支柱功能。webpack自身也是构建开你在webpack配置中用到的相同的插件系统之上！插件目的在于解决loader无法实现的其他事。(我自己的理解，loader解决的是各种不同资源的问题，plugins更多解决的是项目整体的事情)</p>\n<pre><code class=\"javascripton\">const path = require(&#39;path&#39;);\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\nmodule.exports = &#123;\n    entry:&#39;./main.js&#39;,\n    output:&#123;\n        path:path.resolve(dirname,&#39;dist&#39;),\n        filename:bundle.js&#39;,\n    &#125;\n&#125;,\nmodule:&#123;\n    rules:[\n    &#123;\n        test:/八.css$/,\n        use: [\n            loader:&#39;style-loader&#39;&#125;,   //先写的loader后执行。\n            loader:&#39;css-loader&#39;&#125;\n        ]\n    &#125;]\n  &#125;,\nplugins:[\n    new BundlesizeWebpackPlugin( &#123; sizeLimit:3 &#125; )  //自己手写的插件（如下）\n    new webpack.ProgressPlugin(), //显示打包过程（webpack内置插件）\n    new HtmlwebpackPlugin(),\n]\n&#125;\n</code></pre>\n<h6 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h6><p><strong>webpack中plugins原理：</strong></p>\n<p>webpack执行时会将plugins字段中的插件实例取出并将webpack实例传入并执行其<strong>apply方法</strong>，通过webpack实例的hooks中的方法我们可以操控对应的钩子函数。</p>\n<p>官方的教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v\">https://webpack.js.org/contribute/writing-a-plugin/</span><br><strong>插件的格式</strong><br>一个JavaScript函数或JavaScript类 ，在它原型上定义的apply方法，会在安装插件时被调用，并被webpack compiler调用一次。指定一个触及到webpack本身的事件钩子，即hooks,用于特定时机处理额外的逻辑<br>Compiler Hooks列表<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmlzLm9yZy9hcGkvY29tcGlsZXItaG9va3Mv\">https://webpack.is.org/api/compiler-hooks/</span></p>\n<pre><code class=\"javascript\">//手写一个webpack插件，打包文件超出限制时，报错。\nconst &#123; resolve &#125; = require(&#39;path&#39;);\nconst &#123; statSync &#125; = require(&#39;fs&#39;); //fs模块中同步读取文件信息\nclass BundlesizeWebpackPlugin &#123;\n    constructor(options) &#123;\n        this.options = options;\n    &#125;\n    apply(compiler) &#123;\n        //获取到传入的参数\n        const &#123; sizeLimit &#125; = this.options;\n        compiler.hooks.compile.tap(&#39;BundleSizePlugin&#39;,(compilationParams)=&gt;&#123; //编译时钩子,参数是参数\n            console.log(&#39;compile阶段&#39;,compilationParams);\n        &#125;)\n        compiler.hooks.done.tap(&#39;BundleSizePlugin&#39;,(stats)=&gt;&#123; //结束时钩子，参数是打包后的信息。\n            console.log(&#39;done&#39;,stats); \n            //拿到打包后文件的路径和文件名\n            const &#123; path , filename &#125; = stats.compilation.outputOptions;\n            //拼接成文件路径\n            const bundlePath = resolve(path,filename);\n            //获取到文件size\n            const &#123; size &#125; = statSync(bundlePath);\n            const bundleSize = size / 1024;\n            if(bundleSize &lt; sizeLimit) &#123;\n                console.log(&#39;Safe:Bundle-Size&#39;,bundleSize,&#39;\\n Size Limit:&#39;,sizeLimit);\n            &#125;else&#123;\n                console.error(&#39;Unsafe:Bundle-Size&#39;,bundleSize,&#39;\\n Size Limit:&#39;,sizeLimit);\n            &#125;\n        &#125;) \n    &#125;\n&#125;\nmodule.exports = BundlesizeWebpackPlugin;\n</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Loaders关注代码中的单个资源，Plugins关注整体流程，可以接触到webpack构建流程中的<br>各个阶段并劫持做一些代码处理。</strong></p>\n<h1 id=\"node后端框架\"><a href=\"#node后端框架\" class=\"headerlink\" title=\"node后端框架\"></a>node后端框架</h1><h2 id=\"Node-js后端框架调研\"><a href=\"#Node-js后端框架调研\" class=\"headerlink\" title=\"Node.js后端框架调研\"></a>Node.js后端框架调研</h2><p><strong>后端框架应该注意的三大问题</strong><br>路由Routes<br>请求Request<br>响应Response</p>\n<h4 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h4><p>官方网址：[https:l&#x2F;expressis.com(https:expressis.com)<br>**安装**<br>官方网址：[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9leHByZXNzaXMuY29tL3poLWNuL3N0YXJ0ZXIvaW5zdGFsbGluZy5odG1sXQ==\">https://expressis.com/zh-cn/starter/installing.html]</span>(https:l&#x2F;expressjs.com&#x2F;zh-<br>cn&#x2F;starter&#x2F;installing.html)<br>使用生成器安装，可以自动生成一系列的脚手架代码：[https:&#x2F;expressjs.com&#x2F;zh<br>cn&#x2F;starter&#x2F;generator.htmll(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9leHByZXNzaXMuY29tL3poLWNuL3N0YXJ0ZXIvZ2VuZXJhdG9yLmh0bWw=\">https://expressis.com/zh-cn/starter/generator.html</span>)</p>\n<p><strong>优点</strong></p>\n<p>快速简单、易上手</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>路由响应中，很可能有：从外部请求数据的服务，有验证路由的请求参数，返回特定的格式。</li>\n<li>所有逻辑不分青红皂白的写在一起！很容易产生冗长的难以维护的代码。</li>\n<li>一些大型必备的模块，如第三方服务初始化，安全，日志都没有明确的标准。</li>\n</ul>\n<p><strong>Express中间件：</strong></p>\n<p>Express是一个基于中间件的框架，其余任务都会在中间件中执行，中间件是一个队列结构，先写入的任务先执行,中间件的写法是：app.use()，当调用中间件时，会向传入的函数中传入req,res和next函数。</p>\n<p><strong>中间件可以完成的任务</strong></p>\n<ul>\n<li>执行任何代码。</li>\n<li>对请求和响应对象进行更改。</li>\n<li>结束请求&#x2F;响应循环。</li>\n<li>调用堆栈中的下一个中间件。</li>\n</ul>\n<h4 id=\"Koa2\"><a href=\"#Koa2\" class=\"headerlink\" title=\"Koa2\"></a>Koa2</h4><p><strong>官网地址</strong>：[https:I&#x2F;koajs.com(https:&#x2F;koajs.com)</p>\n<p><strong>Koa2和Express的区别</strong></p>\n<ul>\n<li>使用Promise(async,await)代替callback (node&gt;v7.6.0)</li>\n<li>使用ctx(上下文对象)封装req(Request)和res(Response),以及一些常用的功能。</li>\n<li><strong>完全不同的中间件机制</strong></li>\n<li><strong>更轻量级，没有捆绑任何中间件</strong></li>\n<li>官方文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2tvYWpzL2tvYS9ibG9iL21hc3Rlci9kb2NzL2tvYS12cy1leHByZXNzLm1k\">https://github.com/koajs/koa/blob/naster/docs/koa-vs-express.md</span></li>\n</ul>\n<p><strong>Koa2中间件：</strong></p>\n<ol>\n<li>Koa2中间件，由Express的队列模型（同步）转变为洋葱模型，当程序运行到<code>await next()</code>的时候就会暂停当前程序，进入下一个中间件，处理完之后才会仔回过头来继续处理。</li>\n<li>Koa2洋葱模型解决的问题就是一个中间件可以调用其他中间件执行后，再继续自己的操作，Express框架中next()执行后就直接到下一个中间件操作，无法退回。</li>\n</ol>\n<p><img data-src=\"/images/Snipaste_2024-04-22_14-30-49.jpg\" alt=\"Koa2中间件\"></p>\n<p><strong>代码示例：</strong></p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nconst PORT = 3000;\napp.use(async (ctx, next)=&gt;&#123;\n    console.log(1)\n    await next();\n    console.log(1)\n&#125;);\napp.use(async (ctx, next) =&gt; &#123;\n    console.log(2)\n    await next();\n    console.log(2)\n&#125;)\napp.use(async (ctx, next) =&gt; &#123;\n    console.log(3)\n&#125;)\napp.listen(PORT);\nconsole.log(`http://localhost:$&#123;PORT&#125;`);\n</code></pre>\n<p><strong>Koa2特点：</strong></p>\n<ul>\n<li>响应机制的不同</li>\n<li>Express:我们直接操作的是res对象，直接res.send之后就立即响应了。</li>\n<li>Koa2:数据的响应是通过ctx.body进行设置，注意这里仅是设置并没有立即响应，而是在所有的中间件结束之后做了响应。</li>\n</ul>\n<p><strong>缺点：</strong>Koa2在使用上有一定的缺点，因为太过于轻量使得在使用时需要手动处理很多操作，可以使用基于Koa2的上层框架（如：egg.js）</p>\n<h4 id=\"egg-js\"><a href=\"#egg-js\" class=\"headerlink\" title=\"egg.js\"></a>egg.js</h4><p><strong>Express和Koa2的不足</strong></p>\n<ul>\n<li>简单而且扩展性强，适合个人的比较小的项目</li>\n<li>没有约定，对于统一维护和开发非常不利</li>\n</ul>\n<p><strong>对于后端框架的需求</strong></p>\n<ul>\n<li>需要有一套优秀的统一的约定或者架构进行开发</li>\n<li>有丰富的扩展机制和可定制性</li>\n<li>Typescript支持</li>\n</ul>\n<p><strong>egg.js</strong></p>\n<ul>\n<li>地址：[https:l&#x2F;eggis.org&#x2F;zh-cnI(https:l&#x2F;eggjs.org&#x2F;zh-cn) （基于Koa2）</li>\n<li>阿里大厂出品，维护有保障。国内开发者开发，中文文档质量有保证。</li>\n<li><strong>约定优于配置，按照一套统一的约定进行应用开发。</strong></li>\n<li>一个插件只做一件事，高度可扩展的插件机制</li>\n<li>支持Typescript</li>\n</ul>\n<pre><code class=\"bash\">//nodejs版本10以上\nnpm init egg --type=ts\nnpm install\nnpm run dev\n</code></pre>\n<p><strong>egg.js概念：</strong></p>\n<ul>\n<li><p>Application-全局应用对象，只有一个实例。</p>\n</li>\n<li><p>Context-上下文对象，每次请求生成一个实例。</p>\n</li>\n<li><p>Request-请求对象，来自Koa。</p>\n</li>\n<li><p>Response-响应对象，来自Koa的一个新的对象。</p>\n</li>\n<li><p>Helper-用来提供一些实用的utility函数。框架内置了几个简单的Helper函数。</p>\n</li>\n</ul>\n<h4 id=\"Nest-js\"><a href=\"#Nest-js\" class=\"headerlink\" title=\"Nest.js\"></a>Nest.js</h4><ul>\n<li>地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm5lc3Rqcy5jbi8=\">https:&#x2F;docs.nestjs.com</span></li>\n<li>内置并且完全支持Typescript</li>\n<li>开箱即用的应用程序架构</li>\n<li>可扩展，松散耦合</li>\n<li>大量采用了装饰器的写法 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm5lc3Rqcy5jbi8xMC9vcGVuYXBpP2lkPSVFOCVBMyU4NSVFOSVBNSVCMCVFNSU5OSVBOA==\">Nest.js装饰器</span></li>\n</ul>\n<h1 id=\"vue-config-js\"><a href=\"#vue-config-js\" class=\"headerlink\" title=\"vue.config.js\"></a>vue.config.js</h1><p><strong>个性化构建结果-vue.config,js</strong><br>在基础的配置上，自定义构建的结果-可以使用vue.config.js<br>文档地址：https:l&#x2F;cli.vuejs.org&#x2F;zh&#x2F;config#vue-config-js<br>简介两个字段<br><strong>PublicPath</strong>-部署应用包时的基本URL,这个配置对应的是webpack的PublicPath属性，默认值为’&#x2F;‘，Vue CLI会假设你的应用是被部署在一个域名的根路径上<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYmMuY29tLyVFMyU4MCU4MiVFNSU4RiVBRiVFNCVCQiVBNSVFOCVBRSVCRSVFNyVCRCVBRSVFNCVCOCVCQSVFNSVBRCU5MCVFOCVCNyVBRiVFNSVCRSU4NC0lRTUlQTYlODIlRTYlOUUlOUMlRTQlQkQlQTAlRTclOUElODQlRTUlQkElOTQlRTclOTQlQTglRTglQTIlQUIlRTklODMlQTglRTclQkQlQjIlRTUlOUMlQThodHRwczphYmMsY29tL3N1Yi8lRTklODIlQTMlRTQlQjklODglRTUlQjAlQjElRTglQUUlQkUlRTclQkQlQUUlRTQlQjglQkEnL3N1YiclRUYlQkMlOEMlRTUlOEYlQUYlRTQlQkIlQTUlRTglQUUlQkUlRTclQkQlQUUlRTQlQjglQkFDRE4lRTglQjclQUYlRTUlQkUlODQtJUU1JTlDJUE4JUU2JTg4JTkxJUU0JUJCJUFDJUU3JTlBJTg0JUU1JUJBJTk0JUU3JTk0JUE4JUU0JUI4JUFEJUVGJUJDJThDJUU2JTlDJTgwJUU1JTkwJThFJUU5JTlEJTk5JUU2JTgwJTgxJUU4JUI1JTg0JUU2JUJBJTkwJUU2JTk4JUFGJUU4JUE2JTgxJUU1JTg1JUE4JUU5JTgzJUE4JUU0JUI4JThBJUU0JUJDJUEwJUU1JTg4JUIwQ0ROJUU3JTlBJTg0JUVGJUJDJThDJUVGJUJDJTg4JUU4JTg0JTlBJUU2JTg5JThCJUU2JTlFJUI2JUU4JTg3JUFBJUU1JThBJUE4JUU1JUFFJThDJUU2JTg4JTkwKSVFRiVCQyU4QyVFNiU4OSU4MCVFNCVCQiVBNSVFOCVCRiU5OSVFOSU4NyU4QyVFNSU4RiVBRiVFNCVCQiVBNSVFOCVBRSVCRSVFNyVCRCVBRSVFNCVCOCVCQSVFNCVCOCU4MCVFNCVCOCVBQWNETiVFNSU5RiU5RiVFNSU5MCU4RC0naHR0cHM6bC9vc3MuaW1vb2MtSWVnby5jb20vZWRpdG9y\">https://abc.com/。可以设置为子路径-如果你的应用被部署在https:abc,com/sub/那么就设置为&#39;/sub&#39;，可以设置为CDN路径-在我们的应用中，最后静态资源是要全部上传到CDN的，（脚手架自动完成)，所以这里可以设置为一个cDN域名-&#39;https:l/oss.imooc-Iego.com/editor</span>‘<br>还可以设置为绝对路径(‘’或者’.&#x2F;‘)，这样所有的资源都会被链接为相对路径</p>\n<p><strong>css.loaderOptions</strong>属性<br>向CSS相关的loader传递选项<br>Ant-design-vue的样式变量：https:lww,antd,com docs&#x2F;vue&#x2F;customize-theme-cn<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Z1ZUNvbXBvbmVudC9hbnQtZGVzaWduLXZ1ZS9ibG9iL21hc3Rlci9jb21wb25lbnRzL3N0eWxlL3RoZW1lcy9kZWZhdWx0Lmxlc3M=\">https://github.com/vueComponent/ant-design-vue/blob/master/components/style/themes/default.less</span><br>添加更多的CSS预处理器：<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbGkudnVlanMub3JnL3poL2d1aWRlL2Nzcy5odG1sIyVFOSVBMiU4NCVFNSVBNCU4NCVFNyU5MCU4NiVFNSU5OSVBOA==\">https://cli.vuejs.org/zh/guide/css.html#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8</span><br>特别注意less和Iess-loader的版本问题。不要装最新的，建议选用：</p>\n<pre><code class=\"javascript\">//vue.config.js配置：\nconst isstaging = !process.env.VUE_APP_STAGINE\nconst isProduction = process.env.NODE_ENV &#39;production&#39;\nmodule.exports = &#123;\n    /生产环境要使用0SS地址\n    /其他环境都使用绝对路径\n    publicPath:(isProduction 6 !isStaging)&#39;https://oss.imooc-lego.com/\n    css:&#123;\n        loaderOptions:&#123;\n        less:&#123;\n            lessoptions:&#123;\n                modifyVars:&#123;\n                   &#39;primary-color&#39;:&#39;#3E7FFF&#39;,\n                &#125;，\n                javascriptEnabled:true\n            &#125;\n        &#125;,\n    configureWebpack: config =&gt; &#123;\n        config.plugins.push(\n            new webpack.IgnorePlugin(&#123;        //打包时忽略对应的文件\n                resourceRegExp: /^\\.\\/locale$/,\n                contextRegExp: /moment$/,\n            &#125;)\n        )\n        if(isAnalyzeMode)&#123;\n            config.plugins.push(\n                new BundleAnalyzerPlugin(&#123;    //添加打包后的文件分析工具（BundleAnalyzerPlugin）\n                    analyzerMode : &#39;static&#39;,\n                &#125;)\n            )\n        &#125;\n    &#125;\n  &#125;\n</code></pre>\n<h1 id=\"项目构建优化\"><a href=\"#项目构建优化\" class=\"headerlink\" title=\"项目构建优化\"></a>项目构建优化</h1><p><strong>好用的webpack插件:webpack-bundle-analyzer</strong></p>\n<p>可视化webpack打包后的工具包大小，便于分析依赖和进行项目优化。如上vue.config.js中配置。</p>\n<p><strong>根据图表的优化步骤</strong></p>\n<p>一、看看有没有什么重复的模块，或者没有用的模块被打包到了最终的代码中<br>二、看看package.json,对比一下是否有应该在devDeps的模块，被错误的放置到了deps当中<br>三、检查是否有重复加载的模块，或者是功能大体相同的模块。<br>比如：使用<strong>es</strong>版本的第三方库，享受tree-shaking的红利。<br>四、检查是否有没有用的模块是否打包到了最终的文件中，通过如下插件忽略对应的文件，从而tree-shaking掉忽略的文件（如国际化需要的各种语言包）,详细配置如上vue.config.js中。</p>\n<p>webpack ignore plugin： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZ2xwbHVnaW5zL2lnbm9yZS1wbHVnaW4vI3Jvb3Q=\">https://webpack.js.orglplugins/ignore-plugin/#root</span></p>\n<p><strong>将三方库中全部导入更换为按需导入</strong></p>\n<pre><code class=\"javascript\">import &#123;Input,Dropdown,Slider,Select&#125; from &#39;Antd-vue&#39;;\nconst components = [Input,Dropdown,Slider,Select];\nconst install = (app) =&gt; &#123;\n    components.forEach(item=&gt;&#123;\n        app.component(item.name,item);\n    &#125;)\n&#125;\nexport default&#123; install &#125;;\n// 在main.js中导入，然后app.use\n</code></pre>\n<p><strong>浏览器缓存优化</strong></p>\n<p>一、项目即使是上线之后也会在后续追加或修改代码，如果分包较少重新上线后就不能使用浏览器缓存的文件，当分包数量较多时，就可以充分利用浏览器缓存。</p>\n<p>二、分包较多时可以使用浏览器支持平行加载多个文件的特性。（HTTP1对同一域名并行请求的个数进行了限制，HTTP2完全突破了这个限制）</p>\n<p><strong>手动分割第三方库为多个文件</strong></p>\n<p>webpack的config.optimization中自带一些优化的配置项：</p>\n<ul>\n<li>minimize：压缩</li>\n<li>splitChunks：分包（可以配置minSize等）</li>\n<li>等等</li>\n</ul>\n<pre><code class=\"javascript\">//vue.config.js配置：\nmodule.exports = &#123;\n    // ....省略\n    configureWebpack: config =&gt; &#123;\n        config.optimization.splitChunks = &#123;\n            maxInitialRequests: Infinity,\n            minSize: 300 * 1024,\n            chunks: &#39;all&#39;,\n            cacheGroups: &#123;\n                antVendor: &#123;\n                    name: &#39;ant-design-vue&#39;,\n                    test: /[\\\\/]node_modules[\\\\/](ant-design-vue)[\\\\/]/,\n                &#125;,\n                canvasVendor: &#123;\n                    name: &#39;html2canvas,\n                    test: /[\\\\/]node_modules[\\\\/](html2canvas)[\\\\/]/,\n                &#125;,\n                vendor: &#123;\n                    name: &#39;vendor&#39;,\n                    test: /[\\\\/]node_modules[\\\\/](!html2canvas)(!ant-design-vue)[\\\\/]/\n                &#125;,\n                all &#123;\n                    test: /[\\\\/]node_modules[\\\\/]/, //匹配全部的node_modules中的文件\n                    name (module) &#123; const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)\n                    return `npm.$&#123;packageName.replace(&#39;@&#39;,&#39;&#39;)&#125;`\n                &#125;,\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"项目运行优化\"><a href=\"#项目运行优化\" class=\"headerlink\" title=\"项目运行优化\"></a>项目运行优化</h1><p><strong>路由懒加载</strong></p>\n<p>使用import函数动态加载，配合魔法注释可以和webpack中的bundler相配合使用，例如：</p>\n<pre><code class=\"javascript\">import(/* webpackChunkName: &quot;my-lodash&quot; */ &#39;lodash&#39;).then(lodash=&gt;&#123;\n     // ....\n&#125;)\n</code></pre>\n<p><strong>改变HTML标题，增强SEO</strong></p>\n<p>项目中动态添加标题的原理：使用HtmlWebpackPlugin插件，插入动态js语句进行占位，然后通过项目中package.json中的name进行替换。</p>\n<pre><code class=\"javascript\">//vue.config.js配置：\nmodule.exports = &#123;\n    // ....省略\n   chainWebpack: config =&gt; &#123;\n       config.plugin(&#39;html&#39;).tap(args=&gt;&#123;\n           args[0].title = &#39;网站标题&#39;,\n           args[0].desc = &#39;网站详情描述&#39;\n           return args;\n       &#125;)\n   &#125;\n&#125;\n//记得添加 &lt;meta name=&quot;viewport&quot; content=&quot;&lt;%= htmlWebpackPlugin.options.desc %&gt;&quot;&gt;\n</code></pre>\n<p><strong>同构渲染方式</strong><br>服务端渲染和客户端渲染的区别就在于在哪里完成html完整文件的拼接：</p>\n<h3 id=\"客户端渲染\"><a href=\"#客户端渲染\" class=\"headerlink\" title=\"客户端渲染\"></a>客户端渲染</h3><p>客户端渲染由客户端完成html文件的拼接，服务端只负责提供数据。</p>\n<ul>\n<li>优势：首屏加载快</li>\n<li>劣势：不利于SEO</li>\n</ul>\n<h3 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h3><p>服务端渲染由服务端完成html文件的凭借，客户端直接渲染即可</p>\n<ul>\n<li>优势：利于SEO，</li>\n<li>劣势：白屏问题（获取html文件较慢），服务端压力大，占用CPU资源。</li>\n</ul>\n<h3 id=\"同构渲染\"><a href=\"#同构渲染\" class=\"headerlink\" title=\"同构渲染\"></a>同构渲染</h3><p>服务端先通过服务端渲染，生成html以及初始化数据，客户端拿到代码和初始化数据，在客户端进行激活渲染。</p>\n<ul>\n<li>优势：兼容了前端渲染的大部分优点（节省服务端资源、多终端适配渲染、局部刷新等），同时也具有服务端渲染首屏加载快，SEO支持好的特点。</li>\n<li>劣势：服务端必须是要js支持的语言，增加了整个系统的复杂度和维护成本。</li>\n</ul>\n<h3 id=\"SSG预渲染\"><a href=\"#SSG预渲染\" class=\"headerlink\" title=\"SSG预渲染\"></a>SSG预渲染</h3><p><strong>静态站点生成</strong> (Static-Site Generation，缩写为 SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。</p>\n<ul>\n<li><p>如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那就可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。</p>\n</li>\n<li><p>SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是<strong>静态</strong>：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。</p>\n</li>\n<li><p>如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 &#x2F;、&#x2F;about 和 &#x2F;contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vdml0ZXByZXNzLmRldi8=\">VitePress</span> 就是一个由 Vite 和 Vue 驱动的静态站点生成器。</p>\n</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL2Jsb2IvbWFpbi9wbGF5Z3JvdW5kL3Nzci12dWUvcHJlcmVuZGVyLmpz\">Vite脚手架渲染SSG代码示例</span>。</p>\n<h1 id=\"部署与HTTP优化\"><a href=\"#部署与HTTP优化\" class=\"headerlink\" title=\"部署与HTTP优化\"></a>部署与HTTP优化</h1><h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a><strong>部署</strong></h3><p><strong>前端部署：https:llci,uejs,org&#x2F;zh&#x2F;guide&#x2F;deployment.html</strong></p>\n<p>原理就是：将构建生成的产物直接烤贝到任何的静态文件服务器当中。</p>\n<p><strong>后端部署：https:&#x2F;eggis.org&#x2F;zh-cn&#x2F;core&#x2F;deployment.html</strong></p>\n<p>几乎没有构建过程：除非你用了typescript等需要编译的语言。</p>\n<ul>\n<li><p>方案一：直接将本地的源代码打个压缩包拷贝到目标服务器，然后启动服务器。</p>\n</li>\n<li><p>方案二：在服务器中直接pu川源代码，install,.然后启动服务器。</p>\n</li>\n</ul>\n<h3 id=\"Nginx-反向代理\"><a href=\"#Nginx-反向代理\" class=\"headerlink\" title=\"Nginx:反向代理\"></a><strong>Nginx:反向代理</strong></h3><p><strong>Nginx</strong>作为服务器软件，它的优点：</p>\n<ul>\n<li>特别适合前后端分离的项目</li>\n<li>保证安全</li>\n<li>非常快</li>\n<li>支持负载均衡</li>\n</ul>\n<p>使用：</p>\n<ul>\n<li>安装nginx</li>\n<li>nginx    命令启动服务器</li>\n<li>nginx -s stop    命令关闭服务器</li>\n<li>nginx -v      命令查看配置信息</li>\n<li>nginx -s reload      命令重启服务</li>\n<li>配置nginx.conf文件</li>\n</ul>\n<h3 id=\"HTTP缓存\"><a href=\"#HTTP缓存\" class=\"headerlink\" title=\"HTTP缓存\"></a><strong>HTTP缓存</strong></h3><p>（若服务器使用nginx，则在nginx.conf中配置）</p>\n<p>Expires <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0V4cGlyZXM=\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires</span><br><strong>Expires响应头包含日期&#x2F;时间，即在此时候之后，响应过期</strong><br>使用nginx添加对应的响应头：expires指令<br>文档地址：http:l&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;http&#x2F;ngx http headers module.html</p>\n<p>但是由于客户端时间和用户端时间并不总是相同的，于是有了Cache-Control：</p>\n<p><strong>Cache-Control</strong>:通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。<br>文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIv\">https://developer</span> mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Headers&#x2F;Cache-Control</p>\n<p>*<strong>Etag</strong>:ETagHTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽<br>因为如果内容没有改变，Wb服务器不需要发送完整的响应，直接返回304表示可以使用缓存文件。<br>*文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0VUYWc=\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</span><br><strong>Last-Modified</strong>:是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。<br>文档地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0xhc3QtTW9kaWZpZWQ=\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified</span><br>nginx Etag:<span class=\"exturl\" data-url=\"aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfY29yZV9tb2R1bGUuaHRtbCNldGFn\">http://nginx.org/en/docs/http/ngx_http_core_module.html#etag</span><br>304 Not Modified <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSElUUC9TdGF0dXMvMzA0\">https://developer.mozilla.org/zh-CN/docs/Web/HITP/Status/304</span></p>\n<p>浏览器使用缓存：</p>\n<p><img data-src=\"/images/image.png\" alt=\"/images/image.png\"></p>\n<h3 id=\"压缩算法\"><a href=\"#压缩算法\" class=\"headerlink\" title=\"压缩算法\"></a>压缩算法</h3><p>压缩比对照表<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWl4ZGIuZ2l0aHViLmlvL3NxdWFzaC1iZW5jaG1hcmsvI3JhdGlvLXZzLWNvbXByZXNzaW9u\">https://quixdb.github.io/squash-benchmark/#ratio-vs-compression</span></p>\n<h4 id=\"gzip\"><a href=\"#gzip\" class=\"headerlink\" title=\"gzip\"></a>gzip</h4><p><strong>一、动态压缩（服务器在返回静态文件之前，由服务器对每个请求压缩后再进行输出）</strong></p>\n<p>nginx中启用gzip：在nginx.conf中配置：</p>\n<ul>\n<li>gzip  on;        开启gzip</li>\n<li>gzip_types     text&#x2F;plain  application&#x2F;javascript              设置那些文件需要压缩</li>\n<li>gzip_min_length   1k;         小于设置值不会压缩</li>\n<li>gzip_comp_level     1;          压缩级别</li>\n<li>等等</li>\n</ul>\n<p><strong>二、静态压缩（服务器直接使用压缩文件进行输出）</strong></p>\n<p>两个步骤</p>\n<ul>\n<li>生成压缩文件（gzip命令或使用webpack插件 compression-webpack-plugin）</li>\n<li>在ngin×开启支持静态压缩的模块（例如gzip_static  :  on）</li>\n</ul>\n<h4 id=\"Brotli\"><a href=\"#Brotli\" class=\"headerlink\" title=\"Brotli\"></a>Brotli</h4><p><strong>一、动态压缩（服务器在返回静态文件之前，由服务器对每个请求压缩后再进行输出）</strong></p>\n<p><strong>使用前提</strong><br>浏览器支持：https:caniuse.com&#x2F;brotli<br><strong>HTTPS协议</strong><br>NGINX对应的模块：https:&#x2F;github.com&#x2F;google&#x2F;nginx&#x2F;brotli</p>\n<p>nginx中启用Brotli：在nginx.conf中配置：</p>\n<ul>\n<li>brotli  on;        开启Brotli</li>\n<li>brotli_types     text&#x2F;plain  application&#x2F;javascript              设置那些文件需要压缩</li>\n<li>等等</li>\n</ul>\n<p><strong>二、静态压缩（服务器直接使用压缩文件进行输出 ,如上。）</strong></p>\n<h3 id=\"HTTP优化\"><a href=\"#HTTP优化\" class=\"headerlink\" title=\"HTTP优化\"></a>HTTP优化</h3><p>HTTP是建立在TCP协议之上，所以<strong>HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性</strong>，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的延迟时间。所以减少这些重新握手和至关重要。</p>\n<h4 id=\"keepAlive属性\"><a href=\"#keepAlive属性\" class=\"headerlink\" title=\"keepAlive属性\"></a>keepAlive属性</h4><p>keepAlive属性可以保持服务器端和客户端建立的会话连接，开启之后除首次建立连接外的其他请求不会进行<strong>DNS Lookup</strong>（NDS域名解析）和<strong>Initial connection</strong>（三报文握手建立连接），可以在服务端文件中进行配置。</p>\n<p><strong>KeepAlive的优点</strong></p>\n<ul>\n<li>TCP连接更少，这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。</li>\n<li>网络拥塞也减少了，拿到响应的延时也减少了</li>\n</ul>\n<h4 id=\"HTTP2\"><a href=\"#HTTP2\" class=\"headerlink\" title=\"HTTP2\"></a>HTTP2</h4><p><strong>使用HTTP&#x2F;2提升性能</strong></p>\n<ul>\n<li>2010年SPDY <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TUERZJUU2JUJDJTk0JUU1JThDJTk2JUU1JTg4JUIw\">https://baike.baidu.com/item/SPDY演化到</span></li>\n<li>2015 HTTP&#x2F;2 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9IVFRQXzI=\">https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_2</span></li>\n</ul>\n<p><strong>兼容性</strong></p>\n<p>需要浏览器支持-https:&#x2F;caniuse.com&#x2F;http2</p>\n<p>需要HTTPS协议支持</p>\n<p><strong>主要特性</strong></p>\n<ul>\n<li>二进制协议：</li>\n</ul>\n<p>HTTP2由原来的文本请求（报文）转变为二进制请求帧，加快传输</p>\n<ul>\n<li>多路复用：</li>\n</ul>\n<p><strong>HTTP2多路复用解决了浏览器同一域名并行请求数量的限制。</strong></p>\n<p>在HTTP&#x2F;2中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟开一个TCP连接都需要慢慢提升传输速度。</p>\n<p><strong>同个域名只需要占用一个TCP连接</strong>，使用一个连接并行发送多个请求和响应，<strong>消除了因多个TCP连接而带来的延时和内存消耗</strong>。</p>\n<ul>\n<li>Header压缩复用</li>\n</ul>\n<p>TTP&#x2F;2在客户端和服务器端使用“<strong>首部表</strong>”来跟踪和存储之前发送的键一值对，对于相同的数据，不再通过每次请求和响应发送。</p>\n<p><strong>配置HTTP2：</strong></p>\n<p>依nginx为例：在server字段的listen字段添加：listen   443   ssl   http2; </p>\n<h1 id=\"Mongodb数据库\"><a href=\"#Mongodb数据库\" class=\"headerlink\" title=\"Mongodb数据库\"></a>Mongodb数据库</h1><h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a><strong>基本操作</strong></h3><pre><code class=\"javascript\">// 导入Mongodb客户端构造函数\nimport &#123; MongoClient,ObjectId, &#125; from &quot;mongodb&quot;;\n// 创建mongo实例(传入url)\nconst client = new MongoClient(&#39;mongodb://localhost:27017/&#39;);\n// 执行函数，连接mongodb数据库\nasync function run() &#123;\n  try &#123;\n    await client.connect(); //等待实例连接\n    const db = client.db(&#39;hello&#39;); //创建数据库\n    const res = await db.command(&#123; ping: 1 &#125;); //ping命令\n    console.log(&#39;connected&#39;, res);\n    const userCollection = db.collection(&#39;user&#39;);//创建集合表\n// 数据的插入\n    // const result = await userCollection.insertOne(&#123;name:&quot;张三&quot;,age:18&#125;)\n    // const results = await userCollection.insertMany([&#123;name:&quot;李四&quot;,age:12&#125;,&#123;name:&quot;王五&quot;,age:13&#125;]);\n    // console.log(result,results); //返回影响的信息，id等\n//数据的查找\n    const result = await userCollection.findOne(&#123;name:&#39;张三&#39;&#125;);\n    console.log(result);\n    const resultCursor =  userCollection.find(); //find返回的是指针对象，不是结果\n    //将游标变为数组结果\n    const results = await userCollection.find().toArray();\n    // console.log(results);\n//比较操作符 $lt小于 $gt大于\n    const results2 = await userCollection.find(&#123;age:&#123;$lt:16&#125;&#125;).toArray();\n    // console.log(results2);\n//逻辑操作符 $or\n    const results3 = await userCollection.find(&#123;$or:[&#123;age:&#123;$gt:12&#125;&#125;,&#123;name:&quot;王五&quot;&#125;]&#125;).toArray();\n    // console.log(results3);\n//元素操作符  $exists存在与否  $type指定类型\n    const results4 = await userCollection.find(&#123;age:&#123;$type:&#39;number&#39;&#125;&#125;).toArray();\n    // console.log(results4);\n//limit  第二个参数传入options配置（projection表示包含字段哪些字段）\n    const result5 = await userCollection.find(&#123;age:&#123;$type:&#39;number&#39;&#125;&#125;,&#123;limit:2,skip:3,sort:&#123;age:-1&#125;,projection:&#123;name:0&#125;&#125;).toArray();\n    // console.log(result5);\n//更新替换数据   update更新数据  replaceOne替换数据 ,修改操作要传具体更新操作符：\n//普通更新操作符： $set设置值 $inc增加 $rename重命名 $unset删除 \n//数组更新操作符： $push数组字段添加 $pop删除 $all包含 $regex正则  .属性符 .$属性占位符\n    const result6 = await userCollection.replaceOne(&#123;name:&quot;张三&quot;&#125;,&#123;name:&quot;Lebrown&quot;&#125;);\n    const result7 = await userCollection.updateOne(&#123;_id:new ObjectId(&#39;6628b9876bac632e95ead1bb&#39;)&#125;,&#123;$set:&#123;name:&quot;updateOne&quot;&#125;,$inc:&#123;age:10&#125;&#125;);\n    const result8 = await userCollection.updateOne(&#123;_id: new ObjectId(&#39;6628b9876bac632e95ead1bb&#39;)&#125;,&#123;$set:&#123;&quot;hobbies.0&quot;:&quot;golf&quot;&#125;&#125;)\n    const result9 = await userCollection.updateOne(&#123;_id: new ObjectId(&#39;6628b9876bac632e95ead1bb&#39;),hobbies:&#39;glof&#39;&#125;,&#123;$set:&#123;&quot;hobbies.$&quot;:&quot;golf-new&quot;&#125;&#125;)\n    // console.log(result8);//返回影响信息\n//删除数据：deleteOne(filter) 和deleteMany\n  &#125; catch (e) &#123;\n    console.error(e);\n  &#125; finally &#123;\n    await client.close();\n  &#125;\n&#125;\nrun();\n</code></pre>\n<h3 id=\"mongodb高级\"><a href=\"#mongodb高级\" class=\"headerlink\" title=\"mongodb高级\"></a><strong>mongodb高级</strong></h3><h5 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h5><p><strong>MongoDB索引</strong></p>\n<ul>\n<li>索引(Index)<strong>为了提高查询效率</strong></li>\n<li>MongoDB的文件类型：<strong>BSON</strong>,Binary JSON,主要被用作MongoDB数据库中的数据存储和网络传输格式。</li>\n<li>假如没有索引，必须扫描这个巨大BSON对象集合中的每个文档并选取那些符合查询条件的记录，这样是低效的。</li>\n<li>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中。</li>\n<li>为某个字段创建索引之后查找速度非常快，ObjectId是自带的索引（ _ id _ ）。</li>\n</ul>\n<p><strong>创建索引</strong></p>\n<p>创建索引可以直接用Navicate等工具，也可以代码中使用：</p>\n<pre><code class=\"javascript\">//......省略\n//给name字段创建索引之前耗时很大，创建之后耗时很小\nconst indexResult = await userCollection.find(&#123;name:&quot;James&quot;&#125;).explain();\nconsole.log(indexResult);\n//创建索引，属性表示字段，值表示升序降序\nconst result = await userCollection.createIndex(&#123;name:1&#125;) //1表示升序\n//取消索引\nconst result1 = await userCollection.dropIndex(&quot;name_1&quot;)\n</code></pre>\n<h5 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h5><p>聚合操作将来自多个文档的值组合在一起，并且可以对分组数据执行各种操作以返回相应的结果。<br><strong>linux常用的管道写法：</strong></p>\n<pre><code class=\"bash\">ps aux | grep mongo\n</code></pre>\n<p><strong>聚合常用的操作符：</strong></p>\n<ul>\n<li>$group将collection中的document:分组，可用于统计结果</li>\n<li>$natch过滤数据，只输出符合结果的文档</li>\n<li>$project修改输入文档的结构（例如重命名，增加、删除字段，创建结算结果等）</li>\n<li>$sot将结果进行排序后输出</li>\n<li>$imit限制管道输出的结果个数</li>\n<li>$skp跳过制定数量的结果，并且返回剩下的结果</li>\n</ul>\n<p><strong>表达式操作符：</strong></p>\n<ul>\n<li>$sum计算总和，{$sum:1}表示返回总和×1的值（即总和的数量），使用{$sum:’$制定字段’}也能直接获取制定字段的值的总和</li>\n<li>$avg求平均值</li>\n<li>$min求min值</li>\n<li>$max求max值</li>\n<li>$push将结果文档中插入值到一个数组中</li>\n<li>$frst根据文档的排序获取第一个文档数据</li>\n<li>$last同理，获取最后一个数据</li>\n</ul>\n<pre><code class=\"javascript\">//.....\nconst pipeLine = [\n    &#123; $match : &#123; age : &#123; $gt : 30 &#125;&#125;&#125;,\n    &#123; $group : &#123; _id : &quot;$steam&quot; , total : &#123; $sum : &quot;$age&quot; &#125; , count : &#123; $sum : 1 &#125;&#125;&#125;,\n    &#123; $sort : &#123; total : 1 &#125;&#125;\n]\ncosnt result = await userCollection.aggregate(pipeLine).toArray();\n//....\n</code></pre>\n<h5 id=\"多表联查\"><a href=\"#多表联查\" class=\"headerlink\" title=\"多表联查\"></a>多表联查</h5><p><strong>普通方式使用多表联查需要两次查询</strong></p>\n<pre><code class=\"javascript\">// 导入Mongodb客户端构造函数\nimport &#123; MongoClient,ObjectId, &#125; from &quot;mongodb&quot;;\n// 创建mongo实例(传入url)\nconst client = new MongoClient(&#39;mongodb://localhost:27017/&#39;);\n// 执行函数，连接mongodb数据库\nasync function run() &#123;\n  try &#123;\n    await client.connect(); //等待实例连接\n    const db = client.db(&#39;hello&#39;); //创建数据库\n    const res = await db.command(&#123; ping: 1 &#125;); //ping命令\n    console.log(&#39;connected&#39;, res);\n//获取表\n     const teamCollection = db.collection(&#39;team&#39;);\n     const playerCollection = db.collection(&#39;player&#39;);\n     const netsTeam = await teamCollection.findOne(&#123;team:&quot;NETS&quot;&#125;);\n     const netsPlayers = await playerCollection.find(&#123;team:netsTeam._id&#125;).toArray();\n  &#125; catch (e) &#123;\n    console.error(e);\n  &#125; finally &#123;\n    await client.close();\n  &#125;\n&#125;\nrun();\n</code></pre>\n<p><strong>使用聚合中$lookup进行多表联查只需要一次查询：</strong></p>\n<pre><code class=\"javascript\">//...\nconst pipeLine2 = [\n    &#123;\n        $match : &#123; team : &#123; $exists : true &#125; &#125;\n    &#125;,\n    &#123;\n        $lookup : &#123;\n            from : &quot;team&quot;,\n            localField : &quot;team&quot;,\n            foreignField : &quot;_id&quot;,\n            as : &quot;team&quot;\n        &#125;\n    &#125;\n] \nconst playerWithTeam = await playerCollection.aggregate(pipeLine2).toArray();\nconsole.log(playerWithTeam);\n//...\n</code></pre>\n<h3 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h3><p>[MongoDB最佳设计实践](<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZGV2ZWxvcGVyL2FydGljbGUvbW9uZ29kYi0=\">https://www.mongodb.com/developer/article/mongodb-</span><br>schema-design-best-practices&#x2F;)</p>\n<p>  关键问题：数据产生关系的时候，选择内嵌还是引用？</p>\n<p><strong>内嵌模式：</strong></p>\n<p>优势：</p>\n<ul>\n<li>只需要一次查询就可以查询所有的信息。</li>\n<li>避免多集合查询。</li>\n<li>只需要一个操作就可以更新多个信息。</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>单个文档太大，查询可能更耗时，获得的无关信息概率增大。</li>\n<li>针对每个文档，MongoDB有一个16M的最大限制，内嵌太多，可能超过这个限制。</li>\n</ul>\n<p><strong>引用模式：</strong></p>\n<p>优势：</p>\n<ul>\n<li>将数据分散到不同文档，数据量会变小。</li>\n<li>不太会超过16M最大限制。</li>\n<li>每次查询取得不必要数据的慨率降低。</li>\n</ul>\n<p>劣势：需要多次查询才能获得最终数据</p>\n<p><strong>最佳设计实践：</strong></p>\n<ul>\n<li><p>一对几个：推荐使用内嵌形式</p>\n</li>\n<li><p>一对很多：推荐使用引用形式</p>\n<ul>\n<li>子集合中使用一个字段保存父集合的_id   ； 或者：</li>\n<li>父集合中使用一个数组保存子集合的_id</li>\n</ul>\n</li>\n<li><p>一对亿万：只能子集合中使用一个字段保存父集合的_id</p>\n</li>\n</ul>\n<h3 id=\"访问权限管理\"><a href=\"#访问权限管理\" class=\"headerlink\" title=\"访问权限管理\"></a><strong>访问权限管理</strong></h3><p><strong>授权文档</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9jb3JlL2F1dGhlbnRpY2F0aW9uLw==\">https://docs.mongodb.com/manual/core/authentication/</span><br><strong>内置的Roles</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2UvYnVpbHQtaW4tcm9sZXMv\">https://docs.mongodb.com/manual/reference/built-in-roles/</span></p>\n<p><strong>在mongo命令行中输入：</strong></p>\n<pre><code class=\"cmd\">show dbs\nuse admin\n# mongodb基于RBAC进行权限管理，设置roles可以设置相应的全选，见上。\ndb.createUser(&#123; user : &#39;root&#39; , pwd : &#39;123456&#39; , roles : [&#39;root&#39;] &#125;) \ndb.auth(&#39;root&#39;,&#39;123456&#39;)\n# --auth 开启数据库的权限验证，也可以直接在mongo.conf中配置（先终止运行mongod）\nmongod --config /usr/local/etc/mongo.conf --auth\n# 操作配置了权限管理的数据库\nmongo -u &quot;root&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot;\n</code></pre>\n<p><strong>初始化一个新数据库以后期望的步骤</strong></p>\n<ul>\n<li>创建admin级谜别的root用户&#x2F;roles:root</li>\n<li>创建对应的数据库lego</li>\n<li>创建该数据库的管理员dmq&#x2F;roles:readWrite</li>\n<li>代码中，使用管理员dmq的用户名密码链接数据库并且完成操作。</li>\n</ul>\n<p>步骤如下：</p>\n<pre><code class=\"cmd\">show dbs\nuse lego\ndb.createUser(&#123; user : &quot;dmq&quot; , pwd : &#39;123456&#39; , roles : [&#123; role : &quot;readWrite&quot; , db : &quot;lego&quot; &#125;]&#125;)\n# 重启服务：mongod --config /usr/local/etc/mongo.conf --auth\n# 这样在mongodb的配置文件中设置用户信息，就保证只能读取数据库信息，保证了数据库的安全。（如果用户信息来自admin数据库就需要配置authSource:&#39;admin&#39;。）\n</code></pre>\n<h1 id=\"Mongoose\"><a href=\"#Mongoose\" class=\"headerlink\" title=\"Mongoose\"></a>Mongoose</h1><p><strong>出现的原因：</strong></p>\n<p>使用原生的mongoDB nodejs driver数据结构及其操作过于灵活。</p>\n<p><strong>mongoose：MongoDB的ODM文档对象映射</strong>（mongoose之于mongodb类似于ts之于js，都是在原有的基础之上加一层抽象层，进行类型定义等操作）</p>\n<p>mongoose：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb25nb29zZWlzLmNvbS8=\">https://mongooseis.com/</span></p>\n<ul>\n<li>建立在native mongoDB nodejs driver之上</li>\n<li>提出Modl,数据模型的概念，用来约束集合中的数据结构</li>\n<li>非常多扩展的内容</li>\n<li>它是一个ODM(Object Document Mapping)工具。</li>\n</ul>\n<h3 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h3><p>ORM指的是<strong>Object Relational Mapping对象关系映射</strong>，针对于<strong>关系型数据库</strong>。</p>\n<p><strong>简单说，ORM就是通过实例对象的语法，完成关系型数据库的操作的技术。</strong></p>\n<p><strong>ORM优点</strong></p>\n<ul>\n<li>不需要再去写晦涩的SQL语句。</li>\n<li>使用面向对象的方式操作数据，代码量少，语义性好，容易理解。</li>\n<li>Classes类-Tables</li>\n<li>Objects实例-Records(表中的一行数据)</li>\n<li>Attributes属性-Records</li>\n<li>内置很多功能，数据验证，清洗，预处理等等操作。</li>\n</ul>\n<h3 id=\"ODM\"><a href=\"#ODM\" class=\"headerlink\" title=\"ODM\"></a>ODM</h3><p>ODM指的是<strong>Object Document Mapping对象文档映射</strong>。ODM针对于<strong>noSql数据库</strong>，关注文档模型，mongoose是ODM的一种实现，可以用于约束数据类型。</p>\n<pre><code class=\"javascript\">const User = mongoose.model(&quot;User&quot;,&#123;\n    username:&#123; type : string &#125;,\n    password:&#123; type : String &#125;\n&#125;)\n//user object\nconst newUser new User(&#123;\n    username:&quot;john-doe&quot;,\n    password:&quot;helloworld&quot;,\n&#125;)\nawait newUser.save()\n</code></pre>\n<h1 id=\"egg-mongoose\"><a href=\"#egg-mongoose\" class=\"headerlink\" title=\"egg-mongoose\"></a>egg-mongoose</h1><p>官网文档很好，请自行查看。</p>\n<h1 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h1><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Stream的官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbA==\">https://nodejs.org/api/stream.html</span><br><strong>流是Node.js中最好，也是最容易误解的慨念</strong><br>流就是数据的合集，数据可以是字符串也可以是数组，流的数据不是一次性全部获得的。</p>\n<p>大文件输出方式：</p>\n<ul>\n<li><p>直接读取</p>\n<p>输入的文件————读取到内存—————-输出文件内容</p>\n</li>\n<li><p>流式读取</p>\n<p>输入的文件————通过可读流读取到管道—————–通过可写流输出文件内容</p>\n</li>\n</ul>\n<p><strong>Node.js支持流的内置模块：</strong></p>\n<p><strong>Readable Streams:</strong></p>\n<ul>\n<li>HTTP responses,on the client</li>\n<li>HTTP requests,on the server</li>\n<li>fs read streams</li>\n<li>zlib streams</li>\n<li>crypto streams</li>\n<li>TCP sockets</li>\n<li>child process stdout and stderr</li>\n<li>process.stdin</li>\n</ul>\n<p><strong>Writable  Streams:</strong></p>\n<ul>\n<li>HTTP requests,on the client</li>\n<li>HTTP responses,on the server</li>\n<li>fs write streams</li>\n<li>zlib streams</li>\n<li>crypto streams</li>\n<li>TCP sockets</li>\n<li>child process stdin</li>\n<li>process.stdout,process.stderr</li>\n</ul>\n<p><strong>流的类型：</strong></p>\n<ul>\n<li>Readable-可读操作。</li>\n<li>Vritable-可写操作。</li>\n<li>Duplex-可读可写操作. </li>\n<li>Transform-操作被写入数据，然后读出结果。</li>\n</ul>\n<h3 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe\"></a>pipe</h3><p><strong>流的流动：</strong></p>\n<p>可读流Readable（数据源input）———————-pipe管道—————————————-可写流Writable（输出output）</p>\n<pre><code class=\"javascript\">import &#123; createReadStream, createWriteStream &#125; from &#39;fs&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nreadStream.pipe(process.stdout);\n</code></pre>\n<p>可读流Readable（数据源input）————-pipe管道—————转换流Transform—————-pipe管道———–可写流Writable（输出output）</p>\n<pre><code class=\"javascript\">import &#123; createReadStream, createWriteStream, write &#125; from &#39;fs&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nconst writeStream = createWriteStream(&#39;./b.txt&#39;);\nreadStream.pipe(writeStream);\n</code></pre>\n<h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong>流是基于EventEmitter（事件），pipe方法是基于事件封装的的语法糖，常见的事件有：</strong></p>\n<p><strong>Readable  Streams：可读流事件和函数</strong></p>\n<ul>\n<li>Events<ul>\n<li>data–当没有数据时触发</li>\n<li>end–没有更多的数据可读时触发</li>\n<li>error–在接受和写入过程中发生错误时触发</li>\n<li>finish–所有数据已被写入到底层系统时触发</li>\n<li>close</li>\n<li>readable</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>pipe() , unpipe()</li>\n<li>read() , unshift() , resume()</li>\n<li>pause() , isPaused()</li>\n<li>setEncoding()</li>\n</ul>\n</li>\n</ul>\n<p><strong>Writable  Streams：写入流事件和函数</strong></p>\n<ul>\n<li>Events<ul>\n<li>drain</li>\n<li>finish</li>\n<li>error</li>\n<li>close</li>\n<li>pipe&#x2F;unpipe</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>write()</li>\n<li>end()</li>\n<li>cork() , uncork()</li>\n<li>setDefaultEncoding()</li>\n</ul>\n</li>\n</ul>\n<p><strong>pipe方法原理：</strong></p>\n<pre><code class=\"javascript\">import &#123; createReadStream , createWriteStream &#125; from &#39;fs&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nconst writeStream = createWriteStream(&#39;./b.txt&#39;);\nreadStream.on(&#39;data&#39; , chunk=&gt;&#123;\n    writeStream.write(chunk);\n&#125;)\nreadStream.on(&#39;end&#39;,()=&gt;&#123;\n    writeStream.end();\n&#125;)\n</code></pre>\n<p>压缩：</p>\n<pre><code class=\"javascript\">import &#123; createReadStream , createWriteStream &#125; from &#39;fs&#39;;\nimport &#123; createGzip &#125; from &#39;zlib&#39;;\nconst readStream = createReadStream(&#39;./a.txt&#39;);\nconst writeStream = createWriteStream(&#39;./b.txt&#39;);\nreadStream.pipe(createGzip()).pipe(writeStream);\n</code></pre>\n<p>封装：</p>\n<pre><code class=\"javascript\">cosnt savePromise = (readStream , writeStream = stdout)&#123;\n    return new Promise(resolve,reject)&#123;\n        readStream\n            .pipe(writeStream)\n            .on(&#39;finish&#39;,resolve)\n            .on(&#39;error&#39;,reject)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"pipeline\"><a href=\"#pipeline\" class=\"headerlink\" title=\"pipeline\"></a>pipeline</h3><p><strong>使用pipe方法有时会存在一个问题：</strong></p>\n<pre><code class=\"javascript\">//....\ncreateReadStream(&#39;./a.txt&#39;)\n    .pipe(stdout)\n    .on(&#39;finish&#39;,finishFn)\n    .on(&#39;error&#39;,errFn);  //这里监听的是pipe后的错误，对于createReadStream的错误则会卡死\n</code></pre>\n<p><strong>于是推出了pipeline方法：</strong></p>\n<pre><code class=\"javascript\">//...\npipeLine(fs.createReadStream(&#39;./a.txt&#39;),zlib.createGzip(),fs.createWriteStream(&#39;./b.txt&#39;),(err)=&gt;&#123;\n    if (err) &#123; console.error(&#39;pipeline failed&#39;,error) &#125;;\n    else &#123; console.log(&#39;successed&#39;) &#125;\n&#125;)\n</code></pre>\n<h1 id=\"对象存储服务\"><a href=\"#对象存储服务\" class=\"headerlink\" title=\"对象存储服务\"></a>对象存储服务</h1><p><strong>自己完成静态文件存储的问题</strong></p>\n<ul>\n<li>Nod.js不擅长处理静态文件的存储和展示，没有未静态文件做特殊的优化</li>\n<li>如果将图片生成多种处理格式要耗费大量的资源和空间</li>\n</ul>\n<p><strong>各三方比对</strong></p>\n<h3 id=\"阿里云OSS\"><a href=\"#阿里云OSS\" class=\"headerlink\" title=\"阿里云OSS\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0Li9vc3M=\">阿里云OSS</span></h3><p><strong>特点</strong></p>\n<ul>\n<li>支持丰富的图片处理<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnQuX2RldGFpbC80NDY4Ni5odG1s\">https://help.aliyun.com/document._detail/44686.html</span></li>\n<li>egg.js有对应的插件：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1vc3M=\">https://github.com/eggjs/egg-oss</span></li>\n</ul>\n<p><strong>价格</strong></p>\n<ul>\n<li>下行流量100GB一年352元<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tb24tYnV5LmFsaXl1bi5jb20vP3NwbT01MTc2Ljc5MzM2OTEuSl81MjUzNzg1MTYwLjEuMmUzOTRjNTlxM0ZJc0EmY29tbW9kaXR5Q29kZT1vc3NiYWcjL2J1eQ==\">https://common-buy.aliyun.com/?spm=5176.7933691.J_5253785160.1.2e394c59q3FIsA&amp;commodityCode=ossbag#/buy</span></li>\n<li>基本图片处理：每月0-10TB:免费&gt;10TB:0.025元&#x2F;GB</li>\n</ul>\n<h3 id=\"七牛云KODO\"><a href=\"#七牛云KODO\" class=\"headerlink\" title=\"七牛云KODO\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucWluaXUuY29tL3ByaWNlcy9rb2Rv\">七牛云KODO</span></h3><p><strong>特点：</strong></p>\n<ul>\n<li>多媒体处理功能非常丰富<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2luaXUuY29tL3Byb2R1Y3RzL2RvcmE=\">https://www.giniu.com/products/dora</span></li>\n<li>图片视频处理</li>\n<li>审核</li>\n<li>人工智能分析</li>\n</ul>\n<p><strong>价格：</strong></p>\n<ul>\n<li>外网流出100GB-年278.4元<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xbWFsbC5xaW5pdS5jb20vdGVtcGxhdGUuL01URXk/c3BlY19jb21ibz1NekUwTlE=\">https://qmall.qiniu.com/template./MTEy?spec_combo=MzE0NQ</span></li>\n<li>基本图片处理：每月0-20TB:免费20TB以上：0.025元&#x2F;GB https:&#x2F;<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5xaW5pdS5jb20vcHJpY2VzL2RvcmE=\">www.qiniu.com/prices/dora</span></li>\n</ul>\n<h3 id=\"腾讯云COS\"><a href=\"#腾讯云COS\" class=\"headerlink\" title=\"腾讯云COS\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzQzNg==\">腾讯云COS</span></h3><p><strong>特点：</strong></p>\n<p>图像处理有一些新的亮点，比如自研的TPG压缩等</p>\n<p><strong>价格：</strong></p>\n<ul>\n<li>外网流出100GB一年396元<span class=\"exturl\" data-url=\"aHR0cHM6Ly9idXkuY2xvdWQudGVuY2VudC4uY29tL3ByaWNlL2NvcyN0YWIwLWxpc3Qx\">https://buy.cloud.tencent..com/price/cos#tab0-list1</span></li>\n<li>基本图片处理：每月0-20TB:免费20TB以上：0.025元&#x2F;GB</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzEyNDYvNDUyNzQ=\">https://cloud.tencent.com/document/product/1246/45274</span></li>\n<li>图片压缩：1元&#x2F;千次</li>\n</ul>\n<h1 id=\"SSR服务端渲染\"><a href=\"#SSR服务端渲染\" class=\"headerlink\" title=\"SSR服务端渲染\"></a>SSR服务端渲染</h1><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>SSR-Server Side Rendering</strong></p>\n<p>Vue关于SSR的介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zc3IudWVqcy5vcmcvemg=\">https://sSr.uejs.org/zh</span></p>\n<p><strong>SSR的优点</strong></p>\n<ul>\n<li>更好的SEO</li>\n<li>更快的渲染时间(Time to content)，</li>\n</ul>\n<p><strong>SSR的缺点</strong></p>\n<ul>\n<li><p>开发的限制，浏览器相关的操作只能在特定的钩子函数中使用</p>\n</li>\n<li><p>SPA应用完全静态化，而SSR app需要Node.js Server才能运行</p>\n</li>\n<li><p>服务端负荷更高</p>\n</li>\n</ul>\n<p><strong>SSR的实现：</strong></p>\n<ul>\n<li><p>基本原理：@vue&#x2F;server-renderer <span class=\"exturl\" data-url=\"aHR0cHM6Ly92My51ZWpzLm9yZy9ndWlkZS9zc3IvZ2V0dGluZy1zdGFydGVkLmh0bWwjaW5zdGFsbGF0aW9u\">https://v3.uejs.org/guide/ssr/getting-started.html#installation</span></p>\n</li>\n<li><p>使用createSSRApp，renderToString以及renderToStream方法</p>\n</li>\n</ul>\n<p><strong>成熟的，大而全的SSR通用开发框架：</strong></p>\n<ul>\n<li>Nuxt.js <span class=\"exturl\" data-url=\"aHR0cHM6Ly9udXh0anMub3JnLw==\">https://nuxtjs.org/</span>  （Vue）</li>\n<li>React类似的Next.js <span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZXh0anMub3JnLw==\">https://nextjs.org</span> （React）</li>\n</ul>\n<h3 id=\"SSR\"><a href=\"#SSR\" class=\"headerlink\" title=\"SSR\"></a>SSR</h3><p>express等框架的res.render方法可以渲染html模板，使用的是nunjucks库进行数据填充。</p>\n<p>index.html</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html class=&quot;no-js&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;&#123;&#123; desc &#125;&#125;&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=&quot;&#123;&#123; bodyStyle &#125;&#125;&quot;&gt;  //根据传入的props动态添加style样式\n    &#123;&#123; html | safe &#125;&#125;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>index.js  (依据express框架为例：)</p>\n<pre><code class=\"javascript\">//...res是响应参数\nres.render(&#39;index&#39;,function(err,html)&#123;\n    res.send(html);\n&#125;)\n</code></pre>\n<h3 id=\"vue中SSR\"><a href=\"#vue中SSR\" class=\"headerlink\" title=\"vue中SSR\"></a>vue中SSR</h3><p>1、vue3有包：@vue&#x2F;server-renderer，在3.2.13版本以上内置了，低于此版本需要自行安装。</p>\n<p>2、使用：</p>\n<pre><code class=\"javascript\">//.......... res是服务端返回\nimport &#123; pipeline &#125; from &#39;stream/promises&#39;;\nimport &#123; createSSRApp &#125; from &#39;vue&#39;;\nimport &#123; renderToString , renderToNodeStream &#125; from &#39;@vue/server-renderer&#39;\nconst vueApp = createSSRApp(&#123;\n    data:()=&gt;&#123; msg:&#39;hello world&#39; &#125;,\n    template: &#39;&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&#39;\n&#125;)\nconst appContent = await renderToString(vueApp);\nres.type = &#39;text/html&#39;;\nres.body = appContent;\n// 或者使用流式输出：\nconst stream = renderToNodeStream(vueApp);\nres.statys = 200;\nawait pipeline(stream,res);\n</code></pre>\n<h1 id=\"RBAC权限验证\"><a href=\"#RBAC权限验证\" class=\"headerlink\" title=\"RBAC权限验证\"></a>RBAC权限验证</h1><h3 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>权限验证的场景以及需求：</strong></p>\n<ul>\n<li>特定的角色的用户才能操作特定的资源</li>\n<li>不同的用户能操作同类资源的特定实体</li>\n<li>不同的用户操作特定资源的不同属性</li>\n</ul>\n<p><strong>谁(User)拥有什么权限(Authority）去操作(Operation)哪些资源(Resource)</strong><br>根据角色完成权限的控制-RBAC(role based access control)，其实就是在原本用户——-权限的对应关系之上加一层中间层角色：用户——角色—–权限。好处是<strong>使得用户和权限的对应关系更加清晰和易于掌控</strong>。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>Node.js实现RBAC的库：</p>\n<ul>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL29udXJ5L2FjY2Vzc2NvbnRyb2w=\">AccessControl.js（不推荐，不维护了）</span></p>\n<ul>\n<li>1.6k Star</li>\n<li>3年没有更新，很多issue没人处理</li>\n<li>不支持ts</li>\n</ul>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nhc2Jpbi9ub2RlLWNhc2Jpbg==\">Casbin</span></p>\n<ul>\n<li>1.7k Star</li>\n<li>ts编写，支持多种编程语言</li>\n<li>概念比较复杂，使用略繁琐</li>\n</ul>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0YWxuaXkvY2FzbA==\">Casl</span></p>\n<ul>\n<li><p>3.4k Star</p>\n</li>\n<li><p>ts编写</p>\n</li>\n<li><p>简单易用，可读性良好</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Casl使用\"><a href=\"#Casl使用\" class=\"headerlink\" title=\"Casl使用\"></a><strong>Casl使用</strong></h3><pre><code class=\"javascript\">import &#123; AbilityBuilder , Ability &#125; from &#39;@casl/ability&#39;;\nclass Work &#123;\n    constructor(attrs)&#123;\n        Object.assign(this,attrs);\n    &#125;\n&#125;\nconst templateWork = new Work(&#123; id : 1 , isTemplate : true &#125;);\nconst notWork = new Work(&#123; id : 2 , isTemplate : false &#125;);\nfunction defineRules()&#123;\n    const &#123; can , cannot ,build &#125; = new AbilityBuilder(Ability);\n    can(&#39;read&#39;,&#39;Work&#39;);\n    cannot(&#39;delete&#39;,&#39;Work&#39;);\n    can(&#39;update&#39;,&#39;Work&#39;,&#123;isTemplate:false&#125;);\n    return build();\n&#125;\nconsole.log(templateWork.constructor.name)\nconst rules defineRules()\nconsole.log(rules.can(&#39;read&#39;,&#39;Work&#39;))\nconsole.log(rules.can(&#39;delete&#39;,&#39;Work&#39;))\nconsole.log(rules.can(&#39;update&#39;,templateWork))\nconsole.log(rules.can(&#39;update&#39;,notWork))\n</code></pre>\n<h1 id=\"部署-1\"><a href=\"#部署-1\" class=\"headerlink\" title=\"部署\"></a>部署</h1><h3 id=\"传统模式\"><a href=\"#传统模式\" class=\"headerlink\" title=\"传统模式\"></a>传统模式</h3><p><strong>本地开发</strong><br>使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1iaW4=\">egg-bin</span>，提供了便捷的方式在本地进行开发、调试、单元测试，它可以自动的监控文件的修改，然后重新运行对应的命令。<br>采用的配置文件是：config.default.ts<br>启动开发环境命令为<code>egg-bin dev</code><br><strong>生产环境运行程序</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbTIua2V5bWV0cmljcy5pby8=\">pm2-process manager</span></p>\n<pre><code class=\"bash\">node script.js \npm2 start script.js\n</code></pre>\n<p><strong>PM2的优势：</strong></p>\n<ul>\n<li>cluster（集群）模式运行</li>\n<li>自动重启auto reload</li>\n<li>热替换hot reload</li>\n<li>性能监控Monitoring</li>\n</ul>\n<p><strong>egg.js中有对应于PM2的内置方法：</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1zY3JpcHRz\">egg-scripts</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2VnZ2pzL2VnZy1jbHVzdGVy\">egg-cluster</span></li>\n</ul>\n<p><strong>egg.js生产环境启动和关闭</strong></p>\n<pre><code class=\"cmd\">egg-scripts start\negg-scripts stop\n</code></pre>\n<p><strong>配置文件</strong><br>config.prod.ts 和 config.default.ts<br><strong>编译过程</strong><br>需要手动将ts转换为js,借助<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3doeGF4ZXMvZWdnLXRzLWhlbHBlcg==\">ets</span><br><code>特别注意将项目中的typscript版本升级到4.4.3 </code></p>\n<pre><code class=\"bash\">npm run tsc\n</code></pre>\n<h3 id=\"Cluster模型\"><a href=\"#Cluster模型\" class=\"headerlink\" title=\"Cluster模型\"></a>Cluster模型</h3><p><strong>Egg.js Cluster模型的原理</strong><br>Egg.js关于这部分内容的文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lZ2dqcy5vcmcvemgtY24vY29yZS9jbHVzdGVyLWFuZC1pcGMuaHRtbA==\">https://eggjs.org/zh-cn/core/cluster-and-ipc.html</span><br><strong>为什么要采用Cluster模式</strong><br>JavaScript代码是运行在单线程上的，那么如果用Node.js来做Web Server,就无法享受到多核运算的好处。<br><strong>什么是Cluster模式</strong><br>文档：<span class=\"exturl\" data-url=\"aHR0cDovL25vZGVqcy5jbi9hcGkvY2x1c3Rlci5odG1s\">http://nodejs.cn/api/cluster.html</span></p>\n<p>Node.js的单个实例在单个线程中运行。为了利用多核系统，用户有时会想<br>要启动Node.js进程的集群来处理负载。</p>\n<ul>\n<li>在服务器上同时启动多个进程</li>\n<li>每个进程里都跑的是同一份源代码（将一个进程的工作分给多个进程去做）</li>\n<li>这些进程可以同时监听一个端口</li>\n</ul>\n<p><strong>Cluster的运行模式：</strong></p>\n<p>Request————-master_process主进程———————workers进程（多个）</p>\n<p><strong>进程间通信（IPC）：</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUExJThDJUU3JUE4JThCJUU5JTk2JTkzJUU5JTgwJTlBJUU4JUE4JThB\">IPC Inter-Process Communication</span></p>\n<p>IPC指的是至少两个进程或线程间传送数据或信号的一些技术或者方法，Node.js将其封装为基于事件的形式便于使用。</p>\n<p><strong>Cluster使用：</strong></p>\n<pre><code class=\"javascript\">import http from &#39;http&#39;;\nimport cluster from &#39;cluster&#39;;\nimport &#123; cpus &#125; from &#39;os&#39;;\nimport process from &#39;process&#39;;\nif(cluster.isPrimary)&#123; //通过cluster.isPrimary来分支处理主进程和worker进程\n    console.log(`master $&#123;process.pid&#125; running`);\n    const cpuLength = cpus().length;\n    for(let i = 0 ; i &lt; cpuLength ; i++)&#123;\n        cluster.fork();\n    &#125;\n    cluster.on(&#39;exit&#39;,(worker)=&gt;&#123;\n        console.log(`worker $&#123;worker.process.pid&#125; exited`);\n    &#125;)\n&#125;else&#123; //分支判断到是worker进程，cluster.fork()复制的worker进程都会进入\n    http.createServer((req,res)=&gt;&#123;\n        res.writeHead(200);\n        res.end(&quot;hello world&quot;);\n    &#125;).listen(8000);\n    console.log(`worker $&#123; process.pid &#125; started`);\n    console.log(cluster.workers); //获得子进程，可以通过process.send和on(&#39;message&#39;)事件进行进程间通信。\n&#125;\n</code></pre>\n<p><strong>egg.js中对于Cluster的二次封装：</strong></p>\n<ul>\n<li>使用egg-scripts启动master process</li>\n<li>使用egg-cluster启动和CPU核数相等的app_worker process</li>\n<li>使用egg-cluster启动的一个独特的agent_worker process</li>\n</ul>\n<p><strong>进程守护</strong><br>考虑到生产环境的健壮性，必须保证进程异常的情况下怎样处理。<br><strong>当代码抛出异常并没有被捕获的时候，worker使用process.on(‘uncaughtException’,handler)来捕获对应的错误，这时进程处于不确定的状态，需要优雅退出。</strong></p>\n<p><strong>系统异常</strong><br>而当一个进程出现异常导致crash或者被系统杀死时，不像未捕获异常发生时我们还有机会让进程继续执行，Master立刻fork一个新的Worker。<br><strong>Agent机制</strong><br>有一些特殊性质的工作，不能多个worker一起合作，容易造成混乱。对于这种工作egg.js提供了一个新的agent进程来完成。</p>\n<p><strong>Egg.js三种进程的总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>进程数量</th>\n<th>作用</th>\n<th>稳定性</th>\n<th>是否运行业务代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master进程</td>\n<td>1</td>\n<td>进程管理，进程间消息转发</td>\n<td>非常高</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Agent进程</td>\n<td>1</td>\n<td>后台运行工作</td>\n<td>高</td>\n<td>少量</td>\n</tr>\n<tr>\n<td>Workers进程</td>\n<td>CPU核数</td>\n<td>执行业务代码</td>\n<td>一般</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<p><strong>Cluster模型和Node多进程的区别：</strong></p>\n<ul>\n<li>Cluster模块可以将一个node进程分裂成多个子进程，每个子进程独立运行在cpu内核上，以提升应用程序的并发能力和性能，通过主进程和子进程之间的通信来实现负载均衡，处理并发请求。</li>\n<li>node多进程使用child_process模块，其不具备负载均衡和通信机制，需要自行实现进程间通信和负载均衡逻辑。可用于处理长时操作，返回结果给主进程。</li>\n</ul>\n<p><strong>Node.js压力测试工具：</strong></p>\n<p>模拟高并发场景：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9hZHRlc3Q=\">Loadtest</span></p>\n<pre><code class=\"bash\"># n                   总过发送多少个请求\n# c concurrency       同时有几个客户端在发送请求\n# rps request per seconds   每秒发送多少个请求\nloadtest -n 400 -c 10 --rps 200 http://mysite.com/ \n</code></pre>\n<h1 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h1><h4 id=\"购买\"><a href=\"#购买\" class=\"headerlink\" title=\"购买\"></a>购买</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2Vjcw==\">阿里云ECS</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L2N2bQ==\">腾讯云CVM</span></p>\n<p>价格（学生优惠）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9hY3QvY2FtcHVzP2Zyb209MTQ1OTk=\">https://cloud.tencent.com/act/campus?from=14599</span> 12G 38</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHVhd2VpY2xvdWQuY29tL3Byb2R1Y3QvZWNzLmh0bWw=\">华为云ECS</span></p>\n<h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4><p><strong>为什么使用root登录时一个不好的实践</strong></p>\n<ul>\n<li>有非常多的bot会尝试使用root+pwd的ssh方式暴力登录机器，当尝试成功以后，黑客就会控制整个系统。</li>\n<li>假如使用特定用户名+pwd,bot需要先猜测用户名(N次)，然后是密码(M次)，这样复杂度提升到N*M</li>\n<li>root可以造成更大的危害，影响整个系统，而某个特定用户只能影响它的文件系统</li>\n</ul>\n<p><strong>创建一个用户账号进行登录</strong></p>\n<pre><code class=\"bash\"># 远程登录\nssh root@xxx.xx.xx.xx\n# 添加用户以及设置密码\nadduser dmq\n</code></pre>\n<p><strong>设置该用户拥有sudo权限，给予它在登录以后切换到root的能力</strong></p>\n<pre><code class=\"bash\"># 修改权限，u表示所有者，w表示写权限+表示添加\nchmod u+w /etc/sudoers\n# 编辑文件\nvim /etc/sudoers\n# 找到  `root ALL=(ALL)  ALL`\n# 再加一行  `dmq ALL=(ALL)  ALL`\n</code></pre>\n<p><strong>使用新用户登录并且测试权限</strong></p>\n<pre><code class=\"bash\">ssh dmq@xxx.xx.xx.xx\n# 可以使用 su 直接切换为root用户\n# 也可以使用sudo快捷的使用root权限进行操作\n</code></pre>\n<p><strong>禁止使用root远程登录ssh</strong></p>\n<pre><code class=\"bash\"># 修改ssh配置\nvim /etc/ssh/sshd_config I\n# 修改yes为no\nPermitRootLogin no\n# 重启sshd服务\nservice sshd restart\n</code></pre>\n<p><strong>可选：不使用密码登录</strong><br>为什么使用密码登录有时候是一个不好的实践？<br><strong>非常简单：用户经常使用非常错误（简单的）用户密码，全球最常用的密码是123456以及bc123,而且用户会在多个账户大量重复使用，所以黑客从别的地方盗取的密码很可能在其他账户也可以使用</strong></p>\n<p><strong>使用SSH kev进行登录</strong><br>SSH key采角了经典的非对称加密技术，可以使用工具创建一个公钥和私钥，你可以将公钥放置在任何的服务器当中，在本地保留私钥。在ssh登录的时候，SSH验证公钥和私钥的合法性，当合法的时候，就可以免密码登录了。证书由1024Bits到4096Bits（128到512字符)的随机字符组成，要比你自己的密码安全的多。</p>\n<pre><code class=\"bash\">#创建ssh key pair\nssh-keygen -t rsa -b 4096 -C &quot;your email@example.com&quot;\nwindows可以使用putty或者git scma软件生成，备注网址：\nhttps://www.jianshu.com/p/95262f5eba7a\n# 本地ssh证书的位置\n-/.ssh/id rsa\n-/.ssh/id rsa.pub\n# 登录远程机器\nssh viking@xxx.xx.xx.xx\n# 创建受信任的登录密钥\n# 这个文件当中的公钥会被当前的主机设置为信任方\ntouch -/.ssh/authorized keys\n# 将id rsa.pub的文本内容黏贴进来\n</code></pre>\n<p><strong>可选，关闭密码登录服务器的功能</strong></p>\n<pre><code class=\"bash\">vim /etc/ssh/sshd config\n#修改为no\nPasswordAuthentication no\n#重启服务\nservice sshd i restart\n</code></pre>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p><strong>准备云服务器必备软件</strong></p>\n<ul>\n<li>nodejs (16)</li>\n<li>MongoDB</li>\n<li>Redis</li>\n<li>Git</li>\n</ul>\n<p><strong>Linux发行版的两大家族</strong></p>\n<ul>\n<li>Debian(完全免费的Linux发行版)-Ubuntu(基于Debian,更加容易上手)-apt包管理系统-软件格式为deb包大</li>\n<li>Red Hat(商用Linux发行版)-CentOS(Red Hat减去收费软件)-yum包管理系统-软件格式为rpm</li>\n</ul>\n<p><strong>软件安装</strong><br><strong>安装Node.js</strong><br>1安装nvm管理node版本<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">https://github.com/nvm-sh/nvm</span><br>2使用包管理器安装node最新版本<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZGVzb3VyY2UvZGlzdHJpYnV0aW9ucy9ibG9iL21hc3Rlci9SRUFETUUubWQjZGVi\">https://github.com/nodesource/distributions/blob/master/README.md#deb</span></p>\n<p><strong>安装MongoDB</strong><br>1从源代码下载安装，回顾之前的内容<br>2使用包管理器安装<br>Ubuntu:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tdWJ1bnR1Lw==\">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/</span><br>Centos:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC90dXRvcmlhbC9pbnN0YWxsLW1vbmdvZGItb24tcmVkLWhhdC8=\">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</span></p>\n<p><strong>安装Redis</strong><br>1从源代码下载安装，回顾之前的基础知识<br>2使用包管理器安装<br>CentOS:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1pbnN0YWxsLXNlY3VyZS1yZWRpcy1jZW50b3MtNw==\">https://www.digitalocean.com/community/tutorials/how-to-install-secure-redis-centos-7</span><br>Ubuntu:<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1pbnN0YWxsLWFuZC1zZWN1cmUtcmVkaXMtb24tdWJ1bnR1LTE4LTA0\">https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04</span></p>\n<h4 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h4><p><strong>使用service或者systemctl管理服务</strong></p>\n<pre><code class=\"bash\"># systemd 模块 - https://en.wikipedia.org/wiki/Systemd\nservice  服务名称(mongod)  操作指令(status/start/stop/restart)\nsystemctl  操作指令(start/stop/status/restart/reload)  服务名称service\n</code></pre>\n<h1 id=\"普通部署\"><a href=\"#普通部署\" class=\"headerlink\" title=\"普通部署\"></a>普通部署</h1><p><strong>在服务器上部署并运行</strong></p>\n<ul>\n<li><p>登录远程机器，使用普通用户。</p>\n</li>\n<li><p>在自己的目录下面，clone代码</p>\n</li>\n<li><p>安装对应的依赖</p>\n<ul>\n<li><p>可以使用sharp淘宝mirror来安装比较大的二进制文件。</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaGFycC5waXhlbHBsdW1iaW5nLmNvbS9pbnN0YWxsI2NoaW5lc2UtbWlycm9y\">https://sharp.pixelplumbing.com/install#chinese-mirror</span></p>\n</li>\n</ul>\n</li>\n<li><p>创建并且设置.env文件</p>\n</li>\n<li><p>开启云服务对应的端口(7001)访问。</p>\n<ul>\n<li><p>阿里云：左侧导航“本实例安全组”，“配置规则”，“手动添加”端口</p>\n</li>\n<li><p>其他云平台请自行查看。</p>\n</li>\n</ul>\n</li>\n<li><p>启动服务器</p>\n<ul>\n<li><p>确认mongo，redis在运行状态</p>\n</li>\n<li><p>npm run tsc</p>\n</li>\n<li><p>npm run start</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>于此可以完成基本的项目部署，但是这种部署方式启动和更新时过于复杂，存在如下问题：</p>\n<p>三个问题</p>\n<ul>\n<li>前置软件的安装，它们在不同操作系统中安装的方式，启动的脚本，预设初始的方式有可能都不相同，这就给我们造成一个很大的困扰，假如你在多台机器上部署的话，可能会遇到各种各样的问题。</li>\n<li>项目需要运行一系列对应的命令才能启动</li>\n<li>项目更新的问题，需要一系列手动的步骤，这是一个非常繁琐，而且容易出错的步骤。有没有更方便的方式可以完成这个过程呢？<ul>\n<li>完成对应的pull代码，更新依赖，启动应用的过程</li>\n<li>是在特定的提交自动触发这个过程</li>\n</ul>\n</li>\n</ul>\n<p>想要更加方便的进行部署可以使用如下工具：</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS9wcm9kdWN0cy9kb2NrZXItZGVza3RvcA==\">Docker</span></h2><h3 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>问题</strong><br>我们希望有一个工具可以帮我们一键智能部署，假如你要部署在多台不同的机器上，可以不用在担心不同系统，不同版本的差异，以及运行之前需要安装不同软件的痛苦。<br><strong>解决</strong><br>当红的虚拟化软件：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbWwv\">Docker</span><br>Docker的进化</p>\n<p><img data-src=\"/images/Snipaste_2024-04-26_20-27-53.jpg\" alt=\"Docker的进化\"></p>\n<ul>\n<li>传统虚拟机，虚拟硬件以后，需要在上面安装一个完整的操作系统。</li>\n<li>Docker:推出了容器的概念，每个容器不需要安装完成的操作系统，里面的进程直接运行在Docker创造的宿主内核中，不需要虚拟硬件。</li>\n</ul>\n<p><strong>Docker的优点</strong></p>\n<ul>\n<li>更快速的启动速度</li>\n<li>更少的资源占用</li>\n<li>一致的运行环境，使用户不关注操作系统而只关心应用程序。</li>\n<li>微服务架构，docker天生适配微服务架构（Docker 有助于将一个复杂系统分解成一系列可组合的部分，这让用户可以用更离散的方式来思考其服务。用户可以在不影响全局的前提下重组软件，使其各部分更易于管理和可插拔。）</li>\n<li>用户可以更准确地控制构建环境的状态，Docker 构建比传统软件构建方法更具有可重现性和可复制性。使持续交付的实现变得更容易。</li>\n</ul>\n<h3 id=\"Docker-images\"><a href=\"#Docker-images\" class=\"headerlink\" title=\"Docker  images\"></a><strong>Docker  images</strong></h3><p>可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9zZWFyY2g/Zz0mdHlwZT1pbWFnZSVFNCVCOCVBRCVFOCU4RSVCNyVFNSU4RiU5NiVFNSU5MCU4NCVFNyVBNyU4RCVFNSVBRSU5OCVFNiU5NiVCOSVFNyU5QSU4NCVFOSU5NSU5QyVFNSU4MyU4RiVFRiVCQyU4QyVFNSVCOSVCNiVFNCVCOCU5NCVFNSU4RiVBRiVFNCVCQiVBNSVFNCVCOCU4QSVFNCVCQyVBMCVFNCVCRCVBMCVFOCU4NyVBQSVFNSVCNyVCMSVFNyU5QSU4NCVFOCU4NyVBQSVFNSVBRSU5QSVFNCVCOSU4OSVFOSU5NSU5QyVFNSU4MyU4Rg==\">https://hub.docker.com/search?g=&amp;type=image中获取各种官方的镜像，并且可以上传你自己的自定义镜像</span><br>Docker镜像仓库获取镜像的命令是docker pull</p>\n<pre><code class=\"bash\"># 下载镜像\ndocker pull &lt;image-name&gt;:&lt;tag&gt;\n# 查看以及下载的镜像\ndocker images\n# 删除镜像\ndocker rmi &lt;image-id&gt;\n# 上传\ndocker push &lt;username&gt;/&lt;repository&gt;:&lt;tag&gt;\n</code></pre>\n<p><strong>使用镜像代理：</strong></p>\n<pre><code class=\"javascripton\">&quot;registry-mirrors&quot;: [\n    &quot;https://docker.mirrors.ustc.edu.cn/&quot;,\n    &quot;https://reg-mirror.qiniu.com&quot;\n]\n</code></pre>\n<h3 id=\"Docker-Container\"><a href=\"#Docker-Container\" class=\"headerlink\" title=\"Docker Container\"></a><strong>Docker Container</strong></h3><p><strong>启动Docker容器</strong></p>\n<pre><code class=\"bash\">docker run -d -p 主机端口:镜像端口 --name 容器名称 镜像名称\n# 例如：（--name 容器名称省略）\ndocker run -d -p 81:80 nginx\n# -d  后台运行\n# -p  端口映射，81为主机的端口，80为镜像端口\n# --name 自定义容器名称\n# 镜像名称，假如本地没有，会自动pull一次镜像进行下载。\n</code></pre>\n<p><strong>其他命令</strong></p>\n<pre><code class=\"bash\"># 查看所有容器\ndocker  ps\n# 停止容器\ndocker stop container-id\n# 删除容器\ndocker rm container-id\n# 启动已终止容器\ndocker container start container-id\n</code></pre>\n<p><strong>进入容器内部</strong></p>\n<pre><code class=\"bash\">docker exec -it &lt;container-id&gt; command\n-i : 即使没有附加也保持STDIN 打开\n-t : 分配一个伪终端\n</code></pre>\n<h3 id=\"持久化容器数据\"><a href=\"#持久化容器数据\" class=\"headerlink\" title=\"持久化容器数据\"></a><strong>持久化容器数据</strong></h3><p>使用-v参数，可以设定一个数据的映射关系，将本地的文件映射到容器中对应的文件中去。</p>\n<pre><code class=\"bash\">docker run -d -p 81:80 -v host:container image-name\n#例如：将本地数据卷映射到容器中\ndocker run -d -v /data/db:/data/db mongo\n</code></pre>\n<p><strong>创建对应的数据卷volumn</strong></p>\n<pre><code class=\"bash\"># 创建数据卷\ndocker volume create &lt;volumn-name&gt;\n#例如：docker volume create mongo\n# 使用volumn数据卷\ndocker run -d -v &lt;volumn-name&gt;:/data/db mongo\n# 例如：docker run -d -v mongo:/data/db mongo\n# 检查数据卷\ndocker volume inspect &lt;volumn-name&gt;\n# 删除数据卷\ndocker volume remove mongo\n</code></pre>\n<h3 id=\"Dockerfile自定义镜像\"><a href=\"#Dockerfile自定义镜像\" class=\"headerlink\" title=\"Dockerfile自定义镜像\"></a>Dockerfile自定义镜像</h3><p>Docker image中的镜像虽然非常多，但是不能完全符合自己项目的全部需求，可以自定义构建一个自己的镜像。</p>\n<p>Dockerfile是一个特殊的文本文件，其中包括一系列指令，用于构建对应的镜像。</p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLyNmcm9t\">指令</span></strong></p>\n<p> <strong>Dockerfile示例：</strong></p>\n<pre><code class=\"dockerfile\"># 指定基础镜像，从node14开始构建\nFROM node:14\n\n# 创建对应的文件夹，作为项目运行的位置\nRUN mkdir -p /usr/src/app\n\n# 指定工作区，后面的运行任何命令都是在这个工作区中完成的\nWORKDIR /usr/sec/app\n\n# 从本地拷贝对应的文件 到 工作区\nCOPY server.js /usr/src/app\n\n# 执行安装命令\nRUN npm install --registry=https://registry.npm.taobao.org\nRUN npm run tsc\n\n#告知当前Docker image暴露的是3000端☐\nEXPOSE 3000\n\n#执行启动命令，一个Dockerfile只能有一个\nCMD node server.js\n</code></pre>\n<p><strong>构建：</strong></p>\n<pre><code class=\"bash\"># 这里特别注意上下文的概念，不要在根目录使用Dockerfi1e\ndocker build [选项] &lt;上下文路径/URL/-&gt;\n# 例如：(在项目文件夹中运行)\ndocker build -t test-node .\n</code></pre>\n<p><strong>.dockerignore文件用于忽略docker中需要打包进镜像的文件</strong></p>\n<p><strong>.dockerignore示例：</strong></p>\n<pre><code class=\"dockerfile\"># Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n# Optional REPL history\n.node_repl_history\n# Output of &#39;npm pack&#39;\n*.tgz\n# Yarn Integrity file\n.yarn-integrity\n</code></pre>\n<p> <strong>多个容器相互通信：</strong></p>\n<p>要点：Docker中每一个container应该只完成一个工作，并且将它做好。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>解耦，这样不同的服务和后端代砀都可以完全分离开来，方便管理以及未来的扩展。</li>\n<li>服务的更新以及升级都是完全独立的。</li>\n<li>在一个container中，启动多个不同的进程，需要一个进程管理器</li>\n</ul>\n<p><strong>通信过程：</strong></p>\n<p>docker容器之间不能直接进行访问，而是应该通过docker网络进行访问。</p>\n<pre><code class=\"bash\"># 创建docker网络\ndocker network create test\n# 在创建的docker网络中启动服务\ndocker run -d --network test --name mongo -p 27017:27017 mongo\n# 将原来项目中的的ip地址替换为docker的name名称\n# 例如原来为：mongodb://localhost:27017/api  的地址要替换为： mongodb://mongo:27017/api\n# 只有在同一个docker网络中启动的项目间才能进行访问。\ndocker run -d --network test --name use -p 80:3000 use\n</code></pre>\n<p>如果每个容器都要这样操作一遍就会显得非常麻烦，这时就需要使用Docer compose工具（配置docker-compose.yml文件）</p>\n<p>Docker compose工具</p>\n<p>Docker compose是Docker官方推出的工具，用来管理和共享多个容器的应用，Mac系统和Windows系统安装客户端时自带。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9pbnN0YWxsLw==\">Linux需要单独安装</span>。</p>\n<pre><code class=\"bash\">docker-compose version\n</code></pre>\n<p><strong>配置：</strong></p>\n<ul>\n<li>docker compose通过一个特殊的yml文件，进行配置，这个文件必须命名为<strong>docker-compose.yml</strong></li>\n<li>docker-compose所有的字段参考文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9jb21wb3NlLWZpbGUvY29tcG9zZS1maWxlLXYzLw==\">https://docs.docker.com/compose/compose-file/compose-file-v3/</span></li>\n</ul>\n<p><strong>docker-compose.yml文件配置示例：</strong></p>\n<pre><code class=\"yaml\">version: &#39;3&#39; # docker指令版本\nservices: # 要启动的服务\n  test-mongo: # 服务名称，这里的服务名称对应着容器通信时的前缀！\n    image: mongo # 使用的镜像名称\n    container_name: test-mongo # 容器名称\n    volumes:  # 使用的数据卷映射\n      - &#39;.docker-volumes/mongo/data:/data/db&#39;\n    ports:  # 端口映射\n      - 27017:27017\n    environment: # 设置环境变量\n      - MONGO_INITDB_ROOT_USERNAME=admin  # 内置的环境变量，可以初始化添加一个User\n      - MONGO_INITDB_ROOT_PASSWORD=pass\n    env_file: # 设置环境变量文件，将敏感信息放置到环境变量文件中\n      - .env\n  test-use: # 第二个项目，注意对齐关系\n    depends_on: # 配置所依赖的服务\n      - test-mongo\n    build: # 设置构建配置\n      context: . # 操作上下文为当前目录\n      dockerfile: Dockerfile # 基于Dockerfile进行构建\n    image: test-use-image\n    container_name: test-use\n    ports:\n      - 7001:7001\n</code></pre>\n<p><strong>启动以及关闭：</strong></p>\n<pre><code class=\"bash\"># 启动\ndocker-compose up -d\n# 关闭\ndocker-compose down\n</code></pre>\n<h3 id=\"数据库配置\"><a href=\"#数据库配置\" class=\"headerlink\" title=\"数据库配置\"></a>数据库配置</h3><p><strong>数据库准备工作</strong></p>\n<ul>\n<li>数据库配置，初始化工作，比如插入一些特定的数据</li>\n<li>避免使用root用户去启动服务，从而提高安全性（配置数据库访问权限）</li>\n</ul>\n<p><strong>特殊的初始化数据库的位置：&#x2F;docker-entrypoint-initdb.d（这个文件夹中的脚本会在容器启动前自动执行）</strong></p>\n<ul>\n<li><p>可以创建js文件或者sh文件（shell）进行执行。</p>\n</li>\n<li><p>mongoDB：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fbW9uZ28=\">https://hub.docker.com/_mongo</span></p>\n</li>\n<li><p>Postgres:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fbHBvc3RncmVz\">https://hub.docker.com/_lpostgres</span></p>\n</li>\n<li><p>特别注意，只有在数据库没有被创建的情况下，也就是<strong>数据库的文件夹是空的情况下</strong>，脚本才会被执行。</p>\n</li>\n</ul>\n<p><strong>docker-compose.yml文件中配置env_file为当前文件夹下的.env文件。</strong></p>\n<p>可以使用js文件或者sh文件，但是由于此文件在其余文件之前运行，此时js文件中通过process.env获取不到所需要的环境变量，可以选用sh文件。</p>\n<p><strong>Shell中EOF&lt;&lt;的用法</strong><br>在Shell中我们通常将EOF与&lt;结合使用，表示，二债的输入作为子命令或子Shell的输入，直到遇到EOF为止，再返回到主调Shell。.</p>\n<pre><code class=\"shell\">#!/bin/bash\nmongo &lt;&lt;EOF\nuse admin\ndb.auth(&#39;root&#39;,&#39;123456&#39;)\nuse lego\ndb.createUser(&#123;\n    user: &#39;$MONGO_DB_USERNAME&#39;,\n    pwd: &#39;$MONGO_DB_PASSWORD&#39;,\n    roles: [&#123;\n        role: &#39;readWrite&#39;,\n        db: &#39;lego&#39;\n    &#125;]\n&#125;)\ndb.createCollection(&#39;works&#39;)\ndb.works.insertMany([\n    &#123;\n          id:19,\n          title:&#39;测试标题&#39;,\n          name:&#39;张三&#39;\n    &#125;\n])\nEOF\n</code></pre>\n<h3 id=\"优化镜像大小\"><a href=\"#优化镜像大小\" class=\"headerlink\" title=\"优化镜像大小\"></a>优化镜像大小</h3><p> <strong>Docker镜像构建优化：使用alpine版本的镜像</strong></p>\n<p>优化镜像大小  ：   什么是Alpine Linux:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbHBpbmVsaW51eC5vcmcv\">https://alpinelinux.org</span></p>\n<p><strong>Alpine的优点</strong></p>\n<ul>\n<li><p>Small小</p>\n<ul>\n<li><p>默认软件包，alpine选择busybox</p>\n</li>\n<li><p>C运行库，一般会用glibc,alpine选择musl</p>\n</li>\n</ul>\n</li>\n<li><p>最简依赖，Simple</p>\n<ul>\n<li><p>很多内置软件的插件都去掉。</p>\n</li>\n<li><p>国际化内容都被删除</p>\n</li>\n</ul>\n</li>\n<li><p>Secure安全</p>\n</li>\n</ul>\n<p><strong>使用alpine版本的镜像可以大大减小镜像的体积。</strong></p>\n<p><strong>DockerBuild构建提速</strong></p>\n<p>docker中运行命令是基于一层一层的，当修改文件之后，COPY后的缓存全部失效，这时就会重新执行后续命令，使用不了缓存，导致构建速度很慢。此时可以将原来COPY文件夹，改为COPY具体的文件（进行拆分），以更好地使用缓存。</p>\n<h3 id=\"部署-2\"><a href=\"#部署-2\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p><strong>安装Docker（有的云服务可以自定义安装）</strong></p>\n<p>Ubuntu：（需要使用root账户进行安装）</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9kb2NrZXIvdWJ1bnR1LWRvY2tlci1pbnN0YWxsLmh0bWw=\">https://www.runoob.com/docker/ubuntu-docker-install.html</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvdWJ1bnR1Lw==\">https://docs.docker.com/engine/install/ubuntu/</span></li>\n</ul>\n<p><strong>配置用户组</strong><br>因为是root安装，普通用户执行对应的命令的时候有可能会报错：<br><code>Can&#39;t connect to docker daemonGot permission denied while trying to connect to the Docker daemonsocket at unix:///var/run/docker.sock</code></p>\n<p><strong>需要将对应的用户添加到docker的用户组中。</strong></p>\n<pre><code class=\"bash\">#usermod命令修改用户账户\n#a--append添加-G--groups\n组的名称\nsudo usermod-aG docker 你的用户名\n#如果组不存在，添加对应的docker组\nsudo groupadd docker\n#查看一个用户所属的组\ngroups\n</code></pre>\n<p><strong>添加下载镜像：</strong></p>\n<pre><code class=\"bash\"># root\nvim /etc/docker/daemon.json\n&#123;\n&quot;registry-mirrors&quot;:\n&quot;https://docker.mirrors.ustc.edu.cn/&quot;,\n&quot;https://reg-mirror.qiniu.com&quot;\n]\n</code></pre>\n<p><strong>运行：</strong></p>\n<pre><code class=\"bash\"># 拉最新的代码\ngit pull\n# 先查看目前端口是否被占用\n# 如果被占用，释放端口\n# 或者改变docker-compose,yml的映射端口\ndocker-compose up -d\n</code></pre>\n<h1 id=\"YAML语言\"><a href=\"#YAML语言\" class=\"headerlink\" title=\"YAML语言\"></a>YAML语言</h1><p>YAML<br>(YAML Ain’t a Markup Language)是一种标记语言，它使用空格作为缩进，看起来非常的简洁，可读性非常的好，非常适合一些内容大纲和配置文件。他最终是通过工具转化为JSON文件的，但是YAML的可读性比JSON强很多，因此复杂的配置文件一般使用YAML。</p>\n<p><strong>例如：</strong></p>\n<pre><code class=\"yaml\"># 字符串不用加引号\nkey: value\nnumber: 100\nboolean: true\n# 字符串不用加引号，但是加上也不会报错\nquote_string: &#39;quote String&#39;\n# 多行字符串使用 literal block语法：也就是竖线\nmutiple_string: |\n  line one\n  line two\n  line three\n# collection types 集合类型\n# 使用缩进表示层级关系，最好使用两个空格，不是两个空格也没关系，对齐就行\nperson:\n  name: dmq\n  age: 18\n  address:\n    city: 上海\n\n# sequences 数组或者列表\nhobbies:\n  - Item 1\n  - Item 2\n  - name: weson\n    value: xyz\n    address:\n      city: 北京\n</code></pre>\n<h1 id=\"Github-Action\"><a href=\"#Github-Action\" class=\"headerlink\" title=\"Github Action\"></a>Github Action</h1><p>Github官方的CI&#x2F;CD工具，作为github的亲儿子，和github几乎是完美的无缝衔接的，功能非常强大。</p>\n<p>CI   CD常用工具：</p>\n<ul>\n<li>Github actions <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucw==\">https://docs.github.com/en/actions</span></li>\n<li>Travis <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudHJhdmlzLWNpLmNvbS8=\">https://www.travis-ci.com/</span></li>\n<li>CircleCl <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaXJjbGVjaS5jb20v\">https://circleci.com/</span></li>\n<li>Jenkins <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamVua2lucy5pby8=\">https://www.jenkins.io/</span></li>\n<li>优势讨论：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMwNjE5NTAzMy9hbnN3ZXIvMTg3MDMyMjExOA==\">https://www.zhihu.com/question/306195033/answer/1870322118</span></li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-04-27_18-37-04.jpg\" alt=\"/images/Snipaste_2024-04-16_12-54-33.jpg\"></p>\n<p><strong>Workflow</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy91bmRlcnN0YW5kaW5nLWdpdGh1Yi1hY3Rpb25zI3dvcmtmbG93cw==\">https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions#workflows</span><br>Workflow是一个可配置的自动化流程，可以包含多个jobs,通过一个在repo当中的yml文件来定义对应的流程，一个repo可以包含多个workflow。<br><strong>Events</strong><br>Event是触发workflow的特殊事件，比如pull request,push或者issue,也可以完全自定义，完整列表请看：https:&#x2F;docs.github.com&#x2F;cn&#x2F;actions&#x2F;learn-github-actions&#x2F;events-that-trigger-workflows</p>\n<p><strong>Jobs</strong></p>\n<p>Job是Workflow当中一系列的可执行步骤，每个Job是在同一个runner中进行的（(Runner是指处于github的一台特殊的虚拟机，支持各种操作系统)，每个步骤或者是一个shell脚本，抑或是一个可执行的action,每个步骤是按顺序执行，并且互相依赖的。</p>\n<p><img data-src=\"/images/Snipaste_2024-04-27_19-54-06.jpg\" alt=\"/images/Snipaste_2024-04-16_12-54-33.jpg\"></p>\n<p><strong>Actions</strong></p>\n<p>Action是github actions中的一个自定义应用，它可以运行一系列复杂的并且常用的任务，使用action可以帮我们减少在workflow中写重复代码，Github提供了非常多常用的action,可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlP3R5cGU9YWN0aW9ucw==\">这里查阅</span>，同时我们也可以写自己的action。</p>\n<p><strong>github secrets</strong></p>\n<p>项目中有的私密信息不希望公开暴露，通常的做法是将私密信息写道env文件中，使用gitingore将其忽略掉，这里还有一个做法就是github secrets，在github官网设置github secret，然后在文件中直接书写变量。</p>\n<p><strong>例如：.github文件夹下workflow文件夹下创建一个yml文件，写入：</strong></p>\n<pre><code class=\"yaml\">name: Github Actions Demo\non: [push]\njobs:\n  Check-Github-actions:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo &quot;triggered by a $&#123;&#123; github.event_name &#125;&#125; event&quot;\n      - run: echo &quot;running on a $&#123;&#123; runner.os &#125;&#125; server hosted by github&quot;\n      - name: check out repo code\n        uses: actions/checkout@v2 # 在工作流程中检出代码仓库的内容、确保工作流程始终使用一致的代码版本\n      - run: echo &quot;the $&#123;&#123; github.reopsitory &#125;&#125; has been cloned&quot;\n      - name: List files in the repo\n        run: |\n          ls $&#123;&#123; github.workspace &#125;&#125;\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        width:\n          repository: &#39;vikingmute/lego-bricks&#39;\n      - name: List files in the repo\n        run: |\n          ls $&#123;&#123; github.workspace &#125;&#125;\n      - uses: actions/setup-node@v2\n        with:\n          node-version: &#39;16&#39;\n      - run: node -v\n      - run: npm install -g typescript\n      - run: tsc -v\n  jobs:\n    SECRET-SSH-ACTIONS:\n      runs-on: ubuntu-latest\n      steps:\n      #使用ssh-action完成远程登陆：文档地址：https://github.com/appleboy/ssh-action\n        - uses: appleboy/ssh-action@master \n          with:\n            host: $&#123;&#123; secrets.HOST &#125;&#125;\n            username: $&#123;&#123; secrets.SSH_USER &#125;&#125;\n            password: $&#123;&#123; secrets.SSH_PWD &#125;&#125;\n            script_stop: true\n            script: |\n              pwd\n              ls -l\n              touch secret.txt\n              echo $&#123;&#123; secrets.MY_SECRET &#125;&#125; &gt;&gt; secret.txt\n</code></pre>\n<h1 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h1><h2 id=\"推送远程镜像仓库\"><a href=\"#推送远程镜像仓库\" class=\"headerlink\" title=\"推送远程镜像仓库\"></a>推送远程镜像仓库</h2><p><strong>普通线上更新流程：</strong></p>\n<pre><code class=\"bash\"># 每次代码更新以后，登录到ssh服务器\n# 关闭服务\ndocker-compose down\n# 更新代码\ngit pull\n# 假如有.env，的更新需要重新设置，env文件\n# 重新build应用镜像\ndocker-compose build lego-backend\n# 重启服务\ndocker-compose up -d\n</code></pre>\n<p><strong>弊端：</strong></p>\n<ul>\n<li><p>初次上线和更新属于两步</p>\n</li>\n<li><p>初次上线需要特别的操作，就是之前手动部署上线的运行的过程</p>\n<ul>\n<li><p>clone代码</p>\n</li>\n<li><p>设置环境变量.env</p>\n</li>\n<li><p>docker-compose up -d</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>追求的成果：</strong></p>\n<p><strong>每次提交，可以自动一次性的部署到任何服务器，实现初次启动或者更新的效果，这才是一个完美的develops的流程</strong></p>\n<p><strong>解决方案：</strong></p>\n<p>将上面本地的镜像存到docker hub服务器中，这样每次就不用重新build，而是直接拉取。</p>\n<pre><code class=\"yaml\">services:\n  lego-redis:\n    image:redis:6\n  lego-mongo:\n    image:mongo:latest\n  lego-backend:\n    image:lego-backend\n#我们需要每次手动的build镜像，也就说镜像只存在于本地\n  build:\n    ......context:.\n    dockerfile:Dockerfile\n</code></pre>\n<p><strong>改为：</strong></p>\n<pre><code class=\"yaml\"># 更好的方案\n# 不需要任何代码库中的文件，只需要一个docker-compose.yml文件\n# 就可以轻松的在任何服务器运行\nservices:\n  lego-redis:\n    image:redis:6\n  lego-mongo\n    image:mongo:latest\n  lego-backend:\n# 不需要build,而是存在于docker hub服务器中，可以每次直接拉取\n    image:lego-backend:1.0.1\n</code></pre>\n<p><strong>docker hub免费版有限制，推荐使用阿里云容器镜像服务：</strong></p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sd3d3LmFsaXl1bi5jb20vcHJvZHVjdC9hY3I=\">阿里云容器镜像服务ACR</span></strong><br>个人版完全免费</p>\n<p>创建镜像仓库之后，需要将本地镜像推送到ACR仓库中：</p>\n<pre><code class=\"bash\"># 来到镜像仓库的基本信息页面\n# 登录\ndocker login --username=用户名 registry.cn-hangzhou.aliyuncs.com\n# tag两种方式：\n# 1:使用tag bui1d\ndocker build--tag &quot;registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]&quot;\n# 2:给 build 好的打 tag\ndocker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]\n# 查看镜像是否 build 完成\ndocker images\n# 推送镜像\ndocker push registry.cn-hangzhou.aliyuncs.com/dmq00/test:[镜像版本号]\n# 在阿里云ACR界面检查看是否已经存在\n</code></pre>\n<h2 id=\"Github-Actions自动部署\"><a href=\"#Github-Actions自动部署\" class=\"headerlink\" title=\"Github Actions自动部署\"></a>Github Actions自动部署</h2><p><strong>使用github actions加成自动化部署：当推送代码到github仓库时，让我们的代码自动提交镜像到镜像仓库。</strong></p>\n<p><strong>大体分为两步</strong></p>\n<ul>\n<li><h6 id=\"在github服务器上build-image并且push\"><a href=\"#在github服务器上build-image并且push\" class=\"headerlink\" title=\"在github服务器上build image并且push\"></a>在github服务器上build image并且push</h6></li>\n<li><p><strong>使用docker-compose-online文件在服务器上运行应用</strong></p>\n</li>\n</ul>\n<p><strong>第一步详细流程分析，在github runner上运行</strong></p>\n<ul>\n<li><p>checkout代码（在github服务器上）</p>\n</li>\n<li><p>创建.env文件，并且添加两个环境变量( upload to OSS需要两个对应的信息 )</p>\n</li>\n<li><p>使用阿里云ACR完成docker login</p>\n</li>\n<li><p>使用正确的阿里云tag进行docker build</p>\n<ul>\n<li>怎样每次push生成特殊的tag？是一个后续的问题</li>\n</ul>\n</li>\n<li><p>docker push</p>\n</li>\n</ul>\n<p>例如：【1】在项目文件夹.github&#x2F;workflow下创建yml文件，写入：</p>\n<pre><code class=\"yaml\">name: build image,push to ACR\non: [push]\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      # checkout 代码\n      - uses: actions/checkout@v2\n      # 创建env文件\n      - run: touch .env\n      # 使用“ &gt;&gt; ”添加信息\n      - run: echo ALC_ACCESS_KEY=$&#123;&#123; secrets.ALC_ACCESS_KEY &#125;&#125; &gt;&gt; .env\n      - run: echo ALC_SECRET_KEY=$&#123;&#123; secrets.ALC_SECRET_KEY &#125;&#125; &gt;&gt; .env\n      # 使用阿里云ACR 完成 docker login\n      - name: Login to Aliyun ACR\n        uses: aliyun/acr-login@v1 # 使用专属的镜像\n        with:\n          login-server: https://registry.cn-hangzhou.aliyuncs.com\n          region-id: cn-hangzhou # 查看官网自己仓库的信息\n          username: &quot;$&#123;&#123; secrets.ACR_USERNAME &#125;&#125;&quot;\n          password: &quot;$&#123;&#123; secrets.ACR_PASSWORD &#125;&#125;&quot;\n        # 使用正确的阿里云 tag 进行 docker build\n        - name: Build image for Docker\n          run: docker build --tag &quot;registry.cn-hangzhou.aliyuncs.com/dmq00/test:0.0.2&quot;\n        - name: Push Image to ACR\n          run: docker push registry.cn-hangzhou.aliyuncs.com/dmq00/test:0.0.2\n</code></pre>\n<p>这样就能保证代码push到github上之后自动将镜像推送到docker镜像仓库，结合dockerfile文件就能保证使用docker镜像时自动执行命令，安装对应依赖并执行项目。</p>\n<p><strong>第二步详细流程分析，在服务器上部署对应的代码并且运行</strong></p>\n<ul>\n<li><p>checkout代码</p>\n</li>\n<li><p>创建.env文件，添加多个环境变量。(应用所有需要的环境变量)，github  secrets中添加。</p>\n</li>\n<li><p>创建文件夹，拷贝如下文件到文件夹内</p>\n<ul>\n<li>.env</li>\n<li>docker-compose-online.yml</li>\n<li>mongo-entrypoint文件夹</li>\n</ul>\n</li>\n<li><p>将新建的文件夹拷贝到服务器(SCP)当中</p>\n<ul>\n<li>使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlYm95L3NjcC1hY3Rpb24=\">https://github.com/appleboy/scp-action</span></li>\n</ul>\n</li>\n<li><p>SSH到服务器中</p>\n<ul>\n<li>进入拷贝的文件夹内</li>\n<li>登录阿里云ACR</li>\n<li>停止服务docker-compose down （第一次的话，没有启动也不会报错）</li>\n<li>启动服务docker-compose up</li>\n<li>清理工作可选，保证安全（删除.env文件，登出docker账户）</li>\n</ul>\n</li>\n</ul>\n<p><strong>后续过程需要完成：</strong></p>\n<ul>\n<li><p>在push tags的时候才触发对应的job</p>\n<p>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy9ldmVudHMtdGhhdC10cmlnZ2VyLXdvcmtmbG93cw==\">https://docs.github.com/cn/actions/learn-github-actions/events-that-trigger-workflows</span></p>\n</li>\n<li><p>怎样获取对应的每次提交相关的特殊信息</p>\n<p>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYWN0aW9ucy9sZWFybi1naXRodWItYWN0aW9ucy9jb250ZXh0cw==\">https://docs.github.com/en/actions/learn-github-actions/contexts</span></p>\n</li>\n<li><p>使用这个特殊信息，在对应的docker-compose-online.yml中进行替换，将要启动的版本替换为将要构建的版本。</p>\n</li>\n</ul>\n","categories":["复杂业务部署与优化"],"tags":["复杂业务部署与优化"]},{"title":"本地文件链接","url":"/2024/03/30/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/","content":"<h1 id=\"链接本地文件的方式\"><a href=\"#链接本地文件的方式\" class=\"headerlink\" title=\"链接本地文件的方式\"></a>链接本地文件的方式</h1><h3 id=\"npm-link\"><a href=\"#npm-link\" class=\"headerlink\" title=\"npm link\"></a>npm link</h3><p>1、带有package.json文件的文件夹内运行：npm link ，即可在用户全局中创建该文件夹的全局链接。</p>\n<p>2、在需要使用文件的地方执行：npm link  文件名，注意文件名是package.json中的name字段值。</p>\n<h3 id=\"file路径\"><a href=\"#file路径\" class=\"headerlink\" title=\"file路径\"></a>file路径</h3><p>在需要使用的package.json的dependence中添加：文件名：”file:  ….”，添加上file路径指向本地文件。</p>\n<h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><p>两种方式的区别在于如果项目较为简单，使用file:路径即可解决，但如果项目较为复杂，且文件包括文件地址需要不断移动时，使用npm  link的方式更好。</p>\n","categories":["脚手架开发"],"tags":["脚手架 cli"]},{"title":"架构风格","url":"/2024/07/29/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTQzMDY4MjA1MDY0I2hlYWRpbmctMA==\">推荐</span></p>\n<h1 id=\"分层架构\"><a href=\"#分层架构\" class=\"headerlink\" title=\"分层架构\"></a>分层架构</h1><h1 id=\"管道架构\"><a href=\"#管道架构\" class=\"headerlink\" title=\"管道架构\"></a>管道架构</h1><h1 id=\"复制风格\"><a href=\"#复制风格\" class=\"headerlink\" title=\"复制风格\"></a>复制风格</h1><h1 id=\"微内核架构\"><a href=\"#微内核架构\" class=\"headerlink\" title=\"微内核架构\"></a>微内核架构</h1><h1 id=\"微前端架构\"><a href=\"#微前端架构\" class=\"headerlink\" title=\"微前端架构\"></a>微前端架构</h1><h1 id=\"组件化架构\"><a href=\"#组件化架构\" class=\"headerlink\" title=\"组件化架构\"></a>组件化架构</h1>","categories":["架构风格"],"tags":["架构风格"]},{"title":"操作系统","url":"/2024/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"操作系统定义\"><a href=\"#操作系统定义\" class=\"headerlink\" title=\"操作系统定义\"></a>操作系统定义</h1><blockquote>\n<p>操作系统（Operating System）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件应用程序，同时也是计算机系统的内核和基石。<br>操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。</p>\n</blockquote>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><blockquote>\n<p>进程是：操作系统进行<code>资源分配</code>的基本单位</p>\n</blockquote>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><blockquote>\n<p>线程是：操作系统进行<code>资源调度</code>的基本单位</p>\n</blockquote>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><blockquote>\n<p>内存是：计算机的随机访问存储器（RAM），是计算机的主要存储资源之一，用于存储计算机运行时正在使用或即将使用的数据和指令。<br>内存具有：易失性（计算机关闭时内存中的数据会丢失）、访问速度快等特点</p>\n</blockquote>\n<h1 id=\"虚拟内存（地址空间）\"><a href=\"#虚拟内存（地址空间）\" class=\"headerlink\" title=\"虚拟内存（地址空间）\"></a>虚拟内存（地址空间）</h1><blockquote>\n<p>虚拟内存是：虚拟内存是操作系统对物理内存的抽象，是一种内存管理技术，允许操作系统将硬盘空间用作临时的RAM来使用<br>虚拟内存能够运行比物理内存更多的内存的程序，同时也为操作系统提供了更大的地址空间，虚拟内存的关键有：</p>\n</blockquote>\n<ul>\n<li>地址转换</li>\n<li>分页</li>\n<li>页面置换算法</li>\n<li>硬盘空间使用</li>\n<li>性能影响</li>\n<li>内存管理</li>\n</ul>\n<h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><blockquote>\n<p>文件是：操作系统对物理磁盘的抽象，是一个基本的数据存储单元，用于在计算机系统或存储设备上保存数据。</p>\n</blockquote>\n<h1 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h1><blockquote>\n<p>shell是：一个程序，可以从键盘中获取命令并将其提供给操作系统进行执行。</p>\n</blockquote>\n<h1 id=\"GUI\"><a href=\"#GUI\" class=\"headerlink\" title=\"GUI\"></a>GUI</h1><blockquote>\n<p>GUI是：一个用户界面，用户可以通过图形或图标指示符与电子设备进行交互</p>\n</blockquote>\n<h1 id=\"计算机架构\"><a href=\"#计算机架构\" class=\"headerlink\" title=\"计算机架构\"></a>计算机架构</h1><blockquote>\n<p>计算机架构是：计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法，主要包括：指令集、内存管理、I&#x2F;O和总线结构等。</p>\n</blockquote>\n<h1 id=\"多处理系统\"><a href=\"#多处理系统\" class=\"headerlink\" title=\"多处理系统\"></a>多处理系统</h1><blockquote>\n<p>多处理系统是：指计算机同时运行多个程序的能力。</p>\n</blockquote>\n<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><blockquote>\n<p>程序计数器是：一个CPU中的寄存器，用于指示计算机在其程序序列中的位置。</p>\n</blockquote>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><blockquote>\n<p>多线程是：指一个软件或硬件上实现多线程并发执行的技术。</p>\n</blockquote>\n<h1 id=\"CPU核心（core）\"><a href=\"#CPU核心（core）\" class=\"headerlink\" title=\"CPU核心（core）\"></a>CPU核心（core）</h1><blockquote>\n<p>CPU核心是：CPU的大脑，它接收指令，并执行计算或运算以满足这些指令，一个CPU可以有多个内核。</p>\n</blockquote>\n<h1 id=\"图形处理器（视觉处理器）\"><a href=\"#图形处理器（视觉处理器）\" class=\"headerlink\" title=\"图形处理器（视觉处理器）\"></a>图形处理器（视觉处理器）</h1><blockquote>\n<p>图形处理器是：</p>\n</blockquote>\n<h1 id=\"缓存命中\"><a href=\"#缓存命中\" class=\"headerlink\" title=\"缓存命中\"></a>缓存命中</h1><blockquote>\n<p>当应用程序或软件请求数据时，会首先发生缓存命中</p>\n</blockquote>\n<h1 id=\"RAM（随机存取存储器、主存）\"><a href=\"#RAM（随机存取存储器、主存）\" class=\"headerlink\" title=\"RAM（随机存取存储器、主存）\"></a>RAM（随机存取存储器、主存）</h1><blockquote>\n<p>RAM是：与CPU直接交换数据的内存存储器</p>\n</blockquote>\n<h1 id=\"ROM（只读存储器）\"><a href=\"#ROM（只读存储器）\" class=\"headerlink\" title=\"ROM（只读存储器）\"></a>ROM（只读存储器）</h1><blockquote>\n<p>ROM是：一助攻半导体存储器,特点是一旦存储数据就无法改变或删除</p>\n</blockquote>\n<h1 id=\"驱动程序\"><a href=\"#驱动程序\" class=\"headerlink\" title=\"驱动程序\"></a>驱动程序</h1><blockquote>\n<p>驱动程序是：一个允许高级别电脑软件与硬件交互的程序</p>\n</blockquote>\n<h1 id=\"USB\"><a href=\"#USB\" class=\"headerlink\" title=\"USB\"></a>USB</h1><blockquote>\n<p>USB是：连接计算机系统与外部设备的一种串口总线标准,也是一种输入输出接口的技术规范</p>\n</blockquote>\n<h1 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h1><blockquote>\n<p>地址空间是：内存中可供程序或进程使用的有效地址规范</p>\n</blockquote>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><blockquote>\n<p>进程间通信是：指至少两个进程或线程间传送数据或信号的一些技术或方法<br>进程间的通信方式有：管道、消息队列、共享内存、信号量、信号、套接字</p>\n</blockquote>\n<ul>\n<li>管道<br>管道一种半双工的通信方式，数据只能单向流动，管道实质上是一个内核缓冲区，且以先进先出的方式存取数据。<br>管道分为命名管道和匿名管道<br>匿名管道它的优点是：简单方便；缺点是：<br>因为管道局限于单向通信且缓冲区有限, 所以它的通信效率低, 不适合进程间频繁地交换数据<br>只能在父子进程间使用<br>命名管道，和匿名管道相比，它的优点是：可以实现任意关系的进程间的通信；缺点是：<br>长期存在系统中，使用不当容易出错</li>\n<li>消息队列<br>消息队列是保存在内核中的消息链表<br>优点：可以实现任意进程间的通信，并且通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题<br>缺点：<br>消息队列不适合比较大数据的传输，因为每个消息体都有最大长度限制，同时全体消息也有总长度上限<br>通信过程中，存在用户态与内核态之间的数据拷贝开销</li>\n<li>共享内存<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<br>优点：进程可以直接读写这块内存而不需要进行数据拷贝，提高效率<br>缺点：<br>多个进程同时修改同一个共享内存，会发生冲突<br>共享内存只能在同一计算机系统中共享</li>\n<li>信号量<br>信号量是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据<br>优点：信号量解决了止多进程竞争共享资源，而造成数据的错乱的<br>缺点：信号量有限</li>\n<li>信号<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>\n<li>套接字<br>套接字通信不仅可以跨网络与不同主机的进程通信，还可以在同主机进程通信<br>优点：<br>传输数据为字节级，传输数据可自定义<br>适合客户端和服务端之间信息实时交互<br>可以加密，数据安全性强<br>缺点：需对传输的数据进行解析，转化成应用级的数据</li>\n</ul>\n<h1 id=\"目录（文件夹）\"><a href=\"#目录（文件夹）\" class=\"headerlink\" title=\"目录（文件夹）\"></a>目录（文件夹）</h1><blockquote>\n<p>目录或文件夹是：指一个装有数字文件系统的虚拟容器</p>\n</blockquote>\n<h1 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h1><blockquote>\n<p>路径是：一种电脑文件或目录的名称的通用表现形式,它指向文件系统上的一个唯一位置</p>\n</blockquote>\n<h1 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a>根目录</h1><blockquote>\n<p>根目录是：</p>\n</blockquote>\n<h1 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h1><blockquote>\n<p>文件描述符是一个用于表述指向文件的引用的抽象化概念</p>\n</blockquote>\n<h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><blockquote>\n<p>客户端是:访问服务器提供的服务的计算硬件或软件</p>\n</blockquote>\n<h1 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h1><blockquote>\n<p>服务端是:为其他程序或设备提供功能的计算机程序或设备</p>\n</blockquote>\n","categories":["操作系统"],"tags":["操作系统"]},{"title":"正则表达式","url":"/2023/02/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><p>​          <strong>正则表达式是一个对象</strong></p>\n<p>正则表达式并不是JS独有的技术，基本上所有语言都支持这个技术</p>\n<p>正则表达式的目的也很单纯，核心作用就是验证数据的合法性</p>\n<p>正则表达式的特点：</p>\n<p>1、正则表达式在JS中只针对字符串起作用</p>\n<p>2、正则表达式会根据你设置的规则，对字符串进行 提取，搜索、替换 等操作</p>\n<p>3、JavaScript中正则表达式是一个内置对象，这个对象通过RegExp() 创建，也可以直接通过赋值一个正则表达式来创建</p>\n<p>第一种：</p>\n<pre><code class=\"javascript\">var reg = new RegExp(正则表达式)\n</code></pre>\n<p>第二种:</p>\n<pre><code class=\"javascript\">var reg = /张/\n</code></pre>\n<p>方法：</p>\n<p>1、test() 用于验证某一个字符串是否符合正则的规则</p>\n<pre><code class=\"javascript\">var str =&quot;abc&quot;;\nvar reg = /a/;\nreg.test(str);\n</code></pre>\n<p>2、exec（）根据正则表达式提取字符串中符合要求的字符，用法与上面类似，注意：正则表达式是可以添加修饰符的，这个修饰符会影响提取字符串的结果</p>\n<h4 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h4><p>1、g代表global全局验证</p>\n<p>2、i 代表忽略大小写</p>\n<p>3、m 代表多行的意思，也就是可以换行匹配</p>\n<h3 id=\"正则表达式的规则\"><a href=\"#正则表达式的规则\" class=\"headerlink\" title=\"正则表达式的规则\"></a>正则表达式的规则</h3><h4 id=\"一元符号\"><a href=\"#一元符号\" class=\"headerlink\" title=\"一元符号\"></a>一元符号</h4><p><code>.</code> 匹配除换行符以外的任意符号</p>\n<p><code>\\w</code> 匹配字符数字和下划线</p>\n<p><code>\\S</code>匹配任何空白符</p>\n<p><code>\\d</code> 匹配所有数字 ,与 [0-9]</p>\n<p><code>\\b</code> 匹配单词边界</p>\n<p><code>|</code> 或匹配</p>\n<p><code>^</code> 匹配字符串的开始</p>\n<p><code>$</code> 匹配字符串的结束</p>\n<h3 id=\"原子组和原子表\"><a href=\"#原子组和原子表\" class=\"headerlink\" title=\"原子组和原子表\"></a>原子组和原子表</h3><h4 id=\"原子表\"><a href=\"#原子表\" class=\"headerlink\" title=\"原子表 [ ]\"></a>原子表 [ ]</h4><pre><code class=\"javascript\">var reg = /^[张王赵]三$/\nconsole.log(reg.test(&quot;张三&quot;));                        //true\nconsole.log(reg.test(&quot;王三&quot;));                        //true\nconsole.log(reg.test(&quot;赵三&quot;));                        //true\nconsole.log(reg.test(&quot;李三&quot;));                        //false\nconsole.log(reg.test(&quot;张四&quot;));                        //false\nconsole.log(reg.test(&quot;张三ssss&quot;));                    //false\nconsole.log(reg.test(&quot;张ssss三&quot;));                    //false\n</code></pre>\n<p>原子表是用中括号的形式存在，它会从这个表中拿出一个进行条件匹配</p>\n<p>在原子表中，还可以写范围</p>\n<pre><code class=\"javascript\">var reg1 = /[0-9]/\nvar reg2 = /[a-z]/\nvar reg3 = /[A-Z]/\n</code></pre>\n<blockquote>\n<p>注意：原子表中的范围不能倒写，会报错</p>\n</blockquote>\n<h4 id=\"原子组\"><a href=\"#原子组\" class=\"headerlink\" title=\"原子组( )\"></a>原子组( )</h4><pre><code class=\"javascript\">var reg = /张三|王三|赵三/;\nvar reg2 = /(张|王|赵)三/    //原子组用小括号表示\n</code></pre>\n<h3 id=\"反义字符\"><a href=\"#反义字符\" class=\"headerlink\" title=\"反义字符\"></a>反义字符</h3><p>**在 [ ]中使用</p>\n<p>[^x]  匹配处理x以外的所有字符，这里的x可以是任意字符</p>\n<p>[^xyz] 同上，匹配除了xyz以外的字符</p>\n<p>\\W 匹配除字母、数字、下划线以外的所有字符，等同 <code>[^\\w]</code></p>\n<p>\\B 匹配不是单词边界的字符</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>\\xnn 匹配十六进制数</p>\n<p>\\f 匹配换页符</p>\n<p>\\n 匹配换行符</p>\n<p>\\r 匹配回车符</p>\n<p>\\unnnn 匹配unicode编码</p>\n<h3 id=\"重复匹配\"><a href=\"#重复匹配\" class=\"headerlink\" title=\"重复匹配\"></a>重复匹配</h3><p><code>*</code> 重复匹配零次或多次</p>\n<p><code>+</code> 重复匹配1次或多次</p>\n<p><code>?</code> 重复匹配0次或1次</p>\n<p><code>&#123;n&#125;</code>  重复匹配n次</p>\n<p><code>&#123;n,&#125;</code> 至少重复匹配n次</p>\n<p><code>&#123;m,n&#125;</code> 重复普配m到n次  m &lt; n</p>\n<pre><code class=\"javascript\">//我希望验证一个字符串，它是a开始，c结束，中间有4个英文字母。怎么写？\nvar reg = /^a[a-zA-Z]&#123;4&#125;c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间有4-6个数字。怎么写？\nvar reg1 = /^a\\d&#123;4,6&#125;c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间至少有4个数字。怎么写？\nvar reg2 = /^a\\d&#123;4,&#125;c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间至少有1个或多个数字。怎么写？\nvar reg3 = /^a\\d+c$/\n\n//我希望验证一个字符串，它是a开始，c结束，中间至少有0个或多个数字。怎么写？\nvar reg4 = /^a\\d*c$/\n\n//我希望验证一个字符串，它以三结束，以张开头，中间有0或1个字符\nvar reg5 = /^张.?三$/\n</code></pre>\n<h3 id=\"贪婪与惰性\"><a href=\"#贪婪与惰性\" class=\"headerlink\" title=\"贪婪与惰性\"></a>贪婪与惰性</h3><p>重复匹配默认都是按照贪婪的特性去匹配较多的次数，如果我们需要按照惰性特征来匹配</p>\n<p>我们可以把上面的多有的重复匹配符号后面加上一个 ？表示惰性匹配</p>\n<pre><code class=\"js\">var str = &quot;cawqdewfeffwerderwe&quot;;\n//我要提取c开始到d结束中间任意长度的字符串\nvar reg = /c[a-z]*d/;\nvar newStr = reg.exec(str);\n//这个时候我们的正则表达式处在贪婪模式下，它会执行贪婪（0到贪婪多次）\n\nvar reg = /c[a-z]*?d/;  //执行惰性重复匹配\n</code></pre>\n<h3 id=\"原子组编号：-n\"><a href=\"#原子组编号：-n\" class=\"headerlink\" title=\"原子组编号：\\n\"></a>原子组编号：\\n</h3><p>原子组通过（）形成一个分组，这个分组会给一个分组编号</p>\n<pre><code class=\"javascript\">var str = &quot;&lt;div&gt;&lt;/div&gt;&quot;;\n//现在希望通过正则验证这个标签\nvar reg = /&lt;[a-zA-Z]+&gt;&lt;\\/[a-zA-Z]+&gt;/;\n//上面的问题在于，我们希望开始标签和结束标签里面匹配到的是相同的字符\nvar flag = reg.test(str);\n</code></pre>\n<p>在上面的表达式中，我们表面上看起来是完成了功能，但是又有隐患，如果我们要匹配的字符串是 <code>&lt;div&gt;&lt;/span&gt;</code> 这样也会验证成功，但是不符合要求</p>\n<p>我们的主要需求是开始标签和结束标签要一致，我们开始匹配的内容 <code>&lt;[a-zA-Z]+&gt;</code> 要与后面匹配的 <code>&lt;\\/[a-zA-Z]+&gt;</code> 保持一致，这个时候我们就要用到原子组</p>\n<pre><code class=\"javascript\">var str = &quot;&lt;div&gt;&lt;/span&gt;&quot;;\n//现在希望通过正则验证这个标签\nvar reg1 = /&lt;[a-zA-Z]+&gt;&lt;\\/[a-zA-Z]+&gt;/;\n//上面的问题在于，我们希望开始标签和结束标签里面匹配到的是相同的字符\nvar flag1 = reg1.test(str);\n\nvar reg2 = /&lt;([a-zA-Z]+)&gt;&lt;\\/\\1&gt;/;\nvar flag2 = reg2.test(str);\n</code></pre>\n<h3 id=\"前瞻后顾-：（）语法\"><a href=\"#前瞻后顾-：（）语法\" class=\"headerlink\" title=\"前瞻后顾 ：（）语法\"></a>前瞻后顾 ：（）语法</h3><p>首先我们要弄清除两个条件</p>\n<blockquote>\n<p>1、你的匹配条件是什么</p>\n<p>2、你的限制条件是什么</p>\n</blockquote>\n<h4 id=\"前瞻\"><a href=\"#前瞻\" class=\"headerlink\" title=\"前瞻\"></a>前瞻</h4><p>匹配条件是A，限制条件是B，B要出现在A的后面</p>\n<pre><code>A(?=B)\n</code></pre>\n<p>如果要匹配abc并且abc要在123的前面</p>\n<pre><code class=\"javascript\">/abc(?=123)/g //全局匹配abc后面紧跟123\n\n//abc123  true\n//abc456  false\n//123abc  false\n</code></pre>\n<h4 id=\"负前瞻\"><a href=\"#负前瞻\" class=\"headerlink\" title=\"负前瞻\"></a>负前瞻</h4><p>匹配条件是A，限制条件是B，B不能出现在A的后面</p>\n<pre><code class=\"javascript\">/abc(?!123)/g\n</code></pre>\n<h4 id=\"后顾\"><a href=\"#后顾\" class=\"headerlink\" title=\"后顾\"></a>后顾</h4><p>匹配条件是A，限制条件是B，B要出现在A的前面</p>\n<pre><code class=\"javascript\">(?&lt;=B)A\n</code></pre>\n<p>要匹配abc并且abc要在123的后面</p>\n<pre><code class=\"javascript\">/(?&lt;=123)abc/g\n\n//abc123  false\n//abc456  false\n//123abc  true\n</code></pre>\n<h4 id=\"负后顾\"><a href=\"#负后顾\" class=\"headerlink\" title=\"负后顾\"></a>负后顾</h4><p>匹配条件是A，限制条件是B，B要不能出现在A的前面</p>\n<pre><code class=\"javascript\">(?&lt;!B)A\n</code></pre>\n<h3 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h3><p>如何匹配中文</p>\n<pre><code class=\"javascript\">var reg = /^[\\u4E00-\\u9FA5]&#123;2,4&#125;$/\n</code></pre>\n<h1 id=\"正则表达式（github）\"><a href=\"#正则表达式（github）\" class=\"headerlink\" title=\"正则表达式（github）\"></a>正则表达式（github）</h1><blockquote>\n<p>regular expression : RegExp</p>\n<p>用来处理字符串的规则</p>\n<ul>\n<li>只能处理字符串</li>\n<li>它是一个规则 : 可以验证字符串是否符合某个规则 (test) ，也可以把字符串中符合规则的内容捕获到 (exec &#x2F; match …)</li>\n</ul>\n</blockquote>\n<pre><code class=\"javascript\">let str = &quot;good good study, day day up! &quot;;\n//=&gt; 学正则就是用来制定规则 (是否包含数字)\nlet reg = /\\d+/;\nreg.test(str); //=&gt; false\n\nstr = &quot;2022-08-05&quot;;\nreg.exec(str); //=&gt;[&quot;2019&quot;,index:0,inputs:&quot;原始字符串&quot;]\n</code></pre>\n<h2 id=\"编写正则表达式\"><a href=\"#编写正则表达式\" class=\"headerlink\" title=\"编写正则表达式\"></a><strong>编写正则表达式</strong></h2><h3 id=\"创建方式有两种\"><a href=\"#创建方式有两种\" class=\"headerlink\" title=\"创建方式有两种\"></a>创建方式有两种</h3><pre><code class=\"javascript\">//=&gt;字面量创建方式 (两个斜杆之间包起来的，都是用来描述规则的元字符)\nlet reg1 = /\\d+/;\n\n//=&gt;构造函数模式创建  两个参数: 元字符字符串 , 修饰符字符串\nlet reg2 = new RegExp(&quot;\\\\d+&quot;);\n</code></pre>\n<p>正则表达式由两部分组成</p>\n<ul>\n<li>元字符</li>\n<li>修饰符</li>\n</ul>\n<pre><code class=\"javascript\">/*常用的元字符*/\n//=&gt;1.量词元字符: 设置出现的次数\n*  零到多次\n+  一到多次\n?  零次或者一次\n&#123;n&#125;  出现n次 (n需为0或者正整数)\n&#123;n,&#125;  出现n到多次\n&#123;n,m&#125;  出现n到m次 (包含n和m)\n\n//=&gt;2.特殊元字符: 单个或者组合在一起代表特殊的含义\n\\    转义字符(普通-&gt;特殊-&gt;普通)\n.    除\\n (换行符) 以外的任意字符\n^    以哪一个元字符作为开始\n$    以哪一个元字符作为结束\n\\n   换行符\n\\d   0~9之间的数字\n\\D   非0~9之间的数字 (大写和小写的意思是相反的)\n\\w   数字、字母、下划线中的任意一个字符\n\\s   一个空白字符 (包含空格、制表符、换页符等)\n\\t   一个制表符 (一个TAb键:四个空格)\n\\b   匹配一个单词的边界\nx|y  x或者y中的一个字符  (1|5|9)\n[xyz] x或者y或者z中的一个字符  [adghve2375]\n[^xy] 除了x/y以外的任意字符\n[a-z] 指定a-z这个范围中的任意字符  [0-9a-zA-Z_](0-9或者a-z或者A-Z或者_中的一个字符) === \\w\n[^a-z] 上一个取反&quot;非&quot;\n()    正则中的分组符号\n(?:)  只匹配不捕获\n(?=)  正向预查\n(?!)  负向预查\n\n//=&gt;3.普通元字符: 代表本身含义\n/jiangbing/ 此正则匹配的就是&quot;jiangbing&quot;\n</code></pre>\n<pre><code class=\"javascript\">/*正则表达式常用的修饰符: img*/\ni =&gt;ignoreCase  忽略单词大小写匹配\nm =&gt;multiline   可以进行多行匹配\ng =&gt;global      全局匹配\n\n/*\n *\t/A/.test(&#39;lalala&#39;); //=&gt;fasle\n *\t/A/i.test(&#39;lalala&#39;); //=&gt;true\n */\n</code></pre>\n<h3 id=\"元字符详细解析\"><a href=\"#元字符详细解析\" class=\"headerlink\" title=\"元字符详细解析\"></a><strong>元字符详细解析</strong></h3><p><code>^$</code></p>\n<pre><code class=\"javascript\">let reg = /^\\d/;\nconsole.log(reg.test(&quot;jiangbing&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;2022jiangbing&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;jiangbing2022&quot;)); //=&gt;false\n</code></pre>\n<pre><code class=\"javascript\">let reg = /\\d$/;\nconsole.log(reg.test(&quot;jiangbing&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;2022jiangbing&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;jiangbing2022&quot;)); //=&gt;true\n</code></pre>\n<pre><code class=\"javascript\">//=&gt;^/$两个都不加: 字符串中包含符合规则的内容即可\nlet reg = /\\d+/;\n//=^/$两个都加: 字符串只能是和规则一致的内容\nlet reg = /^\\d+$/;\n\n//=&gt;举个例子: 验证手机号码(11位，第一个数字是1即可)\nlet reg = /^1\\d&#123;10&#125;$/;\n</code></pre>\n<p><code>\\</code></p>\n<pre><code class=\"javascript\">//=&gt;.不是小数点，是除\\n外的任意字符\nlet reg = /^2.3$/;\nconsole.log(reg.test(&quot;2.3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2@3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;23&quot;)); //=&gt;fasle\n\n//=&gt;基于转义字符，让其只能代表小数点\nlet reg = /^2\\.3$/;\nconsole.log(reg.test(&quot;2.3&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2@3&quot;)); //=&gt;false\n\nlet str = &quot;\\\\d&quot;;\nreg = /^\\d$/;  //=&gt;\\d代表0-9的数字\nconsole.log(reg.test(&quot;str&quot;)); //=&gt;fasle\nreg = /^\\\\d$/;  //=&gt;把特殊符号转换为普通的\nconsole.log(reg.test(&quot;str&quot;)); //=&gt;true\n</code></pre>\n<p><code>x|y</code></p>\n<pre><code class=\"javascript\">let reg = /^18|29$/;\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;29&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;129&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;189&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;1829&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;829&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;182&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;82&quot;)); //=&gt;fasle\n\n//---直接x|y会存在很乱的优先级问题，一般我们写的时候都伴随着小括号进行分组，因为小括号改变处理的优先级 =&gt;小括号: 分组\nlet reg = /^(18|29)$/;\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;29&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;129&quot;)); //=&gt;fasle\nconsole.log(reg.test(&quot;189&quot;)); //=&gt;fasle\n//=&gt;只能是18或者29中的一个了\n</code></pre>\n<p><code>[]</code></p>\n<pre><code class=\"javascript\">//1.中括号中出现的字符一般都代表本身的含义\nlet reg = /^[@+]$/;\nconsole.log(reg.test(&quot;@&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;+&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;@@&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;@+&quot;)); //=&gt;false\n\nreg = /^[\\d]$/; //=&gt;\\d在中括号中还是0-9\nconsole.log(reg.test(&quot;d&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;\\\\&quot;)); //=&gt;false\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;true\n\nreg = /^[\\\\d]$/; //=&gt;\\d已经被\\转义\nconsole.log(reg.test(&quot;d&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;\\\\&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;false\n\n//2.中括号中不存在多位数\nreg = /^[18]$/;\nconsole.log(reg.test(&quot;1&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;8&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;18&quot;)); //=&gt;false\n\nreg = /^[10-29]$/; //=&gt;1或者0-2或者9\nconsole.log(reg.test(&quot;1&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;9&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;0&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;2&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;10&quot;)); //=&gt;false\n</code></pre>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a><strong>常用的正则表达式</strong></h3><p>1.验证是否为有效数字</p>\n<pre><code class=\"javascript\">/*\n *\t规则分析\n *\t\t1.可能出现 + - 号，也可能不出现  [+-]?\n *\t\t2.一位0-9都可以，多位首位不能为0  (\\d|([1-9]\\d+)\n *\t\t3.小数点部分可能有可能没有，一旦有后面必须有小数点+数字  (\\.\\d+)?\n */\nlet reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/;\n</code></pre>\n<p>2.验证密码</p>\n<pre><code class=\"javascript\">//=&gt;数字、字母、下划线\n//=&gt;6~16位\nlet val = userPassInp.value,\n    reg = /^\\w&#123;6,16&#125;$/;\nlet flag = reg.test(val);\n\n/*\nfunction checkPass(val)&#123;\n    if(val.length &lt;6 || val.length &gt;16)&#123;\n        alert(&#39;长度必须介于6-16位之间!&#39;);\n        retrun;\n    &#125;\n    let area = [&#39;a&#39;,&#39;b&#39;...&#39;_&#39;]; //=&gt;包含数字、字母、下划线\n    for(let i=0;i&lt;val.length;i++)&#123;\n        let char = val[i];\n        if(!area.includes(char))&#123;\n            alert(&quot;格式不正确&quot;);\n            return;\n        &#125;\n    &#125;\n&#125;\n*/\n</code></pre>\n<p>3.验证真实姓名</p>\n<pre><code class=\"javascript\">/*\n *\t1.验证汉字  /^[\\u4E00-\\u9FA5]$/\n *\t2.名字长度 2~10位\n *\t3.可能有译名 ·汉字  (·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;\n */\nlet reg = /^[\\u4E00-\\u9FA5]&#123;2,10&#125;(·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;$/;\n</code></pre>\n<p>4.验证邮箱</p>\n<pre><code class=\"javascript\">let reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/;\n\n//=&gt; \\w+((-\\w+)|(\\.\\w+))*\n// 1.开头是数字字母下划线 (1到多位)\n// 2.还可以是 &quot;-数字字母下划线 或者 .数字字母下划线&quot;，整体零到多次\n// 邮箱的名字由&quot;数字、字母、下划线、-、.&quot;几部分组成，但是-/.不能连续出现也不能作为开始\n\n//=&gt; @[A-Za-z0-9]+\n// 1.@后面紧跟着: 数字、字母 (1-多位)\n\n//=&gt; ((\\.|-)[A-Za-z0-9]+)*\n// 1.对@后面名字的补充\n// 多域名   .com.cn\n// 企业域名  zxt@zhufeng-peixun-office.com\n\n//=&gt; \\.[A-Za-z0-9]+\n// 1. @xxx.com / @xxx.cn 这个匹配的是最后的域名 (.com/.cn/.org/.edu/.net/.vip...)\n</code></pre>\n<p>5.身份证号码</p>\n<pre><code class=\"javascript\">/*\n *\t1.一共18位\n *\t2.最后一位可能是X\n *\n *\t身份证前六位: 省市县 130828\n *\t中间八位: 年月日\n *\t最后四位:\n *\t\t最后一位 =&gt; X或者数字\n *\t\t倒数第二位 =&gt; 偶数 女  奇数 男\n *\t\t其余的是经过算法算出来的\n */\n//let reg = /^\\d&#123;17&#125;(\\d|X)$/;\n//=&gt;小括号分组的第二个作用: 分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容\nlet reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(\\d|X)$/;\nreg.exec(&quot;130828199012040617&quot;);//=&gt;[&#39;130828199012040617&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, &#39;7&#39;, index: 0, input: &#39;130828199012040617&#39;, groups: undefined] 捕获结果是一个数组，包含每一个小分组单独获取的内容\n</code></pre>\n<p><strong>正则两种创建方式的区别</strong></p>\n<pre><code class=\"javascript\">//=&gt;构造函数因为传递的是字符串，\\需要写两个才代表斜杆\nlet reg = /\\d+/g;\nreg = new RegExp(&quot;\\\\d+&quot;,&quot;g&quot;);\n\n//=&gt;正则表达式中的部分内容是变量存储的值\n// 1.两个斜杆中间包起来的都是元字符 (如果正则中要包含某个变量的值，则不能使用字面量方式创建)\nlet type = &#39;zhufeng&#39;;\nreg = /^@&quot;+type+&quot;@$/;\nconsole.log(reg.test(&quot;@zhufeng@&quot;)); //=&gt;false\nconsole.log(reg.test(&#39;@&quot;&quot;&quot;typeeee&quot;@&#39;)); //=true\n// 2.这种情况只能使用构造函数方式(因为它传递的规则是字符串，只有这样才能进行字符拼接)\nreg = new RegExp(&quot;^@&quot;+type+&quot;@$&quot;);\nconsole.log(reg.test(&quot;@zhufeng@&quot;)); //=&gt;true\n</code></pre>\n<hr>\n<h2 id=\"正则的捕获\"><a href=\"#正则的捕获\" class=\"headerlink\" title=\"正则的捕获\"></a><strong>正则的捕获</strong></h2><blockquote>\n<p>实现正则捕获的办法</p>\n<ul>\n<li>正则RegExp.prototype上的方法<ul>\n<li>exec</li>\n<li>test</li>\n</ul>\n</li>\n<li>字符串String.prototype上支持正则表达式处理的方法<ul>\n<li>replace</li>\n<li>match</li>\n<li>splite</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"javascript\">let str = &quot;zhufeng2022yangfan2023qihang2024&quot;;\nlet reg = /\\d+/;\n/*\n *\t基于exec实现正则的捕获\n *\t\t1.捕获到的结果是null或者一个数组\n *\t\t\t数组第一项: 本次捕获到的内容\n *\t\t\t其余项: 对应小分组本次单独捕获的内容\n *\t\t\tindex: 当前捕获内容在字符串中的起始索引\n *\t\t\tinput: 原始字符串\n *\t\t2.每执行一次exec，只能捕获到一个符合正则规则的，但是默认情况下，我们执行100遍，获取的结果永远都是第一个匹配到的，其余的捕获不到\n *\t\t=&gt;&quot;正则捕获的懒惰性&quot;: 默认只捕获第一个\n */\nconsole.log(reg.exec(str)); //=&gt;[&#39;2022&#39;, index: 7, input: &#39;zhufeng2022yangfan2023qihang2023&#39;]\n\n/*\n//=&gt;实现正则捕获的前提是: 当前正则要和字符串匹配，如果不匹配捕获的结果是null\nlet reg = /^\\d+$/;\nconsole.log(reg.test(str)); //=&gt;fasle\nconsole.log(reg.exec(str)); //=&gt;null\n</code></pre>\n<h3 id=\"懒做性的解决办法\"><a href=\"#懒做性的解决办法\" class=\"headerlink\" title=\"懒做性的解决办法\"></a>懒做性的解决办法</h3><pre><code class=\"javascript\">let str = &quot;zhufeng2022yangfan2023qihang2024&quot;;\nlet reg = /\\d+/;\n/* \n *  reg.lastIndex: 当前正则下一次匹配的起始索引位置\n *  懒惰性捕获的原因: 默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个\n *  解决办法: 全局修饰符g\n */\n/* console.log(reg.lastIndex); //=&gt;0 下面匹配捕获是从str索引零的位置开始找\n   console.log(reg.exec(str));\n   console.log(reg.lastIndex); //=&gt;0 第一次匹配捕获完成，lastIndex没有改变，所以下一次exec依然是从字符串最开始找，找到的永远是第一个匹配到的 \n */\n\n/* reg = /\\d+/g;\n   console.log(reg.exec(str)); //=&gt;[&quot;2022&quot;...]\n   console.log(reg.lastIndex); //=&gt;11 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改\n   console.log(reg.exec(str)); //=&gt;[&quot;2023&quot;...]\n   console.log(reg.lastIndex); //=&gt;22\n   console.log(reg.exec(str)); //=&gt;[&quot;2024&quot;...]\n   console.log(reg.lastIndex); //=&gt;32\n   console.log(reg.exec(str)); //=&gt;null  当全部捕获后，再次捕获的结果是null，但是lastIndex又回归了初始值零，再次捕获又从第一个开始了...\n   console.log(reg.lastIndex); //=&gt;0\n   console.log(reg.exec(str)); //=&gt;[&quot;2019&quot;...] \n */\n\n/* reg = /\\d+/g;\n   if (reg.test(str)) &#123;\n           //=&gt;验证一下: 只有正则和字符串匹配我们再捕获\n        console.log(reg.lastIndex); //=&gt;11  基于test匹配验证后，lastIndex已经被修改为第一次匹配后的结果，所以下一次捕获不再从头开始\n        console.log(reg.exec(str)); //=&gt;[&quot;2023&quot;...]\n    &#125; \n */\n\n\n//=&gt;需求: 编写一个execAll，执行一次可以把所有匹配的结果捕获到 (前提正则一定要设置全局修饰符g)\n~ function() &#123;\n    function execAll(str = &quot;&quot;) &#123;\n        //=&gt;str: 需要匹配的字符串\n        //=&gt;this: RegExp的实例 (当前操作的正则)\n        //=&gt;进来后第一件事，是验证当前正则是否设置了g，不设置则不能在进行循环捕获了，否则会导致死循环\n        if (!this.global) return this.exec(str);\n        //=&gt;ary存储最后所有捕获的信息   res存储每一次捕获的内容\n        let ary = [],\n            res = this.exec(str);\n        while (res) &#123;\n            //=&gt;把每一次捕获的内容res[0]存放到数组中\n            ary.push(res[0]);\n            //=&gt;只要捕获的内容不为null，则继续捕获下去\n            res = this.exec(str);\n\n        &#125;\n        return ary.length === 0 ? null : ary;\n    &#125;\n    RegExp.prototype.execAll = execAll;\n&#125;();\n\nreg = /\\d+/g;\nconsole.log(reg.execAll(str));\n//=&gt;字符串中的match方法，可以在执行一次的情况下，捕获到所有匹配的数据 (前提: 正则也得设置g才可以)\nconsole.log(str.match(reg));\n</code></pre>\n<h3 id=\"正则的分组捕获\"><a href=\"#正则的分组捕获\" class=\"headerlink\" title=\"正则的分组捕获\"></a>正则的分组捕获</h3><pre><code class=\"javascript\">//=&gt;身份证号码\nlet str = &quot;130828199012040112&quot;;\nlet reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(?:\\d|X)$/;\nconsole.log(reg.exec(str)); //=&gt;[&#39;130828199012040112&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, index: 0, input: &#39;130828199012040112&#39;]\nconsole.log(str.match(reg)); //=&gt;[&#39;130828199012040112&#39;, &#39;130828&#39;, &#39;1990&#39;, &#39;12&#39;, &#39;04&#39;, &#39;1&#39;, index: 0, input: &#39;130828199012040112&#39;]\n//=&gt;第一项: 大正则匹配的结果\n//=&gt;其余项: 每一个小分组单独匹配捕获的结果\n//=&gt;如果设置了分组 (改变优先级)，但是捕获的时候不需要单独捕获，可以基于?:来处理\n</code></pre>\n<pre><code class=\"javascript\">//=&gt;既要捕获到&#123;数字&#125;，也想单独的把数字也获取到，例如:第一次找到&#123;0&#125; 还需单独获取0\nlet str = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;;\n\n/*\n    //=&gt;不设置g只匹配一次，exec和match获取的结果一致 (既有大正则匹配的信息，也有小分组匹配的信息)\n    let reg = /\\&#123;(\\d+)\\&#125;/;\n    console.log(reg.exec(str)); //=&gt;[&#39;&#123;0&#125;&#39;,&#39;0&#39;,...]\n    console.log(str.match(reg)); //=&gt;[&#39;&#123;0&#125;&#39;,&#39;0&#39;,...]\n*/\n\nlet reg = /\\&#123;(\\d+)\\&#125;/g;\n//console.log(str.match(reg)); //=&gt; [&#39;&#123;0&#125;&#39;, &#39;&#123;1&#125;&#39;, &#39;&#123;2&#125;&#39;]\t 多次匹配的情况下，match只能把大正则匹配的内容获取到，小分组匹配的信息无法获取\nlet aryBig = [],\n    arySmall = [],\n    res = reg.exec(str);\nwhile(res)&#123;\n    let [big,small] = res;\n    aryBig.push(big);\n    arySmall.push(small);\n    res = reg.exec(str);\n&#125;\nconsole.log(aryBig,arySmall); //=&gt;[&#39;&#123;0&#125;&#39;, &#39;&#123;1&#125;&#39;, &#39;&#123;2&#125;&#39;] (3) [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]\n</code></pre>\n<pre><code class=\"javascript\">//=&gt;分组的第三个作用: &quot;分组引用&quot;\nlet str = &quot;book&quot;; //=&gt;&quot;good&quot;、&quot;look&quot;、&quot;moon&quot;、&quot;foot&quot;...\nlet reg = /^[a-zA-Z]([a-zA-Z])\\1[a-zA-Z]$/; //=&gt;分组引用就是通过&quot;\\数字&quot;让其代表和对应分组出现一模一样的内容\nconsole.log(reg.test(&quot;book&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;deep&quot;)); //=&gt;true\nconsole.log(reg.test(&quot;some&quot;)); //=&gt;false\n</code></pre>\n<h3 id=\"正则捕获的贪婪性\"><a href=\"#正则捕获的贪婪性\" class=\"headerlink\" title=\"正则捕获的贪婪性\"></a>正则捕获的贪婪性</h3><pre><code class=\"javascript\">let str = &quot;珠峰2022@2023培训&quot;;\n//=&gt;正则捕获的贪婪性: 默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的\nlet reg = /\\d+/g;\nconsole.log(str.match(reg)); //=&gt;[&quot;2019&quot;,&quot;2022&quot;]\n\n//=&gt;在量词元字符后面设置? : 取消捕获时候的贪婪性 (按照正则匹配的最短结果来获取) \nreg = /\\d+?/g;\nconsole.log(str.match(reg)); //=&gt;[&#39;2&#39;, &#39;0&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;0&#39;, &#39;2&#39;, &#39;3&#39;]\n</code></pre>\n<p><code>?\t问号在正则中的五大作用</code></p>\n<ul>\n<li>问号左边是非量词元字符 : 本身代表量词元字符，出现零到一次</li>\n<li>问号左边是量词元字符 : 取消捕获时候的贪婪性</li>\n<li>(?:) 只匹配不捕获</li>\n<li>(?&#x3D;) 正向预查</li>\n<li>(?!) 负向预查</li>\n</ul>\n<h3 id=\"其他正则捕获的方法\"><a href=\"#其他正则捕获的方法\" class=\"headerlink\" title=\"其他正则捕获的方法\"></a>其他正则捕获的方法</h3><p>1.test也能捕获 (本意是匹配)</p>\n<pre><code class=\"javascript\">let str = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;;\nlet reg = /\\&#123;(\\d+)\\&#125;/g;\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;0&quot;\n\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;1&quot;\n\nconsole.log(reg.test(str)); //=&gt;true\nconsole.log(RegExp.$1); //=&gt;&quot;2&quot;\n\nconsole.log(reg.test(str)); //=&gt;fasle\nconsole.log(RegExp.$1); //=&gt;&quot;2&quot;\t存储的是上次捕获的结果\n\n//=&gt;RegExp.$1~RegExp.$9: 获取当前本次正则匹配后，第一个到第九个分组的信息\n</code></pre>\n<p>2.replace 字符串中实现替换的方法 (一般都是伴随正则一起使用的)</p>\n<pre><code class=\"javascript\">let str = &quot;zhufeng@2022|zhufeng@2023&quot;;\n//=&gt;把&quot;zhufeng&quot;替换成&quot;珠峰&quot;\n// 1.不用正则，执行一次只能替换一个\nstr = str.replace(&quot;zhufeng&quot;,&quot;珠峰&quot;).replace(&quot;zhufeng&quot;,&quot;珠峰&quot;);\nconsole.log(str); //=&gt;&quot;珠峰@2022|珠峰@2023&quot;\n\n// 2.使用正则会简单点\nstr = str.replace(/zhufeng/g,&quot;珠峰&quot;);\nconsole.log(str); //=&gt;&quot;珠峰@2022|珠峰@2023&quot;\n</code></pre>\n<pre><code class=\"javascript\">let str = &quot;zhufeng@2022|zhufeng@2023&quot;;\n//=&gt;把&quot;zhufeng&quot;替换成&quot;zhufengpeixun&quot;\nstr = str.replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;).replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;);\nconsole.log(str); //=&gt;&quot;zhufengpeixunpeixun@2022|zhufeng@2023&quot; 每一次替换都是从字符串第一个位置开始找的 (类似于正则捕获的懒惰性)\n\n//=&gt;基于正则g可以实现\nstr = str.replace(/zhufeng/g,&quot;zhufengpeixun&quot;);\nconsole.log(str); //=&gt;&quot;zhufengpeixun@2022|zhufengpeixun@2023&quot;\n</code></pre>\n<p><strong>案例 : 把时间字符串进行处理</strong> </p>\n<pre><code class=\"javascript\">let time = &quot;2022-08-09&quot;;\n//=&gt;变为&quot;2022年08月09日&quot;\nlet reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;\n\n//=&gt;这样可以实现\n//time = time.replace(reg,&quot;$1年$2月$3日&quot;);\n//console.log(time); //=&gt;&quot;2022年08月09日&quot;\n\n//=&gt;还可以这样处理 [str].replace([reg],[function])\n// 1.首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行几次 (而且是匹配一次就执行一次)\n// 2.不仅把方法执行，而且replace还给方法传递了实参信息 (和exec捕获的内容一致的信息: 大正则匹配的内容，小分组匹配的信息....)\n// 3.在函数中我们返回的是啥，就把当前大正则匹配的内容替换成啥\n/*\n    time = time.replace(reg,(big,$1,$2,$3)=&gt;&#123;\n        //=&gt;这里的$1~$3是我们自己设置的变量\n        console.log(big,$1,$2,$3); //=&gt;&quot;2022-08-09 2022 08 09&quot;\n    &#125;);\n */\ntime = time.replace(reg,(...arg)=&gt;&#123; \n    console.log(arg);\n    let  [,$1,$2,$3] = arg;\n    $2.length&lt;2 ? $2=&quot;0&quot;+$2 : null;\n    $3.length&lt;2 ? $3=&quot;0&quot;+$3 : null;\n    return $1+&quot;年&quot;+$2+&quot;月&quot;+$3+&quot;日&quot;;\n&#125;); \n</code></pre>\n<p><strong>单词首字母大写</strong></p>\n<pre><code class=\"javascript\">let str = &quot;good good study, day day up! &quot;;\nlet reg = /\\b([a-zA-Z])[a-zA-Z]*\\b/g;\n//=&gt;函数被执行了六次，每一次都把正则匹配信息传递给函数\n//=&gt;每一次arg: [&#39;good&#39;,&#39;g&#39;] [&#39;good&#39;,&#39;g&#39;] [&#39;good&#39;,&#39;g&#39;] [&#39;study&#39;,&#39;s&#39;]...\nstr = str.replace(reg,(...arg)=&gt;&#123;\n    let [content,$1] = arg;\n    $1 = $1.toUpperCase();\n    content = content.substring(1);\n    return $1 + content;\n&#125;);\nconsole.log(str); //=&gt;&quot;Good Good Study, Day Day Up! &quot;\n</code></pre>\n<p><strong>验证一个字符串中哪个字母出现的次数最多，多少次?</strong></p>\n<pre><code class=\"javascript\">let str = &quot;zhufengpeixunzhoulaoshi&quot;;\n\n/*\n *\t去重思维\n */\nlet obj = &#123;&#125;;\n[].forEach.call(str,char=&gt;&#123;\n    if(typeof obj[char] !== &quot;undefined&quot;)&#123;\n        obj[char++];\n        return;\n    &#125;\n    obj[char] = 1; \n&#125;);\nconsole.log(obj);let obj = &#123;&#125;;\n[].forEach.call(str, char =&gt; &#123;\n    if (typeof obj[char] !== &quot;undefined&quot;) &#123;\n        obj[char]++;\n        return;\n    &#125;\n    obj[char] = 1;\n&#125;);\nlet max = 1,\n    res = [];\nfor (let key in obj) &#123;\n    let item = obj[key];\n    item &gt; max ? max = item : null;\n&#125;\nfor (let key in obj) &#123;\n    let item = obj[key];\n    if (item === max) &#123;\n        res.push(key);\n    &#125;\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n\n/*\n *\t排序\n */\nstr = str.split(&#39;&#39;).sort((a, b) =&gt; a.localeCompare(b)).join(&#39;&#39;);\n//console.log(str); //=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;\nlet reg = /([a-zA-Z])\\1+/g;\nlet ary = str.match(reg); //=&gt;[&#39;ee&#39;, &#39;hhh&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;oo&#39;, &#39;uuu&#39;, &#39;zz&#39;]\nary.sort((a, b) =&gt; b.length - a.length);\nconsole.log(ary); //=&gt;[&#39;hhh&#39;, &#39;uuu&#39;, &#39;ee&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;oo&#39;, &#39;zz&#39;]\nlet max = ary[0].length,\n    res = [ary[0].substr(0, 1)];\nfor (let i = 1; i &lt; ary.length; i++) &#123;\n    let item = ary[i];\n    if (item.length &lt; max) &#123;\n        break;\n    &#125;\n    res.push(item.substr(0, 1));\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n\n/*\n *\t正则\n */\nlet max = 0,\n    res = [],\n    flag = false;\nstr = str.split(&#39;&#39;).sort((a, b) =&gt; a.localeCompare(b)).join(&#39;&#39;);\n// console.log(str); //=&gt;&quot;aeefghhhiilnnoopsuuuxzz&quot;\nfor (let i = str.length; i &gt; 0; i--) &#123;\n    let reg = new RegExp(&quot;([a-zA-Z])\\\\1&#123;&quot; + (i - 1) + &quot;&#125;&quot;, &quot;g&quot;);\n    // i=3  /([a-zA-Z])\\1&#123;2&#125;/  &quot;hhh&quot; &quot;uuu&quot;\n    str.replace(reg, (content, $1) =&gt; &#123;\n        res.push($1);\n        max = i;\n        flag = true;\n    &#125;);\n    if (flag) break;\n&#125;\nconsole.log(`出现次数最多的字符是:$&#123;res&#125;，出现了$&#123;max&#125;次`); //=&gt;出现次数最多的字符是:h,u，出现了3次\n</code></pre>\n<p><strong>时间字符串格式化</strong></p>\n<pre><code class=\"javascript\">~ function() &#123;\n    /* \n     *  formatTime: 时间字符串的格式化处理\n     */\n    /* function formatTime() &#123;\n        // 1.首先获取时间字符串中的年月日等信息\n        let timeAry = this.match(/\\d+/g);\n        // console.log(timeAry)//[&#39;2022&#39;, &#39;8&#39;, &#39;10&#39;, &#39;16&#39;, &#39;00&#39;, &#39;43&#39;]\n        let template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;;\n        template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (content, $1) =&gt; &#123;\n            //=&gt;content: 当前本次大正则匹配的信息   $1: 本次小分组单独匹配的信息\n            //以$1的值作为索引，到timeAry中找到对应的时间 (如果没有则用&quot;00&quot;补)\n            let time = timeAry[$1] || &quot;00&quot;;\n            time.length &lt; 2 ? time = &quot;0&quot; + time : null;\n            return time;\n        &#125;)\n        return template;\n    &#125;*/\n    //=&gt;简化版本\n    /* \n     *  formatTime: 时间字符串的格式化处理\n     *  @params\n     *      template: [string] 我们最后期望获取日期格式的模板\n     *      模板规则: &#123;0&#125;-&gt;年  &#123;1~5&#125;-&gt;月日时分秒\n     *  @return\n     *      [string]格式化后的时间字符串\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function formatTime(template = &quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;) &#123;\n        let timeAry = this.match(/\\d+/g);\n        return template = template.replace(/\\&#123;(\\d+)\\&#125;/g, (...[, $1]) =&gt; &#123;\n            let time = timeAry[$1] || &quot;00&quot;;\n            return time.length &lt; 2 ? time = &quot;0&quot; + time : time;\n        &#125;);\n    &#125;\n\n    /* 扩展到内置类String.prototype上 */\n    [&quot;formatTime&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\n\n//=&gt;服务器获取的\n// &quot;2022-8-10 16:00:43&quot;\n// &quot;2022/8/10 16:00:43&quot;\n// &quot;2022/8/10&quot;\n//=&gt;想要转变为的格式\n// &quot;08月10日 16时00分&quot;\n// &quot;2022年8月10日&quot;\n// ...\nlet time = &quot;2022-8-10 16:00:43&quot;;\nconsole.log(time.formatTime()); //=&gt;2022年08月10日 16时00分43秒\nconsole.log(time.formatTime(&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;)); //=&gt;2022年08月10日\nconsole.log(time.formatTime(&quot;&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;&quot;)); //=&gt;08-10 16:00\ntime = &quot;2022/8/13&quot;;\nconsole.log(time.formatTime()); //=&gt;2022年08月13日 00时00分00秒\nconsole.log(time.formatTime(&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&quot;)); //=&gt;2022年08月13日\nconsole.log(time.formatTime(&quot;&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;&quot;)); //=&gt;08-13 00:00\n</code></pre>\n<p><em><strong>queryURLParams</strong></em></p>\n<pre><code class=\"javascript\">~ function() &#123;\n    /* \n     *  queryURLParams: 获取URl地址问号和后面的参数信息 (可能也包含HASH值)\n     *  @params   \n     *  @return\n     *      [object]把所有问号参数信息以键值对的方式存储起来并且返回\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function queryURLParams() &#123;\n        let obj = &#123;&#125;;\n        this.replace(/([^?=&amp;#]+)=([^?=&amp;#]+)/g, (...[, $1, $2]) =&gt; obj[$1] = $2);\n        this.replace(/#([^?=&amp;#]+)/g, (...[, $1]) =&gt; obj[&#39;HASH&#39;] = $1);\n        return obj;\n    &#125;\n    \n    /* 扩展到内置类String.prototype上 */\n    [&quot;queryURLParams&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\nlet url = &quot;http://www.zhufengpeixun.cn/?lx=1&amp;from=wx#video&quot;;\nconsole.log(url.queryURLParams()); //=&gt;&#123;lx: &#39;1&#39;, from: &#39;wx&#39;, HASH: &#39;video&#39;&#125;\n</code></pre>\n<p><strong>千分符</strong></p>\n<pre><code class=\"javascript\">~ function() &#123;\n    /* \n     *  millimeter: 实现大数字的千分符处理\n     *  @params    \n     *  @return\n     *      [string]千分符后的字符串\n     *  by 江冰 on 2022-8-10 16:33:43\n     */\n    function millimeter() &#123;\n        return this.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, content =&gt; content + &#39;,&#39;);\n    &#125;\n\n    /* 扩展到内置类String.prototype上 */\n    [&quot;millimeter&quot;].forEach(item =&gt; &#123;\n        String.prototype[item] = eval(item);\n    &#125;);\n&#125;();\nlet num = &quot;15628954&quot;; //=&gt;&quot;15,628,954&quot; 千分符\nconsole.log(num.millimeter()); //=&gt;&quot;15,628,954&quot;\n\n// 把字符串倒过来\nnum = num.split(&#39;&#39;).reverse().join(&#39;&#39;);\nfor (let i = 2; i &lt; num.length - 1; i += 4) &#123;\n    let prev = num.substring(0, i + 1),\n        next = num.substring(i + 1);\n    num = prev + &quot;,&quot; + next;\n&#125;\nnum = num.split(&#39;&#39;).reverse().join(&#39;&#39;);\nconsole.log(num); //=&gt;&quot;15,628,954&quot;\n</code></pre>\n<h1 id=\"常用的正则表达式-1\"><a href=\"#常用的正则表达式-1\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h1><pre><code class=\"javascript\">//正整数\n/^[0-9]*[1-9][0-9]*$/;\n//负整数\n/^-[0-9]*[1-9][0-9]*$/;\n//正浮点数\n/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;\n//负浮点数\n/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/;\n//浮点数\n/^(-?\\d+)(\\.\\d+)?$/;\n//email地址\n/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;\n//url地址\n/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;\n或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&#39;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$\n//年/月/日（年-月-日、年.月.日）\n/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;\n//匹配中文字符\n/[\\u4e00-\\u9fa5]/;\n//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)\n/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;\n//匹配空白行的正则表达式\n/\\n\\s*\\r/;\n//匹配中国邮政编码\n/[1-9]\\d&#123;5&#125;(?!\\d)/;\n//匹配身份证\n/\\d&#123;15&#125;|\\d&#123;18&#125;/;\n//匹配国内电话号码\n/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;\n//匹配IP地址\n/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;\n//匹配首尾空白字符的正则表达式\n/^\\s*|\\s*$/;\n//匹配HTML标记的正则表达式\n&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;\n//sql 语句\n^(select|drop|delete|create|update|insert).*$\n//提取信息中的网络链接\n(h|H)(r|R)(e|E)(f|F) *= *(&#39;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#39;|&quot;| *|&gt;)?\n//提取信息中的邮件地址\n\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\n//提取信息中的图片链接\n(s|S)(r|R)(c|C) *= *(&#39;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#39;|&quot;| *|&gt;)?\n//提取信息中的 IP 地址\n(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\n//取信息中的中国手机号码\n(86)*0*13\\d&#123;9&#125;\n//提取信息中的中国邮政编码\n[1-9]&#123;1&#125;(\\d+)&#123;5&#125;\n//提取信息中的浮点数（即小数）\n(-?\\d*)\\.?\\d+\n//提取信息中的任何数字\n(-?\\d*)(\\.\\d+)?\n//电话区号\n^0\\d&#123;2,3&#125;$\n//腾讯 QQ 号\n^[1-9]*[1-9][0-9]*$\n//帐号（字母开头，允许 5-16 字节，允许字母数字下划线）\n^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$\n//中文、英文、数字及下划线\n^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$\n</code></pre>\n","categories":["正则表达式"],"tags":["正则表达式"]},{"title":"浏览器渲染原理","url":"/2023/10/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","content":"<h1 id=\"浏览器渲染原理\"><a href=\"#浏览器渲染原理\" class=\"headerlink\" title=\"浏览器渲染原理\"></a>浏览器渲染原理</h1><p>过程包含<code>渲染进程</code>（主线程、合成线程、线程池）、<code>预解析进程</code>和<code>网络进程</code></p>\n<h2 id=\"解析HTML\"><a href=\"#解析HTML\" class=\"headerlink\" title=\"解析HTML\"></a>解析HTML</h2><blockquote>\n<p>浏览器会开辟渲染进程、预解析进程和网络线程，预解析进程快速扫描并交给网络线程加载js和css文件，渲染进程会解析HTML字符串，解析成DOM树和CSSOM树这种容易操作的对象，也给JS提供了操作这两颗树的能力（document.body和document.styleSheets）。预解析进程加载和执行JS代码时，渲染进程会被阻塞，因为JS代码可能会操作DOM树和CSSOM树<br>解析HTML的结果是得到DOM树和CSSOM树。</p>\n</blockquote>\n<h2 id=\"样式计算\"><a href=\"#样式计算\" class=\"headerlink\" title=\"样式计算\"></a>样式计算</h2><blockquote>\n<p>得到DOM树和CSSOM树之后，还需要知道每个DOM对应的样式，<code>渲染进程的主线程</code>会遍历DOM中的每个节点，并计算他最终的样式，称之为<code>Computed Style</code>，也叫做合并<code>DOM树</code>和<code>CSSOM树</code>为<code>渲染树</code><br>样式计算的结果是得到一颗<code>渲染树</code>，这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb</code>，<code>相对单位</code>会变成<code>绝对单位</code></p>\n</blockquote>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><blockquote>\n<p>布局阶段会遍历DOM树的每一个节点，计算每个节点的几何信息（节点的宽高、相对于包含块的位置）最后生成<code>布局树</code>，由于<code>display:none</code>、<code>匿名行盒</code>、<code>匿名块盒</code>的原因，导致<code>DOM树</code>和<code>布局树</code>不是一一对应的<br>布局的结果是创建<code>布局树</code></p>\n</blockquote>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><blockquote>\n<p>主线程会使用一套复杂的策略对<code>布局树</code>进行分层，分层的好处在于将来改变一个层之后，仅会对该层进行后续处理，从而提升效率。<code>滚动条</code>、<code>transform</code>、<code>opacity</code>、<code>will-change</code>等都会影响分层的结果<br>分层的结果是分层了<code>布局树</code></p>\n</blockquote>\n<h2 id=\"生成绘制指令\"><a href=\"#生成绘制指令\" class=\"headerlink\" title=\"生成绘制指令\"></a>生成绘制指令</h2><blockquote>\n<p>主线程会为每一层单独生成绘制指令，用于描述这一层内容怎么画出来，类似于canvas中的画笔。<br>生成绘制指令的结果是：<code>得到了绘制指令集</code></p>\n</blockquote>\n<h2 id=\"分块\"><a href=\"#分块\" class=\"headerlink\" title=\"分块\"></a>分块</h2><blockquote>\n<p>得到<code>绘制指令集</code>之后，主线程会将每个图层的绘制信息交给合成线程，剩下的工作将由合成线程完成。合成线程首先会对每个图层进行分块，将其划分为更多的小区域，合成线程会从线程池中拿出多个线程来完成分块工作。</p>\n</blockquote>\n<h2 id=\"光栅化\"><a href=\"#光栅化\" class=\"headerlink\" title=\"光栅化\"></a>光栅化</h2><blockquote>\n<p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。光栅化就是<code>将每个块变成位图</code>，位图可以理解成内存里的一个二维数组，这个二维数组记录了每个像素点信息。GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。<br>光栅化的结果，就是<code>一块一块的位图</code>。</p>\n</blockquote>\n<h2 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h2><blockquote>\n<p>合成线程计算出每个位图的在屏幕上的位置，交给GPU进行最终实现。<br>注：光栅化阶段和绘制阶段也统称为：合成阶段，<code>transform</code>就在这一阶段被执行。</p>\n</blockquote>\n<h4 id=\"何为进程？\"><a href=\"#何为进程？\" class=\"headerlink\" title=\"何为进程？\"></a>何为进程？</h4><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p>\n<p><img data-src=\"/images/image-20220809205743532\" alt=\"image\"><br>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>\n<h4 id=\"何为线程？\"><a href=\"#何为线程？\" class=\"headerlink\" title=\"何为线程？\"></a>何为线程？</h4><p>有了进程后，就可以运行程序的代码了。</p>\n<p>运行代码的「人」称之为「线程」。</p>\n<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>\n<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>\n<p><img data-src=\"/images/image-20220809210859457\" alt=\"image\"></p>\n<p>浏览器有哪些进程和线程？<br>浏览器是一个多进程多线程的应用程序</p>\n<p>浏览器内部工作极其复杂。</p>\n<p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>\n<p><img data-src=\"/images/image-20220809213152371\" alt=\"image\"></p>\n<p>可以在浏览器的任务管理器中查看当前的所有进程</p>\n<p>其中，最主要的进程有：</p>\n<h1 id=\"浏览器进程\"><a href=\"#浏览器进程\" class=\"headerlink\" title=\"浏览器进程\"></a>浏览器进程</h1><p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>\n<h4 id=\"网络进程\"><a href=\"#网络进程\" class=\"headerlink\" title=\"网络进程\"></a>网络进程</h4><p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p>\n<h4 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h4><p>渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。</p>\n<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p>\n<p>将来该默认模式可能会有所改变，有兴趣的同学可参见chrome官方说明文档</p>\n<p>渲染主线程是如何工作的？<br>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>\n<p>解析 HTML<br>解析 CSS<br>计算样式<br>布局<br>处理图层<br>每秒把页面画 60 次<br>执行全局 JS 代码<br>执行事件处理函数<br>执行计时器的回调函数<br>……<br>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p>\n<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p>\n<p>比如：</p>\n<p>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？<br>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？<br>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？<br>……<br>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p>\n<p><img data-src=\"/images/image-20220809223027806\" alt=\"image\"></p>\n<p>在最开始的时候，渲染主线程会进入一个无限循环<br>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。<br>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务<br>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>\n<p>整个过程，被称之为事件循环（消息循环）</p>\n<p>若干解释</p>\n<h4 id=\"何为异步？\"><a href=\"#何为异步？\" class=\"headerlink\" title=\"何为异步？\"></a>何为异步？</h4><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>\n<p>计时完成后需要执行的任务 —— setTimeout、setInterval<br>网络通信完成后需要执行的任务 – XHR、Fetch<br>用户操作后需要执行的任务 – addEventListener<br>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>\n<p><img data-src=\"/images/image-20220810104344296\" alt=\"image\"></p>\n<p>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</p>\n<p>因此，浏览器选择异步来解决这个问题</p>\n<p><img data-src=\"/images/image-20220810104858857\" alt=\"image\"></p>\n<p>使用异步的方式，渲染主线程永不阻塞</p>\n<p>面试题：如何理解 JS 的异步？</p>\n<p>参考答案：</p>\n<p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>\n<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>\n<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>\n<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>\n<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>\n<p>JS为何会阻碍渲染？<br>先看代码</p>\n<pre><code class=\"javascript\">  var h1 = document.querySelector(&#39;h1&#39;);\n  var btn = document.querySelector(&#39;button&#39;);  \n  // 死循环指定的时间\n  function delay(duration) &#123;\n    var start = Date.now();\n    while (Date.now() - start &lt; duration) &#123;&#125;\n  &#125;\n  btn.onclick = function () &#123;\n    h1.textContent = &#39;hello world！&#39;;\n    delay(3000);\n  &#125;;\n</code></pre>\n<p>点击按钮后，会发生什么呢？</p>\n<p>&lt;见具体演示&gt;</p>\n<p>任务有优先级吗？<br>任务没有优先级，在消息队列中先进先出</p>\n<p>但消息队列是有优先级的</p>\n<p>根据 W3C 的最新解释:</p>\n<p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。<br>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BlcmZvcm0tYS1taWNyb3Rhc2stY2hlY2twb2ludA==\">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</span><br>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p>\n<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>\n<p>延时队列：用于存放计时器到达后的回调任务，优先级「中」<br>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」<br>微队列：用户存放需要最快执行的任务，优先级「最高」<br>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p>\n<p>例如：</p>\n<p>&#x2F;&#x2F; 立即把一个函数添加到微队列<br>Promise.resolve().then(函数)<br>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p>\n<h1 id=\"面试题：\"><a href=\"#面试题：\" class=\"headerlink\" title=\"面试题：\"></a>面试题：</h1><h4 id=\"阐述一下-JS-的事件循环\"><a href=\"#阐述一下-JS-的事件循环\" class=\"headerlink\" title=\"阐述一下 JS 的事件循环\"></a>阐述一下 JS 的事件循环</h4><p>参考答案：</p>\n<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>\n<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>\n<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>\n<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>\n<h4 id=\"JS-中的计时器能做到精确计时吗？为什么？\"><a href=\"#JS-中的计时器能做到精确计时吗？为什么？\" class=\"headerlink\" title=\"JS 中的计时器能做到精确计时吗？为什么？\"></a>JS 中的计时器能做到精确计时吗？为什么？</h4><p>参考答案：</p>\n<p>不行，因为：</p>\n<p>计算机硬件没有原子钟，无法做到精确计时<br>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差<br>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差<br>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</p>\n<h1 id=\"URL到页面渲染的全程\"><a href=\"#URL到页面渲染的全程\" class=\"headerlink\" title=\"URL到页面渲染的全程\"></a>URL到页面渲染的全程</h1><p>整体流程</p>\n<p>用户在某个标签页输入 URL 并回车后，浏览器主进程会新开一个网络线程，发起 HTTP 请求<br>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站<br>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。<br>浏览器会进行 DNS 查询，通过DNS查询将域名解析为 IP 地址<br>检查域名是否在缓存当中<br>DNS缓存: 浏览器缓存——&gt;hosts文件——&gt;路由器缓存——&gt;网络服务商缓存——&gt;根域名服务器缓存<br>浏览器获得 IP 地址后，向服务器请求建立 TCP 连接<br>TCP三次握手<br>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号<br><em><strong>服务器端接收到 SYN 包，如果它可以建立连接：</strong></em>服务器端选择它自己的初始序列号服务器端设置 SYN 位，表明自己选择了一个初始序列号服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包<br><em><strong>客户端通过发送下面一个封包来确认这次连接：</strong></em>自己的序列号+1接收端 ACK+1设置 ACK 位<br><em><strong>数据通过下面的方式传输：</strong></em>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号<br><em><strong>关闭连接时：</strong></em>要关闭连接的一方发送一个 FIN 包另一方确认这个 FIN 包，并且发送自己的 FIN 包要关闭的一方使用 ACK 包来确认接收到了 FIN<br>TLS握手<br>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。<br>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥<br>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥<br>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥<br>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值<br>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密<br>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容<br>HTTP 的长连接与短连接与2.0<br>HTTP&#x2F;1.0 默认使用的是短连接。也就是说，浏览器每请求一个静态资源，就建立一次连接，任务结束就中断连接。<br>HTTP&#x2F;1.1 默认使用的是长连接。长连接是指在一个网页打开期间，所有网络请求都使用同一条已经建立的连接。当没有数据发送时，双方需要发检测包以维持此连接。长连接不会永久保持连接，而是有一个保持时间。实现长连接要客户端和服务端都支持长连接。<br>长连接的优点：TCP 三次握手时会有 1.5 RTT 的延迟，以及建立连接后慢启动（slow-start）特性，当请求频繁时，建立和关闭 TCP 连接会浪费时间和带宽，而重用一条已有的连接性能更好。<br>长连接的缺点：长连接会占用服务器的资源。<br>HTTP 2.0 的三大特性是头部压缩、服务端推送、多路复用。<br>HTTP 1.1 允许通过同一个连接发起多个请求。但是由于 HTTP 1.X 使用文本格式传输数据，服务端必须按照客户端请求到来的顺序，串行返回数据。此外，HTTP 1.1 中浏览器会限制同时发起的最大连接数，超过该数量的连接会被阻塞。<br>HTTP 2 引入了多路复用，允许通过同一个连接发起多个请求，并且可以并行传输数据。HTTP 2 使用二进制数据帧作为传输的最小单位，每个帧标识了自己属于哪个流，每个流对应一个请求。服务端可以并行地传输数据，而接收端可以根据帧中的顺序标识，自行合并数据。<br>在 HTTP 1.1 中，由于浏览器限制每个域名下最多同时有 6 个请求，其余请求会被阻塞，因此我们通常使用多个域名（比如 CDN）来提高浏览器的下载速度。HTTP 2 就不再需要这样优化了。<br>同理，在 HTTP 1.1 中，我们会将多个 JS 文件、CSS 文件等打包成一个文件，将多个小图片合并为雪碧图，目的是减少 HTTP 请求数。HTTP 2 也不需要这样优化了。<br>浏览器向服务器发起 HTTP 请求<br>服务器处理请求，返回 HTTP 响应<br>浏览器的渲染进程解析并绘制页面<br>如果遇到 JS&#x2F;CSS&#x2F;图片 等静态资源的引用链接，重复上述过程，向服务器请求这些资源<br>browser</p>\n<p>TCP四次挥手</p>\n<p>流程:<br>客户端应用程序发出释放连接的报文段，并停止发送数据，主动关闭 TCP 连接。客户端主机发送释放连接的报文段，报文段中首部 FIN 位置为 1 ，不包含数据，序列号位 seq &#x3D; u，此时客户端主机进入 FIN-WAIT-1(终止等待 1) 阶段。<br>服务器主机接受到客户端发出的报文段后，即发出确认应答报文，确认应答报文中 ACK &#x3D; 1，生成自己的序号位 seq &#x3D; v，ack &#x3D; u + 1，然后服务器主机就进入 CLOSE-WAIT(关闭等待) 状态。<br>客户端主机收到服务端主机的确认应答后，即进入 FIN-WAIT-2(终止等待2) 的状态。等待客户端发出连接释放的报文段。<br>这时服务端主机会发出断开连接的报文段，报文段中 ACK &#x3D; 1，序列号 seq &#x3D; v，ack &#x3D; u + 1，在发送完断开请求的报文后，服务端主机就进入了 LAST-ACK(最后确认)的阶段。<br>客户端收到服务端的断开连接请求后，客户端需要作出响应，客户端发出断开连接的报文段，在报文段中，ACK &#x3D; 1, 序列号 seq &#x3D; u + 1，因为客户端从连接开始断开后就没有再发送数据，ack &#x3D; v + 1，然后进入到 TIME-WAIT(时间等待) 状态，请注意，这个时候 TCP 连接还没有释放。必须经过时间等待的设置，也就是 2MSL 后，客户端才会进入 CLOSED 状态，时间 MSL 叫做最长报文段寿命（Maximum Segment Lifetime）。<br>服务端主机收到了客户端的断开连接确认后，就会进入 CLOSED 状态。因为服务端结束 TCP 连接时间要比客户端早，而整个连接断开过程需要发送四个报文段，因此释放连接的过程也被称为四次挥手。<br>关闭连接的方式通常有两种，分别是 RST 报文关闭和 FIN 报文关闭。<br>如果进程异常退出了，内核就会发送 RST 报文来关闭，它可以不走四次挥手流程，是一个暴力关闭连接的方式。<br>TIMEWAIT</p>\n<p>TIME_WAIT 状态相当于是客户端在关闭前的最后一个状态，它是一种主动关闭的状态；而 LAST_ACK 是服务端在关闭前的最后一个状态，它是一种被动打开的状态。<br>需要 TIME_WAIT 状态的原因:<br>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；<br>保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；<br>为什么是 2 MSL 的时长呢？<br>这其实是相当于至少允许报文丢失一次。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>客户端受端口资源限制：如果客户端 TIME_WAIT 过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接；<br>服务端受系统资源限制：由于一个四元组表示TCP连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口，但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接；<br>Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭：<br>同时关闭</p>\n<p>由于 TCP 是全双工的协议，所以是会出现两方同时关闭连接的现象，也就是同时发送了 FIN 报文。当客户端与服务端同时发起 FIN 报文请求关闭连接时, 都认为自己是主动方，所以都进入了 FIN_WAIT1 状态，FIN 报文的重发次数仍由 tcp_orphan_retries 参数控制。接下来，双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。</p>\n","categories":["浏览器"],"tags":["浏览器","原理"]},{"title":"杂记","url":"/2023/01/01/%E6%9D%82%E8%AE%B0/","content":"<h1 id=\"obj-key和Object-defineProperty\"><a href=\"#obj-key和Object-defineProperty\" class=\"headerlink\" title=\"obj.key和Object.defineProperty\"></a>obj.key和Object.defineProperty</h1><blockquote>\n<p>给某一个对象<code>obj</code>创建属性<code>name</code>时，可以直接使用：<code>obj.name=XXX</code>的方式，这样创建的属性就具有默认的配置型：<code>writable:true</code>可写入，<code>enumerable:true</code>可枚举，<code>configurable:true</code>可配置的特性。如果想要添加属性并改变这些默认的配置时，就需要使用<code>Object.defineProperty</code>进行配置：</p>\n</blockquote>\n<pre><code class=\"javascript\">Object.defineProperty(obj,&#39;name&#39;,&#123;\n  enumerable: false,\n  value: function()&#123;\n    // ...\n  &#125;\n&#125;)\n</code></pre>\n<h1 id=\"category-标签\"><a href=\"#category-标签\" class=\"headerlink\" title=\"category 标签\"></a>category 标签</h1><p>category 标签定义类别，表示一类的主题内容</p>\n<Category title=\"电影\">\n<video controls src=\"媒体文件\"></video>\n\n\n</Category>\n\n<h1 id=\"track-标签\"><a href=\"#track-标签\" class=\"headerlink\" title=\"track 标签\"></a>track 标签</h1><p>用于在媒体标签中处理文字 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track\"><code>&lt;track&gt;</code></a></p>\n<h1 id=\"figure-标签\"><a href=\"#figure-标签\" class=\"headerlink\" title=\"figure 标签\"></a>figure 标签</h1><p>figure 标签（可附标题内容元素，通常内部使用图片和媒体，也有利于 SEO）</p>\n<pre><code class=\"html\">&lt;figure&gt;\n  &lt;img\n    src=&quot;/zh-CN/docs/Web/HTML/Element/figure/favicon-192x192.png&quot;\n    alt=&quot;The beautiful MDN logo.&quot;\n  /&gt;\n  &lt;figcaption&gt;MDN Logo&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre>\n<h1 id=\"iframe-内联标签\"><a href=\"#iframe-内联标签\" class=\"headerlink\" title=\"iframe 内联标签\"></a>iframe 内联标签</h1><blockquote>\n<p>iframe标签也被称为：嵌入式框架，它可以把一个网页的框架和内容嵌入到现有的网页中，优点是重载页面时不用加载整个页面，提高了网页重载速度。缺点：会产生很多页面，不好管理、会阻塞页面加载、需要调用外部资源，增加了请求次数、浏览器后退按钮无效、SEO差，搜索引擎会跳过iframe的爬取，宽度高度等问题，并且小型设备无法完全显示框架。</p>\n</blockquote>\n<h6 id=\"iframe-内联框架标签：\"><a href=\"#iframe-内联框架标签：\" class=\"headerlink\" title=\"iframe 内联框架标签：\"></a>iframe 内联框架标签：</h6><pre><code class=\"html\">&lt;iframe src=&quot;./student.html&quot; name=&quot;fm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;当点击`&lt;a\n  href=&quot; &quot;\n  target=&quot;fm&quot;\n&gt;\n&lt;/a\n&gt;` 标签时，只会替换跳转iframe页面，而非整个网页\n</code></pre>\n<p><strong>使用 ifram 标签访问页面</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n      iframe &#123;\n        width: 100%;\n        height: 650px;\n      &#125;\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;iframe src=&quot;https://www.csdn.net/&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h1 id=\"HTML微格式\"><a href=\"#HTML微格式\" class=\"headerlink\" title=\"HTML微格式\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9taWNyb2Zvcm1hdHMub3JnL3dpa2kvaC1jYXJk\">HTML微格式</span></h1><blockquote>\n<p>HTML微格式是为了兼容HTML文档的人机可读性的目的，在标签中添加语义注解（通过结构化类型名应用到标记中，可以生成人类观众可以清楚理解的内容），一般用于标记人员(h-me)、联系信息（h-card）、博客（h-entry）、地点等信息。</p>\n</blockquote>\n<pre><code class=\"html\">&lt;a href=&quot;./home.html&quot;&gt;to home&lt;/a&gt;\n&lt;div&gt;\n  &lt;div&gt;北京&lt;/div&gt;\n  &lt;div&gt;China&lt;/div&gt;\n  &lt;div&gt;15830294021&lt;/div&gt;\n&lt;/div&gt;\n&lt;!--添加微格式之后： --&gt;\n&lt;a href=&quot;./home.html&quot; rel=&quot;&quot;&gt;to home&lt;/a&gt;\n&lt;div class=&quot;vcard&quot;&gt; &lt;!-- 结构化类名 --&gt;\n  &lt;div class=&quot;adr&quot;&gt;北京&lt;/div&gt;\n  &lt;div class=&quot;country-name&quot;&gt;China&lt;/div&gt;\n  &lt;div class=&quot;tel&quot;&gt;15830294021&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<h1 id=\"替换元素\"><a href=\"#替换元素\" class=\"headerlink\" title=\"替换元素\"></a>替换元素</h1><blockquote>\n<p>指的是展现效果不由css控制的元素，他们外观的渲染是独立于css的<br>常见的有：</p>\n</blockquote>\n<ul>\n<li>img标签</li>\n<li>iframe标签</li>\n<li>音视频标签</li>\n</ul>\n<h1 id=\"lt-x3D-符号-gt\"><a href=\"#lt-x3D-符号-gt\" class=\"headerlink\" title=\"&lt;%&#x3D; 符号 %&gt;\"></a>&lt;%&#x3D; 符号 %&gt;</h1><p><strong>用于 html 中嵌入 js 语句</strong></p>\n<h1 id=\"css-属性\"><a href=\"#css-属性\" class=\"headerlink\" title=\"css 属性\"></a>css 属性</h1><p>css 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL1JlZmVyZW5jZQ==\">100 多个属性</span></p>\n<h1 id=\"CSS-基本数据类型\"><a href=\"#CSS-基本数据类型\" class=\"headerlink\" title=\"CSS 基本数据类型\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL0NTU19UeXBlcw==\">CSS 基本数据类型</span></h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQ1NTL2ZpbHRlcg==\">filter</span> 用于定义滤镜</p>\n<h1 id=\"选择文件夹\"><a href=\"#选择文件夹\" class=\"headerlink\" title=\"选择文件夹\"></a>选择文件夹</h1><p>**<code>showDirectoryPicker()</code>**方法，用于选择文件夹目录</p>\n<p>**<code>showOpenFilePicker()</code>**用于显示一个文件选择器</p>\n<p><code>showSaveFilePicker()</code>用于更改一个文件</p>\n<h1 id=\"JS-引擎优化\"><a href=\"#JS-引擎优化\" class=\"headerlink\" title=\"JS 引擎优化\"></a>JS 引擎优化</h1><p>一、<em>小的数字类型(Sim) ,占据四个字节 , 正常 num 占据八个字节</em></p>\n<p>二、</p>\n<h1 id=\"js8-种数据类型\"><a href=\"#js8-种数据类型\" class=\"headerlink\" title=\"js8 种数据类型\"></a>js<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9QcmltaXRpdmU=\">8 种数据类型</span></h1><p><strong>基本：</strong>null、undefined、number、boolean、string、symbol、bigInt、</p>\n<p>**引用数据类型 : ** Object</p>\n<h1 id=\"for-in-循环和-for-of-循环\"><a href=\"#for-in-循环和-for-of-循环\" class=\"headerlink\" title=\"for in 循环和 for of 循环\"></a>for in 循环和 for of 循环</h1><p>（1）for in 通常遍历对象，for of 通常遍历数组</p>\n<p>（2）<code>for  in</code> 会遍历对象的可枚举属性，这个过程是通过原型链实现的 ；<code>for...of</code> 循环遍历可迭代对象的元素，这个过程是通过迭代器实现的。</p>\n<p>（3）实际上，在底层，<code>for...in</code> 循环会遍历对象自身及其原型链上所有可枚举的属性（包括继承自父对象的属性），因此需要使用 <code>hasOwnProperty()</code> 方法来判断属性是否是对象自身的属性。<code>for...of</code> 循环实际上是基于这个迭代器实现的。循环首先获取可迭代对象的迭代器，然后按照迭代器定义的顺序依次遍历每个元素，并将当前元素的值赋给循环变量。</p>\n<h1 id=\"封装的简易随机数\"><a href=\"#封装的简易随机数\" class=\"headerlink\" title=\"封装的简易随机数\"></a>封装的简易随机数</h1><pre><code class=\"javascript\">//随机数\nfunction rannum(min, max) &#123;\n  return Math.round(Math.random() * (max - min)) + min;\n&#125;\n</code></pre>\n<h1 id=\"解决获取对象属性时存在的兼容性问题\"><a href=\"#解决获取对象属性时存在的兼容性问题\" class=\"headerlink\" title=\"解决获取对象属性时存在的兼容性问题\"></a>解决获取对象属性时存在的兼容性问题</h1><h6 id=\"获取对象属性问题\"><a href=\"#获取对象属性问题\" class=\"headerlink\" title=\"获取对象属性问题\"></a>获取对象属性问题</h6><ol>\n<li><p>浏览器兼容性：不同浏览器在处理 CSS 属性名称上存在差异。例如，某些浏览器可能将 <code>background-color</code> 属性解析为 <code>backgroundColor</code>，而另一些浏览器则保持原样。这就导致了使用 <code>obj.attr</code> 的方式无法跨浏览器获得准确的样式值。</p>\n</li>\n<li><p>获取计算后样式：直接通过 <code>obj.attr</code> 获取的是元素的内联样式（即<strong>行内样式</strong>），而不是计算后的样式（包括 CSS 样式和继承样式）。如果需要获取元素显示时的实际样式，例如考虑到外部样式表或通过其他选择器影响的样式，需要使用 <code>getComputedStyle</code> 或 <code>currentStyle</code> 方法。</p>\n<p>**例如：如下代码中，dom 获取的属性值和页面呈现的值不一致</p>\n<pre><code class=\"html\">&lt;style&gt;\n  div &#123;\n    width: 100px !important;\n  &#125;\n&lt;/style&gt;\n&lt;body&gt;\n  &lt;div style=&quot;width:500px;height:10px;background-color:black&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  let div = document.querySelector(&quot;div&quot;);\n  console.log(div.style.width); // 页面呈现的为100px, dom获取到的是行内样式（500px）\n&lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n<h6 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h6><p>封装函数获取计算后的 dom 元素属性值（<code>getComputedStyle</code>）,同时注意 IE 浏览器没有此方法</p>\n<pre><code class=\"javascript\">function getstyle(obj, attr) &#123;\n  if (window.getComputedStyle) &#123;\n    //标准\n    return getComputedStyle(obj)[attr];\n  &#125; else &#123;\n    //IE\n    return obj.currentStyle[attr];\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">//非 IE 浏览器中，currentStyle 属性是不存在的\nfunction getStyle(obj, attr) &#123;\n  return obj.currentStyle\n    ? obj.currentStyle[attr]\n    : window.getComputedStyle(obj, null)[attr];\n&#125;\n</code></pre>\n<h1 id=\"构造函数创建对象方法\"><a href=\"#构造函数创建对象方法\" class=\"headerlink\" title=\"构造函数创建对象方法\"></a>构造函数创建对象方法</h1><p>静态方法只能通过构造函数调用，实例方法通过对象调用，定义在对象身上，原型方法通过对象调用，定义在对象原型上（节省内存）</p>\n<p>原型方法和实例方法是 JavaScript 中定义在对象上的两种不同类型的方法，它们有以下区别和好处：</p>\n<ol>\n<li>区别：<ul>\n<li>原型方法：定义在对象的原型上，即通过构造函数的 <code>prototype</code> 属性添加的方法。所有通过该构造函数创建的实例对象都共享同一个原型方法。</li>\n<li>实例方法：定义在对象实例上，通过构造函数创建的每个对象实例都具有自己的实例方法。</li>\n</ul>\n</li>\n<li>好处：<ul>\n<li>原型方法的好处：<ul>\n<li>节省内存：所有通过构造函数创建的实例对象共享原型方法，避免为每个实例对象重复创建方法，节省了内存开销。</li>\n<li>动态性：原型方法的修改会立即反映在所有实例对象上。当你在原型上添加、删除或修改方法时，所有实例对象会自动继承这些变化，无需更新每个实例对象。</li>\n</ul>\n</li>\n<li>实例方法的好处：<ul>\n<li>封装性：实例方法可以使用构造函数内部的变量和方法，实现更灵活和封装的对象行为。</li>\n<li>访问实例属性：实例方法可以直接访问实例对象的属性，因为它们是在实例对象中定义的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"javascript\">// 构造函数\nfunction People(color) &#123;\n  this.color = color;\n  this.seeColor = function () &#123;\n    console.log(&quot;color is &quot; + this.color);\n  &#125;;\n&#125;\n// 静态方法\nPeople.say = function () &#123;\n  console.log(&quot;静态方法color is &quot;, this.color);\n&#125;;\n// 原型方法\nPeople.prototype.eat = function () &#123;\n  console.log(&quot;原型方法color is &quot;, this.color);\n&#125;;\n// 实例\nvar pp = new People();\n\n// 调用静态方法\nPeople.say(); // 静态方法color is  undefined\npp.say(); // 报错信息：Uncaught TypeError: pp.say is not a function\n\n// 调用原型方法\nPeople.eat(); // 报错信息：Uncaught TypeError: People.eat is not a function\npp.eat(); // 原型方法color is  Red\n\n// 调用实例方法\nPeople.seeColor(); // Uncaught TypeError: People.seeColor is not a function\npp.seeColor(); // color is Red\n</code></pre>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9hbGw=\">Promise.all()</span></h3><p>Promise.all（）静态方法接受一个 Promose 可迭代对象作为输入，并返回一个 Promise，当所有输入的 Promise 都被兑现时，返回的 Promise 也将被兑现，并返回一个包含所有对闲置的数组，如果输入的任何 Promise 都被拒绝，则返回的 Promise 也将被拒绝</p>\n<h1 id=\"生成乱文\"><a href=\"#生成乱文\" class=\"headerlink\" title=\"生成乱文\"></a>生成乱文</h1><p>以下是使用 <code>lorem</code> 快捷键生成乱文的步骤：</p>\n<ol>\n<li>在编辑器中选中或定位到您想要插入乱文的位置。</li>\n<li>键入 <code>lorem</code> 并按下 Tab 键。</li>\n</ol>\n<p>这将会触发代码片段的展开，生成一段默认长度的乱文。</p>\n<p>如果您需要生成特定长度的乱文，可以在 <code>lorem</code> 后面跟随所需的长度，例如 <code>lorem5</code> 会生成 5 个单词的乱文。</p>\n<h1 id=\"NodeList-和-HTMLCollection\"><a href=\"#NodeList-和-HTMLCollection\" class=\"headerlink\" title=\"NodeList 和 HTMLCollection\"></a>NodeList 和 HTMLCollection</h1><p>他们都是伪数组 ， 用 typeof 进行检测时，返回 function。</p>\n<ul>\n<li><p>NodeList（<code>.querySelectorAll(selector)</code>、<code>.childNodes</code>、<code>.getElementsByName</code> .querySelectorAll 等获取）</p>\n<ul>\n<li><code>NodeList</code> 包含文档中匹配选择器所得到的所有节点，包括元素、文本节点、注释节点等；<code>NodeList</code> 是静态的，即当文档中的节点发生变化时，<code>NodeList</code> 中的内容不会实时发生变化。</li>\n</ul>\n</li>\n<li><p>HTMLCollection（<code>.getElementsByClassName()</code>、<code>.getElementsByTagName( )</code>等）</p>\n</li>\n</ul>\n<p>而 <code>HTMLCollection</code> 则只包含文档中指定标签名的元素节点；</p>\n<p>而 <code>HTMLCollection</code> 是静态的，和 HTML 强相关，即：当文档中的节点发生变化时，<code>HTMLCollction</code> 中的内容会实时发生变化。</p>\n<p>两者都可以像数组一样使用索引访问其成员，但 <code>NodeList</code> 对象具有更多的方法（如 <code>forEach</code>、<code>item</code> 等），而 <code>HTMLCollection</code> 相对较少。<code>NodeList</code> 和 <code>HTMLCollection</code> 都可以用于获取文档中的元素集合，并进行相关操作。其中，<code>HTMLCollection</code> 更适用于固定集合的情况，如 <code>document.forms</code>、<code>document.links</code>、<code>document.images</code> 等；而 <code>NodeList</code> 则更适用于动态查询、筛选和遍历节点的情况，</p>\n<h1 id=\"HTML-相关性发展\"><a href=\"#HTML-相关性发展\" class=\"headerlink\" title=\"HTML 相关性发展\"></a>HTML 相关性发展</h1><p>早期使用 getElementsByClassName 等 API,得到的是 HTMl 强相关的 HTMLCollection<br>当 DOM 发生变化时,HTMLCollection 也会随之变化,但是由于强相关会导致页面回流重绘好多次<br>后来出现 querySelectorAll 这个 API,得到的是 HTML 弱相关的 NodeList<br>NodeList 对于 DOM 有一层处理,所以是弱相关,操作 NodeList 的元素不会导致浏览器频繁更新渲染</p>\n<h1 id=\"HTML-Element-所有的元素\"><a href=\"#HTML-Element-所有的元素\" class=\"headerlink\" title=\"HTML Element 所有的元素\"></a>HTML Element 所有的元素</h1><p>(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9FbGVtZW50\">HTML 元素</span>)</p>\n<h1 id=\"HTML-全局属性\"><a href=\"#HTML-全局属性\" class=\"headerlink\" title=\"HTML 全局属性\"></a>HTML 全局属性</h1><h2 id=\"DOM-元素的操作方法-HTML-强相关\"><a href=\"#DOM-元素的操作方法-HTML-强相关\" class=\"headerlink\" title=\"DOM 元素的操作方法(HTML 强相关):\"></a>DOM 元素的操作方法(HTML 强相关):</h2><p>HTMLCollection 数组<br>DOM.setAttribute(‘style’, ‘font-size: 1px;’);<br>DOM.getAttribute(‘style’); 得到属性值<br>DOM.getAttributeNS(‘namedValue’,’key’,’value’) 设置属性值(带命名空间)<br>DOM.removeAttribute(‘style’) 移除属性值<br>DOM.removeAttributeNS(‘style’) 移除属性值(带命名空间)<br>DOM.hasAttribute(‘style’) 判断是否有属性值<br>DOM.hasAttributeNS(‘style’) 判断是否有属性值(带命名空间)<br>DOM.toggleAttribute(‘style’) 反转属性值(有则删除,无则添加)</p>\n<h2 id=\"DOM-元素属性-和-HTML-非强相关\"><a href=\"#DOM-元素属性-和-HTML-非强相关\" class=\"headerlink\" title=\"DOM 元素属性(和 HTML 非强相关)\"></a>DOM 元素属性(和 HTML 非强相关)</h2><p>NodeList 数组<br>DOM.classList 返回 classList 对象<br>DOM.style 返回 CSSStyleDeclaration 对象<br>DOM.dataset 返回自定义属性<br>DOM.innerHTML 返回元素内部 HTML 内容<br>DOM.outerHTML 返回元素及其子元素 HTML 内容<br>DOM.textContent 设置或返回元素及其子元素的文本内容<br>DOM.value input 等特殊标签才有</p>\n<h2 id=\"全局属性列表\"><a href=\"#全局属性列表\" class=\"headerlink\" title=\"全局属性列表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcyMlRTUlODUlQTglRTUlQjElODAlRTUlQjElOUUlRTYlODAlQTclRTUlODglOTclRTglQTElQTg=\">全局属性列表</span></h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy9kYXRhLSo=\">data-* 属性</span></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus\"><code>autofocus</code> (en-US)</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/autocapitalize\"><code>autocapitalize</code></a></p>\n<p>等</p>\n<h1 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket\"><code>WebSocket</code></a></h1><p>XML 和 WebSocket</p>\n<p>XML 是一种用于存储和传输数据的标准格式，常用于 Web 应用程序之间传递数据。XML 的好处是灵活、可扩展、易于阅读，并且可以通过各种编程语言解析和操作。使用 XML，我们可以定义自己的标记来描述数据，达到数据交换的目的。</p>\n<p>WebSocket 是 HTML5 提供的一种新的网络通信协议。它可以在浏览器和服务器之间建立一个实时的、双向通信的通道，使得数据可以实时地双向传输。WebSocket 的好处是实时性好、带宽利用率高、开发成本低，能够有效地解决 HTTP 协议中存在的单向请求-响应模式不能满足实时性需求的问题。</p>\n<p>在实际开发中，XML 和 WebSocket 可以结合使用。例如，可以使用 XML 来编写数据格式，然后使用 WebSocket 将数据传输到客户端或服务器端。这样可以实现双向通信，并且能够按需发送和接收数据，从而提高了系统的实时性和效率。</p>\n<pre><code class=\"javascript\">// WebSocket构造器创建一个WebSocket对象\nvar socket = new WebSocket(&quot;ws://127.0.0.1:9000&quot;);\n// 当连接上时,给服务端发送数据\nsocket.addEventListener(&quot;open&quot;, function (e) &#123;\n  socket.send(&quot;Hello Server!&quot;);\n&#125;);\nlet div = document.querySelector(&quot;div&quot;);\n// 收到数据时，进行处理\nsocket.addEventListener(&quot;message&quot;, function (event) &#123;\n  var blob = event.data;\n  console.log(event.data);\n  let a = JSON.parse(event.data);\n  console.log(a.list);\n  for (let i = 0; i &lt; a.list.length; i++) &#123;\n    // 遍历得到每一个数组\n    let p = document.createElement(&quot;p&quot;);\n    console.log(a.list[i].name);\n    p.innerText = a.list[i].name;\n    div.appendChild(p);\n  &#125;\n&#125;);\n</code></pre>\n<p>fetch（ES6 原生，是基于 Promise 对象封装的方法）、axios（基于 XMLHttpRequest 的库）和 XMLHttpRequest 都可以用于请求数据</p>\n<h1 id=\"void-一元运算符\"><a href=\"#void-一元运算符\" class=\"headerlink\" title=\"void 一元运算符\"></a>void 一元运算符</h1><h3 id=\"在箭头函数中避免泄漏\"><a href=\"#在箭头函数中避免泄漏\" class=\"headerlink\" title=\"在箭头函数中避免泄漏\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3ZvaWQjJUU1JTlDJUE4JUU3JUFFJUFEJUU1JUE0JUI0JUU1JTg3JUJEJUU2JTk1JUIwJUU0JUI4JUFEJUU5JTgxJUJGJUU1JTg1JThEJUU2JUIzJTg0JUU2JUJDJThG\">在箭头函数中避免泄漏</span></h3><p>箭头函数标准中，允许在函数体不使用括号来直接返回值。如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用。安全起见，当函数返回值不会被使用到的时候，应该使用 <code>void</code> 运算符，来确保 API 改变时，并不会改变箭头函数的行为。</p>\n<pre><code class=\"javascript\">button.onclick = () =&gt; void doSomething();\n</code></pre>\n<p>运算 js 表达式，返回 undefined</p>\n<pre><code class=\"html\">&lt;a href=&quot;javascript:void(document.form.submit())&quot;&gt;Click here to submit&lt;/a&gt;\n</code></pre>\n<h1 id=\"in-关系运算符\"><a href=\"#in-关系运算符\" class=\"headerlink\" title=\"in 关系运算符\"></a>in 关系运算符</h1><p>使用键，而非值</p>\n<p>一、数组：</p>\n<p>index in arr （使用索引，不能用值，数组中默认 index 为键，还有 length 键）</p>\n<p>二、对象：</p>\n<p>“PI” <strong>in</strong> Math**;**（例子），注意不可枚举的属性会返回 false，如对象中 Prototype</p>\n<p>三、字符串</p>\n<pre><code class=\"javascript\">var myString = new String(&quot;coral&quot;);\n&quot;length&quot; in myString; // returns true\nvar mycar = &#123; make: &quot;Honda&quot;, model: &quot;Accord&quot;, year: 1998 &#125;;\n&quot;make&quot; in mycar; // returns true\n&quot;model&quot; in mycar; // returns true\n</code></pre>\n<h1 id=\"draggable-属性\"><a href=\"#draggable-属性\" class=\"headerlink\" title=\"draggable 属性\"></a>draggable 属性</h1><p>设置元素可拖拽，相关事件：ondragstart 拖拽开始、ondragover 拖拽经过、ondragenter 拖拽进入和 ondrop 停止拖拽。事件中(event . )包含 dataTransfer.effectAllowed&#x3D;“ copy ”等，表示设置拖拽复制还是移动 move</p>\n<h1 id=\"css-变量\"><a href=\"#css-变量\" class=\"headerlink\" title=\"css 变量\"></a>css 变量</h1><pre><code class=\"css\">:root &#123;\n  --big-size: 20px;\n  --color-green: green;\n&#125;\n</code></pre>\n<h1 id=\"分号分隔的重要性\"><a href=\"#分号分隔的重要性\" class=\"headerlink\" title=\"分号分隔的重要性\"></a>分号分隔的重要性</h1><pre><code class=\"javascript\">// 你不知道的JS------报错\nfunction foo(el) &#123;\n  console.log(el, this.id);\n&#125;\nvar obj = &#123;\n  id: &quot;awesom&quot;,\n&#125;;\n// 分号很关键，在特殊用法的时候，不用分号断开会报错\n[1, 2, 3].forEach(foo, obj);\n</code></pre>\n<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><h6 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h6><p>普通函数的 this 的绑定与函数调用方式有关，与函数定义的位置无关，</p>\n<h6 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h6><p>箭头函数的 this 与函数定义位置有关，与调用方式无关,（但与上层作用域的调用方式有关，上层 this 改变时，会跟着改变），其没有自己的 this，会找沿用上层的 this。</p>\n<h6 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h6><p>立即执行函数的 this 一定指向 window（因为会立即执行，太早执行了）</p>\n<h6 id=\"定时器函数\"><a href=\"#定时器函数\" class=\"headerlink\" title=\"定时器函数\"></a>定时器函数</h6><p>定时器里的函数的 this 一定指向 window（因为会被赋为函数地址，延迟后普通调用）</p>\n<h6 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h6><p>事件处理函数<strong>普通形式</strong>的 this 指向绑定的 DOM 元素（ 注意和 e.target 有所区别 ），箭头函数形式指向绑定的作用域</p>\n<p>一、this 的默认绑定（独立函数调用）</p>\n<pre><code class=\"javascript\">var obj = &#123;\n  name: &quot;jgas&quot;,\n  foo: function () &#123;\n    console.log(this);\n  &#125;,\n&#125;;\nvar bar = obj.foo;\n// -----------                 this默认绑定\n// this的指向与调用方式有关\nobj.foo(); //this指向obj\nbar(); //this指向window\n</code></pre>\n<p>二、this 的隐式绑定（对象函数调用，或数组调用）</p>\n<pre><code class=\"javascript\">// 定义一个对象\nconst person = &#123;\n  name: &quot;Alice&quot;,\n  sayHello: function () &#123;\n    console.log(&quot;Hello, &quot; + this.name);\n  &#125;,\n&#125;;\n\n// 调用对象的方法\nperson.sayHello(); // 输出：Hello, Alice\n</code></pre>\n<p>三、this 的显示绑定（特殊方法调用）</p>\n<pre><code class=\"javascript\">函数名.call(); // -----call传参数用 , 分割  this写在第一个形参\n函数名.apply(); //---apply传参用[]数组,   this写在第一个形参\n函数名.bind(); //-------bind ,显示绑定对象中的this,this写在第一个形参\n// 当使用这些函数改变this指向，传入null或者undefined时，自动将this绑定为全局对象\n</code></pre>\n<p>四、通过 new 关键字绑定（实例调用）</p>\n<p>通过 new 关键字进行绑定时，会创建一个实例对象的时候将 this 绑定到实例上。</p>\n<pre><code class=\"javascript\">function Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n&#125;\n\nconst person1 = new Person(&quot;Alice&quot;, 25);\nconsole.log(person1.name); // 输出：Alice\nconsole.log(person1.age); // 输出：25\n// JS中通过new关键字进性绑定this就是new绑定,new绑定会在生成实例时尽享绑定,指向构造的实例\n</code></pre>\n<p>五、this 绑定的优先级：</p>\n<p><em>new 关键字绑定 &gt; bind 方法绑定 ; new &gt; 隐式绑定 ; 显示绑定 &gt; 隐式绑定; 默认绑定优先级最低</em></p>\n<p>六、箭头函数的 this</p>\n<p>箭头函数不会创建自己的执行上下文，而是继承了外部作用域的执行上下文。这意味着箭头函数的 <code>this</code> 值是在定义函数时确定的，而不是在函数调用时确定的。箭头函数的 <code>this</code> 始终指向其定义时所处的上下文，无论它在哪里被调用。</p>\n<pre><code class=\"javascript\">function Person(name) &#123;\n  this.name = name;\n  this.obj = &#123;\n    name: &quot;obj&quot;,\n    foo1: function () &#123;\n      return function () &#123;\n        console.log(this.name);\n      &#125;;\n    &#125;,\n    foo2: function () &#123;\n      return () =&gt; &#123;\n        console.log(this.name);\n      &#125;;\n    &#125;,\n  &#125;;\n&#125;\nvar person1 = new Person(&quot;person1&quot;);\nvar person2 = new Person(&quot;person2&quot;);\n</code></pre>\n<p>① 普通函数，独立调用</p>\n<pre><code class=\"javascript\">person1.obj.foo1()(); //普通函数独立调用，this指向window\nperson1.obj.foo1.call(person2)(); //普通函数独立调用，this指向window\nperson1.obj.foo1().call(person2); //普通函数，通过call进行调用，this指向person2\n</code></pre>\n<p>② 箭头函数独立调用</p>\n<pre><code class=\"javascript\">person1.obj.foo2()(); //箭头函数不绑定this去上一层找，this指向obj\nperson1.obj.foo2.call(person2)(); //call方法绑定作用域，然后调用，里面的箭头函数没this，去外层作用域查找，this指向person2\nperson1.obj.foo2().call(person2); //obj隐式调用函数，后面call调用箭头函数没有this，因此去外层作用于查找，this指向obj\n</code></pre>\n<h1 id=\"let-和-const-声明的影响\"><a href=\"#let-和-const-声明的影响\" class=\"headerlink\" title=\"let 和 const 声明的影响\"></a>let 和 const 声明的影响</h1><p>let 和 const 声明的变量不会存储到 window 对象中，而是存储到 VariableMap 中。</p>\n<p><strong>（引入 let 和 const 关键字之后，window 和 GlobalObject 已经不是同一个对象了，let 和 const 声明的变量存在 VariableMap 中、一个 hash map，当使用变量时会在 VariableMap 中查找）</strong></p>\n<h1 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h1><p>NaN&#x3D;&#x3D;&#x3D;NaN 返回 false，因为 NaN 是一个特殊的 Number 类型的值（不是对象），存储时为双精度浮点型，每次取出都不一样。（NaN 和其他值永不相等！）</p>\n<p>相较于 Infinity，Infinity&#x3D;&#x3D;&#x3D;Infinity 返回的是 true。</p>\n<h1 id=\"函数和对象的原型问题\"><a href=\"#函数和对象的原型问题\" class=\"headerlink\" title=\"函数和对象的原型问题\"></a>函数和对象的原型问题</h1><p>函数可以看成是特殊的对象，函数的原型指向对象，而在 JS 当中 Object 是一个构造函数，每个构造函数都是 Function 的实例，因此，Object 是 Function 的一个实例。</p>\n<pre><code class=\"javascript\">console.log(typeof Function); //function\nconsole.log(Object.getOwnPropertyDescriptors(Function)); //不会报错\nconsole.log(Function instanceof Object); //true\nconsole.log(Function instanceof Function); //true\nconsole.log(Object instanceof Object); //true\nconsole.log(Object instanceof Function); //true\nconsole.log(Array instanceof Function); //true\nconsole.log(Number instanceof Function); //true\nconsole.log(BigInt instanceof Function); //true\n</code></pre>\n<h1 id=\"双等号和三等号\"><a href=\"#双等号和三等号\" class=\"headerlink\" title=\"双等号和三等号\"></a>双等号和三等号</h1><p>双等号和三等号的区别在于，是否会进行隐式转换。而在是否判断地址上没有区别（无论是双等号还是三等号 ， 判断应用数据类型时都会判断地址是否相等），因此两者的区别仅在于判断基本数据类型时是否隐式转换。</p>\n<pre><code class=\"javascript\">let as = [1, 2];\nlet bs = [1, 2];\nconsole.log(as == bs); //F\nconsole.log(as === bs); //F   判断引用类型值时,无论是双等号,还是三等号,都会判断内存地址\nlet cs = 100;\nlet ds = &quot;100&quot;;\nconsole.log(cs == ds); //T   隐式转换\nconsole.log(cs === ds); //F    判断简单类型值时,都不会判断其地址\n</code></pre>\n<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1><h1 id=\"Vue-use-和-Vue-component\"><a href=\"#Vue-use-和-Vue-component\" class=\"headerlink\" title=\"Vue.use 和 Vue.component\"></a>Vue.use 和 Vue.component</h1><ol>\n<li>Vue.use 与 vue.component 的区别<br><code>Vue.use</code>是用于<strong>注册插件</strong>,这个插件必须是一个对象 。 插件是通过将 Vue 构造函数上添加方法和属性，来扩展 Vue 功能。</li>\n<li>而<code>vue.component</code>是<strong>注册组件</strong>.差别就像是 Vue.use&#x3D;只能穿戴,vue.component&#x3D;手机.Vue.use 比 vue.component 更强大,一般是由多个组件组成 . 组件是 Vue 实例的一部分，用于封装可复用的模块。</li>\n<li>vue.use 如何封装<br>Vue.use 可以接收一个对象，对象中内置了一个 install 函数，install 函数的参数为 Vue 构造函数（可以用 Vue.use 进行多个组件的批量注册）</li>\n</ol>\n<p>在 Vue.use(obj) 时，会自动调用该 install 函数，并传入 Vue 构造器</p>\n<p>用 vue.use 进行组件注册时候，会首先判断组件的 installed 属性是否为 true,为 true 说明此组件已经注册过,如果没有注册的话,在 use 注册的同时,会给组件添加一个属性 installed：true</p>\n<p>插件的 install 方法将接收两个参数，第一个是参数是 Vue，第二个参数是配置项 options</p>\n<pre><code class=\"javascript\">//      components文件夹下的 index.js:\nimport PageTools from &quot;@/components/PageTools&quot;;\nimport UploadExcel from &quot;@/components/UploadExcel&quot;;\nimport UploadImg from &quot;@/components/UploadImg&quot;;\nexport default &#123;\n  install(Vue) &#123;\n    Vue.component(PageTools.name, PageTools);\n    Vue.component(UploadExcel.name, UploadExcel);\n    Vue.component(UploadImg.name, UploadImg);\n  &#125;,\n&#125;;\n//        main.js文件中:\nimport MyPlugin from &quot;@/components/index&quot;;\nVue.use(MyPlugin);\n</code></pre>\n<h1 id=\"Vue-组件\"><a href=\"#Vue-组件\" class=\"headerlink\" title=\"Vue 组件\"></a>Vue 组件</h1><pre><code class=\"javascript\">VueComponent是通过Vue.extend()方法创建的组件构造函数的原型。当您使用Vue.extend()创建一个组件时，会返回一个新的组件构造函数，而这个构造函数的原型即为VueComponent\nVueComponent.prototype.__proto__ === Vue.prototype\n</code></pre>\n<p><code>VueComponent</code> 和 <code>Vue.extend</code> 是 Vue.js 中用于创建组件的两个关键概念，它们之间有着紧密的联系。</p>\n<p>在 Vue.js 中，每个组件都是一个 <code>VueComponent</code> 实例。<code>VueComponent</code> 对象代表了一个已经挂载到 DOM 树上的 Vue 组件实例，包括了该组件的状态数据、模板和组件实例方法等信息。通过访问 <code>$options</code> 属性，可以获取该组件的选项对象。</p>\n<p>而 <code>Vue.extend</code> 方法则用于创建一个可以动态生成 <code>VueComponent</code> 实例的组件构造函数，每当需要创建一个新的实例时，就可以调用这个构造函数来创建。</p>\n<p>具体而言，<code>Vue.extend</code> 会接收一个组件选项对象作为参数，并返回一个组件构造函数，我们可以将这个构造函数传递给 <code>Vue.component</code> 方法或者在某个 Vue 实例中局部注册，使得该组件可以在应用程序的任何地方使用。在 Vue 应用程序中，一个 Vue 组件最终都会被转换成一个 <code>VueComponent</code> 实例，而 <code>Vue.extend</code> 方法则是用于创建这些实例所使用的组件构造函数。</p>\n<p>下面是一个简单的示例，展示了如何使用 <code>Vue.extend</code> 方法来创建一个组件构造函数，并使用该构造函数创建多个 <code>VueComponent</code> 实例：</p>\n<pre><code class=\"javascript\">javascriptCopy Code// 创建一个组件构造函数\nconst MyComponent = Vue.extend(&#123;\n  template: &#39;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#39;,\n  data() &#123;\n    return &#123;\n      message: &#39;Hello, Vue!&#39;\n    &#125;;\n  &#125;\n&#125;);\n// 创建两个组件实例\nnew MyComponent().$mount(&#39;#app1&#39;);\nnew MyComponent().$mount(&#39;#app2&#39;);\n</code></pre>\n<p>在上述示例中，我们使用 <code>Vue.extend</code> 方法创建了一个名为 <code>MyComponent</code> 的组件构造函数，并在选项对象中定义了模板和状态数据。然后，我们通过创建两个 <code>MyComponent</code> 实例并分别将它们挂载到不同的元素上。</p>\n<p>这里需要注意的是，每次调用 <code>MyComponent</code> 构造函数都会生成一个新的 <code>VueComponent</code> 实例。也就是说，虽然这两个实例是基于同一个组件构造函数创建的，但它们之间是相互独立的，彼此不会共享状态数据和实例方法。</p>\n<h1 id=\"native-修饰符详解\"><a href=\"#native-修饰符详解\" class=\"headerlink\" title=\"native 修饰符详解\"></a>native 修饰符详解</h1><p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1WdWUuanMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">Vue.js</span>中，.native 修饰符用于在自定义组件上监听原生 DOM 事件。通过使用.native 修饰符，可以将原生事件绑定到组件的根元素上，而不是绑定到组件内部的子组件元素上。这使得在组件使用过程中，可以更方便地监听和处理原生事件。如果不使用 <code>native</code> 修饰符，那么在绑定事件时，实际上绑定的是组件的内部事件而不是原生 DOM 的事件。这意味着事件处理函数会被绑定到组件根元素上，而不是直接绑定到原生 DOM 元素上</p>\n<p>总结: 给组件绑定原生事件后, 如果没触发就加 <strong>.native</strong></p>\n<h1 id=\"sync-修饰符详解\"><a href=\"#sync-修饰符详解\" class=\"headerlink\" title=\"sync 修饰符详解\"></a>sync 修饰符详解</h1><p>sync 修饰符相当于自定义事件的语法糖，用于父子组件数据之间的双向绑定，与 v-model 类似，（sync 修饰符修饰 v-bind 指令）</p>\n<p>一、 一般数据进行双向绑定要：①v-bind 绑定数据，② 添加一个自定义事件（父组件上）接受新值改变旧值 ③ 子组件中抛出自定义事件，传入改变后的值（this.$emit）</p>\n<p>二、 但是使用 sync 修饰符进行绑定之后，相当于父组件单项绑定数据的同时添加了一个自定义事件（upload : bindName），子组件不用再抛出事件，绑定的数据会随着父组件数据的改变自动改变</p>\n<p>三、v-model 和 sync 修饰符的原理相同，都是语法糖，相当于 v-bind 绑定一个 value 属性，然后 v-on 添加一个自定义事件</p>\n<h1 id=\"this-set-给对象添加响应式数据\"><a href=\"#this-set-给对象添加响应式数据\" class=\"headerlink\" title=\"this.$set 给对象添加响应式数据\"></a>this.$set 给对象添加响应式数据</h1><p><code>this.$set</code> 是 Vue.js 提供的一个实例方法，用于在 Vue 实例中响应式地添加新属性到已有的对象上。它并不是 JavaScript 或者浏览器原生提供的方法，而是 Vue.js 框架提供的一种特殊功能。</p>\n<p>通常情况下，当我们使用 Vue 来创建数据驱动的程序时，如果我们直接给一个对象添加新的属性，这个新属性将不会被 Vue 监听到变化，因为 Vue 无法自动追踪对象属性的添加或删除。这时候就可以使用 <code>this.$set</code> 方法来解决这个问题。</p>\n<p>具体用法如下：</p>\n<pre><code class=\"javascript\">javascriptCopy Code// 在 Vue 实例的方法中使用 this.$set\nthis.$set(obj, &#39;newProp&#39;, 123)\n</code></pre>\n<p>其中，<code>obj</code> 是已有的对象，<code>newProp</code> 是要添加的新属性名，<code>123</code> 是新属性的初始值。</p>\n<p>通过使用 <code>this.$set</code> 方法，Vue 将能够监听到新属性的变化，从而实现响应式更新。</p>\n<p>需要注意的是，在 Vue 2.x 版本中，通常情况下是不推荐直接给对象添加新属性的，而是应该在初始化时就声明好所有的属性。但是在某些动态场景下，比如处理服务器返回的数据、动态表单等，可能会用到 <code>this.$set</code> 方法来动态添加属性并保持响应式。</p>\n<h1 id=\"Vue3-中为-v-for-循环渲染的列表添加-ref\"><a href=\"#Vue3-中为-v-for-循环渲染的列表添加-ref\" class=\"headerlink\" title=\"Vue3 中为 v-for 循环渲染的列表添加 ref\"></a>Vue3 中为 v-for 循环渲染的列表添加 ref</h1><p>只需要 v-bind ref 为一个函数即可，则函数在每次进行列表渲染的时候都会执行一次，函数的参数为当前列表的 DOM 元素</p>\n<h1 id=\"Vue-中组件通信\"><a href=\"#Vue-中组件通信\" class=\"headerlink\" title=\"Vue 中组件通信\"></a>Vue 中组件通信</h1><p>一、父子组件传值和自定义事件</p>\n<p>二、全局事件总线</p>\n<p>三、依赖注入 Provide &#x2F; Inject</p>\n<p>四、Vuex</p>\n<p>五、组件上使用 ref</p>\n<p>六、pinia</p>\n<h1 id=\"Vue3-新增内置组件\"><a href=\"#Vue3-新增内置组件\" class=\"headerlink\" title=\"Vue3 新增内置组件\"></a>Vue3 新增内置组件</h1><p>一、teleport 传送，通过 to 属性传送对应内容</p>\n<p>二、suspense 异步组件 未定（占位）</p>\n<p>三、fragment 片段，比 template 更加轻量</p>\n<h1 id=\"swc-loader\"><a href=\"#swc-loader\" class=\"headerlink\" title=\"swc-loader\"></a>swc-loader</h1><p>swc-loader 是用于 pollyfill 的打包工具之一，底层采用 rust 进行编写，大大提升了打包构建的速度</p>\n<h1 id=\"SSE（Server-Send-Event）\"><a href=\"#SSE（Server-Send-Event）\" class=\"headerlink\" title=\"SSE（Server-Send-Event）\"></a>SSE（Server-Send-Event）</h1><p>SSE 采用服务端主动发送事件的方式（返回响应头 Content-Type:”text&#x2F;event-stream’’），向前端发送信息，前端通过事件的注册（通过 EventSource 构造函数创建实例，通过事件注册的方式）来接受。采用的是发布订阅的模式。</p>\n<ul>\n<li><p>服务端注册 api，res.writeHead 中书写 Content-Type，通过 res.write 方法进行写入</p>\n</li>\n<li><p>浏览器端</p>\n<ul>\n<li><p>通过<code>new EventSource(url,options);</code>创建事件源</p>\n</li>\n<li><p>通过实例的 readState 判断连接状态</p>\n</li>\n<li><p>通过监听实例的 onmessage 事件来获取服务端响应过来的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"获取网络连接状态\"><a href=\"#获取网络连接状态\" class=\"headerlink\" title=\"获取网络连接状态\"></a>获取网络连接状态</h1><p>一、事件监听（不断执行）</p>\n<pre><code class=\"javascript\">window.addEventListener(&quot;online&quot;, () =&gt; &#123;\n  console.log(&quot;网络连接成功&quot;);\n&#125;);\nwindow.addEventListener(&quot;offline&quot;, () =&gt; &#123;\n  console.log(&quot;网络连接失败&quot;);\n&#125;);\n</code></pre>\n<p>二、通过 navigator（执行一次）</p>\n<pre><code class=\"javascript\">if (navigator.onLine) &#123;\n  console.log(&quot;在线&quot;);\n&#125; else &#123;\n  console.log(&quot;掉线&quot;);\n&#125;\n</code></pre>\n<p>获取更多详细连接信息（通过 navigator.connection）</p>\n<pre><code class=\"javascript\">//需要兼容性处理\nif (&quot;connection&quot; in navigator) &#123;\n  const networkInfo = navigator.connection;\n  console.log(&quot;当前网络估计下行速度&quot;, networkInfo.downlink);\n  console.log(&quot;当前网络估计速度类型&quot;, networkInfo.effectiveType);\n  console.log(&quot;当前网络估计往返时间&quot;, networkInfo.rtt);\n  console.log(&quot;是否处于数据节省模式&quot;, networkInfo.saveData);\n&#125; else &#123;\n  console.log(&quot;当前浏览器不支持&quot;);\n&#125;\n</code></pre>\n<h1 id=\"—————————-JS-函数式编程\"><a href=\"#—————————-JS-函数式编程\" class=\"headerlink\" title=\"—————————-JS 函数式编程\"></a>—————————-JS 函数式编程</h1><p>在 JavaScript 中，函数式编程（Functional Programming）是一种以函数为基本构建块的编程范式。它强调将计算视为数学函数的执行，并避免了状态和可变数据。函数式编程在 JavaScript 中具有以下特点：</p>\n<ol>\n<li>函数是一等公民：在函数式编程中，函数被视为一等公民，可以像其他值（如数字、字符串）一样被传递、赋值和返回。这意味着函数可以作为参数传递给其他函数，也可以从函数中返回另一个函数。</li>\n<li>纯函数（Pure Function）：纯函数是指没有副作用的函数，它的输出完全由输入决定，不会改变外部状态或产生其他可见效果。纯函数对于相同的输入始终返回相同的结果，且不会修改原始数据。在函数式编程中，鼓励使用纯函数来处理数据，因为它们易于测试、理解和推理。</li>\n<li>不可变性（Immutability）：函数式编程鼓励使用不可变数据，即数据在创建后不能被修改。当需要对数据进行操作时，函数式编程通常会创建新的数据副本而不是直接修改原始数据。这样可以避免出现意外的副作用和数据竞争，并使代码更加可靠和可维护。</li>\n<li>高阶函数（Higher-Order Function）：高阶函数是指能够接受一个或多个函数作为参数，或者返回一个函数作为结果的函数。JavaScript 中的函数可以作为值进行传递和操作，因此非常适合编写高阶函数。高阶函数可以接收其他函数作为参数，也可以返回新的函数，从而实现函数的组合和抽象。</li>\n<li>函数组合（Function Composition）：函数式编程鼓励使用函数组合来创建复杂功能。函数组合是指将一个函数的输出作为另一个函数的输入，并生成一个新的函数。通过将多个小功能的函数组合在一起，可以形成更复杂的功能，提高代码的可读性和可维护性。</li>\n</ol>\n<p>函数式编程的目标是编写简洁、模块化且可复用的代码。通过使用函数式编程范式，可以实现代码的易于测试、可扩展、并行处理以及更好的可维护性。在 JavaScript 中，函数式编程通常与其他编程范式（如面向对象编程）结合使用，以充分发挥 JavaScript 的灵活性和表达力。</p>\n<h1 id=\"prototype-和、-proto\"><a href=\"#prototype-和、-proto\" class=\"headerlink\" title=\"prototype 和、_ _proto _ _\"></a>prototype 和、_ _proto _ _</h1><p>构造函数的 prototype 是实例的原型对象（_ _ <em>proto</em> _ _）</p>\n<ol>\n<li><p><code>prototype</code> 属性： <code>prototype</code> 是函数对象特有的属性，它指向一个对象，该对象被用作构造函数创建的实例的原型。当使用 <code>new</code> 关键字创建一个对象时，该对象的 <code>__proto__</code> 属性会指向构造函数的 <code>prototype</code> 属性。通过修改构造函数的 <code>prototype</code> 属性，可以为通过该构造函数创建的实例添加共享的方法和属性。</p>\n<p>示例：</p>\n<pre><code class=\"javascript\">javascriptCopy Codefunction Person(name) &#123;\n  this.name = name;\n&#125;\n\nPerson.prototype.sayHello = function() &#123;\n  console.log(&#39;Hello, &#39; + this.name);\n&#125;;\n\nconst person1 = new Person(&#39;Alice&#39;);\nperson1.sayHello(); // 输出：Hello, Alice\n</code></pre>\n</li>\n<li><p><code>__proto__</code> 属性： <code>__proto__</code> 是每个对象（包括函数对象）都具有的属性，它指向该对象的原型。通过 <code>__proto__</code> 属性，可以访问和操作对象的原型链。当访问一个对象的属性时，如果对象本身没有该属性，JavaScript 引擎会沿着对象的原型链向上查找，直到找到该属性或到达原型链的顶端（即 <code>null</code>）。</p>\n<p>示例：</p>\n<pre><code class=\"javascript\">javascriptCopy Codeconst obj = &#123; a: 1 &#125;;\nconsole.log(obj.__proto__); // 输出：Object &#123;&#125;\n\nconst arr = [1, 2, 3];\nconsole.log(arr.__proto__); // 输出：Array []\n\nfunction Person(name) &#123;\n  this.name = name;\n&#125;\n\nconst person1 = new Person(&#39;Alice&#39;);\nconsole.log(person1.__proto__); // 输出：Person &#123;&#125;\n</code></pre>\n<p>需要注意的是，<code>__proto__</code> 属性在现代 JavaScript 中已经被标准化为内部属性 <code>[[Prototype]]</code>，推荐使用 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf()</code> 方法来访问和设置对象的原型。</p>\n</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><code>prototype</code> 属性是函数对象特有的属性，用于指定构造函数创建的实例的原型。</li>\n<li><code>__proto__</code> 属性是每个对象都具有的属性，用于指向该对象的原型。它可以访问和操作对象的原型链。</li>\n</ul>\n<h1 id=\"hasOwnProperty-和-in\"><a href=\"#hasOwnProperty-和-in\" class=\"headerlink\" title=\"hasOwnProperty 和 in\"></a>hasOwnProperty 和 in</h1><p>OBJ . hasOwnProperty 检查对象中是否有属性（只返回在自己身上的，不包括原型）</p>\n<p>属性 in OBJ 检查对象中是否有属性，只能检查对象是否可以调用该属性</p>\n<h1 id=\"ES6-剩余参数\"><a href=\"#ES6-剩余参数\" class=\"headerlink\" title=\"ES6 剩余参数\"></a>ES6 剩余参数</h1><pre><code class=\"javascript\">//形参中使用数组，然后展开\nfunction a(...nums) &#123;\n  //传参数组\n  console.log(nums); //数组\n&#125;\nsum(&quot;sd&quot;, &quot;s&quot;, &quot;a&quot;, &quot;b&quot;);\n</code></pre>\n<h1 id=\"模拟-call-方法定义过程\"><a href=\"#模拟-call-方法定义过程\" class=\"headerlink\" title=\"模拟 call 方法定义过程\"></a>模拟 call 方法定义过程</h1><p>（用 JS 代码模拟，实际是 C++代码）</p>\n<pre><code class=\"javascript\">Function.prototype.hycall = function (thisArg, ...args) &#123;\n  var fn = this;\n  thisArg = thisArg ? Object(thisArg) : window;\n  thisArg.fn = fn;\n  var result = thisArg.fn(...args);\n  delete thisArg.fn;\n  return result;\n&#125;;\nfunction foo() &#123;\n  console.log(&quot;foo函数执行&quot;, this);\n&#125;\nfunction sum(sum1, sum2) &#123;\n  console.log(&quot;sum函数执行&quot;, this, sum1, sum2);\n  return num1 + num2;\n&#125;\nfoo.call(undefined); //系统调用call方法\nvar result = sum.call(&#123;&#125;, 20, 30); //系统调用call方法\nfoo.hycall(undefined);\nvar result = sum.hycall(&quot;abc&quot;, 20, 30);\nconsole.log(&quot;hycall的调用：&quot;, result);\n</code></pre>\n<h1 id=\"模拟-apply-方法定义过程\"><a href=\"#模拟-apply-方法定义过程\" class=\"headerlink\" title=\"模拟 apply 方法定义过程\"></a>模拟 apply 方法定义过程</h1><pre><code class=\"javascript\">Function.prototype.hyapply = function (thisArg, argArray) &#123;\n  // 获取到要执行的函数,this因为是隐式调用，指向当前的函数\n  var fn = this;\n  // 处理绑定的thisArg,(边界判断了0)\n  thisArg =\n    thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window;\n  // 执行函数\n  thisArg.fn = fn;\n  var result;\n  // 没有传参数数组时\n  // if (!argArray) &#123;\n  //     result = thisArg.fn()\n  // &#125; else &#123;\n  //     result = thisArg.fn(...argArray)\n  // &#125;  或者\n  // argArray = argArray ? argArray:[]   或者\n  argArray = argArray || [];\n  // 形参处理\n  result = thisArg.fn(...argArray);\n  delete thisArg.fn;\n  return result;\n&#125;;\nfunction sum(num1, num2) &#123;\n  console.log(&quot;sum被调用&quot;, this, num1, num2);\n  return num1 + num2;\n&#125;\n\n// 自己实现的调用\nvar result = sum.hyapply(&quot;abc&quot;, [20, 30]);\nconsole.log(result);\n</code></pre>\n<h1 id=\"关键字-arguments-函数中\"><a href=\"#关键字-arguments-函数中\" class=\"headerlink\" title=\"关键字 arguments(函数中)\"></a>关键字 arguments(函数中)</h1><p>一、<strong>类数组对象</strong>，默认绑定函数执行时传入的参数</p>\n<p>二、可以使用 length 或者索引，但是不能使用数组内置的一些方法（类数组对象）</p>\n<pre><code class=\"javascript\">function ad() &#123;\n  console.log(arguments);\n  console.log(arguments.length);\n  console.log(arguments[0]);\n&#125;\nad(1, 4, 2, 1, 22);\nad(&quot;sd&quot;, &quot;sdj&quot;);\nad(&quot;d&quot;);\n</code></pre>\n<p>三、如何让 arguments 类数组对象可以使用数组的内置方法？</p>\n<pre><code class=\"javascript\">//一、 遍历类数组对象\nfunction foo(num1, num2) &#123;\n  var newArr = [];\n  for (var i = 0; i &lt; arguments.length; i++) &#123;\n    newArr.push[arguments[i] * 10];\n  &#125;\n  console.log(newArr);\n&#125;\nfoo(10, 20, 30, 40, 50);\n\n// 二、数组原型上使用方法，加到arguments上（argument类数组，可遍历迭代，因此可以使用）\nvar newArr2 = Array.prototype.slice.call(arguments);\nconsole.log(newArr2);\n// 或 三：\nvar newArr3 = [].slice.call(arguments);\nconsole.log(newArr3);\n// 或   四、将类数组对象转成数组类型\nvar newArr4 = Array.from(arguments);\n// 或  五、转成数组类型\nvar newArr5 = [...arguments];\n</code></pre>\n<p>四、<strong>箭头函数没有<code>arguments</code>对象 ，函数执行时会去上层作用域寻找</strong></p>\n<p>五、<strong>注意浏览器中全局对象中没有<code>arguments</code> ， 但是 node 环境全局中有<code>arguments</code>，里面存放的是模块</strong></p>\n<h1 id=\"剩余参数…args\"><a href=\"#剩余参数…args\" class=\"headerlink\" title=\"剩余参数…args\"></a>剩余参数…args</h1><p>…args 不是关键字！！，只能使用在函数定义时，最后一个形参</p>\n<p><code>...arg</code> 和 <code>arguments</code> 都可以用于处理函数中的参数。但是，它们之间有一些重要的区别和不同：</p>\n<ol>\n<li><strong>变量类型不同</strong>：<code>...arg</code> 表示一个数组，而 <code>arguments</code> 表示一个类似数组的对象。</li>\n<li><strong>使用限制不同</strong>：<code>...arg</code> 只能用在函数定义时的最后一个参数上，而 <code>arguments</code> 可以在任何地方使用。</li>\n<li><strong>可迭代性不同</strong>：由于 <code>...arg</code> 生成的是一个真正的数组，因此可以使用数组的所有方法，如 <code>forEach()</code>、<code>map()</code>、<code>reduce()</code> 等。而 <code>arguments</code> 并非真正的数组，因此不能使用数组方法，需要通过数组转换才能使用。</li>\n</ol>\n<h1 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h1><p>一、定义：①、相同的输入，产生相同的输出，输出只和函数内部执行有关。即输出不会因为外部变量或状态改变受影响</p>\n<p>②、无副作用，不会改变外部变量的值或状态（副作用是产生 bug 的温床）</p>\n<p>二、举例：数组中<code>slice</code>方法是纯函数，<code>splice</code>方法是非纯函数</p>\n<h1 id=\"函数的柯里化\"><a href=\"#函数的柯里化\" class=\"headerlink\" title=\"函数的柯里化\"></a>函数的柯里化</h1><p>在<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUE3JTkxJUU1JUFEJUE2\">计算机科学</span>中，<strong>柯里化</strong>（英语：Currying），又译为<strong>卡瑞化</strong>或<strong>加里化</strong>，是把接受多个<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJTgzJUU2JTk1JUI4XyglRTclQTglOEIlRTUlQkMlOEYlRTglQTglQUQlRTglQTglODgp\">参数</span>的<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU2JTk1JUIw\">函数</span>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。例如：</p>\n<pre><code class=\"javascript\">const add = (x, y) =&gt; x + y; //柯里化转化为；\nconst add2 = (x) =&gt; (y) =&gt; x + y;\nadd2(4)(4);\n\n//又或者：\n\nfunction foo(m, n, x, y) &#123;\n  return m + n + x + y;\n&#125;\nfoo(10, 20, 30, 40);\n//柯里化的过程\nfunction bar(m) &#123;\n  return function (n) &#123;\n    return function (x) &#123;\n      return function (y) &#123;\n        m + n + x + y;\n      &#125;;\n    &#125;;\n  &#125;;\n&#125;\nbar(10)(20)(30)(40);\n//简化柯里化代码\nvar sum3 = (x) =&gt; (y) =&gt; (z) =&gt; x + y + z;\n</code></pre>\n<p>柯里化的作用和好处：使得一个函数处理问题尽可能的<strong>单一、简单</strong>，而不是一大推处理过程交给一个函数来处理，并且可以<strong>复用和定制化</strong><br>柯里化的本质：将某个操作中已完成的结果保留，知道其余部分后续也完成后可以一并提供的机制，通过在一个函数中返回另一个函数实现</p>\n<pre><code class=\"javascript\">var log = (date) =&gt; (type) =&gt; (message) =&gt; &#123;\n  console.log(\n    `[$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;][$&#123;type&#125;]:[$&#123;message&#125;]`\n  );\n&#125;;\nvar nowLog = log(new Date());\nnowLog(&quot;DEBUG&quot;)(&quot;查找到轮播图的bug&quot;);\nnowLog(&quot;FETURE&quot;)(&quot;新增了添加功能&quot;);\nvar nowAndDebugLog = log(new Date())(&quot;DEBUG&quot;);\nnowAndDebugLog(&quot;找到bug&quot;);\nvar nowAndFutureLog = log(new Date())(&quot;FETURE&quot;);\nnowAndFutureLog(&quot;添加功能&quot;);\n</code></pre>\n<p><strong>柯里化的本质：</strong></p>\n<p>函数柯里化就是将多参函数转变为单参函数的过程，柯里化将函数转变为高阶的返回新函数的函数，目的是将原先传入的多个参数利用函数作用域储存起来，以供后续直接使用。</p>\n<h1 id=\"————————-面向对象编程\"><a href=\"#————————-面向对象编程\" class=\"headerlink\" title=\"————————-面向对象编程\"></a>————————-面向对象编程</h1><h1 id=\"浏览器事件循环\"><a href=\"#浏览器事件循环\" class=\"headerlink\" title=\"浏览器事件循环\"></a>浏览器事件循环</h1><p>①setTimeout、Http、DOM、等并不在浏览器内核（如 V8 引擎中）</p>\n<p>② 调用函数时，进入函数就将函数放进执行栈，离开函数就将函数弹出执行栈</p>\n<p>③ 在栈中表现很慢的东西叫做阻塞（http 请求，多重 for 循环，加载资源等），执行栈中的内容是一个个执行的，因为 js 是一门单线程的语言，那么当执行阻塞时，为了不影响到页面的流畅 ，浏览器会开启其余的线程（交互线程、文件线程、网络线程、计时线程、等）进行辅助处理</p>\n<h1 id=\"webAPI\"><a href=\"#webAPI\" class=\"headerlink\" title=\"webAPI\"></a>webAPI</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9KYXZhU2NyaXB0L0NsaWVudC1zaWRlX3dlYl9BUElzL0ludHJvZHVjdGlvbg==\">Web API 简介 - 学习 Web 开发 | MDN (mozilla.org)</span></p>\n<p>分为：一、浏览器 API 二、第三方 API</p>\n<h1 id=\"navigator-sendBeacon\"><a href=\"#navigator-sendBeacon\" class=\"headerlink\" title=\"navigator.sendBeacon\"></a>navigator.sendBeacon</h1><pre><code class=\"javascript\">//性能中继器，使用不同指标来衡量和分析应用程序的性能\n//当页面上任何指标值完成计算时，将传递计算出的结果并触发这个函数\n//可以使用它将结果记录到控制台或者发送到特定端点\nfunction sendTo(metric) &#123;\n  const content = JSON.stringify(metric);\n  if (navigator.sendBeacon) &#123;\n    navigator.sendBeacon(&quot;http://test&quot;, content); //navigator.sendBeacon的作用是\n  &#125; else &#123;\n    fetch(&quot;http://test.com&quot;, &#123;\n      content,\n      method: &quot;POST&quot;,\n      keepAlive: true, //fetch中的keepAlice保证了即使页面刷新或者关闭，发出的请求仍然存在并进行，而不是进行到一半的请求突然停止\n    &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;发送成功&quot;);\n      &#125;)\n      .catch((e) =&gt; &#123;\n        console.error(e);\n      &#125;);\n  &#125;\n&#125;\nreportWebVitals(sendTo); //每一次得到计算结果都会执行一次\n</code></pre>\n<h3 id=\"对比-Ajax-fetch\"><a href=\"#对比-Ajax-fetch\" class=\"headerlink\" title=\"对比 Ajax fetch\"></a>对比 Ajax fetch</h3><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>不受页面卸载过程的影响，确保数据可靠发送。</li>\n<li>异步执行，不阻塞页面关闭或跳转。</li>\n<li>能够发送跨域请求。</li>\n</ol>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>fetch 和 ajax 都可以发送任意请求 而 sendBeacon 只能发送 POST</li>\n<li>fetch 和 ajax 可以传输任意字节数据 而 sendBeacon 只能传送少量数据（64KB 以内）</li>\n<li>fetch 和 ajax 可以定义任意请求头 而 sendBeacon 无法自定义请求头</li>\n<li>sendBeacon 只能传输 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>ArrayBufferView</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\"><code>Blob</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>DOMString</code></a>、<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\"><code>FormData</code></a> 或 <a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\"><code>URLSearchParams</code></a> 类型的数据</li>\n<li><code>如果处于危险的网络环境，或者开启了广告屏蔽插件 此请求将无效</code></li>\n</ol>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ol>\n<li>发送心跳包：可以使用 <code>navigator.sendBeacon</code> 发送心跳包，以保持与服务器的长连接，避免因为长时间没有网络请求而导致连接被关闭。</li>\n<li>埋点：可以使用 <code>navigator.sendBeacon</code> 在页面关闭或卸载时记录用户在线时间，pv uv，以及错误日志上报 按钮点击次数。</li>\n<li>发送用户反馈：可以使用 <code>navigator.sendBeacon</code> 发送用户反馈信息，如用户意见、bug 报告等，以便进行产品优化和改进</li>\n</ol>\n<h1 id=\"深拷贝新增\"><a href=\"#深拷贝新增\" class=\"headerlink\" title=\"深拷贝新增\"></a>深拷贝新增</h1><p>window.structuredClone 方法，用于直接实现深拷贝。</p>\n<h1 id=\"React-StrictMode\"><a href=\"#React-StrictMode\" class=\"headerlink\" title=\"React.StrictMode\"></a>React.StrictMode</h1><p>React 的严格模式默认会渲染两次 react 组件（提前进行一个预渲染），第一次渲染用于收集工作（如计算和副作用），第二次渲染实际上显示在屏幕上。这种双重渲染有助于 React 检测组件中可能的副作用。以便于开发者能发现和修复性能问题。例如，如果一个函数组件在渲染时执行了不必要的计算或者副作用，这可能会在两次渲染中表现出来。通过比较两次渲染的结果，React 可以检测出组件中是否有副作用。如果两次渲染的结果不一致，那么可能表明组件在渲染过程中产生了副作用。</p>\n<h1 id=\"gt-gt-gt-0是什么意思\"><a href=\"#gt-gt-gt-0是什么意思\" class=\"headerlink\" title=\"&gt;&gt;&gt; 0是什么意思\"></a>&gt;&gt;&gt; 0是什么意思</h1><blockquote>\n<p><code>&gt;&gt;&gt;</code>标识无符号右移，该操作符会将符号位保留，将位数向左移动一位，那么无符号位移0有什么作用呢？其实无符号位移0相当于：①将非number类型的数据转换为number,②将number转换为无符号的32bit数据，也就是Uint32类型。这些与移位的位数无关，移位0位主要就是用了js的内部特性做了前两种转换。</p>\n</blockquote>\n<h1 id=\"巧用双等于null\"><a href=\"#巧用双等于null\" class=\"headerlink\" title=\"巧用双等于null\"></a>巧用双等于null</h1><blockquote>\n<p>如果想要同时判断不等于null和undefined，可以巧用双等号，例如：<code>if(this == null)&#123; return &quot;this is null or undefined&quot;&#125;</code>，从而同时判断不为null，undefined。</p>\n</blockquote>\n","categories":["杂记"],"tags":["杂记","技巧"]},{"title":"正则理念","url":"/2024/01/10/%E6%AD%A3%E5%88%99/","content":"<h1 id=\"正则理念\"><a href=\"#正则理念\" class=\"headerlink\" title=\"正则理念\"></a>正则理念</h1><h1 id=\"两种模糊匹配\"><a href=\"#两种模糊匹配\" class=\"headerlink\" title=\"两种模糊匹配\"></a>两种模糊匹配</h1><ul>\n<li>如果正则只有精确匹配是没有多大意义的(匹配的是固定的结果)</li>\n<li>正则表达式就强大在能实现模糊匹配</li>\n</ul>\n","categories":["正则表达式"],"tags":["正则理念"]},{"title":"框架高级","url":"/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/","content":"<h1 id=\"vue高级用法\"><a href=\"#vue高级用法\" class=\"headerlink\" title=\"vue高级用法\"></a>vue高级用法</h1><h3 id=\"watchEffect函数\"><a href=\"#watchEffect函数\" class=\"headerlink\" title=\"watchEffect函数\"></a>watchEffect函数</h3><blockquote>\n<p>立即运行传入的函数，同时自动追踪其依赖，并在依赖更改时重新执行。<br>watchEffect的返回值是用于清除该副作用的函数。</p>\n</blockquote>\n<pre><code class=\"js\">const data = ref(0);\nconst stop = watchEffect(()=&gt;console.log(data.value,&#39;data变化了&#39;));\nstop(); //清除响应性监听\n</code></pre>\n<blockquote>\n<p>watchEffect的第二个参数是options配置项，可以配置flush、onTrack函数和onTrigger函数</p>\n</blockquote>\n<pre><code class=\"js\">watchEffect(()=&gt;&#123;&#125;,&#123;\n    flush:&quot;post&quot;, //flush配置项配置回调函数的刷新时机，post会在DOM渲染之后触发、sync会在vue进行任何更新之前进行触发\n    onTrack(e)&#123;debugger&#125;;\n    onTrigger(e)&#123;debugger&#125;;\n&#125;)\n</code></pre>\n<h3 id=\"watchSyncEffect函数\"><a href=\"#watchSyncEffect函数\" class=\"headerlink\" title=\"watchSyncEffect函数\"></a>watchSyncEffect函数</h3><blockquote>\n<p>回调函数会在DOM渲染之后触发,相当于watchEffect中配置了fulsh:”post”</p>\n</blockquote>\n<h3 id=\"watchSyncEffect函数-1\"><a href=\"#watchSyncEffect函数-1\" class=\"headerlink\" title=\"watchSyncEffect函数\"></a>watchSyncEffect函数</h3><blockquote>\n<p>回调函数在vue进行任何更新之前触发,相当于watchEffect中配置了fulsh:”sync”</p>\n</blockquote>\n<h3 id=\"effectScope函数\"><a href=\"#effectScope函数\" class=\"headerlink\" title=\"effectScope函数\"></a>effectScope函数</h3><blockquote>\n<p>effectScope函数创建一个effect作用域，可以捕获其中所创建的响应式副作用（即计算属性和侦听器），这样捕获到的副作用可以一起处理。</p>\n</blockquote>\n<pre><code class=\"javascript\">const scope = effectScope();\nscope.run(()=&gt;&#123;\n  const doubled = computed(() =&gt; counter.value * 2)\n  watch(doubled, () =&gt; console.log(doubled.value))\n  watchEffect(() =&gt; console.log(&#39;Count: &#39;, doubled.value))\n&#125;)\nscope.stop(); //清除掉作用域内所有的effect\n</code></pre>\n<h3 id=\"getCurrentScope函数\"><a href=\"#getCurrentScope函数\" class=\"headerlink\" title=\"getCurrentScope函数\"></a>getCurrentScope函数</h3><blockquote>\n<p>获取当前活跃的effect作用域</p>\n</blockquote>\n<h3 id=\"onScopeDispost函数\"><a href=\"#onScopeDispost函数\" class=\"headerlink\" title=\"onScopeDispost函数\"></a>onScopeDispost函数</h3><blockquote>\n<p>在当前活跃的effect作用域上注册一个处理回调函数。当相关的effect作用域停止时会调用这个回调函数。</p>\n</blockquote>\n<h3 id=\"shallowRef函数\"><a href=\"#shallowRef函数\" class=\"headerlink\" title=\"shallowRef函数\"></a>shallowRef函数</h3><blockquote>\n<p>用于浅层响应式,避免深层比较带来的效率问题</p>\n</blockquote>\n<h3 id=\"triggerRef函数\"><a href=\"#triggerRef函数\" class=\"headerlink\" title=\"triggerRef函数\"></a>triggerRef函数</h3><blockquote>\n<p>强制触发依赖于一个浅层ref的副作用，通常在对浅引用的内部值进行深度变更后使用</p>\n</blockquote>\n<h3 id=\"customRef函数\"><a href=\"#customRef函数\" class=\"headerlink\" title=\"customRef函数\"></a>customRef函数</h3><blockquote>\n<p>customRef函数创建一个自定义的ref，显示声明对其依赖追踪和更新触发的控制方式。预期接受一个工厂函数作为参数，这个工厂函数接收track和trigger两个函数作为参数，并返回一个带有get和set方法的对象</p>\n</blockquote>\n<pre><code class=\"js\">// 定义一个返回懒执行响应式数据的函数\nfunction useDebouncedRef(value,delay=200)&#123;\n    let timeout;\n    return customRef((track,trigger)=&gt;&#123;\n        return &#123;\n            get()&#123;\n                track();\n                return value;\n            &#125;,\n            set(newValue)&#123;\n                clearTimeout(timeout);\n                timeout = setTimeout(()=&gt;&#123;\n                    value = newValue;\n                    trigger();\n                &#125;,delay)     \n            &#125;\n        &#125;\n    &#125;)\n&#125;\n</code></pre>\n<h3 id=\"shallowReactive\"><a href=\"#shallowReactive\" class=\"headerlink\" title=\"shallowReactive\"></a>shallowReactive</h3><blockquote>\n<p>shallowReactive是reactive的浅层作用形式，只有跟级别的属性是响应式的，属性的值会被原样存储和暴露，这也意味着值为ref的属性不会被自动解包了。</p>\n</blockquote>\n<h3 id=\"shallowReadonly\"><a href=\"#shallowReadonly\" class=\"headerlink\" title=\"shallowReadonly\"></a>shallowReadonly</h3><blockquote>\n<p>shallowReadonly是readonly的浅层作用形式。</p>\n</blockquote>\n<h3 id=\"isRef函数\"><a href=\"#isRef函数\" class=\"headerlink\" title=\"isRef函数\"></a>isRef函数</h3><blockquote>\n<p>用于检查某个值是否是ref</p>\n</blockquote>\n<h3 id=\"unref函数\"><a href=\"#unref函数\" class=\"headerlink\" title=\"unref函数\"></a>unref函数</h3><blockquote>\n<p>如果是ref，返回ref内部的值，否则返回参数本身</p>\n</blockquote>\n<h3 id=\"toRef函数\"><a href=\"#toRef函数\" class=\"headerlink\" title=\"toRef函数\"></a>toRef函数</h3><ul>\n<li>传入ref返回ref本身</li>\n<li>传入props.key创建一个只读的ref</li>\n<li>传入number或者string相当于ref函数</li>\n<li>传入响应式数据和键值会封装为一个ref，但是相比于直接封装ref来说，会与源属性进行同步<pre><code class=\"js\">const state = reactive(&#123;foo:1,bar:2&#125;);\nconst fooRef = toRef(state,&#39;foo&#39;); //fooRef会和state的响应性相关联\nconst fooRef2 = ref(state.foo); //fooRef2不会和state.foo的响应性相关联\n</code></pre>\n</li>\n</ul>\n<h3 id=\"toRefs函数\"><a href=\"#toRefs函数\" class=\"headerlink\" title=\"toRefs函数\"></a>toRefs函数</h3><blockquote>\n<p>vue3中的ref将reactive响应性绑定到.value属性上，其本质就是为了防止开发者错误的将响应式数据进行解构后的变量又其当作响应式数据。所以加了一层隔离。toRefs函数也是用于解决这个问题。<br>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的ref。每个单独的ref都是使用toRef创建的</p>\n</blockquote>\n<pre><code class=\"js\">const state = reactive(&#123;\n  name:&quot;张三&quot;,\n  age:18  \n&#125;)\nconst stateAsRefs = toRefs(state);\nstate.name = &quot;李四&quot;; //toRefs返回的响应式数据和原响应式数据相互关联\nconsole.log(stateAsRefs.name.value) //李四\n//toRefs的存在是为了保证reactive响应式被解构之后仍然存在响应性\nconst &#123;name,age&#125; = toRefs(state)\n//解构之后的name和age都是响应式对象\n</code></pre>\n<h3 id=\"toRaw函数\"><a href=\"#toRaw函数\" class=\"headerlink\" title=\"toRaw函数\"></a>toRaw函数</h3><blockquote>\n<p>toRaw返回由reactive、readonly、shallowReactive或者shallowReadonly创建的代理对应的原始对象（栈赋值），返回的对象不再具有响应式，栈赋值时不会影响到页面的展示，但如果改变该对象的堆中的属性，原对象的依赖项也会随之变化</p>\n</blockquote>\n<h3 id=\"markRaw函数\"><a href=\"#markRaw函数\" class=\"headerlink\" title=\"markRaw函数\"></a>markRaw函数</h3><blockquote>\n<p>将一个对象标记为不可被转为代理，返回该对象本身</p>\n</blockquote>\n<h3 id=\"toValue函数\"><a href=\"#toValue函数\" class=\"headerlink\" title=\"toValue函数\"></a>toValue函数</h3><blockquote>\n<p>将值、函数、或响应式数据规范化为普通值，toValue(ref(1)) —&gt; 1</p>\n</blockquote>\n<h3 id=\"isProxy函数\"><a href=\"#isProxy函数\" class=\"headerlink\" title=\"isProxy函数\"></a>isProxy函数</h3><blockquote>\n<p>检查一个对象是否是由reactive、readonly、shallowReactive或者shallowReadonly创建的代理。</p>\n</blockquote>\n<h3 id=\"isReactive函数\"><a href=\"#isReactive函数\" class=\"headerlink\" title=\"isReactive函数\"></a>isReactive函数</h3><blockquote>\n<p>检查一个对象是否是由reactive或shallowReactive创建的代理</p>\n</blockquote>\n<h3 id=\"isreadonly函数\"><a href=\"#isreadonly函数\" class=\"headerlink\" title=\"isreadonly函数\"></a>isreadonly函数</h3><blockquote>\n<p>检查传入的值是否是只读对象，只读对象的属性可以更改，但是不能通过传入的对象直接赋值。</p>\n</blockquote>\n<h3 id=\"Transition组件\"><a href=\"#Transition组件\" class=\"headerlink\" title=\"Transition组件\"></a>Transition组件</h3><ul>\n<li>使用过渡样式</li>\n<li>mode属性定义动画进行的顺序,常用out-in </li>\n<li>name属性定义动画的名称,配合css使用</li>\n<li>appear属性初次渲染过渡</li>\n<li>生命周期钩子用于自定义过渡中执行过程,依次是before-enter,enter,after-enter,enter-cancelled,before-leave,leave,leave-cancelled,可用的参数有el和done()</li>\n<li>css样式过渡:name-enter-from\\name-enter-active\\name-enter-to\\name-leave-from\\name-leave-active\\name-leave-to定义对应时期的样式(只对可以过渡变化的样式生效)</li>\n</ul>\n<h3 id=\"TransitionGroup组件\"><a href=\"#TransitionGroup组件\" class=\"headerlink\" title=\"TransitionGroup组件\"></a>TransitionGroup组件</h3><ul>\n<li>TransitionGroup组件用于对v-for列表中的元素或组件插入 、移除或顺序变化添加动画效果.</li>\n<li>属性和生命周期和Transition一样</li>\n<li>tag属性可以指定TransitionGroup为一个容器</li>\n</ul>\n<h3 id=\"KeepAlive组件\"><a href=\"#KeepAlive组件\" class=\"headerlink\" title=\"KeepAlive组件\"></a>KeepAlive组件</h3><ul>\n<li>KeepAlive用于在多个组件间切换状态时缓存被移除的组件实例(使组件保存状态)</li>\n<li>KeepAlive的原理就是当KeepAlive中的组件被移除时,用变量将整个组件缓存起来,需要切换时直接使用缓存起来的变量</li>\n<li>include和exclude属性用于包含或排除对应的组件name</li>\n<li>KeepAlive的组件包含onActivated和onDeactived两个生命周期钩子</li>\n</ul>\n<h3 id=\"Teleport组件\"><a href=\"#Teleport组件\" class=\"headerlink\" title=\"Teleport组件\"></a>Teleport组件</h3><ul>\n<li>Teleport组件,用于将组件内部的一部分模板传送到外部结构中去</li>\n<li>to属性用于指定传送到的组件或者DOM元素</li>\n</ul>\n<h3 id=\"Suspense组件\"><a href=\"#Suspense组件\" class=\"headerlink\" title=\"Suspense组件\"></a>Suspense组件</h3><ul>\n<li>Suspense组件用于显示异步组件加载中的显示状态</li>\n<li>Suspense组件中fallback具名插槽用于显示加载内容</li>\n<li>Suspense组件嵌套Suspense组件时,给内部Suspense组件加上suspensible属性表示为异步组件,否则则会被父级Suspense组件视为同步组件</li>\n</ul>\n<h3 id=\"watch的options配置项\"><a href=\"#watch的options配置项\" class=\"headerlink\" title=\"watch的options配置项\"></a>watch的options配置项</h3><blockquote>\n<p>watch的options配置项中可以使用:</p>\n</blockquote>\n<ul>\n<li>immediate,为true时会在初始化时立即执行一次</li>\n<li>deep,为true时会深度监听对象堆中变化</li>\n<li>flush,调整回调函数的执行时机</li>\n<li>once,回调函数只会执行一次</li>\n<li>onTrack函数,当响应式被收集时进行触发<strong>只在开发模式下有效</strong></li>\n<li>onTrigger函数,当依赖项变更时进行触发<strong>只在开发模式下有效</strong></li>\n</ul>\n<h3 id=\"computed的options配置项\"><a href=\"#computed的options配置项\" class=\"headerlink\" title=\"computed的options配置项\"></a>computed的options配置项</h3><ul>\n<li>onTrack函数,当响应式被收集时进行触发<strong>只在开发模式下有效</strong></li>\n<li>onTrigger函数,当依赖项变更时进行触发<strong>只在开发模式下有效</strong></li>\n</ul>\n<h3 id=\"vue对jsx的支持友好\"><a href=\"#vue对jsx的支持友好\" class=\"headerlink\" title=\"vue对jsx的支持友好\"></a>vue对jsx的支持友好</h3><ul>\n<li>在vue中也可以很方便的去集成jsx或tsx语法，tsx语法需要在tsconfig.json中配置：jsx：preserve，最终的jsx语法会被转换为h函数</li>\n<li>对于事件和案件修饰符，可以使用vue中的withModifiers函数</li>\n</ul>\n<h3 id=\"vue对web-component的支持友好\"><a href=\"#vue对web-component的支持友好\" class=\"headerlink\" title=\"vue对web component的支持友好\"></a>vue对web component的支持友好</h3><ul>\n<li>在 Vue 应用中使用自定义元素基本上与使用原生 HTML 元素的效果相同</li>\n<li>需要在构建工具中配置compilerOptions.isCustomElement这个选项</li>\n<li>传递ODM属性时，需要使用v-bind绑定，通过.prop修饰符进行设置<pre><code class=\"html\">&lt;my-element :user.prop=&quot;&#123; name: &#39;jack&#39; &#125;&quot;&gt;&lt;/my-element&gt;\n&lt;!-- 等价简写 --&gt;\n&lt;my-element .user=&quot;&#123; name: &#39;jack&#39; &#125;&quot;&gt;&lt;/my-element&gt;\n</code></pre>\n</li>\n<li>使用vue构建web component需要使用defineCustomElement这个方法定义出组件，然后通过customElement.define这个方法将vue组件添加标签到HTML中</li>\n</ul>\n<h3 id=\"web-component的优缺点\"><a href=\"#web-component的优缺点\" class=\"headerlink\" title=\"web component的优缺点\"></a>web component的优缺点</h3><ul>\n<li>全部使用自定义元素来构建应用的方式可以使得应用永不过时和多平台、框架共享</li>\n<li>但是设想与显示总是存在偏差：</li>\n<li><ul>\n<li>1、原生web component并不具备响应式的系统</li>\n</ul>\n</li>\n<li><ul>\n<li>2、原生web component并不具备一个声明式的、高效的模板系统</li>\n</ul>\n</li>\n<li><ul>\n<li>3、SSR渲染时，web component需要在node.js中模拟出DOM，这将增大服务器端的压力</li>\n</ul>\n</li>\n<li><ul>\n<li>4、当下要想使用shadow DOM书写局部作用域的CSS，必须要将样式嵌入到JavaScript中才可以在运行时注入到shadow root上，这将导致SSR场景下需要渲染大量重复的样式标签。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vue结合js动画库\"><a href=\"#vue结合js动画库\" class=\"headerlink\" title=\"vue结合js动画库\"></a>vue结合js动画库</h3><ul>\n<li>以gsap为例，vue结合js动画库实现动画效果时，不能直接对响应式变量进行动画设置，因为是响应式完成之后才被监听到，此时响应式变量已经是最新的值，所以应该再来一个响应式变量中转一下，页面动画效果绑定的是中转的变量。</li>\n</ul>\n<h3 id=\"vue生命周期\"><a href=\"#vue生命周期\" class=\"headerlink\" title=\"vue生命周期\"></a>vue生命周期</h3><ul>\n<li>vue3中setup替代了beforeCreate和created</li>\n<li>beforeMount、monuted、beforeUpdate、updated、beforeUnmount、unMounted</li>\n<li>错误捕获钩子：onErrorCaptured，如果在onErrorCaptured中抛出一个错误，则会被app.config.errorHandler捕获到</li>\n<li>开发时钩子：onRenderTracked（组件渲染过程中追踪到响应式依赖时调用）和onRenderTriggered（当响应式依赖触发了组件渲染时调用）</li>\n<li>SSR钩子：onServerPrefetch（注册一个异步函数，在组件实例在服务器上被渲染之前调用），SSR渲染时，组件作为初始请求的一部分被渲染，这时可以在服务器上预请求数据，因为它比在客户端上更快。</li>\n<li>keepAlive组件下的钩子：onActivated和onDeactivated两个，用于当组件激活和失活时调用</li>\n</ul>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><h2 id=\"Fiber\"><a href=\"#Fiber\" class=\"headerlink\" title=\"Fiber\"></a>Fiber</h2><blockquote>\n<p>Fiber架构：Fiber架构是一个增量渲染，架构风格类似协程，Fiber架构出现的原因是由于 JS 单线程执行的特性当遇到繁琐的执行任务时，原来React15的协调过程就会很长，从而延迟DOM的渲染更新，进而出现掉帧。Fiber架构将任务分给一个个的迭代器进行执行，并且使迭代器的执行过程发生在浏览器的空闲时间，从而最大程度利用了这部分资源，使得UI渲染不会被大量执行任务所阻塞。<br>fiber树：fiber树是一个数据结构，架构在虚拟DOM转换到真实DOM之间，在Fiber结构中的任务是可以中断执行的，继续执行时会丢弃掉原来的工作从头再来，并且重新执行中断的任务，对用于来说也是无感的，因为Fiber架构的视图更新是后缓冲区视图 替换 前缓冲区视图的过程。<br>由于Fiber架构下的reconciler协调阶段是异步可中断的，且会被反复重新执行，使得反复执行时有可能触发的生命周期钩子被废弃，例如：componentWillMount、componentWillReceiveProps、componentWillUpdate这些。<br>fiber树（fiber节点构成的树状链表）的遍历与执行：</p>\n</blockquote>\n<ul>\n<li>fiber树遍历：children子节点—-sibling兄弟节点—-return父节点</li>\n<li>fiber树的执行：遍历到最底层子节点A—-A的兄弟节点—–A的父节点B——B的兄弟节点（深度优先遍历）<blockquote>\n<p>fiber节点（对象）：一个fiber节点对应一个React 组件，fiber节点里包含了组件的work任务等信息，比如组件的Hooks执行逻辑（它是一个链表，可以通过memorizedState拿到跟节点，Hooks执行逻辑里面存储了state）、生命周期、对于html组件的增删改查等副作用<br>当执行fiber节点中的任务时，每次执行完之后React就会检查当前帧还剩多少时间，没有时间就会将控制权让出去。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"fiber树、VDOM和diff算法\"><a href=\"#fiber树、VDOM和diff算法\" class=\"headerlink\" title=\"fiber树、VDOM和diff算法\"></a>fiber树、VDOM和diff算法</h3><blockquote>\n<p>fiber树就是VDOM,fiber树的变化反映了组件的状态变化<br>diff算法的本质就是: 对比<code>current fiber</code> 和 <code>JSX对象</code> 生成 <code>work-in-progress-fiber</code><br>即使是最前沿的算法,完全对比两棵树的时间复杂度也需要O(n^3),其中</p>\n</blockquote>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><blockquote>\n<p>注意：react Hooks只能在件顶层进行调用并且不能写在条件判断中，这是因为hooks以链表的形式存放在fiber节点中（类组件的副作用也存在fiber节点中），每次更新时会基于链表的顺序进行调用，而调用hooks所产生的state就存在于hooks节点之中，如果hooks写在条件判断中则导致hooks链表执行混乱，使得状态更新出错。</p>\n</blockquote>\n<h2 id=\"workLoop工作循环\"><a href=\"#workLoop工作循环\" class=\"headerlink\" title=\"workLoop工作循环\"></a>workLoop工作循环</h2><blockquote>\n<p>workLoop中会根据当前帧的剩余时间去执行fiber节点中的任务,如果时间不够就将控制权转给UI渲染,并保存当期的执行上下文(包括当前fiber节点的状态),当UI渲染完毕后,恢复其执行(执行到一半的任务会重新执行)</p>\n</blockquote>\n<h2 id=\"双缓冲策略\"><a href=\"#双缓冲策略\" class=\"headerlink\" title=\"双缓冲策略\"></a>双缓冲策略</h2><blockquote>\n<p>双缓冲策略是用于减少组件渲染过程中的闪烁和卡顿。双缓冲策略是对于fiber树来说的<br>双缓冲策略会维护两个Fiber树：Work-in-progress-fiber树 和 current-fiber树。协调过程中React会比较新旧两个fiber树的差异，从而确定哪些组件需要更新。一旦新的fiber树构建完成，React就会使用diff算法去更新真实DOM。更新完成后会将工作Fiber树的根节点与当前Fiber树的根节点进行交换，这个过程叫做提交。</p>\n</blockquote>\n<h3 id=\"Fiber更新的三个阶段\"><a href=\"#Fiber更新的三个阶段\" class=\"headerlink\" title=\"Fiber更新的三个阶段\"></a>Fiber更新的三个阶段</h3><ul>\n<li>开始阶段: <code>ReactFiberBeginWork</code></li>\n<li><ul>\n<li>这个阶段react需要决定哪些组件需要更新、哪些组件可以复用、哪些组件需要被挂载或卸载</li>\n</ul>\n</li>\n<li><ul>\n<li>React 通过比较新旧 Fiber 树来确定变化，这个过程称为协调算法（Reconciliation）。</li>\n</ul>\n</li>\n<li><ul>\n<li>此阶段会创建一个新的工作进度树（work-in-progress tree），表示 UI 的最新状态。</li>\n</ul>\n</li>\n<li><ul>\n<li>这个阶段是可中断的，React 可以决定挂起渲染过程，稍后再恢复。</li>\n</ul>\n</li>\n<li>完成阶段: <code>ReactFiberCompeleteWork</code></li>\n<li><ul>\n<li>这个阶段发生在实际将更新应用到屏幕之前。</li>\n</ul>\n</li>\n<li><ul>\n<li>React 执行生命周期方法，如 getSnapshotBeforeUpdate，允许组件捕获当前的 DOM 状态或执行捕获操作。</li>\n</ul>\n</li>\n<li><ul>\n<li>这个阶段用于执行那些需要在提交前知道布局效果的副作用，例如，测量组件的尺寸或位置。</li>\n</ul>\n</li>\n<li>提交阶段: <code>ReactFiberCommitWork</code></li>\n<li><ul>\n<li>这是实际将更改应用到真实 DOM 的阶段。</li>\n</ul>\n</li>\n<li><ul>\n<li>React 处理所有副作用，如 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法。</li>\n</ul>\n</li>\n<li><ul>\n<li>更新 DOM 元素和属性，添加或删除 DOM 节点，以确保真实 DOM 与工作进度树同步。这个阶段是连续的，不能被中断，因为 DOM 更新通常需要原子性地完成。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为什么hooks不能写在条件判断\"><a href=\"#为什么hooks不能写在条件判断\" class=\"headerlink\" title=\"为什么hooks不能写在条件判断\"></a>为什么hooks不能写在条件判断</h2><blockquote>\n<p>hooks函数最终会被存在组件对应的fiber节点的memoizatedState中，组件每次更新会按照顺序执行(hooks里面存着state状态)，如果组件每次更新时的hooks链表顺序乱了,就会导致state对应不上、状态混乱</p>\n</blockquote>\n<h2 id=\"react不可变数据\"><a href=\"#react不可变数据\" class=\"headerlink\" title=\"react不可变数据\"></a>react不可变数据</h2><blockquote>\n<p>例如当setData(data + 1)副作用在组件内连续调用三次时,其实是相当于只调用了一次,这就是react不可变数据或者说:当前快照只能操作当前快照的值 ;<br>出现react不可变数据现象的原因是由于: hooks执行逻辑最后会以链表的形式存储在fiber节点之中,而那里面不会有类似上面data这样的变量,data会在hooks执行过程被存储之前转换为其具体的值,上例正确的写法是写成一个函数,这样在存储hooks执行逻辑到fiber节点中时就会先执行传入的这个函数,例如应该写成:setData(()&#x3D;&gt;data+1)</p>\n</blockquote>\n<h3 id=\"useState钩子\"><a href=\"#useState钩子\" class=\"headerlink\" title=\"useState钩子\"></a>useState钩子</h3><blockquote>\n<p>创建可以直接更新的状态变量</p>\n</blockquote>\n<h3 id=\"useReducer钩子\"><a href=\"#useReducer钩子\" class=\"headerlink\" title=\"useReducer钩子\"></a>useReducer钩子</h3><blockquote>\n<p>与useState相似，创建状态变量，同时可以自定义reducer（内部变量变化的调度机制）</p>\n</blockquote>\n<pre><code class=\"jsx\">function App() &#123;\n  //注意：reducer中的返回值就是新的state\n  const dataReducer = (state, aciton) =&gt; &#123;\n    switch (aciton) &#123;\n      case 0: return &quot;你好&quot;;\n      case 1: return &quot;世界&quot;;\n      case 2: return &quot;你好世界&quot;;\n      default: return &quot;世界你好&quot;;\n    &#125;\n  &#125;\n  const [data, dispatchData] = useReducer(dataReducer, &quot;你好世界&quot;);\n  return (\n    &lt;&gt;\n      &lt;h1&gt;&#123;data&#125;&lt;/h1&gt;\n      &lt;button onClick=&#123;() =&gt; dispatchData(0)&#125;&gt;你好&lt;/button&gt;\n      &lt;button onClick=&#123;() =&gt; dispatchData(1)&#125;&gt;世界&lt;/button&gt;\n      &lt;button onClick = &#123;()=&gt;dispatchData(2)&#125;&gt;你好世界&lt;/button&gt;\n      &lt;button onClick=&#123;() =&gt; dispatchData(3)&#125;&gt;世界你好&lt;/button&gt;\n    &lt;/&gt;\n  )\n&#125;\n</code></pre>\n<h3 id=\"createContext和useContext钩子\"><a href=\"#createContext和useContext钩子\" class=\"headerlink\" title=\"createContext和useContext钩子\"></a>createContext和useContext钩子</h3><blockquote>\n<p>createContext和useContext直接使用相当于是创建可用的变量</p>\n</blockquote>\n<pre><code class=\"jsx\">const testContext = createContext(&quot;初始化数据&quot;)\n// 在组件中就可以拿到testContextData,然后使用:\nconst testContextData = useContext(testContext);\n</code></pre>\n<blockquote>\n<p>createContext和useContext高级用法本质上是依赖注入,他返回一个对象，对象的Provider属性是一个组件，用于注入数据（在Provider组件上绑定value属性），注入的数据可以通过useContext获取</p>\n</blockquote>\n<pre><code class=\"jsx\">const ThemeContext = createContext(null); //创建context\nfunction MyPage() &#123;\n  const [theme, setTheme] = useState(&#39;dark&#39;);\n  // 将依赖注入到组件内部\n  return (\n    &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;\n      &lt;ThemeText /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n&#125;\n// 组件内部使用注入的依赖\nfunction ThemeText()&#123;\n  const themeData = useContext(ThemeContext);\n  return &lt;&gt;&#123;themeData&#125;&lt;/&gt;\n&#125;\n</code></pre>\n<h3 id=\"useRef钩子\"><a href=\"#useRef钩子\" class=\"headerlink\" title=\"useRef钩子\"></a>useRef钩子</h3><blockquote>\n<p>帮助引用一个不需要渲染的值(不会触发组件重新渲染),返回一个具有current属性的对象,通常用于保存DOM节点<br>注意,改变 ref 不会触发重新渲染，所以 ref 不适合用于存储期望显示在屏幕上的信息。如有需要，使用 state 代替。React希望不要在渲染期间写入或者读取 ref.current,如果不得不在渲染期间读取 或者写入，那么应该 使用 state 代替。</p>\n</blockquote>\n<pre><code class=\"jsx\">function App() &#123;\n  const inputFocus = (ref) =&gt; &#123;\n    ref.current.focus();\n  &#125;;\n  const inputRef = useRef(null);\n  return (\n    &lt;&gt;&lt;input ref=&#123;inputRef&#125; /&gt;\n      &lt;button onclick=&#123;(e) =&gt; inputFocus(inputRef)&#125;&gt;聚焦输入框&lt;/button&gt;&lt;/&gt;\n  );\n&#125;\nexport default App\n</code></pre>\n<h3 id=\"useEffect钩子\"><a href=\"#useEffect钩子\" class=\"headerlink\" title=\"useEffect钩子\"></a>useEffect钩子</h3><blockquote>\n<p>接收两个参数: 副作用函数和依赖项数组,当依赖项变化时自动执行副作用函数,副作用函数的返回值是一个清理函数,会在每次组件更新前进行执行<br>useEffect中第二个参数不传代表<strong>每次渲染组件后都执行一次</strong>，传空数组代表<strong>只会在第一次挂载后执行</strong>，传依赖项代表在<strong>依赖项变化时执行。</strong>并且默认组件挂载时就会自动执行一次,以便可以读取到依赖项<br>useEffect 依赖项中传入 ref 通常是无效的，因为 ref 相当于不使用渲染赋值的 state 状态，传递过去的 ref 引用始终相同（不随着快照的渲染而变化）。<br>某些逻辑不能放在 effect 中执行，因为 effect 的执行是和组件渲染强绑定的（例如不能在 effect 中写购买商品的逻辑，这样会导致组件以任何方式被渲染都会执行购买逻辑，这样是不对的）<br>effect 中 return 的函数会在下一次 effect 执行前被执行，常用于执行清理函数（清除定时器等）</p>\n</blockquote>\n<h3 id=\"useLayoutEffect钩子\"><a href=\"#useLayoutEffect钩子\" class=\"headerlink\" title=\"useLayoutEffect钩子\"></a>useLayoutEffect钩子</h3><blockquote>\n<p>在浏览器重新绘制屏幕前执行，可以在此处测量布局。</p>\n</blockquote>\n<h3 id=\"useInsertionEffect钩子\"><a href=\"#useInsertionEffect钩子\" class=\"headerlink\" title=\"useInsertionEffect钩子\"></a>useInsertionEffect钩子</h3><blockquote>\n<p>在 React 对 DOM 进行更改之前触发，库可以在此处插入动态 CSS。</p>\n</blockquote>\n<h3 id=\"useMemo钩子\"><a href=\"#useMemo钩子\" class=\"headerlink\" title=\"useMemo钩子\"></a>useMemo钩子</h3><blockquote>\n<p>缓存函数的计算结果,只有当依赖项发生变化时,才会重新计算</p>\n</blockquote>\n<h3 id=\"useCallback钩子\"><a href=\"#useCallback钩子\" class=\"headerlink\" title=\"useCallback钩子\"></a>useCallback钩子</h3><blockquote>\n<p>缓存函数的定义,接收的参数是: 缓存函数和依赖项,只有当依赖项(栈值)发生变化时,才会更新</p>\n</blockquote>\n<pre><code class=\"jsx\">function ProductPage(&#123; productId, referrer, theme &#125;) &#123;\n  // 在多次渲染中缓存函数\n  const handleSubmit = useCallback((orderDetails) =&gt; &#123;\n    post(&#39;/product/&#39; + productId + &#39;/buy&#39;, &#123;\n      referrer,\n      orderDetails,\n    &#125;);\n  &#125;, [productId, referrer]); // 只要这些依赖没有改变\n\n  return (\n    &lt;div className=&#123;theme&#125;&gt;\n      &#123;/* ShippingForm 就会收到同样的 props 并且跳过重新渲染 */&#125;\n      &lt;ShippingForm onSubmit=&#123;handleSubmit&#125; /&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<blockquote>\n<p>useCallback是由useMemo封装而来: (useCallback内部存储的不是原来的函数体,而是一个普通函数返回函数体被useMemo缓存的结果)</p>\n</blockquote>\n<pre><code class=\"jsx\">function useCallback (fn,dependencies)&#123;\n  return useMemo(()=&gt;fn,dependencies)\n&#125;\n</code></pre>\n<h3 id=\"useTransition钩子\"><a href=\"#useTransition钩子\" class=\"headerlink\" title=\"useTransition钩子\"></a>useTransition钩子</h3><blockquote>\n<p>允许将状态转换标记为非阻塞，并允许其他更新中断它。为了更好地控制组件更新和动画而设计</p>\n</blockquote>\n<h3 id=\"useDeferredValue钩子\"><a href=\"#useDeferredValue钩子\" class=\"headerlink\" title=\"useDeferredValue钩子\"></a>useDeferredValue钩子</h3><blockquote>\n<p>允许延迟更新 UI 的非关键部分，以让其他部分先更新。</p>\n</blockquote>\n<h3 id=\"Fragment组件\"><a href=\"#Fragment组件\" class=\"headerlink\" title=\"Fragment组件\"></a>Fragment组件</h3><blockquote>\n<p><Fragment> 通常使用 &lt;&gt;…&lt;&#x2F;&gt; 代替，它们都允许你在不添加额外节点的情况下将子元素组合。</p>\n</blockquote>\n<h3 id=\"Profiler组件\"><a href=\"#Profiler组件\" class=\"headerlink\" title=\"Profiler组件\"></a>Profiler组件</h3><blockquote>\n<p><Profiler> 允许你编程式测量 React 树的渲染性能。接受一个id用于表示测量的UI部分,接受一个回调函数,当包裹的组件树更新时会传入渲染信息进行调用。</p>\n</blockquote>\n<pre><code class=\"jsx\">&lt;Profiler id=&quot;App&quot; onRender=&#123;onRender&#125;&gt;\n  &lt;App /&gt;\n&lt;/Profiler&gt;\n</code></pre>\n<h3 id=\"StrictMode组件\"><a href=\"#StrictMode组件\" class=\"headerlink\" title=\"StrictMode组件\"></a>StrictMode组件</h3><blockquote>\n<p>开启严格模式,开发阶段会渲染两次,使得尽早地发现组件中错误</p>\n</blockquote>\n<h3 id=\"Suspense组件-1\"><a href=\"#Suspense组件-1\" class=\"headerlink\" title=\"Suspense组件\"></a>Suspense组件</h3><blockquote>\n<p>展示子组件加载完成前渲染的内容.</p>\n</blockquote>\n<pre><code class=\"jsx\">&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;\n  &lt;AsyncComponent /&gt;\n&lt;/Suspense&gt;\n</code></pre>\n<h3 id=\"memo方法\"><a href=\"#memo方法\" class=\"headerlink\" title=\"memo方法\"></a>memo方法</h3><blockquote>\n<p>memo允许你的组件在道具没有改变的情况下跳过重新渲染</p>\n</blockquote>\n<h3 id=\"createPortal方法\"><a href=\"#createPortal方法\" class=\"headerlink\" title=\"createPortal方法\"></a>createPortal方法</h3><blockquote>\n<p>createPortal 允许你将 JSX 作为 children 渲染至 DOM 的指定部分。</p>\n</blockquote>\n<h3 id=\"createRoot方法\"><a href=\"#createRoot方法\" class=\"headerlink\" title=\"createRoot方法\"></a>createRoot方法</h3><blockquote>\n<p>createRoot 允许在浏览器的 DOM 节点中创建根节点以显示 React 组件。</p>\n</blockquote>\n<h3 id=\"hydrateRoot方法\"><a href=\"#hydrateRoot方法\" class=\"headerlink\" title=\"hydrateRoot方法\"></a>hydrateRoot方法</h3><blockquote>\n<p>hydrateRoot 函数允许你在先前由 react-dom&#x2F;server 生成的浏览器 HTML DOM 节点中展示 React 组件。</p>\n</blockquote>\n<h3 id=\"act方法\"><a href=\"#act方法\" class=\"headerlink\" title=\"act方法\"></a>act方法</h3><blockquote>\n<p>行为测试助手,用于测试</p>\n</blockquote>\n<h3 id=\"forwardRef方法\"><a href=\"#forwardRef方法\" class=\"headerlink\" title=\"forwardRef方法\"></a>forwardRef方法</h3><blockquote>\n<p>允许组件使用ref将 DOM 节点指向给父组件。</p>\n</blockquote>\n<h3 id=\"lazy方法\"><a href=\"#lazy方法\" class=\"headerlink\" title=\"lazy方法\"></a>lazy方法</h3><blockquote>\n<p>延迟加载组件(懒加载)。常配合Suspense组件使用</p>\n</blockquote>\n<h3 id=\"startTransition方法\"><a href=\"#startTransition方法\" class=\"headerlink\" title=\"startTransition方法\"></a>startTransition方法</h3><blockquote>\n<p>可以在不阻止UI的情况下更新状态。</p>\n</blockquote>\n<h1 id=\"Vue和React比对\"><a href=\"#Vue和React比对\" class=\"headerlink\" title=\"Vue和React比对\"></a>Vue和React比对</h1><h3 id=\"setup和Hooks\"><a href=\"#setup和Hooks\" class=\"headerlink\" title=\"setup和Hooks\"></a>setup和Hooks</h3><ul>\n<li>React Hooks在组件每次更新时,如果不做优化就会重新调用,这也带来一些性能问题</li>\n<li>Hooks有严格的调用顺序,并且不能写在条件分支中,还必须要写在react组件里面</li>\n<li>昂贵的计算需要使用useMemo,也需要传入正确的数组</li>\n<li>要解决变量闭包导致的问题,再结合并发功能,使得很难推理出一段钩子代码是什么时候运行的,并且很不好处理需要在多次渲染间保持引用的可变状态</li>\n</ul>\n<h1 id=\"react类组件和函数式组件\"><a href=\"#react类组件和函数式组件\" class=\"headerlink\" title=\"react类组件和函数式组件\"></a>react类组件和函数式组件</h1><blockquote>\n<p>类组件和函数式的比对实际上是: 面向对象和函数式编程这两大编程思想的碰撞<br>函数式编程关心的是:  需要做什么,而不是怎么去做 , 而面向对象关心的是:  数据和对象</p>\n</blockquote>\n<h2 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h2><blockquote>\n<p>完成某项任务关心的是: 数据和对象<br>面向对象编程主要围绕着数据或者对象而不是功能和逻辑实现,他将<code>关注点放在对于数据的操作方法</code>,<code>面向对象将数据和操作方法封装为一个类中,这样有利于代码的可复用性和可扩展性</code><br>面向对象编程的优点是: 效率高(符合现实世界)、容易维护(结构清晰)、易扩展(面向对象的程序往往高内聚而低耦合)、可重用(得益于对象的继承)<br>面型对象编程的缺点是: 过度的对象化、状态过于共享导致推理复杂、状态共享导致的并发问题(可变状态复杂的共享机制导致面向对象的代码几乎不可能并行化,需要复杂的线程锁定、互斥等机制)、消耗内存、性能低(会创建很多的类和实例)</p>\n</blockquote>\n<h3 id=\"面向对象编程三大特点\"><a href=\"#面向对象编程三大特点\" class=\"headerlink\" title=\"面向对象编程三大特点:\"></a>面向对象编程三大特点:</h3><ul>\n<li>封装</li>\n<li><ul>\n<li><code>封装意味着所有的数据和方法都被封装在对象内</code>，由开发者自己选择性的去公开哪些属性和方法，对于创建的实例来说他能访问的只能是这些公开的属性和方法，而对于其他对象来说是无权访问此类或者进行更改，<code>封装这一特性为程序提供了更高的安全性</code>。</li>\n</ul>\n</li>\n<li>继承</li>\n<li><ul>\n<li><code>继承意味着代码的可重用性</code>，子类和父类这两个概念就是很好的体现，子类拥有父类所有的属性和方法避免数据和方法的重复定义，同时也能够保持独特的层析结构,<code>继承这一特性为程序提供了可重用性</code>。</li>\n</ul>\n</li>\n<li>多态</li>\n<li><ul>\n<li>多态意味着设计对象以共享行为，使用继承子类可以用新的方法去覆盖父类共享的行为，多态性允许同一个方法执行两种不同的行为：覆盖和重载。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><blockquote>\n<p>完成某项任务关心的是: 需要做什么,而不是怎么去做<br>函数式编程又称声明式编程,最明显的特点就是我们<code>不太关心函数的具体实现</code>,而<code>只关心自己的业务逻辑线路</code><br>函数式编程的优点是: 代码可读性强、有一定的逻辑复用能力、并发速度快、出错率少易排查 ;<br>函数式编程的缺点是: 性能消耗大(主要是创建执行上下文的消耗) 和 资源占用大(数据不可变导致要创建很多重复的对象),同时不利于实现时间旅行等操作(状态很难回滚)</p>\n</blockquote>\n<h3 id=\"函数式编程三大特点\"><a href=\"#函数式编程三大特点\" class=\"headerlink\" title=\"函数式编程三大特点:\"></a>函数式编程三大特点:</h3><ul>\n<li>函数是一等公民: 在JS中函数和其他数据类型一样处于平等地位,可以作为变量赋值给其他变量,并且可以作为参数和返回值</li>\n<li>声明式编程: 函数式编程又称声明式编程,我们不太关心函数内部的具体实现,而是关心业务逻辑的执行流程</li>\n<li>纯函数: 纯函数特点:无副作用、引用透明 和 数据不可变</li>\n<li><ul>\n<li>无副作用: 本身不会依赖和修改外部变量</li>\n</ul>\n</li>\n<li><ul>\n<li>引用透明: 输入相同的值一定会得到相同的结果</li>\n</ul>\n</li>\n<li><ul>\n<li>数据不可变: 针对引用数据类型的入参,最好的方式是重新生成一份数据</li>\n</ul>\n</li>\n</ul>\n","categories":["框架高级"],"tags":["框架高级"]},{"title":"浮点数存储","url":"/2023/07/02/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/","content":"<p>思考：</p>\n<p>为什么0.1+0.2 !&#x3D; 0.3？</p>\n<p>为什么1.005.toFixed(2)&#x3D;1.00而不是1.01</p>\n<p>双精度存储<br>首先在开始之前需要了解一下JavaScript的number类型在计算机中是如何存储的，这也是一切问题的基础。JavaScript的数字都是number类型的，不管是整数还是浮点数都以IEEE754双精度的格式存储在计算机中，什么是双精度呢？就是以64个bit位来存储</p>\n<p>分别是1个符号位+11个指数位+52个尾数位</p>\n<p>举个例子，如果是5.5这个数字的话，则计算过程是这样的：</p>\n<p>5.5 转二进制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 101.1 科学计数法 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1.011*2^2<br>存入计算机：<br>符号位：0<br>指数位：2 加1023 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1025 转二进制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 10000000001<br>尾数位：1.011 隐去小数点左边的1 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 011</p>\n<p>为什么0.1+0.2 !&#x3D; 0.3？<br>答：0.1 转二进制 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 0.0001100110011001100…(1100循环)<br>转科学计数法 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 1.100110011…(1100循环) *2^-4<br>数据是无限循环的，但是可供使用的尾数位却是有限的，只有52位可以使用，所以在第53位会被舍去并且进位</p>\n<p>计算结果转换为十进制数字就是0.30000000000000004</p>\n<p>所以就是因为，0.1和0.2在计算机中的二进制存储会让它们本身损失掉一定的精度，而它们在计算机中的二进制存储转换成十进制时已经不是真正的0.1和0.2了，相加的结果也就自然不是0.3了。</p>\n<p>问题来了，既然0.1在计算机中的存储已经有了舍入误差，那为什么num&#x3D;0.1能得到0.1呢？</p>\n<p>可以在控制台使用toPrecision看一下0.1在不同精度下的返回</p>\n<p>可以看出来其实0.1是截断了一部分精度后得到的结果，那么这个问题就可以转化为：双精度浮点数是按什么规则来截断的呢？<br>答：如果一个 IEEE 754 的双精度浮点数被转成至少含17位有效数字的十进制数字字符串，当这个字符串转回双精度浮点数时，必须要跟原来的数相同；换句话说，如果一个双精度的浮点数转为十进制的数字时，只要它转回来的双精度浮点数不变，精度取最短的那个就行。</p>\n<p>拿0.1来举例子，0.1和0.10000000000000001转成双精度浮点数的存储是一样的，所以取最短的0.1就行了。</p>\n<p>为什么1.005.toFixed(2)&#x3D;1.00而不是1.01<br>因为在第一个问题中已经说了，一个十进制数字转为双精度浮点数然后再取出来时，跟原十进制数字可能会有误差，试一下1.005取20个精度：</p>\n<p>1.005.toPrecision(20) &#x2F;&#x2F;返回1.0049999999999998934<br>很明显1.005只是一个被截断后的数字，它的双精度浮点数代表的20位精度的数字是1.0049999999999998934，所以进行保留2位的四舍五入时，2位后的数字会被全部舍去。</p>\n","categories":["计算机组成原理"],"tags":["浮点数","存储"]},{"title":"深拷贝","url":"/2024/04/30/%E6%B7%B1%E6%8B%B7%E8%B4%9D/","content":"<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>我们知道在javascript中有八种数据类型：其中number，string，undefined，null，boolean，symbol和bigint为基本数据类型，而object为复杂数据类型</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><ul>\n<li>对于基本数据类型，其值直接存储于栈中。</li>\n<li>对于复杂数据类型，其值存储于堆中，而栈中只存储堆中的地址。这样做的好处有：<ul>\n<li>节省内存空间：存储在堆中的对象可以通过栈内的引用被访问和操作，意味着对象可以在不同的上下文中被共享和引用，从而节省内存。</li>\n<li>垃圾回收：堆内存中的对象不再被引用时，垃圾回收机制就会自动进行回收，从而避免了内存泄漏和资源浪费。</li>\n<li>动态分配内存：堆内存允许对象动态的增长和缩小，因此可以根据需要灵活地修改对象的结构和内容，使得js对象可以轻松地扩展以适应不同的应用需求。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"深拷贝-1\"><a href=\"#深拷贝-1\" class=\"headerlink\" title=\"深拷贝\"></a><strong>深拷贝</strong></h2><p>而深拷贝和浅拷贝就是对于复杂数据类型object来说的，当拷贝了对象的一层（即堆的引用）时，就称之为浅拷贝，当拷贝了对象的两层（堆中创建新的对象）时，就称之为深拷贝。</p>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><ol>\n<li><p><code>JSON.parse(JSON.stringify(obj))</code>，第一种方法是使用JSON方法，但是这个方法有一些限制：JSON序列化时函数会被转为null，正则表达式会被转为空对象。</p>\n</li>\n<li><p>递归实现：</p>\n<pre><code class=\"js\">\n\n```javascript\nfunction deepCopy(obj, parent = null) &#123;\n    // 创建一个新对象\n    let result = &#123;&#125;;\n    let keys = Object.keys(obj),\n        key = null,\n        temp = null,\n        _parent = parent;\n    // 该字段有父级则需要追溯该字段的父级\n    while (_parent) &#123;\n        // 如果该字段引用了它的父级则为循环引用\n        if (_parent.originalParent === obj) &#123;\n            // 循环引用直接返回同级的新对象\n            return _parent.currentParent;\n        &#125;\n        _parent = _parent.parent;\n    &#125;\n    for (let i = 0; i &lt; keys.length; i++) &#123;\n        key = keys[i];\n        temp = obj[key];\n        // 如果字段的值也是一个对象\n        if (temp &amp;&amp; typeof temp === &#39;object&#39;) &#123;\n            // 递归执行深拷贝 将同级的待拷贝对象与新对象传递给 parent 方便追溯循环引用\n            result[key] = DeepCopy(temp, &#123;\n                originalParent: obj,\n                currentParent: result,\n                parent: parent\n            &#125;);\n\n        &#125; else &#123;\n            result[key] = temp;\n        &#125;\n    &#125;\n    return result;\n&#125;\n```\n</code></pre>\n</li>\n<li><p>MessageChannel实现深克隆：由于浏览器不能将一个函数正确的复制到另一个线程中，所以不能支持函数的深克隆。</p>\n<pre><code class=\"javascript\">function deepCopy(obj) &#123;\n  return new Promise((resolve) =&gt; &#123;\n    const &#123;port1, port2&#125; = new MessageChannel();\n    port2.onmessage = ev =&gt; resolve(ev.data);\n    port1.postMessage(obj);\n  &#125;);\n&#125;\n\ndeepCopy(obj).then((copy) =&gt; &#123;// 异步的\n    let copyObj = copy;\n    console.log(copyObj, obj)\n    console.log(copyObj == obj)\n&#125;);\n</code></pre>\n</li>\n<li><p>H5新增structuredClone<br>结构化克隆解决了该JSON.stringify()技术的许多（尽管不是全部）缺点。结构化克隆可以处理循环依赖，支持许多内置数据类型，并且更健壮且速度更快。<br>但是，它仍然有一些限制：</p>\n</li>\n</ol>\n<p>原型：如果你使用structuredClone()类实例，你将获得一个普通对象作为返回值，因为结构化克隆会丢弃对象的原型链。<br>函数：如果你的对象包含函数，它们将被悄悄丢弃。<br>不可克隆：有些值不是结构化可克隆的，尤其是Error、 DOM 节点 和 Function。尝试这样做将引发 DataCloneError 异常。<br>属性描述符：setter和getter(以及类似元数据的功能)不会被复制。例如，如果使用属性描述符将对象标记为只读，则复制后的对象中是可读写(默认配置)。<br>RegExp：RegExp对象的lastIndex字段不会保留。</p>\n<h1 id=\"浅拷贝实现方案\"><a href=\"#浅拷贝实现方案\" class=\"headerlink\" title=\"浅拷贝实现方案\"></a>浅拷贝实现方案</h1><ol>\n<li><code>Object.assign(&#123;&#125;,obj)</code>，第二方法是使用Object.assign()</li>\n<li><code>const obj1 = &#123;...obj2&#125;</code>，使用扩展运算符</li>\n</ol>\n","categories":["面试题"],"tags":["深拷贝,面试题"]},{"title":"渲染模式","url":"/2023/05/17/%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MjMzNjk5NjgwNDkwNzk5MTYyLw==\">推荐一篇掘金大佬的文章，写的很详细</span></p>\n","categories":["渲染模式"],"tags":["渲染模式"]},{"title":"版本管理","url":"/2024/01/23/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","content":"<h1 id=\"集中式版本管理\"><a href=\"#集中式版本管理\" class=\"headerlink\" title=\"集中式版本管理\"></a>集中式版本管理</h1><blockquote>\n<p>集中式版本管理依赖于单一的中央服务器来存储所有项目的源代码、历史记录和版本信息。<br>集中式版本管理适合需要严格权限控制和单一数据中心管理的场景，但依赖于网络连接和中央服务器的稳定性。</p>\n</blockquote>\n<h1 id=\"分布式版本管理\"><a href=\"#分布式版本管理\" class=\"headerlink\" title=\"分布式版本管理\"></a>分布式版本管理</h1><blockquote>\n<p>分布式版本管理系统是一种代码管理工具，它允许每个开发者拥有代码仓库的完整本地副本，而不仅仅是中央服务器上的一个单一版本。这种系统的设计哲学是去中心化的思想.<br>分布式版本管理适合大型项目和多团队协作，提供更高的灵活性和灾难恢复能力，但需要更多的本地资源和网络带宽。<br>git是目前最先进的分布式版本控制系统,易学习,占用内存小,速度快等特点</p>\n</blockquote>\n<h1 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h1><blockquote>\n<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>\n</blockquote>\n","categories":["版本管理"],"tags":["版本管理"]},{"title":"计组知识点","url":"/2024/01/02/%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81CPU%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"一、缓存\"><a href=\"#一、缓存\" class=\"headerlink\" title=\"一、缓存\"></a>一、缓存</h1><h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><blockquote>\n<blockquote>\n<h6 id=\"凡是为于速度相差较大的两种硬件之间-用于协调两者数据传输速度差异的结构-均可称之为Cache-电脑高速缓冲存储器\"><a href=\"#凡是为于速度相差较大的两种硬件之间-用于协调两者数据传输速度差异的结构-均可称之为Cache-电脑高速缓冲存储器\" class=\"headerlink\" title=\"凡是为于速度相差较大的两种硬件之间,用于协调两者数据传输速度差异的结构,均可称之为Cache (电脑高速缓冲存储器)\"></a><strong>凡是为于速度相差较大的两种硬件之间,用于协调两者数据传输速度差异的结构,均可称之为<code>Cache</code></strong> (电脑高速缓冲存储器)</h6></blockquote>\n<ul>\n<li>缓存的存在是为了解决 CPU 和内存之间存取速度的差异的</li>\n<li>内存中被 CPU 访问最频繁的数据和指令会被复制到 CPU 的缓存中（这其中的“频繁”是由专门的算法来定义的</li>\n<li>这样 CPU 就不用去很慢的内存中读取需要的数据和指令了</li>\n</ul>\n</blockquote>\n<h2 id=\"2、被扩充概念\"><a href=\"#2、被扩充概念\" class=\"headerlink\" title=\"2、被扩充概念\"></a>2、被扩充概念</h2><blockquote>\n<h6 id=\"如今缓存的概念已被扩充\"><a href=\"#如今缓存的概念已被扩充\" class=\"headerlink\" title=\"如今缓存的概念已被扩充\"></a>如今缓存的概念已被扩充</h6><ul>\n<li><strong>CPU</strong> 与 <strong>主内存</strong> 之间 (就我们常说的缓存)</li>\n<li><strong>内存</strong> 与 <strong>硬盘</strong> 之间 (磁盘缓存)</li>\n<li><strong>硬盘</strong> 与 <strong>网络</strong>之间 (称为<strong>Internet</strong> 临时文件夹或网络内容缓存等)</li>\n</ul>\n</blockquote>\n<h2 id=\"3、缓存的作用\"><a href=\"#3、缓存的作用\" class=\"headerlink\" title=\"3、缓存的作用\"></a>3、缓存的作用</h2><blockquote>\n<h6 id=\"用于协调两者数据传输速度差异的结构\"><a href=\"#用于协调两者数据传输速度差异的结构\" class=\"headerlink\" title=\"用于协调两者数据传输速度差异的结构\"></a>用于协调两者数据传输速度差异的结构</h6><p>实例:</p>\n<ul>\n<li>缓存 是 CPU 的一部分</li>\n<li>缓存 是硬盘控制器上的一块内存芯片</li>\n<li>硬盘上的缓存: 当硬盘存取零碎数据时需要不断地在硬盘与内存之间交换数据</li>\n</ul>\n</blockquote>\n<h1 id=\"二、内存\"><a href=\"#二、内存\" class=\"headerlink\" title=\"二、内存\"></a>二、内存</h1><h2 id=\"1、什么是内存\"><a href=\"#1、什么是内存\" class=\"headerlink\" title=\"1、什么是内存?\"></a>1、什么是内存?</h2><blockquote>\n<p><strong>在计算机的组成结构中,有一个很重要的部分,就是存储器,那么他的具体概念是什么呢?</strong> </p>\n<ol>\n<li>存储器是用来存储程序和数据的部件,对于计算机来说,有了存储器才有记忆功能,才能保证正常工作</li>\n<li>存储器的种类很多,按照其用途可以分为 <code>主存储器</code> 和 <code>辅助存储器</code></li>\n</ol>\n<ul>\n<li>主存储器又称为 <strong><code>内存储器</code></strong>(<strong>就是我们常说的内存</strong>) </li>\n<li>辅助存储器又成为 <strong><code>外存储器</code></strong> (<strong>简称外存</strong>)</li>\n<li>所以实际上有很多人容易弄混淆这个概念,以为存储器就是内存</li>\n</ul>\n</blockquote>\n<h2 id=\"2、内存与外存\"><a href=\"#2、内存与外存\" class=\"headerlink\" title=\"2、内存与外存\"></a>2、内存与外存</h2><h3 id=\"Ⅰ-外存-ROM\"><a href=\"#Ⅰ-外存-ROM\" class=\"headerlink\" title=\"Ⅰ - 外存 (ROM)\"></a>Ⅰ - 外存 (ROM)</h3><blockquote>\n<blockquote>\n<p><strong>外存通常是磁性介质或光盘: 如硬盘、软盘、磁带、CD等</strong></p>\n</blockquote>\n<ul>\n<li>能长期保存信息,且<strong>不依赖于电</strong>来保存信息,即断电不会失去保存的信息</li>\n<li>由于是机械部件带动,速度与CPU相比就显得慢得多</li>\n<li>**<code>ROM</code>**（Read Only Memory） 只读内存，应用于硬盘存储</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-内存-RAM\"><a href=\"#Ⅱ-内存-RAM\" class=\"headerlink\" title=\"Ⅱ - 内存 (RAM)\"></a>Ⅱ - 内存 (RAM)</h3><blockquote>\n<blockquote>\n<p><strong>物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路</strong></p>\n</blockquote>\n<ul>\n<li>指的是主板上的存储不见,是CPU直接与之沟通并用其存储数据的不见</li>\n<li>存放当前 正在使用的(<strong>即执行中</strong>) 的数据和程序</li>\n<li><strong>它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路</strong></li>\n<li>内存只用于暂时存放程序和数据,一旦关闭电源或者发生断电,其中的程序和数据就会丢失</li>\n<li>随机存储器  **<code>RAM</code>**（Random Access Memory）俗称内存</li>\n</ul>\n</blockquote>\n<h2 id=\"3、内存分类\"><a href=\"#3、内存分类\" class=\"headerlink\" title=\"3、内存分类\"></a>3、内存分类</h2><blockquote>\n<p>内存分为 <strong>静态RAM</strong> 和 <strong>动态RAM</strong></p>\n<p><img data-src=\"/images/image-20211011121001215.png\" alt=\"/images/image-20211011121001215\"> </p>\n<p><strong>静态RAM</strong> 速度比 <strong>动态RAM</strong> 快很多</p>\n<ol>\n<li>速度比较：静态RAM &gt; 动态RAM &gt; ROM；缓存 &gt; 内存 &gt; 外存。</li>\n</ol>\n</blockquote>\n<h3 id=\"Ⅰ-静态RAM\"><a href=\"#Ⅰ-静态RAM\" class=\"headerlink\" title=\"Ⅰ - 静态RAM\"></a>Ⅰ - 静态RAM</h3><blockquote>\n<blockquote>\n<p><strong>静态RAM，指SRAM：只要有供电，它保存的数据就不会丢失，且为高速存储器，如CPU中的高速缓存（cache）</strong></p>\n</blockquote>\n<p>缓存通常使用的是静态RAM, 不过由于静态RAM集成度低,因此便延申出一级缓存和二级缓存</p>\n<ul>\n<li>一级缓存为 静态RAM</li>\n<li>二级缓存为告诉动态RAM（比静态RAM慢，但比常规动态RAM要快）</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-动态RAM\"><a href=\"#Ⅱ-动态RAM\" class=\"headerlink\" title=\"Ⅱ - 动态RAM\"></a>Ⅱ - 动态RAM</h3><blockquote>\n<blockquote>\n<p><strong>动态RAM，指DRAM：有供电，还要根据它要求的刷新时间参数，才能保持存储的数据不丢失，如电脑中的内存条</strong></p>\n</blockquote>\n<p>现在使用的内存一般都是<strong>动态RAM</strong> </p>\n<ul>\n<li>因为静态RAM集成度相对较低:存储相同数据量,静态RAM的提及是动态RAM的6倍之多,且价格高</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-动态RAM-与-静态RAM-的区别\"><a href=\"#Ⅲ-动态RAM-与-静态RAM-的区别\" class=\"headerlink\" title=\"Ⅲ  -  动态RAM 与 静态RAM 的区别\"></a>Ⅲ  -  动态RAM 与 静态RAM 的区别</h3><blockquote>\n<ul>\n<li>动态RAM 会周期地刷新,而 静态RAM 不会进行刷新</li>\n<li>动态RAM 是靠MOSS电路中的栅极电容来记忆信息的; 静态RAM 是靠双稳态触发器来记忆信息的</li>\n<li>由于电容上的电荷会泄露,需要定时给予补充. 所以 动态RAM 需要设置刷新电路,而静态不用</li>\n</ul>\n<h6 id=\"应用上的区别\"><a href=\"#应用上的区别\" class=\"headerlink\" title=\"应用上的区别\"></a>应用上的区别</h6><ul>\n<li>动态RAM 比 静态RAM 集成度高、功耗低,从而成本也低,适用于做大容量储存器,所以<strong>主内存通常采用动态RAM</strong></li>\n<li>另外:内存还应用于显卡、声卡及CMOS等设备中,用于充当设备缓存或保存固定的程序及数据</li>\n<li><strong>高速缓冲存储器(Cache)则使用静态RAM</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"4、内存是如何工作的\"><a href=\"#4、内存是如何工作的\" class=\"headerlink\" title=\"4、内存是如何工作的?\"></a>4、内存是如何工作的?</h2><blockquote>\n<blockquote>\n<p><strong>既然内存是用来存放当前 正在使用的(即执行中) 的数据和程序,那么你可能会问:它是怎么工作的呢?</strong></p>\n</blockquote>\n<p>我们平常所提到的计算机内存指的是 <strong>动态内存(即DRAM)</strong> ,动态内存中所谓的 ‘<strong>动态</strong>‘ 指的是当我们将数据写入DRAM后,经过一段时间数据就会丢失,因此我们需要一个额外的电路进行内存刷新操作</p>\n<h6 id=\"具体工作过程是这样的\"><a href=\"#具体工作过程是这样的\" class=\"headerlink\" title=\"具体工作过程是这样的:\"></a>具体工作过程是这样的:</h6><ul>\n<li>一个DRAM的存储单元存储的是0还是1取决于电容是否电荷. <code>有电荷代表1、无电荷代表0</code></li>\n<li>但时间一长,代表 1 的电容会放电,代表 0 的电荷会吸收电荷 (<strong>这就是数据丢失的原因</strong>)</li>\n<li>刷新操作定期对电容进行检查,若电量大于满点亮的 <strong>1&#x2F;2</strong> 则认为其代表 <strong>1</strong>, 并把电容充满</li>\n<li>定期刷新操作时,若电量小于 <strong>1&#x2F;2</strong> 则认为其代表 <strong>0</strong>, 并把电容放电,籍此来保持数据的连续性</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"三、CPU\"><a href=\"#三、CPU\" class=\"headerlink\" title=\"三、CPU\"></a>三、CPU</h1><h2 id=\"1、CPU的简单工作原理图\"><a href=\"#1、CPU的简单工作原理图\" class=\"headerlink\" title=\"1、CPU的简单工作原理图\"></a>1、CPU的简单工作原理图</h2><blockquote>\n<p><img data-src=\"/images/image-20211009180308915.png\" alt=\"/images/image-20211009180308915\"></p>\n<p><strong>CPU 一般由控制单元、逻辑运算单元和存储单元(寄存器)组成（注意忽略了中断系统）</strong> </p>\n<p>CPU负责执行指令，是所有计算机硬件中速度最快的。一般用<strong>时钟周期</strong>（时钟频率）来衡量CPU的性能。</p>\n</blockquote>\n<h3 id=\"Ⅰ-控制单元\"><a href=\"#Ⅰ-控制单元\" class=\"headerlink\" title=\"Ⅰ - 控制单元\"></a>Ⅰ - 控制单元</h3><blockquote>\n<ul>\n<li>在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzkyMDQy\">节拍脉冲</span> 的作用下,将 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTglOEIlRTUlQkElOEYlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTgvMzIxOTUzNg==\">程序计数器</span> (Program Counter – PC)指向的 <strong>主存或多级高速缓存</strong> 中的 <code>指令地址</code> 送到地址总线</li>\n<li>接着获取 <strong>指令地址</strong> 所对应的指令并放入<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMzIxOTQ4Mw==\">指令寄存器</span> (Instruction Register – IR) 中</li>\n<li>然后通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTglQUYlOTElRTclQTAlODElRTUlOTklQTgvMzI5NTI2MQ==\">指令译码器</span> (Instruction Decoder – ID)分析指令需要进行的操作</li>\n<li>最后通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOEUlQTclRTUlODglQjYlRTUlOTklQTgvMTkyMTcyNQ==\">操作控制器</span>(Operation Controller – OC)向其他设备发出 微操作控制信号</li>\n</ul>\n<p>也许你对上述过程中提到的名词感到陌生,下面将会列举出来</p>\n</blockquote>\n<h4 id=\"①-节拍脉冲是什么\"><a href=\"#①-节拍脉冲是什么\" class=\"headerlink\" title=\"① 节拍脉冲是什么?\"></a>① 节拍脉冲是什么?</h4><blockquote>\n<p>时钟周期是由CPU时钟定义的定长时刻距离，是CPU作业的最小时刻单位，也称<code>节拍脉冲</code>或T周期。通常为节拍脉冲或T周期，既主频的倒数，它是处理操作的最基本的单位</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzkyMDQy\">原文地址</span></p>\n</blockquote>\n<h4 id=\"②-程序计数器\"><a href=\"#②-程序计数器\" class=\"headerlink\" title=\"②  程序计数器\"></a>②  程序计数器</h4><blockquote>\n<blockquote>\n<h6 id=\"程序计数器是用于存放下一条指令所在单元的地址的地方。\"><a href=\"#程序计数器是用于存放下一条指令所在单元的地址的地方。\" class=\"headerlink\" title=\"程序计数器是用于存放下一条指令所在单元的地址的地方。\"></a>程序计数器是用于存放下一条指令所在单元的地址的地方。</h6></blockquote>\n<p>当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMzIxOTQ4Mw==\">指令寄存器</span>中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTglOEIlRTUlQkElOEYlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTgvMzIxOTUzNg==\">原文地址</span></p>\n</blockquote>\n<h4 id=\"③-指令寄存器\"><a href=\"#③-指令寄存器\" class=\"headerlink\" title=\"③  指令寄存器\"></a>③  指令寄存器</h4><blockquote>\n<p>根据指令在存贮器中的地址（由指令地址计数器给出），把指令从存贮器中取出来之后，需要有一个专门用于存放指令的地方，以便对指令进行分析和执行。这个专门存放现行指令的部件就叫做指令寄存器。指令寄存器的位数应满足指令长度的要求 [2] 。</p>\n<p>指令寄存器与CPU的8根数据总线相连接。当<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTglOEIlRTUlQkElOEYlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTgvMzIxOTUzNg==\">程序计数器</span>访问存储器地址时，存储在该地址单元内的信息经8位数据总线送出，并储存在指令存器中</p>\n</blockquote>\n<h5 id=\"a-属性描述\"><a href=\"#a-属性描述\" class=\"headerlink\" title=\"a) 属性描述\"></a>a) 属性描述</h5><blockquote>\n<p>BSDL语言中有一个重要的描述，即指令寄存器（Instruclion Register），它是由一些强制的、可选的和用户自定义的指令集合而成。</p>\n<p>关于这个指令寄存器的属性描述，必须包含5个要素：</p>\n<blockquote>\n<ul>\n<li>指令寄存器的长度、</li>\n<li>各种指令的名称、</li>\n<li>对应的操作码、</li>\n<li>指令寄存器的捕获操作码</li>\n<li>哪些指令是内部的</li>\n</ul>\n</blockquote>\n</blockquote>\n<h5 id=\"b-取指过程\"><a href=\"#b-取指过程\" class=\"headerlink\" title=\"b) 取指过程\"></a>b) 取指过程</h5><blockquote>\n<p>取指令阶段完成的任务是将现行指令从主存中取出来并送至指令寄存器中,具体操作如下</p>\n<ol>\n<li>将 <strong>程序计数器</strong>(PC) 中的内容送至存储器<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUMlQjAlRTUlOUQlODAlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMzIxOTYxOQ==\">地址寄存器</span>（MAR),并送地址总线</li>\n<li>由控制单元(CU) 经控制总线(CB)向存储器发 <strong>读命令</strong></li>\n<li>从主存中取出的指令通过数据总线(DB), 送到存储器<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlQUYlODQlRTUlQUQlOTglRTUlOTklQTgvMTk0NDIzMQ==\">数据寄存器</span>（MDR）</li>\n<li>将MDR的内容送至指令寄存器（R）中</li>\n<li>将PC的内容递增，为取下一条指令做好准备</li>\n</ol>\n<p>以上这些操作对任何一条指令来说都是必须要执行的操作，所以称为公共操作</p>\n</blockquote>\n<h4 id=\"④-指令译码器\"><a href=\"#④-指令译码器\" class=\"headerlink\" title=\"④ 指令译码器\"></a>④ 指令译码器</h4><blockquote>\n<p>指令译码器(Instruction Decoder,ID)是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTclRTUlODglQjYlRTUlOTklQTgvMjIwNjEyNg==\">控制器</span>中的主要部件之一。</p>\n<ul>\n<li>计算机能且只能执行“指令”。指令由<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTclQTAlODEvMzIyMDQxOA==\">操作码</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUMlQjAlRTUlOUQlODAlRTclQTAlODEvMzIyMDQ1NA==\">地址码</span>组成。</li>\n<li>操作码表示要执行的操作性质，即执行什么操作，或做什么；地址码是操作码执行时的操作对象的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUMlQjAlRTUlOUQlODAvODA0MjA=\">地址</span>。</li>\n<li>计算机执行一条指定的指令时，必须首先分析这条指令的操作码是什么，以决定操作的性质和方法，然后才能控制计算机其他各部件协同完成指令表达的功能。</li>\n<li>这个分析工作由 <strong>指令译码器</strong> 来完成。</li>\n<li>指令执行通过 控制部件 进行 指令译码，标量指令由标量<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQTQlODQlRTclOTAlODYlRTYlOUMlQkE=\">处理机</span>执行向量指令各Cache控制器监听总线所有操作，并对操作做相应处理（修改或作废），如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NRVNJJUU1JThEJThGJUU4JUFFJUFFLzIyNzQyMzMx\">MESI协议</span>。</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlODclRTQlQkIlQTQlRTglQUYlOTElRTclQTAlODElRTUlOTklQTgvMzI5NTI2MQ==\">原文地址</span></p>\n</blockquote>\n<h4 id=\"⑤-操作控制器\"><a href=\"#⑤-操作控制器\" class=\"headerlink\" title=\"⑤ 操作控制器\"></a>⑤ 操作控制器</h4><blockquote>\n<p>操作控制器的功能就是根据指令<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTclQTAlODE=\">操作码</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTclQjYlRTUlQkElOEYlRTQlQkYlQTElRTUlOEYlQjc=\">时序信号</span>，产生各种操作<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTclRTUlODglQjYlRTQlQkYlQTElRTUlOEYlQjc=\">控制信号</span>，以</p>\n<p>便正确地建立<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTklODAlOUElRTglQjclQUY=\">数据通路</span>，从而完成取指令和执行指令的控制。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOEUlQTclRTUlODglQjYlRTUlOTklQTgvMTkyMTcyNQ==\">原文地址</span></p>\n</blockquote>\n<h5 id=\"a-指令执行过程\"><a href=\"#a-指令执行过程\" class=\"headerlink\" title=\"a) 指令执行过程\"></a>a) 指令执行过程</h5><blockquote>\n<p>1、取指令：根据指令地址（由PC提供），从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUQlOTglRTUlODIlQTglRTUlOTklQTg=\">存储器</span>中取出所要执行的指令。</p>\n<p>2、分析指令：</p>\n<p>（1）<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUYlOTElRTclQTAlODE=\">译码</span>分析。确定指令应完成的操作，产生相应操作的控制电位。去参与形成该指令功能所需要的全部控制命令（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkUlQUUlRTYlOTMlOEQlRTQlQkQlOUMvODE5MDI2OQ==\">微操作</span>控制信号）。</p>\n<p>（2）根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlQkIlRTUlOUQlODAlRTYlOTYlQjklRTUlQkMlOEY=\">寻址方式</span>的分析和指令功能要求，形成<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOTUlQjA=\">操作数</span>的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODklRTYlOTUlODglRTUlOUMlQjAlRTUlOUQlODA=\">有效地址</span>，并按此地址取出操作数（运算型指令）或形成转移地址（转移类指令），以实现程序转移。</p>\n<p>3、执行指令：根据指令分析所产生的操作<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEUlQTclRTUlODglQjYlRTQlQkYlQTElRTUlOEYlQjc=\">控制信号</span>和形成的有效地址，按一定算法形成指令控制序列，控制有关部件完成指令规定的功能。</p>\n</blockquote>\n<h5 id=\"b-控制方式\"><a href=\"#b-控制方式\" class=\"headerlink\" title=\"b) 控制方式\"></a>b) 控制方式</h5><blockquote>\n<p>操作控制器常用的控制方式有<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlQUQlQTUlRTYlOEUlQTclRTUlODglQjYvOTY0OTg5Nw==\">同步控制</span>、异步控制、联合控制。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlQUQlQTUlRTYlOEUlQTclRTUlODglQjYlRTYlOTYlQjklRTUlQkMlOEY=\">同步控制方式</span>：任何指令的运行或指令中各个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkUlQUUlRTYlOTMlOEQlRTQlQkQlOUMvODE5MDI2OQ==\">微操作</span>的执行，均由确定的，具有统一基准时标的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTclQjYlRTUlQkElOEYlRTQlQkYlQTElRTUlOEYlQjc=\">时序信号</span>所控制。即所有的操作均由统一的时钟控制，在标准时间内完成。（在同步控制下，每个时序信号的结束就意味着安排完成的工作已经完成，随即开始执行后续的微操作或自动转向下条指令的运行。）</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQkMlODIlRTYlQUQlQTUlRTYlOEUlQTclRTUlODglQjYlRTYlOTYlQjklRTUlQkMlOEY=\">异步控制方式</span>：没有统一的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlQUQlQTUlRTQlQkYlQTElRTUlOEYlQjcvODU1NTQwMg==\">同步信号</span>，采用问答方式进行时序协调，将前一操作的回答作为下一操作的启动信号。</p>\n<p>联合控制方式：将同步控制和异步控制相结合。其通常设计思想为：在功能部件内部采用同步方式或以同步方式为主的控制方式；在功能部件间采用异步方式。</p>\n</blockquote>\n<h3 id=\"Ⅱ-运算单元\"><a href=\"#Ⅱ-运算单元\" class=\"headerlink\" title=\"Ⅱ - 运算单元\"></a>Ⅱ - 运算单元</h3><blockquote>\n<p>如果 <strong>控制单元</strong> 发出的控制信号存在<strong>算数运算</strong>(加减乘除、增1、减1、取反等) 或者 <strong>逻辑运算</strong>(与、或、非、异或),那么<strong>需要通过运算单元获取存储单元的计算数据</strong>进行处理</p>\n</blockquote>\n<h3 id=\"Ⅲ-储存单元\"><a href=\"#Ⅲ-储存单元\" class=\"headerlink\" title=\"Ⅲ - 储存单元\"></a>Ⅲ - 储存单元</h3><blockquote>\n<p>包括片内 <strong>缓存</strong> 和 <strong>寄存器组</strong> ,是CPU中临时存放数据的地方</p>\n<ul>\n<li>CPU直接访问主存数据大概需要花费数百个机器周期</li>\n<li>而访问 <strong>缓存</strong> 和 <strong>寄存器组</strong> 只需要若干个或者几十个机器周期</li>\n<li>因此会使用 <strong>缓存</strong> 和 <strong>寄存器组</strong> 来存储和获取临时数据(即将被运算或者运算之后的数据),从而提升运行效率</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅳ-指令周期\"><a href=\"#Ⅳ-指令周期\" class=\"headerlink\" title=\"Ⅳ - 指令周期\"></a>Ⅳ - 指令周期</h3><blockquote>\n<p>计算机系统执行程序指令时需要花费时间,其中取出一条指令并执行这条指令的时间叫做 <strong>指令周期</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"2、为什么需要缓存\"><a href=\"#2、为什么需要缓存\" class=\"headerlink\" title=\"2、为什么需要缓存\"></a>2、为什么需要缓存</h2><blockquote>\n<blockquote>\n<p><strong><code>CPU</code></strong> 负责运算，<code>内存</code> 负责暂时存储运算所涉及的东西，<code>高速缓存是CPU内部集成的小容量高速内存</code></p>\n<p><strong>高速缓存</strong>和内存的区别是，缓存容量极小，但是与<strong>CPU</strong>关系密切，所以传输速度比内存快得多</p>\n</blockquote>\n<ul>\n<li>缓存只是内存中少部分数据的复制品,所以CPU到缓存中寻找数据时也会出现找不到的情况(因为这些数据没用从内存复制到缓存中去)</li>\n<li>在这种缓存中找不到的情况下, CPU 还是会到内存中去找数据,这样系统的速度就会慢下来,不过<strong>CPU会把这些数据复制到缓存中去</strong>,以便下一次不用再到内存中去取,以此提高系统运行效率</li>\n<li>不过随着时间的变化,被访问得最频繁得数据不是一成不变的,也许昨天访问的不频繁的数据今天就非常频繁地进行了访问;</li>\n<li>所以说缓存中的数据经常要按照一定的算法来更换,这样才能保证缓存中的数据是被访问的最频繁的</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"3、CPU的作用\"><a href=\"#3、CPU的作用\" class=\"headerlink\" title=\"3、CPU的作用\"></a>3、CPU的作用</h2><h3 id=\"Ⅰ-缩短延迟\"><a href=\"#Ⅰ-缩短延迟\" class=\"headerlink\" title=\"Ⅰ - 缩短延迟\"></a>Ⅰ - 缩短延迟</h3><blockquote>\n<p>访问缓存的时间应该尽可能缩短,可以通过多种的方式缩短这个时间:</p>\n<ul>\n<li>比如能够通过减少缓存的大小、关联性来降低缓存的延迟; </li>\n<li>或者方法预测、增加宽带等</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-提高命中率\"><a href=\"#Ⅱ-提高命中率\" class=\"headerlink\" title=\"Ⅱ - 提高命中率\"></a>Ⅱ - 提高命中率</h3><blockquote>\n<p>所谓命中率是在高速缓存中找到内存引用的速率,我们希望能够首先通过缓存中获得信息以得到速度的优势;</p>\n<p>所以缓存需要最大限度地实现这一目标</p>\n<p>对于单个高速缓存来说:大小、关联性和块大小决定命中率</p>\n</blockquote>\n<h3 id=\"Ⅲ-降低更低级别内存下的开销\"><a href=\"#Ⅲ-降低更低级别内存下的开销\" class=\"headerlink\" title=\"Ⅲ - 降低更低级别内存下的开销\"></a>Ⅲ - 降低更低级别内存下的开销</h3><blockquote>\n<p>高速缓存是内存层次结构的一部分,其性能会影响其他性能,处理其他内存花费的时间越长意味着系统性能越低</p>\n<p>也就是说尽可能地让处理在缓存中完成</p>\n</blockquote>\n<h3 id=\"Ⅳ-减少错失惩罚\"><a href=\"#Ⅳ-减少错失惩罚\" class=\"headerlink\" title=\"Ⅳ - 减少错失惩罚\"></a>Ⅳ - 减少错失惩罚</h3><blockquote>\n<p>缓存中不能命中是无法避免的事情,但是我们可以减少处理未命中所需地时间以获得更好的处理器性能,通过提升命中率与不同的优化能有效降低错失惩罚</p>\n<p>高速缓存是CPU中十分重要的部分,占据了大量的资源开销和成本,如果咱看过CPU架构图的话就会发现缓存占据了至少50%的面积,绝对至关重要</p>\n</blockquote>\n<hr>\n<h2 id=\"4、时钟周期与指令周期\"><a href=\"#4、时钟周期与指令周期\" class=\"headerlink\" title=\"4、时钟周期与指令周期\"></a>4、时钟周期与指令周期</h2><blockquote>\n<p><strong><code>CPU时钟周期</code></strong> 是操作的最小时间单位,值是主频的倒数,现代计算机的主频可以达到几GHZ.</p>\n<p>**<code>指令周期</code>**是取出并执行一个指令的时间单位,一个指令需要多个 CPU 操作来执行,一般来说一个指令周期至少包含2个CPU时钟周期(取指 + 执行)</p>\n<p>同一个硬件架构下不同CPU的时钟周期越高,相同时间内能够执行的指令越多,性能就越好; 但在不同硬件架构下只比较CPU主频大小意义不大，处理器结构不同，指令集就不同，相同意义的指令所需的CPU时钟周期也就不同</p>\n<p>除了计算机架构不同外，在比较计算机整体性能的时候还需要考虑很多因素，例如<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg5JThEJUU3JUFCJUFGJUU2JTgwJUJCJUU3JUJBJUJG\">前端总线</span>（”front side bus”，FSB），<strong>内存的时钟周期</strong>，CPU<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFOSU4MCU5QSVFNyU5NCVBOCVFNSVBRiU4NCVFNSVBRCU5OCVFNSU5OSVBOCZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=\">通用寄存器</span>的数据宽度和机器的一级、二级<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJDJTkzJUU1JUFEJTk4\">缓存</span>等。</p>\n</blockquote>\n<hr>\n<h2 id=\"5、存储单元-寄存器\"><a href=\"#5、存储单元-寄存器\" class=\"headerlink\" title=\"5、存储单元(寄存器)\"></a>5、存储单元(寄存器)</h2><blockquote>\n<p>寄存器是CPU的内部组成单元,是CPU运算时取 <strong>指令</strong> 和 <strong>数据</strong> 的地方,速度很快.</p>\n<blockquote>\n<ul>\n<li>可以理解成对于 CPU 来说, <strong>对寄存器进行 读&#x2F;写 是不需要时间的</strong></li>\n<li>或者说如果只是操作寄存器 (比如类似mov BX,AX之类的操作),那么一秒钟执行的指令个数理论上等于主频,因为寄存器是CPU的一部分</li>\n</ul>\n</blockquote>\n<h6 id=\"寄存器可以用来暂存指令、数据和地址-在CPU中分为\"><a href=\"#寄存器可以用来暂存指令、数据和地址-在CPU中分为\" class=\"headerlink\" title=\"寄存器可以用来暂存指令、数据和地址. 在CPU中分为\"></a>寄存器可以用来暂存指令、数据和地址. 在CPU中分为</h6><ul>\n<li><strong>通用寄存器</strong>: 如指令寄存器<code>IR</code>; </li>\n<li><strong>特殊功能寄存器</strong> : 如程序计数器<code>PC 、sp</code>等</li>\n</ul>\n<p><img data-src=\"/images/image-20211012102032541.png\" alt=\"/images/image-20211012102032541\"> </p>\n</blockquote>\n<hr>\n<h1 id=\"四、CPU的多级缓存-高速缓存\"><a href=\"#四、CPU的多级缓存-高速缓存\" class=\"headerlink\" title=\"四、CPU的多级缓存(高速缓存)\"></a>四、CPU的多级缓存(高速缓存)</h1><blockquote>\n<blockquote>\n<h6 id=\"高速缓存（cache）通常分为L1-L2-L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件\"><a href=\"#高速缓存（cache）通常分为L1-L2-L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件\" class=\"headerlink\" title=\"高速缓存（cache）通常分为L1,L2,L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件\"></a>高速缓存（cache）通常分为L1,L2,L3三级，速度递减，容量递增，是为了弥补CPU与内存之间运算速度的差异而设置的硬件</h6></blockquote>\n<p><img data-src=\"/images/image-20211012100054332.png\" alt=\"/images/image-20211012100054332\"></p>\n<p>上图为最简单的高速缓存的配置, 数据的读取和储存都将经过高速缓存, CPU 核心与高速缓存有一条特殊的快速通道: 主存和高速缓存都连在系统总线上,这条总线还用于其他组件的通信</p>\n<p>高速缓存出现不久,系统变得越来越复杂,高速缓存与主存之间的速度差异越来越大,直到加入了另一级缓存: 新加入的这级缓存比第一缓存更大而且更慢,同时经济上不合适,所以有了二级缓存、三级缓存</p>\n</blockquote>\n<h2 id=\"1、多级缓存出现的意义\"><a href=\"#1、多级缓存出现的意义\" class=\"headerlink\" title=\"1、多级缓存出现的意义\"></a>1、多级缓存出现的意义</h2><h3 id=\"Ⅰ-为什么需要CPU-Cache\"><a href=\"#Ⅰ-为什么需要CPU-Cache\" class=\"headerlink\" title=\"Ⅰ - 为什么需要CPU Cache\"></a>Ⅰ - 为什么需要CPU Cache</h3><blockquote>\n<blockquote>\n<p><strong>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以Cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu -&gt; cache -&gt; memort）</strong></p>\n</blockquote>\n<p>当 <strong>CPU</strong> 处理数据时, 它会先到 <strong>Cache</strong> 中去寻找,如果数据因之前的操作已经读取而被暂存其中的话就不必再从主内存中读取数据</p>\n<ul>\n<li>由于 CPU 的运行速度一般比主内存的读取速度快.主存 <strong>时钟周期</strong>(访问主存储器所需要时间) 为数个 CPU 时钟周期</li>\n<li>因此如果要访问主内存的话,就必须等待数个CPU周期从而造成浪费</li>\n<li><strong>L1缓存</strong> 的速度可以在 2-4 个CPU时钟频率内完成,速度很快</li>\n</ul>\n<p>Linux下可以通过 <code>lscpu</code> 命令来查看 CPU 的信息,其中就包括 Cache 层次</p>\n</blockquote>\n<h3 id=\"Ⅱ-CPU-Cache-有什么意义\"><a href=\"#Ⅱ-CPU-Cache-有什么意义\" class=\"headerlink\" title=\"Ⅱ - CPU Cache 有什么意义\"></a>Ⅱ - CPU Cache 有什么意义</h3><blockquote>\n<ul>\n<li>时间局限性: 如果某个数据被访问,那么在不久的将来他很可能被再次访问</li>\n<li>空间局限性: 如果某个数据被访问,那么与他相邻的数据很快也可能被访问</li>\n</ul>\n</blockquote>\n<h2 id=\"2、原理\"><a href=\"#2、原理\" class=\"headerlink\" title=\"2、原理\"></a>2、原理</h2><blockquote>\n<blockquote>\n<p>提供 ‘<strong>缓存</strong>‘ 的目的是为了让数据访问的速度适应 CPU 的处理速度,多级Cache技术，利用使用一个大的二级Cache来处理一级Cache的缺失，从而降低缺失代价</p>\n</blockquote>\n<p>通常它不像系统主存那样使用 <strong><code>DRAM(动态)</code></strong> 技术,而是使用 <strong>昂贵但比较快速</strong> 的 <strong><code>SRAM(静态)</code></strong> 技术,其原理是:</p>\n<ul>\n<li>内存中 ‘<strong>程序执行与数据访问的局域性行为</strong>‘, 即一定程序执行时间和空间内,被访问的代码集中于一部分</li>\n<li>为了充分发挥缓存的作用,不仅依靠 ‘<strong>暂存刚刚访问过的数据</strong>‘, 还要使用硬件实现的指令 <strong>预测 与 数据预取技术</strong> –&gt; 尽可能把将要使用的数据预先从内存中取到缓存里</li>\n</ul>\n</blockquote>\n<h2 id=\"3、数据结构\"><a href=\"#3、数据结构\" class=\"headerlink\" title=\"3、数据结构\"></a>3、数据结构</h2><blockquote>\n<p>高速缓存的数据结构类似于 <strong><code>拉链式的散列表</code></strong> ,<strong>Key</strong>是内存地址,<strong>值</strong>是内存数据的副本或是即将写入内存的数据</p>\n<p><img data-src=\"/images/image-20211012101834104.png\" alt=\"/images/image-20211012101834104\"> </p>\n<p>其中 <strong>Tag</strong> 可以理解为数据的内存地址, <strong>Data Block</strong> 是内存数据, <strong>Flag</strong> 用于标识数据状态</p>\n</blockquote>\n<h2 id=\"4、CPU的多级缓存\"><a href=\"#4、CPU的多级缓存\" class=\"headerlink\" title=\"4、CPU的多级缓存\"></a>4、CPU的多级缓存</h2><blockquote>\n<p>CPU的核心数量、高频高低都会影响性能，但如果让CPU更聪明、更有效率的执行计算任务，那么缓存的作用就至关重要了</p>\n</blockquote>\n<h3 id=\"Ⅱ-一级缓存-L1-Cache\"><a href=\"#Ⅱ-一级缓存-L1-Cache\" class=\"headerlink\" title=\"Ⅱ - 一级缓存 (L1 Cache)\"></a>Ⅱ - 一级缓存 (L1 Cache)</h3><blockquote>\n<blockquote>\n<h6 id=\"CPU一级缓存-就是指-CPU-的第一层级的高速缓存-主要担当的工作是-缓存指令-和-缓存数据\"><a href=\"#CPU一级缓存-就是指-CPU-的第一层级的高速缓存-主要担当的工作是-缓存指令-和-缓存数据\" class=\"headerlink\" title=\"CPU一级缓存,就是指 CPU 的第一层级的高速缓存, 主要担当的工作是 缓存指令 和 缓存数据 .\"></a><strong>CPU一级缓存</strong>,就是指 CPU 的第一层级的高速缓存, 主要担当的工作是 <strong>缓存指令</strong> 和 <strong>缓存数据</strong> .</h6></blockquote>\n<ul>\n<li>一级缓存的容量与结构对于CPU性能的影响十分巨大,但是由于它的结构相对复杂且还有成本问题</li>\n<li>一般来说, <strong><code>CPU 的一级缓存比较小</code></strong>, 通常 CPU 的一级缓存也就能做到 <strong>256KB</strong> 左右的水平</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅱ-二级缓存-L2-Cache\"><a href=\"#Ⅱ-二级缓存-L2-Cache\" class=\"headerlink\" title=\"Ⅱ - 二级缓存 (L2 Cache)\"></a>Ⅱ - 二级缓存 (L2 Cache)</h3><blockquote>\n<blockquote>\n<h6 id=\"CPU-二级缓存-就是指-CPU-的第二层级的高速缓存\"><a href=\"#CPU-二级缓存-就是指-CPU-的第二层级的高速缓存\" class=\"headerlink\" title=\"CPU 二级缓存, 就是指 CPU 的第二层级的高速缓存\"></a>CPU 二级缓存, 就是指 CPU 的第二层级的高速缓存</h6></blockquote>\n<ul>\n<li>二级缓存的容量会直接影响到 CPU 的性能,所以二级缓存的容量越大越好</li>\n<li>例如intel的第八代i7-8700处理器，共有六个核心数量，而每个核心都拥有256KB的二级缓存，属于各核心独享，这样二级缓存总数就达到了1.5MB。</li>\n</ul>\n</blockquote>\n<h3 id=\"Ⅲ-三级缓存-L3-Cache\"><a href=\"#Ⅲ-三级缓存-L3-Cache\" class=\"headerlink\" title=\"Ⅲ - 三级缓存 (L3 Cache)\"></a>Ⅲ - 三级缓存 (L3 Cache)</h3><blockquote>\n<p>CPU 三级缓存, 就是指 CPU 的第三层级的高速缓存, 起作用就是进一步降低内存的延迟, 同时提升海量数据计算时的性能</p>\n<blockquote>\n<h6 id=\"和一级、二级缓存不同的是-三级缓存时核心共享的-能够将容量做很大\"><a href=\"#和一级、二级缓存不同的是-三级缓存时核心共享的-能够将容量做很大\" class=\"headerlink\" title=\"和一级、二级缓存不同的是,三级缓存时核心共享的,能够将容量做很大\"></a>和一级、二级缓存不同的是,三级缓存时核心共享的,能够将容量做很大</h6></blockquote>\n</blockquote>\n<h3 id=\"Ⅳ-缓存一致性-MESI\"><a href=\"#Ⅳ-缓存一致性-MESI\" class=\"headerlink\" title=\"Ⅳ - 缓存一致性(MESI)\"></a>Ⅳ - 缓存一致性(MESI)</h3><blockquote>\n<p>CPU种每个 <code>缓存行</code> 使用 <strong>四种</strong> 状态进行标记</p>\n</blockquote>\n<h4 id=\"①-M-Modified-修改\"><a href=\"#①-M-Modified-修改\" class=\"headerlink\" title=\"① M: Modified 修改\"></a>① M: Modified 修改</h4><blockquote>\n<p>指的时该 <strong>缓存行</strong> 只被缓存在该 CPU 种,并且是<code>被修改过</code>的, <strong>因此他与主存的数据是不一致的</strong>,</p>\n<p>该缓存行中的数据需要在未来某个时间点(<strong>允许其他CPU读取主存相应的内容之前</strong>) 写回主存,然后<code>状态变成E (独享)</code></p>\n</blockquote>\n<h4 id=\"②-Exclusive-独享\"><a href=\"#②-Exclusive-独享\" class=\"headerlink\" title=\"② Exclusive 独享\"></a>② Exclusive 独享</h4><blockquote>\n<p>缓存行 只被缓存在该 CPU 的缓存中,是<code>未被修改过</code>的,<strong>与主存的数据是一致的</strong>. </p>\n<p>可以在任何时刻当有其他CPU读取该内存时,状态变成 <code>S(共享)</code></p>\n<p>当CPU修改缓存行的内容时, 状态变成 <code>M(修改)</code></p>\n</blockquote>\n<h4 id=\"③-Share-共享\"><a href=\"#③-Share-共享\" class=\"headerlink\" title=\"③ Share 共享\"></a>③ Share 共享</h4><blockquote>\n<p>意味着该 缓存行 <code>可能被多个 CPU 进行缓存</code>,并且<strong>该缓存中的数据与主存数据是一致的</strong></p>\n<p>当有一个 CPU 修改 <strong>该缓存行</strong> 时,其他 CPU 是可以被作废的,变成 <code>I(无效的)</code></p>\n</blockquote>\n<h4 id=\"④-Invalid-无效的\"><a href=\"#④-Invalid-无效的\" class=\"headerlink\" title=\"④ Invalid 无效的\"></a>④ Invalid 无效的</h4><blockquote>\n<p>代表这个缓存是无效的，可能是有其他CPU修改了该缓存行</p>\n</blockquote>\n<h4 id=\"⑤对应的四个操作\"><a href=\"#⑤对应的四个操作\" class=\"headerlink\" title=\"⑤对应的四个操作\"></a>⑤对应的四个操作</h4><blockquote>\n<p>local read：读本地缓存<br>local write：写本地缓存<br>remote read：将内存中的数据读取过来<br>remote write：将数据写回主存</p>\n</blockquote>\n<h5 id=\"a-详细说明\"><a href=\"#a-详细说明\" class=\"headerlink\" title=\"a) 详细说明\"></a>a) 详细说明</h5><blockquote>\n<blockquote>\n<p><strong>在一个典型的多核系统中，每一个核都会有自己的缓存来共享总线，每一个CPU会发出读写（I&#x2F;O）请求，而缓存的目的是为了减少CPU读写共享主存的次数；</strong></p>\n</blockquote>\n<ol>\n<li>一个缓存除了在无效（Invalid）状态，都可以满足CPU的读请求，一个无效（Invalid）的缓存行必须从主存中读取（变成Share或者Exclusive状态）来满足该CPU的读请求</li>\n<li>一个 <code>写请求</code> 只有在该缓存行是 <strong><code>修改</code></strong> 或者 <strong><code>独享</code></strong> 状态时才能被执行</li>\n</ol>\n<ul>\n<li>如果缓存行处于 <strong><code>共享</code></strong> 状态，必须<strong>先将其他缓存中的 该缓存行</strong> 变成 <code>无效</code> 状态</li>\n<li><strong>也即是不允许不同CPU同时修改同一缓存行，即使修改该缓存行中的不同数据也不允许</strong></li>\n<li>该操作经常作用广播的方式来完成，例如：Request For Ownership（RFO）</li>\n</ul>\n<ol start=\"3\">\n<li>缓存可以随时将一个 <strong>非修改</strong> 状态的缓存行作废，或者变成 <strong><code>无效</code></strong> 状态，而一个**<code>修改</code>** 状态的缓存行必须先被写回主存</li>\n<li>一个处于 <strong>共享</strong> 状态的 缓存行  也<code>必须监听</code> 其他缓存中<strong>使该 缓存行 <code>无效</code> 或者 <code>独享</code> 该缓存行的请求</strong>，并将该 缓存行 变成 <strong><code>无效</code></strong></li>\n<li>一个处于 <strong>独享</strong> 状态的 缓存行 也<code>必须监听</code>其他缓存中 <strong>读主存中该缓存行的操作</strong>，一旦有这种操作，该缓存行需要变成<code>共享</code>状态</li>\n<li>对于 <code>修改</code> 和 <code>独享</code> 状态而言总是精确的，他们在该缓存行的真正状态是一致的。</li>\n</ol>\n<ul>\n<li>而 <code>共享</code> 状态可能是非一致的</li>\n<li>如果一个缓存将处于 <code>共享</code> 状态的缓存行作废了，而另一个缓存实际上可能已经独享了 该缓存行，但是该缓存却不会将该 缓存行 升迁为 <code>独享</code> 状态</li>\n<li>这是因为<strong>其他缓存不会广播他们作废掉该缓存行的通知</strong>，同样由于缓存并没有保存该缓存行的 copy 的数量，因此也没有办法确定自己是否已经独享（Share了该缓存行）</li>\n</ul>\n<p>从上面的意义看来独享（Exclusive）状态时一种投机性的优化：如果一个CPU想修改一个处于共享（Share）状态的缓存航，总线事务需要将所有缓存行的copy变成Invalid状态，而修改独享（Exclusive）状态的缓存不需要使用总线事务</p>\n</blockquote>\n","categories":["计算机组成原理"],"tags":["计算机组成原理","缓存","内存","CPU"]},{"title":"网络安全","url":"/2024/05/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","content":"<h1 id=\"前端网络安全\"><a href=\"#前端网络安全\" class=\"headerlink\" title=\"前端网络安全\"></a>前端网络安全</h1><h2 id=\"1-XSS-跨站脚本攻击\"><a href=\"#1-XSS-跨站脚本攻击\" class=\"headerlink\" title=\"#1. XSS 跨站脚本攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzEteHNzLSVFOCVCNyVBOCVFNyVBQiU5OSVFOCU4NCU5QSVFNiU5QyVBQyVFNiU5NCVCQiVFNSU4NyVCQg==\">#</span>1. XSS 跨站脚本攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>XSS 是常见的 Web 攻击技术之一.所谓的跨站脚本攻击指得是:恶意攻击者往 Web 页面里注入恶意 Script 代码，用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取 cookie 信息、会话劫持等各种攻击。</p>\n</blockquote>\n<p><strong>危害</strong></p>\n<p>1、<strong>盗取各类用户帐号</strong>，如机器登录帐号、用户网银帐号、各类管理员帐号</p>\n<p>2、<strong>控制企业数据</strong>，包括读取、篡改、添加、删除企业敏感数据的能力</p>\n<p>3、<strong>盗窃企业重要的具有商业价值的资料</strong></p>\n<p>4、<strong>非法转账</strong></p>\n<p>5、<strong>强制发送电子邮件</strong></p>\n<p>6、<strong>网站挂马</strong></p>\n<p>7、<strong>控制受害者机器向其它网站发起攻击</strong></p>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>过滤用户的输入信息，禁止用户在输入的过程中输入 “&lt;”, “&gt;”, “引号”, “$”, “_”</li>\n<li>核心的用户身份标示或 token 保存在 Cookie 中,Cookie 中一定要加 “HTTPOnly” 在结尾，保证只有在 html 操作时才能将 cookie 中的内容发送出去，在 JS 中无法获得用户的 Cookie 信息</li>\n</ul>\n<h2 id=\"2-CSRF-网络攻击\"><a href=\"#2-CSRF-网络攻击\" class=\"headerlink\" title=\"#2. CSRF 网络攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzItY3NyZi0lRTclQkQlOTElRTclQkIlOUMlRTYlOTQlQkIlRTUlODclQkI=\">#</span>2. CSRF 网络攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。</p>\n</blockquote>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>减少在 cookie 中存储客户核心内容比如用户的 token、ID、access_token 等</li>\n<li>GET 请求不对数据进行修改</li>\n<li>不让第三方网站访问到 Cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>请求时附带验证信息，比如验证码或者 Token</li>\n</ul>\n<h2 id=\"3-DDOS-攻击\"><a href=\"#3-DDOS-攻击\" class=\"headerlink\" title=\"#3. DDOS 攻击\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96eHBzdXBlci5naXRodWIuaW8vYWR2YW5jZWRfZnJvbnRfZW5kL2Jvb2svYnJvd3Nlci9zYWZlLmh0bWwjXzMtZGRvcy0lRTYlOTQlQkIlRTUlODclQkI=\">#</span>3. DDOS 攻击</h2><p><strong>原理</strong></p>\n<blockquote>\n<p>DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。</p>\n</blockquote>\n<p><strong>前端如何处理</strong></p>\n<ul>\n<li>防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。</li>\n</ul>\n<p><strong>后端如何处理</strong></p>\n<ul>\n<li>HTTP 请求的拦截，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。</li>\n<li>带宽扩容，或者使用 CDN</li>\n</ul>\n","categories":["网络安全"],"tags":["网络安全"]},{"title":"脚手架开发","url":"/2024/04/12/%E8%84%9A%E6%89%8B%E6%9E%B6/","content":"<h1 id=\"需求分析\"><a class=\"anchor\" href=\"#需求分析\">#</a> 需求分析</h1>\n<p><strong>为什么需要优化研发流程？</strong></p>\n<ul>\n<li>项目量级增加：几干行代码 -&gt; 几万行代码</li>\n<li>项目数量扩大：几个项目 -&gt; 几干个项目</li>\n<li>项目复杂度高：Wb 项目 -&gt;H5/PC/ 小程序 / 后端 / 脚手架</li>\n<li>团队人数增长：几个人 -&gt; 几百人</li>\n<li>传统的项目研发流程已经无法满足业务需求</li>\n</ul>\n<h1 id=\"git开发流程\"><a class=\"anchor\" href=\"#git开发流程\">#</a> git 开发流程</h1>\n<p>单人 git 项目开发流程</p>\n<p><img data-src=\"/images/Snipaste_2024-05-27_13-57-14.png\" alt=\"images\" /></p>\n<p>多人 git 项目开发流程</p>\n<p><img data-src=\"/images/Snipaste_2024-05-27_14-05-13.png\" alt=\"images\" /></p>\n<h1 id=\"浏览器获取资源步骤\"><a class=\"anchor\" href=\"#浏览器获取资源步骤\">#</a> 浏览器获取资源步骤</h1>\n<p><img data-src=\"/images/Snipaste_2024-05-27_14-34-47.png\" alt=\"images\" /></p>\n<p><strong>项目创建流程思考</strong></p>\n<p>当团队较大时，让每一个团队成员开发创建项目体验趋于一致就非常重要。</p>\n<p><strong>项目创建流程</strong></p>\n<ul>\n<li>项目代码</li>\n<li>抽象出项目模板</li>\n<li>存储到数据库</li>\n<li>脚手架读取数据库</li>\n<li>根据脚手架创建新的项目</li>\n</ul>\n<p><strong>提升前端研发效率的手段</strong></p>\n<ul>\n<li>物料和模板</li>\n<li>低代码搭建</li>\n<li>等等</li>\n</ul>\n<p>从使用角度理解什么是脚手架？</p>\n<h1 id=\"脚手架简介\"><a class=\"anchor\" href=\"#脚手架简介\">#</a> 脚手架简介</h1>\n<p>脚手架本质是一个操作系统的客户端，它通过命令行执行，比如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue create vue-test-app</pre></td></tr></table></figure><p>上面这条命令由 3 个部分组成：</p>\n<ul>\n<li>主命令：vue</li>\n<li>command:create</li>\n<li>command 的 param:vue-test-app</li>\n</ul>\n<p>它表示创建一个 vue 项目，项目的名称为 vue-test-app, 以上是最一个较为简单的脚手架命令，但实际场易<br />\n往更加复杂，比如：<br />\n当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装 ue 项目，此时我们就可以输入：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue create vue-test-app <span class=\"token parameter variable\">--force</span></pre></td></tr></table></figure><p>这里的 - force 叫做 option, 用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景<br />\n通过 vue create<br />\n 创建项目时，会自动执行 npm install 帮用户安装依赖，如果我们希望使用淘宝源来安装，<br />\n可以输入命令：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue create vue-test-app <span class=\"token parameter variable\">--force</span> <span class=\"token parameter variable\">-r</span> https://registry.npm.taobao.org</pre></td></tr></table></figure><p>这里的 - x 也叫做 option, 它与 --force 不同的是它使用 -，并且使用简写，这里的 - x 也可以替换成 --registry, 有的同学可能要问，为什么老师知道这个命令，其实我们输入下面的命令就可以看到 vue create 支持的所有 options:<br />\nvue create  --help</p>\n<p>-r  https:/registry.npm.taobao.org 后面的 https://registry.npm.taobao.org 成为 option 的 param, 其实任 - force 可以理解为：-force true,f 简写为：--force 或 - f</p>\n<h1 id=\"脚手架原理\"><a class=\"anchor\" href=\"#脚手架原理\">#</a> 脚手架原理</h1>\n<p><strong>脚手架的执行原理如下：</strong></p>\n<ul>\n<li>在终端输入 vue create vue-test-app</li>\n<li>终端解析出 vue 命令</li>\n<li>终端在环境变量中找到 ue 命令</li>\n<li>终端根据 vue 命令链接到实际文件 vue.js</li>\n<li>终端利用 node 执行 `ue.js</li>\n<li>vue.js 解析 command/options</li>\n<li>vue.js 执行 command</li>\n<li>执行完毕，退出执行</li>\n</ul>\n<p><strong>从应用的角度看如何开发一个脚手架</strong></p>\n<p>这里以 vue-cli 为例：</p>\n<ul>\n<li>开发 npm 项目，该项目中应包含一个 bin/vue.js 文件，并将这个项目发布到 npm</li>\n<li>将 npm 项目安装到 node 的 lib/node_modules</li>\n<li>在 node 的 bin 目录下配置 vue 软链接指向 lib/node modules/Qvue/cli/bin/vue.js</li>\n<li>这样我们在执行 vue 命令的时候就可以找到 vue.js 进行执行</li>\n</ul>\n<p><strong>还有很多疑问需要解答</strong></p>\n<ul>\n<li>\n<p>为什么全局安装 vue/cli 后会添加的命令为 vue?  （npm install -g @vue/cli）</p>\n</li>\n<li>\n<p>答：vue/cli 项目的 package.json 中的 bin 字段配置的名称为 vue。</p>\n</li>\n<li>\n<p>全局安装 vue/c1i 时发生了什么？</p>\n</li>\n<li>\n<p>答：全局 node_modules 中下载项目文件，并根据项目 package.json 中的 bin 字段配置可执行文件软链接。</p>\n</li>\n<li>\n<p>为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令直接去执行它？</p>\n</li>\n<li>\n<p>答：js 文件配置了蛇棒（操作系统的接口），例如：</p>\n</li>\n<li>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#!/usr/bin/env node</span></pre></td></tr></table></figure><p>通常使用环境变量中找 node 命令，因为每个电脑上的 node 文件位置不同，但是环境变量中都会有 node 软连接。</p>\n</li>\n</ul>\n<h1 id=\"脚手架的开发流程\"><a class=\"anchor\" href=\"#脚手架的开发流程\">#</a> 脚手架的开发流程</h1>\n<p><strong>脚手架开发流程详解</strong></p>\n<p>开发流程</p>\n<ul>\n<li>创建 npm 项目</li>\n<li>创建脚手架入口文件，最上方添加 #!/usr/bin/env node</li>\n<li>配置 package.json, 添加 bin 属性</li>\n<li>编写脚手架代码</li>\n<li>将脚手架发布到 npm</li>\n</ul>\n<p><strong>使用流程</strong></p>\n<ul>\n<li>\n<p>安装脚手架</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-g</span> your-own-cli</pre></td></tr></table></figure></li>\n<li>\n<p>使用脚手架</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>your-own-cli-binName</pre></td></tr></table></figure></li>\n</ul>\n<p><strong>脚手架开发难点解析</strong></p>\n<ul>\n<li>\n<p>分包：将复杂的系统拆分成若干个模块</p>\n</li>\n<li>\n<p>命令注册：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>- vue create</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>- vue <span class=\"token function\">add</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>- vue invoke</pre></td></tr></table></figure></li>\n<li>\n<p>参数解析：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vue <span class=\"token builtin class-name\">command</span> <span class=\"token punctuation\">[</span>options <span class=\"token operator\">&lt;</span>params<span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n<li>\n<p>options: 全称：--version、--help。简写为：-v   -h</p>\n</li>\n<li>\n<p>帮助文档：global help</p>\n</li>\n<li>\n<p>命令行交互</p>\n</li>\n<li>\n<p>日志打印</p>\n</li>\n<li>\n<p>命令行文字变色</p>\n</li>\n<li>\n<p>网络通信</p>\n</li>\n<li>\n<p>文件处理</p>\n</li>\n</ul>\n<h1 id=\"开发细节\"><a class=\"anchor\" href=\"#开发细节\">#</a> 开发细节</h1>\n<p><strong>两种链接本地文件的方式</strong></p>\n<ul>\n<li>\n<p>npm  link 命令会将命令执行的当前文件夹根据 bin 字段软连接到全局的 node_moduls。</p>\n</li>\n<li>\n<p>npm link 包名称 ，这个命令会将全局包添加软连接到当前项目的 node_modules 中。</p>\n</li>\n<li>\n<p>npm unlink 包名称 ，这个命令用于移除全局 node_modules 中指定的软连接。（不过这个命令不好用，建议使用 <code>npm uninstall -g </code> 包名称、或者 <code>npm remove -g </code> 包名称  代替）</p>\n</li>\n<li>\n<p>调试过程中，当本地包相互依赖时，可以使用 File: 路径进行指向。</p>\n<p><strong>两种方式的区别</strong></p>\n</li>\n</ul>\n<p>npm  link 的方式创建的软连接可以实时同步更改的文件，但是项目文件多了就不方便管理、很复杂，File 路径不能实时同步文件修改，需要执行 npm install，但是管理方便。</p>\n<h1 id=\"脚手架发布体系\"><a class=\"anchor\" href=\"#脚手架发布体系\">#</a> 脚手架发布体系</h1>\n<p><strong>利用脚手架统一管理发布阶段</strong></p>\n<p><strong>利用脚手架做发布的优势</strong></p>\n<ul>\n<li>规范：利用统一发布规范，如 commiti 记录、分支名称、代码规范等</li>\n<li>效率：避免大量重复操作，浪费开发时间</li>\n<li>安全：构建和发布全部在云端操作，避免个人发布时带来的安全隐患</li>\n</ul>\n<p><strong>脚手架发布的流程？</strong></p>\n<ul>\n<li>GitF1low 自动化代码提交</li>\n<li>远程代码自动检查</li>\n<li>云端完成构建与发布操作</li>\n</ul>\n<h1 id=\"脚手架发布流程\"><a class=\"anchor\" href=\"#脚手架发布流程\">#</a> 脚手架发布流程</h1>\n<ul>\n<li>检查 package.json 中 name 和 bin 字段，name 字段不能和已存在的线上包名重复，</li>\n<li>检查版本号，是否需要更新</li>\n<li>npm login</li>\n<li>npm publish</li>\n</ul>\n<h1 id=\"npm新特性workspace\"><a class=\"anchor\" href=\"#npm新特性workspace\">#</a> npm 新特性：workspace</h1>\n<p><strong>作用</strong></p>\n<p>本地调试时，需要多次执行 npm  link，node15 版本推出 workspace，workspace 新特性可以帮助我们进行多 package 包管理，可以让多个 npm 包在同一个项目中进行开发和管理：</p>\n<ul>\n<li>将子包中所有的依赖包都提升到根目录进行安装，提升包的安装速度</li>\n<li>初始化 (npm install) 后自动将子包之间的依赖进行关联</li>\n<li>各个子包共享一些流程（eslint、githook、publish flow 等等）</li>\n</ul>\n<h1 id=\"lerna多package管理\"><a class=\"anchor\" href=\"#lerna多package管理\">#</a> Lerna 多 package 管理</h1>\n<h3 id=\"lerna简介\"><a class=\"anchor\" href=\"#lerna简介\">#</a> Lerna 简介</h3>\n<p><strong>原生脚手架开发痛点分析</strong>（Lerna 解决了哪些问题： ）</p>\n<p><strong>痛点一：重复操作</strong></p>\n<ul>\n<li>多 Package 本地 link</li>\n<li>多 Package 依赖安装</li>\n<li>多 Package. 单元测试</li>\n<li>多 Package 代码提交</li>\n<li>多 Package 代码发布</li>\n</ul>\n<p><strong>痛点二：版本一致性</strong></p>\n<ul>\n<li>发布时版本一致性</li>\n<li>发布后相互依赖板本升级</li>\n<li>package 越多，管理复杂度越高</li>\n</ul>\n<p><strong>简介：</strong></p>\n<p>Lerna 是一个优化基于 git+npm 的多 package 项目的管理工具。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>大幅减少重复操作</li>\n<li>提升操作的标准化</li>\n</ul>\n<p>Lera 是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。优化的主要目标往往都是以效能为核心。</p>\n<h3 id=\"lerna使用\"><a class=\"anchor\" href=\"#lerna使用\">#</a> Lerna 使用</h3>\n<p><strong>Lerna 开发脚手架流程如下：</strong></p>\n<ul>\n<li>\n<p>npm 上创建 group</p>\n</li>\n<li>\n<p>初始化 npm 项目</p>\n</li>\n<li>\n<p>安装 lerna</p>\n</li>\n<li>\n<p>package.json 中配置 workspaces</p>\n<pre><code class=\"language-javascripton\">&quot;workspaces&quot;: [\n    &quot;packages/*&quot;\n  ],\n//workspaces字段允许指定一个或多个目录作为工作区。一、可以在父级目录的package.json中管理他们的依赖，从而较少体积。二、工作区每个包之间直接相互引用，有助于提高开发效率。三、工作区所有包共享版本控制历史。\n</code></pre>\n</li>\n<li>\n<p>lerna init 初始化项目（创建了 git）</p>\n</li>\n<li>\n<p>配置 gitignore 排除不需要提交的文件</p>\n</li>\n<li>\n<p>--------------------------- 初始化完成</p>\n</li>\n<li>\n<p>lerna create 创建 package</p>\n</li>\n<li>\n<p>lerna add 安装依赖（最新版废弃），使用 npm install &lt;dependency&gt; --workspace  &lt;workspace &gt; 代替。</p>\n</li>\n<li>\n<p>lerna link 链接依赖（最新版废弃），workspace 自动链接。</p>\n</li>\n<li>\n<p>---------------------------- 项目创建完成</p>\n</li>\n<li>\n<p>lerna exec 执行 shell 脚本</p>\n</li>\n<li>\n<p>lerna run 执行 npm 命令</p>\n</li>\n<li>\n<p>lerna clean 清空依赖</p>\n</li>\n<li>\n<p>lerna bootstrap 重装依赖（最新版废弃），使用 npm install 代替</p>\n</li>\n<li>\n<p>---------------------------- 项目开发完成</p>\n</li>\n<li>\n<p>git push 提交到远程仓库</p>\n</li>\n<li>\n<p>lerna version 升级版本号</p>\n</li>\n<li>\n<p>lerna changed 查看上版本以来全部的变更。</p>\n</li>\n<li>\n<p>git add . 添加到 git 工作区</p>\n</li>\n<li>\n<p>lerna diff 查看 diff</p>\n</li>\n<li>\n<p>lerna publish 进行项目发布</p>\n<pre><code class=\"language-javascripton\">//默认是私有仓库，需要在package.json中进行配置：\n&quot;publishConfig&quot;: &#123;\n\t&quot;access&quot;:&quot;public&quot;\n&#125;\n</code></pre>\n</li>\n<li>\n<p>---------------------------- 项目发布完成</p>\n</li>\n</ul>\n<p>这里注意 npm 最新版 workspace 特性的推广导致 lerna 许多命令在最新版被废弃。</p>\n<h3 id=\"lerna学习收获\"><a class=\"anchor\" href=\"#lerna学习收获\">#</a> Lerna 学习收获</h3>\n<ul>\n<li>熟悉 Yargs 脚手架开发框架</li>\n<li>熟悉多 Package 管理工具 Lerna 的使用方法和实现原理</li>\n<li>深入理解 Node.js 模块路径解析流程</li>\n</ul>\n<h4 id=\"一-yargs\"><a class=\"anchor\" href=\"#一-yargs\">#</a> <strong>一、yargs</strong></h4>\n<p><strong>脚手架构成</strong></p>\n<ul>\n<li>\n<p>bin:package,json 中配置 bin 属性，npm link 本地安装</p>\n</li>\n<li>\n<p>command: 命令</p>\n</li>\n<li>\n<p>options: 参数 (boolean/string/number)</p>\n</li>\n<li>\n<p>文件顶部增加  #！/usr/bin/env node</p>\n</li>\n</ul>\n<p><strong>脚手架初始化流程</strong></p>\n<ul>\n<li>\n<p>构造函数：Yargs (0</p>\n</li>\n<li>\n<p>常用方法：</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>Yargs.options</p>\n</li>\n<li>\n<p>Yargs.option</p>\n</li>\n<li>\n<p>Yargs.group</p>\n</li>\n<li>\n<p>Yargs.demandCommand</p>\n</li>\n<li>\n<p>Yargs.recommendCommands</p>\n</li>\n<li>\n<p>Yargs.strict</p>\n</li>\n<li>\n<p>Yargs.fail</p>\n</li>\n<li>\n<p>Yargs.alias</p>\n</li>\n<li>\n<p>Yargs.wrap</p>\n</li>\n<li>\n<p>Yargs.epilogue</p>\n</li>\n</ol>\n<ul>\n<li>脚手架参数解析</li>\n</ul>\n<ol>\n<li>hideBin(process.argv)/Yargs.argv</li>\n<li>Yargs.parse(argv,options)</li>\n</ol>\n<ul>\n<li>命令注册方法</li>\n</ul>\n<ol>\n<li>Yargs.command(command,describe,builder,handler)</li>\n<li>Yargs.command({command,describe,builder,handler )</li>\n</ol>\n<h4 id=\"二-lerna实现原理\"><a class=\"anchor\" href=\"#二-lerna实现原理\">#</a> <strong>二、Lerna 实现原理</strong></h4>\n<p>Lerna 是基于 git+npm 的多 package 项目管理工具</p>\n<p><strong>实现原理：</strong></p>\n<ul>\n<li>通过 import-local 优先调用本地 lerna 命令</li>\n<li>通过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数</li>\n<li>lerna 命令注册时需要传入 builder 和 handler 两个方法，builder 方法用于注册命令专属的 options</li>\n<li>handler 用来处理命令的业务逻辑</li>\n<li>lerna 通过配置 npm 本地依赖的方式来进行本地开发，具体写法是在 package.json 的依赖中写入：file:your-local--module-path, 在 lerna publish 时会自动将该路径替换</li>\n</ul>\n<h4 id=\"三-nodejs模块路径解析流程\"><a class=\"anchor\" href=\"#三-nodejs模块路径解析流程\">#</a> 三、Node.js 模块路径解析流程</h4>\n<ul>\n<li>\n<p>Node.js 项目模块路径解析是通过 require.resolve 方法来实现的</p>\n</li>\n<li>\n<p>require,resolve 就是通过 Module.reso1 veFileName 方法实现的</p>\n</li>\n<li>\n<p>require,resolve 实现原理：<strong>Module,resolveFileName 方法核心流程有 3 点：</strong></p>\n<ol>\n<li>\n<p>判断是否为内置模块</p>\n</li>\n<li>\n<p>通过 Module,resolveLookupPaths 方法生成 node_modules 可能存在的路径</p>\n</li>\n<li>\n<p>通过 Module,findPath 查询模块的真实路径</p>\n</li>\n</ol>\n<p><strong>Module,findPath 核心流程有 4 点：</strong></p>\n<ol>\n<li>\n<p>查询缓存（将 request 和 paths 通过 \\xoo 合并成 cacheKey)</p>\n</li>\n<li>\n<p>遍历 paths, 将 path 与 request 组成文件路径 basePath</p>\n</li>\n<li>\n<p>如果 basePath 存在则调用 fs,realPathSync 获取文件真实路径</p>\n</li>\n<li>\n<p>将文件真实路径缓存到 Module.pathCache (key 就是前面生成的 cacheKey)</p>\n</li>\n</ol>\n<p><strong>fs.realPathSync 核心流程有 3 点：</strong></p>\n</li>\n</ul>\n<ol>\n<li>\n<p>查询缓存（缓存的 key 为 p, 即 Module.findPath 中生成的文件路径）】</p>\n</li>\n<li>\n<p>从左往右遍历路径字符串，查询到 / 时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路径 P, 然后继续往后遍历，这里有 1 个细节需要特别注意：</p>\n<p>遍历过程中生成的子路径 base 会缓存在 knownHard 和 cache 中，避免重复查询</p>\n</li>\n<li>\n<p>遍历完成得到模块对应的真实路径，此时会将原始路径 original 作为 key, 真实路径作为 value, 保存到缓存中</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>require.resolve,paths 等价于 Module.resolveLookupPaths，, 该方法用于获取所有 node_modules 可能存在的路径</p>\n</li>\n<li>\n<p>require.resolve,paths 实现原理：<br />\n如果路径为 /（根目录），直接返回【'/node modules'】否则，将路径字符串从后往前遍历，查询到 / 时，拆分路径，在后面加上 node_modules, 并传入一个 paths 数组，直至查询不到 / 后返回 paths 数组</p>\n</li>\n</ul>\n<h1 id=\"yargs\"><a class=\"anchor\" href=\"#yargs\">#</a> yargs</h1>\n<p><strong>yargs 使用简要介绍：</strong></p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#! /usr/bin/env node</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 获得 yargs 构造实例</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> yargs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'yargs/yargs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 参数解析函数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> hideBin <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'yargs/helpers'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">const</span> arg <span class=\"token operator\">=</span> <span class=\"token function\">hideBin</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">const</span> cli <span class=\"token operator\">=</span> <span class=\"token function\">yargs</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 配置命令：</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>cli</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">usage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Usage: $0 [command] &lt;options>'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 使用说明，$0 表示命令</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">demandCommand</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'A command is required,pass --help to see info'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 最少一个次命令</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">strict</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 对于未知的命令行参数进行提示输出。</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">recommendCommands</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 查找提示近似命令</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">alias</span><span class=\"token punctuation\">(</span><span class=\"token string\">'h'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'help'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//options 别名</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">alias</span><span class=\"token punctuation\">(</span><span class=\"token string\">'v'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'version'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>cli<span class=\"token punctuation\">.</span><span class=\"token function\">terminalWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 命令行输出宽度</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">epilog</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">welcomn use cli-core</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 结语</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">options</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 注册多个 options 选项</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token literal-property property\">debug</span><span class=\"token operator\">:</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span><span class=\"token string\">\"boolean\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>      <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bootstrap debug mode\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>      <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span> <span class=\"token string\">\"d\"</span> <span class=\"token comment\">// 添加别名</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'registry'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 添加单个选项</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token literal-property property\">hidden</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 不对外暴露命令</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span><span class=\"token string\">\"string\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span><span class=\"token string\">\"define global registry\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span><span class=\"token string\">'r'</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'debug'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Dev Options'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 对 Options 选项进行分类</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">group</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'registry'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Extra Options\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'init [name]'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'init a project'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">yargs</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 注册次命令，制定对应 options</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    yargs</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>      <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span> <span class=\"token string\">'Name of a project'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token literal-property property\">alias</span><span class=\"token operator\">:</span> <span class=\"token string\">'n'</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">argv</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span>    <span class=\"token comment\">// 第二种注册命令的方法（更加精细）</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token literal-property property\">command</span><span class=\"token operator\">:</span> <span class=\"token string\">'list'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token literal-property property\">aliases</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'ls'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'la'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'ll'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token literal-property property\">describe</span><span class=\"token operator\">:</span> <span class=\"token string\">'List local packages'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token function-variable function\">builder</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">yargs</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>      <span class=\"token comment\">//.... 操作</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token function-variable function\">handler</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">argv</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>  <span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 使用参数</span></pre></td></tr></table></figure><h1 id=\"commander\"><a class=\"anchor\" href=\"#commander\">#</a> commander</h1>\n<p><strong>commander 简单单例模式</strong></p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#! /usr/bin/env node</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> commander <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'commander'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> pkg <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../package.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> program <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> commander<span class=\"token punctuation\">;</span> <span class=\"token comment\">//commander 单例，包含已注册好的基础命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">version</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>commander 强大功能</strong></p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token hashbang comment\">#! /usr/bin/env node</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> commander <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'commander'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">const</span> pkg <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../package.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">const</span> program <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">commander<span class=\"token punctuation\">.</span>Command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 手动实例化一个 commander 实例</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">.</span>bin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">usage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;command> [options]'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 使用说明</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">version</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 版本</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-d,--debug'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'是否开启调试模式'</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 配置 option 选项：选项，帮助信息，默认值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-e,--envName &lt;envName>'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'获取变量名称'</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//option 获得传参</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 解析参数</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// 使用 command 注册命令</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">const</span> clone <span class=\"token operator\">=</span> program<span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'clone &lt;source> [destination]'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//&lt; 必选项 >，[可选项]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>clone</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'clone a repository'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">option</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-f,--force'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'是否强制克隆'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">source<span class=\"token punctuation\">,</span>destination<span class=\"token punctuation\">,</span>cmdObj</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'do clone'</span><span class=\"token punctuation\">,</span>source<span class=\"token punctuation\">,</span>destination<span class=\"token punctuation\">,</span>cmdObj<span class=\"token punctuation\">.</span>force<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 使用 addCommand 注册子命令</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">const</span> service <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">commander<span class=\"token punctuation\">.</span>Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'service'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>service</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'start [port]'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'start service at port'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">port</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'do service start'</span><span class=\"token punctuation\">,</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>service</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stop'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stop service'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stop service'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">addCommand</span><span class=\"token punctuation\">(</span>service<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">// 参数解释和自动匹配功能</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">arguments</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;cmd> [options]'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 强制传入命令</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">description</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test command'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 描述</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token literal-property property\">cmd</span><span class=\"token operator\">:</span> <span class=\"token string\">'命令'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token literal-property property\">options</span><span class=\"token operator\">:</span> <span class=\"token string\">'参数'</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">action</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cmd<span class=\"token punctuation\">,</span>options</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 匹配全部命令</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>cmd<span class=\"token punctuation\">,</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token comment\">// 默认命令与命令转向功能</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>program</pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token function\">command</span><span class=\"token punctuation\">(</span><span class=\"token string\">'install [name]'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'install package'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token literal-property property\">executableFile</span><span class=\"token operator\">:</span> <span class=\"token string\">'imooc-cli'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 将 install [name] 命令转向 imooc-cli</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>            <span class=\"token literal-property property\">isDefault</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// 设置为默认命令</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>            <span class=\"token literal-property property\">hidden</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// 命令不可见</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token punctuation\">.</span><span class=\"token function\">alias</span><span class=\"token punctuation\">(</span><span class=\"token string\">'i'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token comment\">// 高级定制 1：自定义 help 信息</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">helpInformation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'--help'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my help information'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\">// 高级定制 2：监听 debug</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'option:debug'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>        process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span> <span class=\"token operator\">=</span> <span class=\"token string\">'verbose'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre></pre></td></tr><tr><td data-num=\"72\"></td><td><pre><span class=\"token comment\">// 高级定制 3：监听未知命令（与默认命令冲突）</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'command:*'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">obj</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'未知命令:'</span><span class=\"token operator\">+</span> obj<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token keyword\">const</span> avaliableCommands <span class=\"token operator\">=</span> program<span class=\"token punctuation\">.</span>commands<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cmd</span><span class=\"token operator\">=></span>cmd<span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'可用命令：'</span><span class=\"token operator\">+</span>avaliableCommands<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre></pre></td></tr><tr><td data-num=\"79\"></td><td><pre><span class=\"token comment\">// 最后要进行参数解析！</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre></pre></td></tr><tr><td data-num=\"82\"></td><td><pre><span class=\"token comment\">// 内置属性和方法</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span>envName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>program<span class=\"token punctuation\">.</span><span class=\"token function\">outputHelp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 内置方法，弹出帮助信息</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">.</span><span class=\"token function\">opts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 内置方法，返回 options 信息</span></pre></td></tr></table></figure><h1 id=\"require加载机制\"><a class=\"anchor\" href=\"#require加载机制\">#</a> require 加载机制</h1>\n<p><strong>require 直接加载.js、.json 和.node 文件，其余文件按照 js 语法进行加载</strong></p>\n<ol>\n<li>加载 js 文件，require 加载的 js 文件需要进行导出</li>\n<li>加载 json 文件，通过 JSON.parse 进行文件解析</li>\n<li>加载 node 文件，通过 process.dlopen 方法加载（node 文件是 C++ 语法）</li>\n<li>其余文件，使用 js 语法加载，此时语法错误的会报错。</li>\n</ol>\n<h1 id=\"node多进程\"><a class=\"anchor\" href=\"#node多进程\">#</a> node 多进程</h1>\n<h3 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h3>\n<p><strong>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</strong></p>\n<p>什么是进程</p>\n<p>进程 (Process) 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单</p>\n<p>位，是操作系统结构的基础。</p>\n<p>进程的概念主要有两点：</p>\n<ul>\n<li>第一，进程是一个实体。每一个进程都有它自己的地址空间。</li>\n<li>第二，进程是一个 “执行中的程序”，存在嵌套关系。</li>\n</ul>\n<p>node 多进程官方文档：</p>\n<p>中文版：<span class=\"exturl\" data-url=\"aHR0cDovL25vZGVpcy5jbi9hcGkvY2hpbGRfcHJvY2VzcyxodG1s\">http://nodeis.cn/api/child_process,html</span></p>\n<p><strong>操作系统会使用时会开辟一个 node 进程，每个 node 文件在运行时都会创建一个 child_process 进行，也就是 node.js 的子进程。</strong></p>\n<h3 id=\"child_precess用法\"><a class=\"anchor\" href=\"#child_precess用法\">#</a> child_precess 用法</h3>\n<p><strong>一、执行可执行文件。</strong></p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> cp <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'child_process'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 默认内置库</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//exec 方法，可以传执行命令，也可以传文件路径，但不支持给文件传参。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>cp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ls -al|grep node_modules'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">//execFile 方法，传文件路径，并且支持给文件传参数。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>cp<span class=\"token punctuation\">.</span><span class=\"token function\">execFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ls'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'-al'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//spawn 方法，传入文件路径，以流式的方式输出，是 exec 和 execFile 的底层原理</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npm'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>install<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token literal-property property\">cwd</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/User/dmq/Desktop/test'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>child<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stdout'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>child<span class=\"token punctuation\">.</span>stderr<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stderr'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>exec 和 spawn 使用场景：</strong></p>\n<p>当文件操作过程复杂，并且需要频繁输出日志时，使用 spawn 进行流式操作。</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npm'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>install<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token literal-property property\">cwd</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/User/dmq/Desktop/test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token literal-property property\">stdio</span><span class=\"token operator\">:</span> <span class=\"token string\">'inherit'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 将输出传给父进程。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 监听错误事件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span><span class=\"token parameter\">e</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 监听退出事件</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'exit'</span><span class=\"token punctuation\">,</span><span class=\"token parameter\">e</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'命令执行成功'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>child<span class=\"token punctuation\">.</span>stdout<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stdout'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>child<span class=\"token punctuation\">.</span>stderr<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'stderr'</span><span class=\"token punctuation\">,</span>chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>当文件操作过程简单，需要直接输出时，使用 exec 方法</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cp<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npm install'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token literal-property property\">cwd</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/User/dmq/Desktop/test'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span>stdout<span class=\"token punctuation\">,</span>stderr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>stdout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>stderr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><strong>二、执行指定 JS 文件（不支持回调）</strong></p>\n<p>fork 方法类似于 require 函数，但是区别在于 fork 方法会创建一个 node 子进程执行 JS 文件，使用独立的 v8 引擎去解析代码。</p>\n<p>index.js 文件：</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> child <span class=\"token operator\">=</span> cp<span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span><span class=\"token string\">'child.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello child process!'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    child<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 及时断开连接，防止主进程和子进程长期处于等待状态</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>child<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'main pid:'</span><span class=\"token punctuation\">,</span>process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>child.js 文件：</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'child process pid:'</span><span class=\"token punctuation\">,</span>process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>process<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>process<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello main process'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"child_process源码\"><a class=\"anchor\" href=\"#child_process源码\">#</a> child_process 源码</h3>\n<p>疑问：</p>\n<ul>\n<li>exec、execFile、spanwn 和 fork 区别：\n<ul>\n<li>exec: 原理是调用 /bin/sh-c 执行我们传入的 shell 脚本，底层调用了 execFile</li>\n<li>execFile: 原理是直接执行我们传入的 file 和 args, 底层调用 spawn 创建和执行子进程，并建立了回调，一次性将所有的 stdout 和 stderr 结果返回</li>\n<li>spawn: 原理是调用了 internal/child_.process, 实例化了 ChildProcess 子进程对象，再调用 child.spawn 创建子进程并执行命令，底层是调用了 child._handle.spawn 执行 process_wrap 中的 spwn 方法，执行过程是异步的，执行完毕后通过 PIPE 进行单向数据通信，通信结束后会子进程发起 onexit 回调，同时 Socket 会执行 close 回调</li>\n<li>fork: 原理是通过 spawn 创建子进程和执行命令，通过 setupchannel 创建 IPC 用于子进程和父进程之</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"eggjsmongodb\"><a class=\"anchor\" href=\"#eggjsmongodb\">#</a> egg.js+mongodb</h1>\n<p><strong>1、egg.js</strong></p>\n<p>用于快速生成后端 api 的框架。</p>\n<p><strong>2、npm init egg 命令</strong></p>\n<p>当执行 <code>npm init egg</code>  命令时，npm 会自动找到 create-egg 这个包（其他包同理，找到 create - 包名），进行执行。<strong>当不想将脚手架安装到本地，而是在线上直接使用时，这个机制就显得十分重要。</strong></p>\n<p><strong>3、mongodb 数据库</strong></p>\n<p>非关系型数据库。</p>\n<ul>\n<li>\n<p><strong>云 mongodb</strong></p>\n<ul>\n<li>\n<p>云 mongodb 开通</p>\n</li>\n<li>\n<p>地址：https:/mongodb.console.aliyun.comL, 创建实例并付款即可</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>本地 mongodb</strong></p>\n<ul>\n<li>\n<p>地址：https:/www.runoob.com/mongodb/mongodb-tutorial.html</p>\n</li>\n<li>\n<p>mongodb 使用方法</p>\n</li>\n<li>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9tb25nb2RiL21vbmdvZGItZGF0YWJhc2VzLWRvY3VtZW50cy1jb2xsZWN0aW9ucy5odG1s\">https://www.runoob.com/mongodb/mongodb-databases-documents-collections.html</span></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>4、egg.js 链接 mongodb 数据库</p>\n<p>utils/mongo.js</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> logger <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'npmlog'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>logger<span class=\"token punctuation\">.</span>level <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span> <span class=\"token operator\">?</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">LOG_LEVEL</span> <span class=\"token operator\">:</span> <span class=\"token string\">'info'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>logger<span class=\"token punctuation\">.</span>heading <span class=\"token operator\">=</span> <span class=\"token string\">'pick'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义头部</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>logger<span class=\"token punctuation\">.</span><span class=\"token function\">addLevel</span><span class=\"token punctuation\">(</span><span class=\"token string\">'success'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">fg</span><span class=\"token operator\">:</span> <span class=\"token string\">'green'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">bold</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义 success 日志</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>logger<span class=\"token punctuation\">.</span><span class=\"token function\">addLevel</span><span class=\"token punctuation\">(</span><span class=\"token string\">'notice'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">fg</span><span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">bg</span><span class=\"token operator\">:</span> <span class=\"token string\">'black'</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义 notice 日志</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">const</span> MongoClient <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mongodb'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>MongoClient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Mongo</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">url<span class=\"token punctuation\">,</span> dbName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url <span class=\"token operator\">=</span> url<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dbName <span class=\"token operator\">=</span> dbName<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      MongoClient<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>          <span class=\"token literal-property property\">useNewUrlParser</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>          <span class=\"token literal-property property\">useUnifiedTopology</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> client</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">const</span> db <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">db</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dbName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span> db<span class=\"token punctuation\">,</span> client <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>          <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">&#123;</span> db<span class=\"token punctuation\">,</span> client <span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token keyword\">const</span> collection <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span><span class=\"token function\">collection</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token function\">action</span><span class=\"token punctuation\">(</span>collection<span class=\"token punctuation\">,</span> <span class=\"token parameter\">result</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>          logger<span class=\"token punctuation\">.</span><span class=\"token function\">verbose</span><span class=\"token punctuation\">(</span><span class=\"token string\">'result'</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>          logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>          <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>client<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>  <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">collection<span class=\"token punctuation\">,</span> onSuccess<span class=\"token punctuation\">,</span> onError</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>      collection<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">projection</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token literal-property property\">_id</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> docs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>          <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>          <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>docs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>  <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">collection<span class=\"token punctuation\">,</span> onSuccess<span class=\"token punctuation\">,</span> onError</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>      collection<span class=\"token punctuation\">.</span><span class=\"token function\">insertMany</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>          <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>          <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>  <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">docName<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">connectAction</span><span class=\"token punctuation\">(</span>docName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">collection<span class=\"token punctuation\">,</span> onSuccess<span class=\"token punctuation\">,</span> onError</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>      collection<span class=\"token punctuation\">.</span><span class=\"token function\">deleteOne</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>          <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>          <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>  <span class=\"token comment\">//   update(collection, data) &#123;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>  <span class=\"token comment\">//   &#125;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>  <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">client</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>    client <span class=\"token operator\">&amp;&amp;</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> Mongo<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>db.js</p>\n<figure class=\"highlight javascript\"><figcaption data-lang=\"javascript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> mongo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mongodb</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mongodb://dmq:dmq0216@127.0.0.1:27017/dbName'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'dbName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token function\">mongo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'project'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h1 id=\"inquirer源码\"><a class=\"anchor\" href=\"#inquirer源码\">#</a> inquirer 源码</h1>\n<h2 id=\"学习路径\"><a class=\"anchor\" href=\"#学习路径\">#</a> 学习路径</h2>\n<ul>\n<li>掌握一些库：readline（命令行读取）/events（事件驱动）/stream（输入输出流）/ansi-escapes（命令行文字样式）/rxjs（处理异步事件）</li>\n<li>掌握命令行交互的实现原理，并实现一个可交互的列表</li>\n<li>分析 inquirer 源码掌握其中的关键实现</li>\n</ul>\n<h1 id=\"ejsglob\"><a class=\"anchor\" href=\"#ejsglob\">#</a> ejs+glob</h1>\n<p>ejs 三方库用于 xml 动态模板渲染，glob 三方库用于根据 <code>文件路径进行遍历和匹配文件</code> ，拿到文件的内容。</p>\n<h1 id=\"ejs源码\"><a class=\"anchor\" href=\"#ejs源码\">#</a> ejs 源码</h1>\n<p>省略，详见官网</p>\n<h1 id=\"require源码\"><a class=\"anchor\" href=\"#require源码\">#</a> require 源码</h1>\n<p>省略，详见官网</p>\n<h1 id=\"代码复用实践\"><a class=\"anchor\" href=\"#代码复用实践\">#</a> 代码复用实践</h1>\n<p>** 代码复用目的：** 提高人效，降低开发成本。</p>\n<p><strong>计算公式</strong>为：<strong>节约工时 = 服用代码节约时间  *  代码复用系数  *  复用次数</strong></p>\n<p><strong>背后思考：</strong></p>\n<ul>\n<li>不同开发者、团队之间会产生了大量重复、通用的代码</li>\n<li>这些代码散落在各自团队的项目代码里</li>\n<li>复用的时候大家习惯于直接拷贝这些代码到项目中，因为这样做对个人成本最低（开发者往往更熟悉自己写的代码)，但是这种做法不利于团队之间代码共享，因为每个人开发不同的业务，对不同页面的熟悉程度不一样，而代码复用的宗旨就是要尽可能将团队中的开发着的整体水平拉齐</li>\n<li>所以需要通过工具化的方式降低代码复用的成本</li>\n</ul>\n","categories":["脚手架开发"],"tags":["脚手架开发"]},{"title":"解决方案","url":"/2023/06/02/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"<h1 id=\"图片上传：\"><a href=\"#图片上传：\" class=\"headerlink\" title=\"图片上传：\"></a>图片上传：</h1><p>input标签中file（accetp接受类型） 、</p>\n<p>fileList（change事件的e.target.files[0]） 、</p>\n<p>Blob（二进制格式数据）、</p>\n<p>FileReader（将文本文件file转为字符串或者URL）、</p>\n<p>URL scheme 、</p>\n<p>拖拽事件：dragenter、dragover、drop</p>\n","categories":["解决方案"],"tags":["解决方案"]},{"title":"JS类型转换","url":"/2023/12/02/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","content":"<h1 id=\"隐式类型转换过程\"><a href=\"#隐式类型转换过程\" class=\"headerlink\" title=\"隐式类型转换过程\"></a>隐式类型转换过程</h1><p><img data-src=\"/images/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png\" alt=\"隐式类型转换\"></p>\n<ul>\n<li>当进行一些操作时，JS会自动调用内部的函数进行隐式类型转换，例如：<code>==判断</code>，数据类型不同的<code>加减法操作</code>，数据前加+或-（<code>+new Date()</code>）或<code>$&#123;obj&#125;</code>等</li>\n<li>两个引用数据类型（对象）之间不会发生隐式类型转换，双等符号（&#x3D;&#x3D;）也会判断其栈中的地址</li>\n<li>隐式类型转换内部使用的函数有：ToNumber、ToString、ToBoolean、ToPrimitive（底层）等</li>\n<li>ToNumber对<code>引用数据类型</code>会先使用<code>ToPrimitive(&#39;number&#39;)</code>，然后使用<code>Number()</code>进行转换</li>\n<li>ToString对<code>引用数据类型</code>会先使用<code>ToPrimitive(&#39;string&#39;)</code>，然后使用<code>String()</code>进行转换</li>\n<li>ToBoolean对<code>null</code>，<code>undefined</code>，<code>false</code>，<code>NaN</code>，<code>&#39;&#39;</code> ，<code>0</code>，<code>-0</code>转换为<code>false</code>，其余都转换为<code>true</code></li>\n</ul>\n<blockquote>\n<p>当进行条件判断时，会调用<code>ToBoolean</code>方法。<br>当引用数据类型（对象）转换到<code>number</code>和<code>string</code>时，使用的<code>ToNumber</code>和<code>ToString</code>都会使用<code>ToPrimitive</code>算法，将对象尝试转为原始数据类型（转换失败会报错）<br>ToPrimitive接收一个<code>hint</code>参数，该参数只能取值：<code>string</code>、<code>number</code>或<code>default</code>。转换流程如下：</p>\n</blockquote>\n<ul>\n<li>存在[Symbol.toPrimitive]，则直接调用，不存在则走如下流程</li>\n<li>如果<code>hint</code>是<code>number</code>或者<code>default</code>，则先调用该对象的<code>valueOf</code>和<code>toString</code>，直到返回基本类型</li>\n<li>如果<code>hint</code>是<code>string</code>，则会依次调用该对象的<code>toString</code>和<code>valueOf</code>，直到返回基本类型</li>\n</ul>\n<h3 id=\"对象的-Symbol-toPrimitive-方法\"><a href=\"#对象的-Symbol-toPrimitive-方法\" class=\"headerlink\" title=\"对象的[Symbol.toPrimitive]方法\"></a>对象的[Symbol.toPrimitive]方法</h3><pre><code class=\"javascript\">//修改Symbol.toPrimitive方法，改变其隐式类型转换\nconst obj1 = &#123;&#125;;\nconsole.log(+obj1);     // NaN\nconsole.log(`$&#123;obj1&#125;`); // &quot;[object Object]&quot;\nconsole.log(obj1 + &quot;&quot;); // &quot;[object Object]&quot;\n// 接下面声明一个对象，手动赋予了Symbol.toPrimitive属性，再来查看输出结果\nconst obj2 = &#123;\n  [Symbol.toPrimitive](hint) &#123;\n    if (hint == &quot;number&quot;) &#123;\n      return 10;\n    &#125;\n    if (hint == &quot;string&quot;) &#123;\n      return &quot;hello&quot;;\n    &#125;\n    return true;\n  &#125;\n&#125;;\nconsole.log(+obj2);     // 10      -- hint 参数值是 &quot;number&quot;\nconsole.log(`$&#123;obj2&#125;`); // &quot;hello&quot; -- hint 参数值是 &quot;string&quot;\nconsole.log(obj2 + &quot;&quot;); // &quot;true&quot;  -- hint 参数值是 &quot;default&quot;\n</code></pre>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"[]\"></a>[]</h3><h1 id=\"快速记忆流程\"><a href=\"#快速记忆流程\" class=\"headerlink\" title=\"快速记忆流程\"></a>快速记忆流程</h1><p>一、原始类型 -&gt; 数字：</p>\n<p><img data-src=\"/images/1.png\"></p>\n<p>二、所有转boolean</p>\n<p><img data-src=\"/images/2.png\"></p>\n<p>三、原始类型</p>\n<p><img data-src=\"/images/3.png\"></p>\n<p>四、对象转原始类型</p>\n<p><img data-src=\"/images/4.png\" alt=\"四、对象转原始类型\"></p>\n<h2 id=\"具体转换规则为：\"><a href=\"#具体转换规则为：\" class=\"headerlink\" title=\"具体转换规则为：\"></a>具体转换规则为：</h2><ul>\n<li><p>如果该值已经是原始数据类型（string、number、boolean），则直接返回该值。</p>\n</li>\n<li><p>如果其中一项是字符串，那另一项值就会转换成对应的字符串类型。</p>\n</li>\n<li><p>如果该值是对象（Object），则调用该对象的 valueOf() 方法，如果返回的结果是原始数据类型，则直接返回该值。</p>\n</li>\n<li><p>如果<code>valueOf()</code>方法的返回结果不是原始数据类型，则调用该对象的 toString() 方法，如果返回的结果是原始数据类型，则直接返回该值。</p>\n</li>\n<li><p>如果<code>toString()</code>方法的返回结果不是原始数据类型，则抛出 TypeError 异常。</p>\n</li>\n</ul>\n<p><img data-src=\"/images/Snipaste_2024-05-28_22-08-50.png\" alt=\"images\"></p>\n","categories":["JS"],"tags":["JS类型转换"]},{"title":"项目质量检测","url":"/2024/01/02/%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B/","content":"<h1 id=\"5-2-项目质量监测\"><a href=\"#5-2-项目质量监测\" class=\"headerlink\" title=\"5-2 项目质量监测\"></a>5-2 项目质量监测</h1><h2 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h2><p>没有规矩不成方圆，所以我们写代码也要有”规矩”，但是我们通常记不住所有的”规矩”，因为人嘛，不可能不犯错。但是，这难不到我们程序员，我们让机器、代码、程序帮我们搞定，让它们来帮我们进行代码质量检查，以便提高的程序的健壮性。</p>\n<p>通常来说，项目的质量决定了：</p>\n<ul>\n<li>软件项目的<strong>命运</strong></li>\n<li>软件项目的<strong>可维护性</strong></li>\n<li>软件项目的<strong>运维成本</strong></li>\n<li>软件项目的<strong>扩展性</strong></li>\n</ul>\n<p><strong>为什么要进行代码质量检查？</strong></p>\n<p>代码检查很重要，原因有三：</p>\n<ol>\n<li><strong>避免低级bug</strong>：一些常见代码问题，如果在编译或运行前不能及时发现，代码中的语法问题会直接导致编译或运行时错误，影响开发效率和代码质量；</li>\n<li><strong>统一代码习惯</strong>：每一个团队或个人都会有一些代码规范或者代码习惯，为了便于后期维护和阅读，我们编写的代码也需要符合一定的格式规范；<ul>\n<li>空格</li>\n<li>统一缩进</li>\n<li>命名规范</li>\n<li>…</li>\n</ul>\n</li>\n<li><strong>保证线上代码质量</strong>：在版本管理中，我们需要在提交或发布之前自动执行一些代码检查工作，确保我们的代码符合最终版本要求。</li>\n</ol>\n<p>如何让一个团队的人产出的代码都在一个基本水平底线之上呢？最初是靠制订规范。要确保规范得以执行只能靠人，所以文字规范成了code review的公共参照标准。<strong>单纯靠人的事最终都容易流于形式，所以需要工具加以保证。</strong>虽说工具并不能完全实现规范中的规则，但至少能够在一定程度上缓解代码不统一的局面。</p>\n<p><strong>本课程的学习路径：</strong></p>\n<ul>\n<li>Why</li>\n<li>What</li>\n<li>How</li>\n</ul>\n<p><strong>本课程的主要内容：</strong></p>\n<p>代码质量监测包括：代码规范（代码编写层面）、功能实现（测试层面）、Code Review（团队协作层面）。</p>\n<p>本课程，代码规范作为展开，以eslint为例子；代码质量中的功能实现，以e2e test为例子。</p>\n<p>关于，功能实现中的单元测试，5-3课程中有具体的框架使用及介绍。</p>\n<ul>\n<li>代码Lint——告别低级代码错误，简单的配置让程序来自动检查</li>\n<li>e2e test——了解什么是黑盒测试，如何进行e2e test，即End to End Test，端到端的测试。</li>\n<li>开源测试平台：Codecov介绍——配合Ci工具，让测试过程自动化，大大提升效率</li>\n</ul>\n<p><img data-src=\"/assets/MacHi-2017-10-15-21-45-04.png\" alt=\"img\"></p>\n<p>这些徽章都是可以点击的，第一个点进去是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kub3JnLyVFRiVCQyU4Q3RyYXZpcy1jaQ==\">https://travis-ci.org/，travis-ci</span> 是一个 CI（Continuous integration，持续集成） 平台，主要提供集群编译、单测、集成测试的环境。<code>.org</code> 的服务对公有仓库免费，<code>.com</code> 面向私人、团队、公司的项目提供商业支持（收费）。使用起来非常简单，使用 Github 帐号登录进去，就能看见开始界面。</p>\n<p>第二个徽章是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlY292LmlvLw==\">codecov.io</span>（单测覆盖率统计平台），接入过程也很简单，也是不同语言选择不同的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmNvZGVjb3YuaW8vZG9jcy9zdXBwb3J0ZWQtbGFuZ3VhZ2Vz\">配置文件</span>，codecov 可以无缝衔接 travis-ci，只需要在原来的配置文件上稍作修改即可，核心就是生成单测的结果文件。\\</p>\n<p><strong>本课程的学习准备：</strong></p>\n<ul>\n<li>IDE vscode，node &gt; 10.15</li>\n<li>包管理工具：yarn, cnpm</li>\n<li>Github账号</li>\n</ul>\n<h2 id=\"代码质量检查\"><a href=\"#代码质量检查\" class=\"headerlink\" title=\"代码质量检查\"></a>代码质量检查</h2><h3 id=\"前端代码中的常见问题-Why-Lint\"><a href=\"#前端代码中的常见问题-Why-Lint\" class=\"headerlink\" title=\"前端代码中的常见问题(Why Lint)\"></a>前端代码中的常见问题(Why Lint)</h3><h4 id=\"书写风格\"><a href=\"#书写风格\" class=\"headerlink\" title=\"书写风格\"></a>书写风格</h4><p>这个问题不用作过多阐述，想必接手过他人代码的同学，多少都有些体会。简单来说，太过随意的代码会让强迫症患者难以容忍，难以阅读理解的代码有时甚至不如推倒重来。</p>\n<pre><code class=\"javascript\">// bad\nvar once\n  , upon\n  , aTime;\n\n// good\nvar once,\n    upon,\n    aTime;\n\n// bad\nvar hero = &#123;\n    firstName: &#39;Bob&#39;\n  , lastName: &#39;Parr&#39;\n  , heroName: &#39;Mr. Incredible&#39;\n  , superPower: &#39;strength&#39;\n&#125;;\n\n// good\nvar hero = &#123;\n  firstName: &#39;Bob&#39;,\n  lastName: &#39;Parr&#39;,\n  heroName: &#39;Mr. Incredible&#39;,\n  superPower: &#39;strength&#39;\n&#125;;\n</code></pre>\n<h4 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h4><p>什么样的代码是低质量或高质量的？好的代码可能会让你如读小说一般被吸引，糟糕的代码会让你看一眼就不想继续、甚至看半天而不知所云。</p>\n<p>有人可能认为初级程序员才会有这种问题，其实不然，一些工作经验两三年的同学写的代码依然如此。对于一些个人自学意识不够积极、没有团队规范性指引的同学，很容易习惯成“学习半年、然后重复三年无长进”的情况。</p>\n<p>Lint会通过源代码去查找：</p>\n<ul>\n<li><p>格式问题</p>\n</li>\n<li><p>不遵守编码标准和惯例</p>\n</li>\n<li><p>精确定位程序中可能存在的逻辑错误</p>\n</li>\n</ul>\n<h4 id=\"高度耦合\"><a href=\"#高度耦合\" class=\"headerlink\" title=\"高度耦合\"></a>高度耦合</h4><p>这种问题其实是非常普遍的。一个函数几百行、一个文件数千行、一个类几十个方法、方法参数定义随意、没有任何注释、方法与变量命名无明确的语义、数据修改与变更穿插在各种方法中等等。 这样的编码方式，你要去理解它的逻辑往往真的很难，一般只能一块块一行行的去做阅读理解（可能还会开启边看边骂娘模式）。</p>\n<p>这主要原因在于开发者个人的基础知识能力、编码经验和意识等的不足。</p>\n<p>其实针对这种情况，常见的开源的编码规范都会有所提及。我的建议是这些同学应该好好温习一下面向对象编程、函数式编程、数据结构、常见设计模式，看一看各种开源的编码规范并尝试去真正的理解它们。当你回顾一个月前的代码时，发现可以改进或重构使得编码逻辑更为简洁清晰，说明你是在成长与进步的。</p>\n<p>经常看到有同学问这类问题：新项目正在选型，Vue.js、React、Angular 三大框架哪个合适？其实团队开发成员对这些都比较有经验，哪种都可以；如果团队成员前端开发经验大都不是太丰富或人员不够稳定，选择 Vue.js 最适合，为什么？因为它更简单简洁，容易上手。Vue.js 通过 prop、data、computed、method、watch 等各种钩子，一定程度上限定了编码方式与风格，使得初级开发者写出来的代码也不会太难看，这也是它越来越受社区推崇的原因之一。</p>\n<h3 id=\"代码质量监测（Def-Lint-Code）\"><a href=\"#代码质量监测（Def-Lint-Code）\" class=\"headerlink\" title=\"代码质量监测（Def: Lint Code）\"></a>代码质量监测（Def: Lint Code）</h3><p>那么，什么是代码质量监测？</p>\n<p>Lint或者Linter是一种分析源代码以标记编程过程中（代码、样式、构建）书写的错误的工具或者过程。</p>\n<blockquote>\n<p><strong>Lint</strong>, or a <strong>linter</strong>, is a tool that analyzes <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU291cmNlX2NvZGU=\">source code</span> to flag programming errors, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29mdHdhcmVfYnVn\">bugs</span>, stylistic errors, and suspicious constructs.[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGludF8oc29mdHdhcmUpI2NpdGVfbm90ZS0x\">1]</span> The term originates from a <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5peA==\">Unix</span> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl91dGlsaXR5X3NvZnR3YXJl\">utility</span> that examined <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ18ocHJvZ3JhbW1pbmdfbGFuZ3VhZ2Up\">C language</span> source code.[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGludF8oc29mdHdhcmUpI2NpdGVfbm90ZS1CZWxsTGFicy0y\">2]</span></p>\n</blockquote>\n<p>代码Lint是动态的监测代码编写的错误，以便我们能写出高质量的代码。</p>\n<blockquote>\n<p>与Prettier或者Format要区别开来，Lint只会告诉你代码中的错误或者不符合规范的地方，而Format是用来对格式进行调整的。</p>\n</blockquote>\n<h3 id=\"如何进行代码质量监测-How-to-Lint\"><a href=\"#如何进行代码质量监测-How-to-Lint\" class=\"headerlink\" title=\"如何进行代码质量监测(How to Lint)\"></a>如何进行代码质量监测(How to Lint)</h3><p>为了统一团队的代码规范，除了一纸规范说明之外，还需要引入工具进行限制。虽说工具并不能完全实现规范中的规则，但至少能够在一定程度上缓解代码不统一的局面。</p>\n<p>相对于后端，前端代码规范的质量检查涉及到HTML, CSS，Javascript ，如今还涉及到SCSS，ES5，JSX,  React，Vue，Angular等。</p>\n<p>常见的代码质量Lint工具：</p>\n<p>HTML &#x2F; tpl:  <span class=\"exturl\" data-url=\"aHR0cDovL2h0bWxoaW50LmNvbS8=\">HTMLHint</span></p>\n<p>CSS &#x2F; SCSS: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsZWxpbnQuaW8v\">StyleLint</span></p>\n<p>JS &#x2F; JSX: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnLw==\">ESLint</span></p>\n<h3 id=\"3种常见的Js检验工具比较\"><a href=\"#3种常见的Js检验工具比较\" class=\"headerlink\" title=\"3种常见的Js检验工具比较\"></a>3种常见的Js检验工具比较</h3><p>常见三个可以使用的js校验器，但是怎么选择使用哪一个呢？接下来让我们看看这四种流行方案的特点、优点和不足：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qc2xpbnQuY29tLw==\">JSLint</span>、<span class=\"exturl\" data-url=\"aHR0cDovL2pzaGludC5jb20v\">JSHint</span>、<span class=\"exturl\" data-url=\"aHR0cDovL2VzbGludC5vcmcv\">ESLint</span>。</p>\n<p>四种工具用相同的基本方式工作。他们都有一套用户分析、报告js文件错误的规则。他们都可以通过npm安装。他们都可以通过命令行使用、作为IDE插件使用、也可以集成到编辑器中。他们四种均支持使用注释进行配置。</p>\n<h4 id=\"JSLint\"><a href=\"#JSLint\" class=\"headerlink\" title=\"JSLint\"></a>JSLint</h4><p>JSLint是其中最老的工具。在2002年 Douglas Crockford开发了该工具，根据其经验，强制使用js语言中精粹的部分。如果你同意这些精粹，JSLint能成为一个好的工具。</p>\n<p>JSLint的缺点是不能配置和拓展。你根本不能禁掉需要特性，并且很多缺少文档。官方文档非常不友好，例如缺少如何将其集成到编辑的信息。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>参数配置完成，可以直接使用</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>JSLint不存在配置文件，如果想改变参数设置，那就存在问题</li>\n<li>有限的配置选项，许多规则不能禁掉</li>\n<li>不能增加个性化规则</li>\n<li>没有文档记录规则</li>\n<li>很难弄清楚哪个规则引起的错误</li>\n</ul>\n<h4 id=\"JSHint\"><a href=\"#JSHint\" class=\"headerlink\" title=\"JSHint\"></a>JSHint</h4><p>作为一个可配置的JSLint版本，JSHint被开发出来。你可以配置每个规则，将其放到一个配置文件中，这样在大项目中可以容易使用。JSHint对每个规则有好的文档，所以可以准确知道每个规则的作用。将其集成到编辑器也是简单的。</p>\n<p>JSHint的一个小缺点是里面的松散默认配置。也即是你在使其可用之前必须将其启动。和ESLint相比，确定哪个规则用户开启或关闭错误信息，JSHint是更加困难。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>大多是参数可以配置</li>\n<li>支持配置文件，在大项目中容易使用</li>\n<li>已经支持需要类库，像jQuery、QUnit、NodeJS、Mocha等</li>\n<li>支持基本的ES6</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>难于知道哪个规则产生错误</li>\n<li>存在两类选项：强制选项和松散选项。使得配置有些混乱</li>\n<li>不支持自定义规则</li>\n</ul>\n<h4 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h4><p>ESLint是比较新出来的工具。它被设计的容易拓展、拥有大量的自定义规则、容易的通过插件来安装。它给出准确的输出，而且包括规则名，这样可以知道哪个规则造成了错误。</p>\n<p>ESLint文档多少有些混乱。规则容易查找，以及被分为逻辑组，但是配置指南在有些地方容易弄混。然而它可以在一个地方提供链接去编辑集成、插件和样例。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>灵活：任何规则都可以开启闭合，以及有些规则有些额外配置</li>\n<li>很容易拓展和有需要可用插件</li>\n<li>容易理解产出</li>\n<li>包含了在其他检查器中不可用的规则，使得ESLint在错误检查上更有用</li>\n<li>支持ES6，支持JSX的工具</li>\n<li>支持自定义报告</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>需要一些配置</li>\n<li>速度慢</li>\n</ul>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2pzY3MuaW5mby8=\">JSCS</span>已经合并到ESlint</p>\n</blockquote>\n<p>总结一下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>JSLint</th>\n<th>JSHint</th>\n<th>ESLint</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始配置</td>\n<td>有</td>\n<td>有</td>\n<td>可配置</td>\n</tr>\n<tr>\n<td>自定义</td>\n<td>命令行，有限</td>\n<td>可配置</td>\n<td>可配置</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ES6</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>JSX</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>执行效率</td>\n<td>高</td>\n<td>中</td>\n<td>低</td>\n</tr>\n<tr>\n<td>输出友好度</td>\n<td>低</td>\n<td>中</td>\n<td>高</td>\n</tr>\n<tr>\n<td>Stars</td>\n<td>3.3k</td>\n<td>8.2k</td>\n<td>14.2k</td>\n</tr>\n</tbody></table>\n<h2 id=\"Lint工具介绍\"><a href=\"#Lint工具介绍\" class=\"headerlink\" title=\"Lint工具介绍\"></a>Lint工具介绍</h2><p>Lint是一种工具，可以分析源代码，并在出现错误或与团队编码约定不符时通知用户。在某些情况下，它还可以自动修复错误。</p>\n<p>虽然已经为不同语言开发了许多种Lint，但是有些人可能遇到过以下问题。</p>\n<ul>\n<li><p>这是我第一次使用这种语言进行编码，什么被认为是这种语言的一般编码风格？</p>\n</li>\n<li><p>我正在使用Lint的默认设置，但错误验证过程太严格。</p>\n<p>我想更改设置，但是更改设置会更容易忽略某些错误吗？</p>\n</li>\n</ul>\n<p>即使对于单一语言，也提出了各种编码约定。因此，特别是首先，确定哪些编码约定更好地遵循可能是困难的。</p>\n<p>因此，让我们研究一下常用的开源软件上的Lint设置，看看正在使用哪种设置和编码约定。</p>\n<h3 id=\"ESLint-1\"><a href=\"#ESLint-1\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p>ESLint是JavaScript的linting实用程序。</p>\n<p>ESLint不依赖于特定的编码约定，用户也可以自由地启用或禁用各个编码约定。从这个意义上讲，它的一个主要特点是其高度可定制性。</p>\n<p>用户可以通过定义原始<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvcnVsZXMv\">规则来</span>灵活地设置编码标准，这些规则是ESLint中默认可用的编码规则。此外，第三方共享的着名编码约定，例如“Google JavaScript Style Guide”或“Airbnb JavaScript Style Guide”也可以重复使用。</p>\n<p>您甚至可以在遵循这些编码约定的同时启用&#x2F;禁用特定文件的特定规则。</p>\n<p>如果您不知道要开始的设置，可以参考ESLint官方提供的“ <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvdXNlci1ndWlkZS9nZXR0aW5nLXN0YXJ0ZWQ=\">入门</span> ”指南，以使用建议的编码约定。</p>\n<p>核心概念：</p>\n<ul>\n<li><p>配置文件：</p>\n<p><code>.eslintrc</code>，<code>.eslintrc.js</code>，<code>.eslintrc.yml</code></p>\n</li>\n<li><p>Rules：</p>\n<ul>\n<li>“off” 或 <code>0</code> - 关闭规则</li>\n<li>“warn” 或 <code>1</code> - 开启规则，使用警告级别的错误：warn (不会导致程序退出)</li>\n<li>“error” 或 <code>2</code> - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</li>\n</ul>\n<p>看一个例子：</p>\n<pre><code class=\"javascripton\">&#123;\n    &quot;rules&quot;: &#123;\n        &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;],\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]\n    &#125;\n&#125;\n</code></pre>\n<p>也可以写成：</p>\n<pre><code class=\"javascripton\">&#123;\n    &quot;rules&quot;: &#123;\n        &quot;semi&quot;: [2, &quot;never&quot;],\n        &quot;quotes&quot;: [2, &quot;single&quot;]\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>Extends：</p>\n<p>使用别人提供的包， 如google</p>\n<pre><code class=\"javascripton\">&#123; \n    &quot;extends&quot;：&quot;google&quot;，\n&#125;\n</code></pre>\n<p>通过使用上述说明，用户可以轻松使用Google JavaScript样式指南中的编码约定，而无需从头开始编写设置。</p>\n</li>\n<li><p>Plugins:</p>\n<p>ESLint提供的默认规则涵盖了基本规则，但JavaScript可以使用的范围非常广泛。因此，您可能希望规则不在默认规则中。在这种情况下，可以在ESLint中开发自己的独立规则。为了让第三方开发自己的规则，ESLint允许使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvZGV2ZWxvcGVyLWd1aWRlL3dvcmtpbmctd2l0aC1wbHVnaW5z\">插件</span>。如果你在npm中搜索eslint-plugin- *，你可以找到第三方提供的大量自定义插件。</p>\n<p>如果ESLint的默认规则未提供您要使用的规则，则建议您查找插件。</p>\n<p>与可共享配置类似，它很容易设置。例如，如果要对React代码执行静态分析，可以安装名为<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXNsaW50LXBsdWdpbi1yZWFjdA==\">eslint-plugin-react的插件</span>，并使用以下设置来执行React语法特有的静态分析。</p>\n<pre><code class=\"javascripton\">&#123; \n    &quot;extends&quot;: &quot;google&quot;，\n    &quot;plugins&quot;: [ \n        &quot;react&quot; \n    ]，\n    &quot;rules&quot;&quot;: &#123; \n        &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;],\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]\n    &#125; \n&#125;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"起步与安装\"><a href=\"#起步与安装\" class=\"headerlink\" title=\"起步与安装\"></a>起步与安装</h4><ol>\n<li><p>在项目中去使用</p>\n<pre><code class=\"javascripton\">// npm init 指令会在项目根目录下生成 package.json 文件。\nnpm init\n\n// --save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了。\nnpm install eslint --save-dev\n</code></pre>\n<ul>\n<li>使用<code>npm run</code></li>\n</ul>\n<p>新增<code>package.json</code> 脚本，或者使用 <code>npx</code>命令</p>\n<pre><code class=\"javascript\">&quot;scripts&quot;: &#123;\n    &quot;lint&quot;: &quot;eslint src&quot;,\n    &quot;lint:create&quot;: &quot;eslint --init&quot;\n&#125;\n</code></pre>\n<p>然后使用<code>run</code>命令：</p>\n<pre><code class=\"bash\">npm run lint\n</code></pre>\n<ul>\n<li>直接使用<code>npx</code>命令：</li>\n</ul>\n<pre><code class=\"bash\">npx eslint --init\n\n// 或者\n./node_modules/.bin/eslint --init\n</code></pre>\n</li>\n<li><p>在全局使用</p>\n<pre><code class=\"bash\">npm install -g eslint\n</code></pre>\n</li>\n</ol>\n<h4 id=\"ESLint初始化\"><a href=\"#ESLint初始化\" class=\"headerlink\" title=\"ESLint初始化\"></a>ESLint初始化</h4><p>配置方法使用 <code>eslint --init</code>方法</p>\n<pre><code class=\"bash\">➜ npx eslint --init\n? How would you like to use ESLint? (Use arrow keys)\n  To check syntax only \n❯ To check syntax and find problems \n  To check syntax, find problems, and enforce code style \n  \n? What type of modules does your project use? (Use arrow keys)\n❯ JavaScript modules (import/export) \n  CommonJS (require/exports) \n  None of these \n  \n// 这里可以针对你的开发项目进行配置\n? Which framework does your project use? \n  React \n  Vue.js \n❯ None of these \n\n// 可以配置代码运行的地方，是浏览器还是Node环境？\n? Where does your code run? \n❯◉ Browser\n ◉ Node\n \n// 最张在哪里缓存\n? What format do you want your config file to be in? (Use arrow keys)\n❯ JavaScript \n  YAML \n  JSON \n\n// 成功创建了配置文件\n? What format do you want your config file to be in? JavaScript\nSuccessfully created .eslintrc.js file in /Users/itheima/Downloads/Demo\n</code></pre>\n<p>配置文件<code>.eslintrc.js</code>：</p>\n<blockquote>\n<p>废弃的用法：<code>.eslintrc</code>，eslint使用配置的顺序：<code>.eslintrc.js</code> &gt; <code>.eslintrc.yaml</code> &gt; <code>.eslintrc.yml</code> &gt; <code>.eslintrc.json</code> &gt; <code>.eslintrc</code> &gt; <code>package.json</code></p>\n</blockquote>\n<p><code>.eslintrc.js</code>文件：</p>\n<pre><code class=\"javascript\">module.exports = &#123;\n    &quot;env&quot;: &#123;\n        &quot;browser&quot;: true,\n        &quot;es6&quot;: true,\n        &quot;node&quot;: true\n    &#125;,\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;globals&quot;: &#123;\n        &quot;Atomics&quot;: &quot;readonly&quot;,\n        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;\n    &#125;,\n    &quot;parserOptions&quot;: &#123;\n        &quot;ecmaVersion&quot;: 2018,\n        &quot;sourceType&quot;: &quot;module&quot;\n    &#125;,\n    &quot;rules&quot;: &#123;\n    &#125;\n&#125;;\n</code></pre>\n<p>再来看看，<code>yaml</code>文件配置：</p>\n<pre><code class=\"yaml\">env:\n  browser: true\n  es6: true\n  node: true\nextends: &#39;eslint:recommended&#39;\nglobals:\n  Atomics: readonly\n  SharedArrayBuffer: readonly\nparserOptions:\n  ecmaVersion: 2018\n  sourceType: module\nrules: &#123;&#125;\n</code></pre>\n<p>该文件导出一个对象，对象包含属性 <code>env</code>、<code>extends</code>、<code>parserOptions</code>、<code>plugins</code>、<code>rules</code> 五个属性：</p>\n<ul>\n<li><p><code>env</code>：指定脚本的运行环境。每种环境都有一组特定的预定义全局变量，（如：nodejs，browser，commonjs等）中。</p>\n</li>\n<li><p><code>parserOptions</code>：用于指定想要支持的JavaScript语言选项</p>\n<ul>\n<li><p><code>ecmaVersion</code> - 默认设置为3，5（默认）， 你可以使用 6、7、8 或 9 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）或 2018（同 9）</p>\n</li>\n<li><p><code>sourceType</code> - 设置为 <code>&quot;script&quot;</code> (默认) 或 <code>&quot;module&quot;</code>（如果你的代码是 ECMAScript 模块)。</p>\n</li>\n<li><pre><code>ecmaFeatures\n</code></pre>\n<p>- 这是个对象，表示你想使用的额外的语言特性:</p>\n<ul>\n<li><code>globalReturn</code> - 允许在全局作用域下使用 <code>return</code> 语句</li>\n<li><code>impliedStrict</code> - 启用全局 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RyaWN0X21vZGU=\">strict mode</span> (如果 <code>ecmaVersion</code> 是 5 或更高)</li>\n<li><code>jsx</code> - 启用 <span class=\"exturl\" data-url=\"aHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9qc3gv\">JSX</span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>globals</code>：执行代码时脚步需要访问的额外全局变量。</p>\n</li>\n<li><p><code>rules</code>：开启某些规则，也可以设置规则的等级。</p>\n</li>\n<li><p><code>extends</code>: 对默认规则进行扩展，可以使用<code>Airbnb</code>，或者<code>Standard</code>规则。</p>\n</li>\n</ul>\n<h4 id=\"eslintignore\"><a href=\"#eslintignore\" class=\"headerlink\" title=\".eslintignore\"></a>.eslintignore</h4><p>可以在项目根目录创建，告诉ESLint忽略某些文件或者目录。相当于.gitignore都是纯文本文件。<br>例如</p>\n<pre><code># 注释，忽略文件node_modules**/.jsbuild\n</code></pre>\n<p>常见的eslintignore内容：</p>\n<pre><code>node_modules/*\n**/node_modules/*\ndist/*\n/build/**\n/coverage/**\n/docs/**\n/jsdoc/**\n/templates/**\n/tests/bench/**\n/tests/fixtures/**\n/tests/performance/**\n/tmp/**\n/lib/rules/utils/unicode/is-combining-character.js\ntest.js\n!.eslintrc.js\n</code></pre>\n<h4 id=\"ESLint的使用方法\"><a href=\"#ESLint的使用方法\" class=\"headerlink\" title=\"ESLint的使用方法\"></a>ESLint的使用方法</h4><ul>\n<li><p>本地使用方法：</p>\n<p>如果你想让 ESLint 成为你项目构建系统的一部分，我们建议在本地安装。你可以使用 npm：</p>\n<pre><code class=\"bash\">$ npm install eslint --save-dev\n</code></pre>\n<p>紧接着你应该设置一个配置文件：</p>\n<pre><code class=\"bash\">$ ./node_modules/.bin/eslint --init\n</code></pre>\n<p>之后，你可以在你项目根目录运行 ESLint：</p>\n<pre><code class=\"bash\">$ ./node_modules/.bin/eslint yourfile.js\n</code></pre>\n<p>使用本地安装的 ESLint 时，你使用的任何插件或可分享的配置也都必须在本地安装。</p>\n</li>\n<li><p>全局使用</p>\n<p>如果你想使 ESLint 适用于你所有的项目，我们建议你全局安装 ESLint。你可以使用 npm：</p>\n<pre><code>$ npm install -g eslint\n</code></pre>\n<p>紧接着你应该设置一个配置文件：</p>\n<pre><code>$ eslint --init\n</code></pre>\n<p>之后，你可以在任何文件或目录运行 ESLint：</p>\n<pre><code>$ eslint yourfile.js\n</code></pre>\n</li>\n</ul>\n<h4 id=\"常用ESlint配置\"><a href=\"#常用ESlint配置\" class=\"headerlink\" title=\"常用ESlint配置\"></a>常用ESlint配置</h4><p>ESLint的规范：</p>\n<p>Standard: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0YW5kYXJkL2VzbGludC1jb25maWctc3RhbmRhcmQ=\">https://github.com/standard/eslint-config-standard</span></p>\n<p>具体地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N0YW5kYXJkL2VzbGludC1jb25maWctc3RhbmRhcmQvYmxvYi9tYXN0ZXIvZXNsaW50cmMuanNvbg==\">eslintrc.json</span></p>\n<p>Airbnb: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9qYXZhc2NyaXB0\">https://github.com/airbnb/javascript</span></p>\n<ol>\n<li><p>comma逗号</p>\n<pre><code class=\"javascript\">rules: &#123;\n    &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;never&quot;],\n&#125;\n</code></pre>\n<p>Bad:</p>\n<pre><code class=\"javascript\">var foo = &#123;\n    a: &#39;123&#39;,\n    b: &#39;321&#39;, // wrong error\n&#125;\n</code></pre>\n<p>Right:</p>\n<pre><code class=\"javascript\">var foo = &#123;\n    a: &#39;123&#39;,\n    b: &#39;321&#39;\n&#125;\n</code></pre>\n</li>\n<li><p>quotes引号</p>\n</li>\n<li><p>semi分号</p>\n</li>\n<li><p>空行</p>\n</li>\n<li><p>驼峰命名</p>\n</li>\n<li><p>日志输出</p>\n</li>\n<li><p>强等判断</p>\n</li>\n<li><p>冗余的变量</p>\n</li>\n<li><p>空格</p>\n<ul>\n<li>关键字后的空格</li>\n<li>函数名后的空格</li>\n<li>缩进</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"在IDE中的配置\"><a href=\"#在IDE中的配置\" class=\"headerlink\" title=\"在IDE中的配置\"></a>在IDE中的配置</h4><ul>\n<li>以下是vscode中插件配置：</li>\n</ul>\n<p><img data-src=\"/./assets/image-20190626120020180.png\" alt=\"/images/image-20190626120020180\"></p>\n<p>配置文件：</p>\n<pre><code class=\"javascripton\">  &quot;eslint.alwaysShowStatus&quot;: true,\n  &quot;eslint.autoFixOnSave&quot;: true,\n  &quot;editor.formatOnSave&quot;: true,\n  &quot;eslint.validate&quot;: [\n    &quot;javascriptreact&quot;,\n    &#123;\n      &quot;language&quot;: &quot;html&quot;,\n      &quot;autoFix&quot;: true\n    &#125;,\n    &#123;\n      &quot;language&quot;: &quot;javascript&quot;,\n      &quot;autoFix&quot;: true\n    &#125;\n  ],\n  &quot;eslint.options&quot;: &#123;\n    &quot;plugins&quot;: [&quot;html&quot;]\n  &#125;,\n</code></pre>\n<p>快速修复配置：</p>\n<p>打开 <code>&quot;editor.formatOnSave&quot;:  true</code>并且要打开<code>eslint.validate</code>如上面的配置，或者在UI界面里面设置。</p>\n<p><img data-src=\"/assets/image-20190627124410671.png\" alt=\"/images/image-20190627124410671\"></p>\n<ul>\n<li>在Webstorm中的配置：</li>\n</ul>\n<p>使用Configure Preferences</p>\n<p><img data-src=\"/assets/image-20190626120415006.png\" alt=\"/images/image-20190626120415006\"></p>\n<p>相比于vscode就智能很多。</p>\n<h4 id=\"实战vue项目配置\"><a href=\"#实战vue项目配置\" class=\"headerlink\" title=\"实战vue项目配置\"></a>实战vue项目配置</h4><p>ESlint配置文件：</p>\n<pre><code class=\"javascript\">module.exports = &#123;\n  root: true,\n  env: &#123;\n    node: true,\n  &#125;,\n  extends: [\n    &#39;plugin:vue/essential&#39;,\n    &#39;@vue/standard&#39;,\n  ],\n  rules: &#123;\n    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,\n    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,\n    semi: [&#39;error&#39;, &#39;never&#39;],\n  &#125;,\n  parserOptions: &#123;\n    parser: &#39;babel-eslint&#39;,\n  &#125;,\n&#125;\n</code></pre>\n<p>需要安装的VSCode插件：</p>\n<ul>\n<li>vue(高亮语法)</li>\n<li>vetur(格式化，代码规范)</li>\n<li>Vue peek(组件跳转)</li>\n<li>vue beautify(vue格式化)</li>\n<li>Vue VSCode Snippets 和 Vue Snippets(代码提示)</li>\n<li>Prettier(格式化 与 上面的Vetur其实是合作格式化)</li>\n</ul>\n<p>vscode配置格式化：</p>\n<pre><code class=\"javascripton\">&quot;eslint.validate&quot;: [\n  &quot;javascript&quot;,\n  &quot;javascriptreact&quot;,\n  &#123;\n    &quot;language&quot;: &quot;html&quot;,\n    &quot;autoFix&quot;: true\n  &#125;,\n  &#123;\n    &quot;language&quot;: &quot;vue&quot;,\n    &quot;autoFix&quot;: true\n  &#125;\n],\n&quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier-eslint&quot;,\n  // prettier\n&quot;prettier.trailingComma&quot;: &quot;es5&quot;,\n&quot;prettier.semi&quot;: false,\n&quot;prettier.jsxSingleQuote&quot;: true,\n&quot;prettier.singleQuote&quot;: true,\n&quot;prettier.eslintIntegration&quot;: true,\n</code></pre>\n<p>配置emmet:</p>\n<pre><code class=\"javascripton\">  &quot;emmet.syntaxProfiles&quot;: &#123;\n    &quot;vue-html&quot;: &quot;html&quot;,\n    &quot;vue&quot;: &quot;html&quot;\n  &#125;,\n</code></pre>\n<p>在Vue-cli工具中，可以使用<code>npm run lint</code>:</p>\n<pre><code class=\"bash\">// bash输出\n➜ npm run lint\n\n&gt; vue-recipe@0.1.0 lint /Users/itheima/vue-demo\n&gt; vue-cli-service lint\n\n DONE  No lint errors found!\n</code></pre>\n<p>来执行vue cli配置好了的Lint脚本：</p>\n<pre><code class=\"javascripton\">  &quot;scripts&quot;: &#123;\n    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n    &quot;build&quot;: &quot;vue-cli-service build&quot;,\n    &quot;lint&quot;: &quot;vue-cli-service lint&quot;\n  &#125;,\n</code></pre>\n<blockquote>\n<p>vscode中插件推荐使用：</p>\n<p>Vue, Vetur, Vue Peek, vue-beautify</p>\n</blockquote>\n<h4 id=\"实战react项目配置\"><a href=\"#实战react项目配置\" class=\"headerlink\" title=\"实战react项目配置\"></a>实战react项目配置</h4><p>使用<code>create-react-app</code>创建react项目：</p>\n<pre><code class=\"bash\">npx create-react-app my-app\n\ncd my-app\n\nnpm start\n</code></pre>\n<blockquote>\n<p>如果<code>npx</code>命令没有，请全局安装<code>create-react-app</code>，使用<code>npm install -g create-react-app</code></p>\n</blockquote>\n<p>然后是安装eslint相关依赖：</p>\n<pre><code class=\"javascripton\">&quot;devDependencies&quot;: &#123;\n  &quot;eslint&quot;: &quot;^5.16.0&quot;,\n  &quot;babel-eslint&quot;: &quot;^10.0.2&quot;,\n  &quot;eslint-plugin-html&quot;: &quot;^6.0.0&quot;,\n  &quot;eslint-plugin-react&quot;: &quot;^7.14.2&quot;\n&#125;\n</code></pre>\n<p>配置eslint，或者使用<code>eslint --init</code>进行初始化：</p>\n<pre><code class=\"javascript\">module.exports = &#123;\n    &quot;env&quot;: &#123;\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;node&quot;: true,\n        &quot;es6&quot;: true\n    &#125;,\n    &quot;extends&quot;: [\n        &quot;eslint:recommended&quot;,\n        &quot;plugin:react/recommended&quot;\n    ],\n    &quot;globals&quot;: &#123;\n        &quot;Atomics&quot;: &quot;readonly&quot;,\n        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;\n    &#125;,\n    &quot;parserOptions&quot;: &#123;\n        &quot;ecmaFeatures&quot;: &#123;\n            &quot;jsx&quot;: true,\n            &quot;arrowFunctions&quot;: true,\n            &quot;classes&quot;: true,\n            &quot;modules&quot;: true,\n            &quot;defaultParams&quot;: true\n        &#125;,\n        &quot;ecmaVersion&quot;: 2018,\n        &quot;sourceType&quot;: &quot;module&quot;\n    &#125;,\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;rules&quot;: &#123;\n    &#125;,\n    &quot;settings&quot;: &#123;\n        &quot;react&quot;: &#123;\n            &quot;pragma&quot;: &quot;React&quot;,\n            &quot;version&quot;: &quot;latest&quot;,\n        &#125;,\n    &#125;,\n&#125;;\n</code></pre>\n<p>几点配置需要注意：</p>\n<ul>\n<li>安装插件：<code>eslint-plugin-react</code></li>\n<li>配置<code>extends</code>: <code>&quot;plugin:react/recommended&quot;</code></li>\n<li>配置<code>settings</code></li>\n</ul>\n<p>配置Airbnb：</p>\n<pre><code class=\"bash\">npm --save-dev install eslint-config-airbnb eslint-plugin-import eslint-plugin-jsx-a11y babel-eslint\n</code></pre>\n<p>有三个依赖：</p>\n<ul>\n<li>eslint-config-airbnb</li>\n<li>eslint-plugin-import</li>\n<li>eslint-plugin-jsx-a11y</li>\n<li>Babel-eslint</li>\n</ul>\n<p>修改项目配置：</p>\n<pre><code class=\"javascript\">module.exports = &#123;\n    &quot;env&quot;: &#123;\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;node&quot;: true,\n        &quot;es6&quot;: true\n    &#125;,\n    // 这里有变化 \n    &quot;extends&quot;: [\n        &quot;eslint:recommended&quot;,\n        &quot;plugin:react/recommended&quot;,\n        &quot;plugin:import/errors&quot;,\n        &quot;plugin:jsx-a11y/recommended&quot;,\n        &quot;airbnb&quot;\n    ],\n    &quot;globals&quot;: &#123;\n        &quot;Atomics&quot;: &quot;readonly&quot;,\n        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;\n    &#125;,\n    &quot;parser&quot;: &quot;babel-eslint&quot;,\n    &quot;parserOptions&quot;: &#123;\n        &quot;ecmaFeatures&quot;: &#123;\n            &quot;jsx&quot;: true,\n            &quot;arrowFunctions&quot;: true,\n            &quot;classes&quot;: true,\n            &quot;modules&quot;: true,\n            &quot;defaultParams&quot;: true\n        &#125;,\n        &quot;ecmaVersion&quot;: 2018,\n        &quot;sourceType&quot;: &quot;module&quot;\n    &#125;,\n    // 这里有变化 \n    &quot;plugins&quot;: [\n        &quot;react&quot;,\n        &quot;jsx-a11y&quot;,\n        &quot;import&quot;\n    ],\n    &quot;rules&quot;: &#123;\n      // 这里可以添加jsx-ally与import相关的自定义rules\n    &#125;,\n    &quot;settings&quot;: &#123;\n        &quot;react&quot;: &#123;\n            &quot;pragma&quot;: &quot;React&quot;,\n            &quot;version&quot;: &quot;latest&quot;,\n        &#125;,\n    &#125;,\n&#125;;\n</code></pre>\n<h3 id=\"StyleLint\"><a href=\"#StyleLint\" class=\"headerlink\" title=\"StyleLint\"></a>StyleLint</h3><p>官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsZWxpbnQuaW8v\">https://stylelint.io/</span></p>\n<ul>\n<li><p>安装依赖：</p>\n<pre><code class=\"bash\">npm install -D stylelint-config-recommended stylelint-config-standard\n\n// yarn \nyarn add stylelint-config-recommended stylelint-config-standard -D\n</code></pre>\n</li>\n<li><p>配置忽略</p>\n<pre><code>// .stylelintignore   忽略stylelint检查的文件\n/src/**/*.css\n</code></pre>\n</li>\n<li><p><code>.stylelintrc.js</code>文件配置</p>\n<pre><code class=\"javascripton\">module.exports = &#123;\n  &quot;extends&quot;: [&quot;stylelint-config-recommended&quot;, &quot;stylelint-config-standard&quot;],\n  &quot;rules&quot;: &#123;\n    &quot;indentation&quot;: 2\n  &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>vscode配置</p>\n<p>安装<code>Prettier</code> + <code>stylelint</code>插件，方便格式化代码。</p>\n<p><img data-src=\"/assets/image-20190628004127626.png\" alt=\"/images/image-20190628004127626\"></p>\n<p>配置文件：</p>\n<pre><code>  &quot;[scss]&quot;: &#123;\n    &quot;editor.formatOnSave&quot;: true\n  &#125;,\n  // 打开scss的validate配置\n  &quot;scss.validate&quot;: true,\n</code></pre>\n</li>\n</ul>\n<h3 id=\"HTMLHint\"><a href=\"#HTMLHint\" class=\"headerlink\" title=\"HTMLHint\"></a>HTMLHint</h3><p>官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odG1saGludC5pby8=\">https://htmlhint.io</span></p>\n<p>github: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2h0bWxoaW50L0hUTUxIaW50\">https://github.com/htmlhint/HTMLHint</span></p>\n<ul>\n<li><p>安装依赖：</p>\n<pre><code class=\"bash\">npm install htmlhint --save-dev\n\n// yarn \nyarn add htmlhint -D\n</code></pre>\n</li>\n<li><p>配置忽略</p>\n<pre><code>// .stylelintignore   忽略stylelint检查的文件\n/src/**/*.css\n</code></pre>\n</li>\n<li><p><code>.htmlhintrc</code>文件配置</p>\n<pre><code class=\"javascripton\">/**\n标签名必须小写\n属性名必须小写\n属性值必须放在双引号中\n属性值一定不可为空\n属性值一定不可重复\nDoctype必须是 HTML 文档的第一行\n标签必须成对\n标签必须自封闭\n特殊字符必须\nID 属性必须唯一\nsrc 属性一定不可为空\ntitle 属性必须出现在标签中\nimg 标签必须包含 alt 属性\nDoctype 必须是 HTML5\nID 和 Class 的命名规则必须统一\n不该使用样式标签\n不该使用行内样式\n不该使用行内脚本\n空格和制表符一定不可混合在行前\nID 和 Class 一定不可使用广告关键词\nhref 必须是绝对路径或者相对路径\n属性值一定不可使用不安全字符\nscript 标签不该使用在头部\n*/\n&#123;\n  &quot;tagname-lowercase&quot;: true, \n  &quot;attr-lowercase&quot;: true,\n  &quot;attr-value-double-quotes&quot;: true,\n  &quot;attr-value-not-empty&quot;: false,\n  &quot;attr-no-duplication&quot;: true,\n  &quot;doctype-first&quot;: true,\n  &quot;tag-pair&quot;: true,\n  &quot;empty-tag-not-self-closed&quot;: true,\n  &quot;spec-char-escape&quot;: true,\n  &quot;id-unique&quot;: true,\n  &quot;src-not-empty&quot;: true,\n  &quot;title-require&quot;: true,\n  &quot;alt-require&quot;: true,\n  &quot;doctype-html5&quot;: true,\n  &quot;id-class-value&quot;: &quot;dash&quot;,\n  &quot;style-disabled&quot;: false,\n  &quot;inline-style-disabled&quot;: false,\n  &quot;inline-script-disabled&quot;: false,\n  &quot;space-tab-mixed-disabled&quot;: &quot;space&quot;,\n  &quot;id-class-ad-disabled&quot;: false,\n  &quot;href-abs-or-rel&quot;: false,\n  &quot;attr-unsafe-chars&quot;: true,\n  &quot;head-script-disabled&quot;: true\n&#125;\n</code></pre>\n</li>\n<li><p>vscode配置</p>\n<p>安装<code>Prettier</code>，<code>HTMLHint</code>插件，方便格式化代码。</p>\n<p><img data-src=\"/./assets/image-20190628003752568.png\" alt=\"/images/image-20190628003752568\"></p>\n<p>用户配置文件：</p>\n<pre><code>  &quot;[html]&quot;: &#123;\n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n  &#125;,\n  // 打开scss的validate配置\n  &quot;files.associations&quot;: &#123;\n      &quot;*.ext&quot;: &quot;html&quot;\n  &#125;,\n</code></pre>\n</li>\n</ul>\n<h2 id=\"e2e-test\"><a href=\"#e2e-test\" class=\"headerlink\" title=\"e2e test\"></a>e2e test</h2><p>通常对Web应用程序执行两种类型的测试：<strong>单元测试</strong>和<strong>端到端</strong>（E2E）测试。</p>\n<p><strong>单元测试</strong></p>\n<p>在测试中使用“单元”的想法是将代码分解为易于测试的小部件。通常，单元是单个函数，但也可以是类或甚至是复杂的算法。</p>\n<p>单元测试的一个关键概念是函数的给定输入应始终产生相同的输出。</p>\n<p>例如，如果我们有一个函数添加了两个调用的数字，<code>add</code>我们可以编写一个单元测试来确保我们作为参数提供的特定数字对总是返回我们期望的输出。</p>\n<p><code>add.spec.js</code></p>\n<pre><code class=\"javascript\">// Function we want to test\nconst add = (x, y) =&gt; x + y;\n\n// Unit test\ntest(&quot;should add two numbers&quot;, () =&gt; &#123;\n  const result = add(2, 3);\n  expect(result).toBe(5);\n&#125;);\n</code></pre>\n<p>任何时候我们运行该测试并且它不等于5，我们可以得出一个错误已经输入我们的代码。</p>\n<p><strong>组件测试</strong></p>\n<p>在大多数Vue.js应用程序中，函数并不真正代表应用程序的原子组成。当然，我们可以对我们的方法进行单元测试，但我们真正关心的是生成的HTML。</p>\n<p>因此，Vue.js app测试中的单元是一个<em>组件</em>而不是一个函数。</p>\n<p>我们如何测试组件？我们以此为例：</p>\n<p><code>displayGreeting.js</code></p>\n<pre><code class=\"javascript\">export default &#123;\n  template: `&lt;div&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/div&gt;`,\n  props: [&#39;name&#39;]\n&#125;;\n</code></pre>\n<p>如前所述，对于给定输入（在这种情况下，支柱），单元测试必须返回一致的输出（在这种情况下，文本内容）。</p>\n<p>使用像Vue Test Utils这样的库，我们可以在内存中安装Vue组件并创建一个“包装器”对象。然后，我们可以查询包装器以对呈现的HTML进行断言。</p>\n<p><code>displayGreeting.spec.js</code></p>\n<pre><code class=\"javascript\">import displayGreeting from &quot;./displayGreeting.js&quot;;\n\ntest(&quot;displays message&quot;, () =&gt; &#123;\n  const name = &quot;Michael&quot;;\n  const wrapper = mount(displayGreeting, &#123; propsData: &#123; name &#125; &#125;);\n  expect(wrapper.text()).toBe(`Hello, $&#123;name&#125;`);\n&#125;);\n</code></pre>\n<p>单元测试优点：</p>\n<ul>\n<li>测试运行得很快</li>\n<li>测试是精确的，允许您识别确切的问题</li>\n</ul>\n<p>单元测试缺点：</p>\n<ul>\n<li>为应用程序的每个方面编写测试都非常耗时</li>\n<li>尽管单元测试通过，整个应用程序可能仍然无法正常工作</li>\n</ul>\n<h3 id=\"什么是e2e-test\"><a href=\"#什么是e2e-test\" class=\"headerlink\" title=\"什么是e2e test?\"></a>什么是e2e test?</h3><p>e2e test（End to End test端到端）测试是一种功能测试。与单元测试不同，不会将应用程序分解为更小的部分以进行测试 - 而是测试整个应用程序。</p>\n<p>e2e测试与您的应用程序交互，就像真实用户一样。例如，您可以编写一个E2E测试：</p>\n<ol>\n<li>加载您的网站</li>\n<li>点击“注册”链接</li>\n<li>为注册表单中的输入提供一些有效的详细信息</li>\n<li>单击“注册按钮”。</li>\n</ol>\n<p>如果身份验证令牌已存储在Cookie中并且应用程序重定向到配置文件页面，则应通过此测试。</p>\n<p>E2E测试优点</p>\n<ul>\n<li>可以一次隐式测试很多东西</li>\n<li>e2e测试可确保您拥有一个工作系统</li>\n</ul>\n<p>e2e测试缺点：</p>\n<ul>\n<li>运行缓慢 - 通常需要5或10分钟才能运行一个站点</li>\n<li>测试很脆弱 - 一个无关紧要的变化，如改变组件逻辑，就需要重新设计e2e test了</li>\n<li>测试无法查明失败的原因</li>\n</ul>\n<p>所以，主要的业务流程可能会写E2E，不过规模要小很多，主要目的是：</p>\n<ul>\n<li>便于给PM展示业务流程</li>\n<li>便于修改Bug之后的回归</li>\n</ul>\n<h3 id=\"e2e-test工具介绍\"><a href=\"#e2e-test工具介绍\" class=\"headerlink\" title=\"e2e test工具介绍\"></a>e2e test工具介绍</h3><h4 id=\"Cypress\"><a href=\"#Cypress\" class=\"headerlink\" title=\"Cypress\"></a>Cypress</h4><ol>\n<li><p>安装 &amp; 桌面应用</p>\n<pre><code class=\"bash\">npm install cypress --save-dev\n</code></pre>\n<p>或者直接下载桌面应用：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5jeXByZXNzLmlvL2Rlc2t0b3A=\">https://download.cypress.io/desktop</span></p>\n</li>\n<li><p>使用方式：</p>\n<pre><code>./node_modules/.bin/cypress open\n\n// npx\nnpx cypress open\n\n// yarn \nyarn run cypress open\n</code></pre>\n<p>或者添加 <code>package.json</code>:</p>\n<pre><code class=\"javascripton\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;cypress:open&quot;: &quot;cypress open&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>使用npm命令：<code>npm run cypress:open</code></p>\n</li>\n</ol>\n<h4 id=\"Nightwatch\"><a href=\"#Nightwatch\" class=\"headerlink\" title=\"Nightwatch\"></a>Nightwatch</h4><h4 id=\"TeatCafe\"><a href=\"#TeatCafe\" class=\"headerlink\" title=\"TeatCafe\"></a>TeatCafe</h4><h3 id=\"e2e-test案例\"><a href=\"#e2e-test案例\" class=\"headerlink\" title=\"e2e test案例\"></a>e2e test案例</h3><h2 id=\"Codecov\"><a href=\"#Codecov\" class=\"headerlink\" title=\"Codecov\"></a>Codecov</h2><h3 id=\"Codecov简介\"><a href=\"#Codecov简介\" class=\"headerlink\" title=\"Codecov简介\"></a>Codecov简介</h3><h3 id=\"Codecov使用\"><a href=\"#Codecov使用\" class=\"headerlink\" title=\"Codecov使用\"></a>Codecov使用</h3><h3 id=\"前端项目中的应用\"><a href=\"#前端项目中的应用\" class=\"headerlink\" title=\"前端项目中的应用\"></a>前端项目中的应用</h3><h2 id=\"补充学习\"><a href=\"#补充学习\" class=\"headerlink\" title=\"补充学习\"></a>补充学习</h2><h3 id=\"补充资料\"><a href=\"#补充资料\" class=\"headerlink\" title=\"补充资料\"></a>补充资料</h3><h4 id=\"代码质量管控的四个阶段\"><a href=\"#代码质量管控的四个阶段\" class=\"headerlink\" title=\"代码质量管控的四个阶段\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yOTA4Njk1OQ==\">代码质量管控的四个阶段</span></h4><p><img data-src=\"/assets/v2-2f1a8ca0a919afd7e77859393c9e96f6_hd.png\" alt=\"img\"></p>\n<p>我把代码质量管控通常需要经历的四个阶段，称之为“四个现代化”：</p>\n<ul>\n<li>规范化 - 建立代码规范与Code Review制度</li>\n<li>自动化 - 使用工具自动检查代码质量</li>\n<li>流程化 - 将代码质量检查与代码流动过程绑定</li>\n<li>中心化 - 以团队整体为视角，集中管理代码规范，并实现质量状况透明化</li>\n</ul>\n<h4 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h4><p><strong>第一部分：软件测试的分类</strong></p>\n<ul>\n<li><p>按测试执行阶段划分</p>\n<p>单元测试、集成测试、系统测试、验收测试（正式验收测试、Alpha测试、Beta测试）</p>\n</li>\n<li><p>按测试技术划分</p>\n<p>白盒测试、黑盒测试、灰盒测试</p>\n</li>\n<li><p>被测试对象是否运行划分</p>\n<p>动态测试、静态测试（文档检查、代码走查、界面检查）</p>\n</li>\n<li><p>按不同的测试手段划分</p>\n<p>手工测试、自动化测试*</p>\n</li>\n<li><p>按测试包含的内容划分</p>\n<p>功能测试、界面测试、安全测试、兼容性测试、易用性测试、性能测试、压力测试、负载测试、恢复测试</p>\n</li>\n<li><p>其他测试</p>\n<p>冒烟测试、回归测试、探索性测试&#x2F;自由测试（测试思维）</p>\n</li>\n</ul>\n<p><strong>第二部分：接下来对软件测试分类进行一个说明</strong></p>\n<p><img data-src=\"/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"><img data-src=\"/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"></p>\n<p><img data-src=\"/assets/v2-f831b8041976b50aad7c2425aada44e2_hd-1561454378198.jpg\" alt=\"img\"><img data-src=\"/assets/v2-f831b8041976b50aad7c2425aada44e2_hd.jpg\" alt=\"img\"></p>\n<p><strong>第三部分：测试工具</strong></p>\n<p>SVN，Git——&gt;版本控制管理工具</p>\n<p>禅道——&gt;Bug管理工具</p>\n<p>Fiddler——&gt;抓包，定位问题你</p>\n<p>postman，jmeter，soapui——&gt;接口测试</p>\n<p>Loadrunner，Jmeter——&gt;性能，压力测试</p>\n<h4 id=\"What-is-“Linting”\"><a href=\"#What-is-“Linting”\" class=\"headerlink\" title=\"What is “Linting”?\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwMzU1OS93aGF0LWlzLWxpbnRpbmc=\">What is “Linting”?</span></h4><h4 id=\"React中的配置资料\"><a href=\"#React中的配置资料\" class=\"headerlink\" title=\"React中的配置资料\"></a>React中的配置资料</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL0BzZ3JvZmYwNC9jb25maWd1cmUtZXNsaW50LXByZXR0aWVyLWFuZC1mbG93LWluLXZzLWNvZGUtZm9yLXJlYWN0LWRldmVsb3BtZW50LWM5ZDk1ZGIwNzIxMw==\">Configure ESLint, Prettier, and Flow in VS Code for React Development</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnNpZGVjaS5jb20vaG93LXRoZS1yZWFjdC1kZXZlbG9wZXItdGVhbS11c2VzLWVzbGludC0yODI4NTY0ODE0ZGE=\">React开发团队如何使用ESLint</span></p>\n<h3 id=\"完整的ESLint文件配置属性的解释\"><a href=\"#完整的ESLint文件配置属性的解释\" class=\"headerlink\" title=\"完整的ESLint文件配置属性的解释\"></a>完整的ESLint文件配置属性的解释</h3><pre><code class=\"javascripton\">/*\n * ESLint的JSON文件是允许JavaScript注释的，但在gist里显示效果不好，所以我把.json文件后缀改为了.js\n */\n\n/*\n * ESLint 配置文件优先级：\n * .eslintrc.js(输出一个配置对象)\n * .eslintrc.yaml\n * .eslintrc.yml\n * .eslintrc.json（ESLint的JSON文件允许JavaScript风格的注释）\n * .eslintrc（可以是JSON也可以是YAML）\n *  package.json（在package.json里创建一个eslintConfig属性，在那里定义你的配置）\n */\n\n/*\n * 你可以通过在项目根目录创建一个.eslintignore文件告诉ESLint去忽略特定的文件和目录\n * .eslintignore文件是一个纯文本文件，其中的每一行都是一个glob模式表明哪些路径应该忽略检测\n */\n\n&#123;\n  //ESLint默认使用Espree作为其解析器\n  //同时babel-eslint也是用得最多的解析器\n  &quot;parser&quot;: &quot;espree&quot;,\n\n  //parser解析代码时的参数\n  &quot;parserOption&quot;: &#123;\n    //指定要使用的ECMAScript版本，默认值5\n    &quot;ecmaVersion&quot;: 5,\n    //设置为script(默认)或module（如果你的代码是ECMAScript模块)\n    &quot;sourceType&quot;: &quot;script&quot;,\n    //这是个对象，表示你想使用的额外的语言特性,所有选项默认都是false\n    &quot;ecmafeatures&quot;: &#123;\n      //允许在全局作用域下使用return语句\n      &quot;globalReturn&quot;: false,\n      //启用全局strict模式（严格模式）\n      &quot;impliedStrict&quot;: false,\n      //启用JSX\n      &quot;jsx&quot;: false,\n      //启用对实验性的objectRest/spreadProperties的支持\n      &quot;experimentalObjectRestSpread&quot;: false\n    &#125;\n  &#125;,\n\n  //指定环境，每个环境都有自己预定义的全局变量，可以同时指定多个环境，不矛盾\n  &quot;env&quot;: &#123;\n    //效果同配置项ecmaVersion一样\n    &quot;es6&quot;: true,\n    &quot;browser&quot;: true,\n    &quot;node&quot;: true,\n    &quot;commonjs&quot;: false,\n    &quot;mocha&quot;: true,\n    &quot;jquery&quot;: true,\n     //如果你想使用来自某个插件的环境时，确保在plugins数组里指定插件名\n     //格式为：插件名/环境名称（插件名不带前缀）\n    &quot;react/node&quot;: true\n  &#125;,\n\n  //指定环境为我们提供了预置的全局变量\n  //对于那些我们自定义的全局变量，可以用globals指定\n  //设置每个变量等于true允许变量被重写，或false不允许被重写\n  &quot;globals&quot;: &#123;\n    &quot;globalVar1&quot;: true,\n    &quot;globalVar2&quot;: false\n  &#125;,\n\n  //ESLint支持使用第三方插件\n  //在使用插件之前，你必须使用npm安装它\n  //全局安装的ESLint只能使用全局安装的插件\n  //本地安装的ESLint不仅可以使用本地安装的插件还可以使用全局安装的插件\n  //plugin与extend的区别：extend提供的是eslint现有规则的一系列预设\n  //而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候\n  //就可以借用插件来实现了\n  &quot;plugins&quot;: [\n    &quot;eslint-plugin-airbnb&quot;,\n    //插件名称可以省略eslint-plugin-前缀\n    &quot;react&quot;\n  ],\n\n  //具体规则配置\n  //off或0--关闭规则\n  //warn或1--开启规则，警告级别(不会导致程序退出)\n  //error或2--开启规则，错误级别(当被触发的时候，程序会退出)\n  &quot;rules&quot;: &#123;\n    &quot;eqeqeq&quot;: &quot;warn&quot;,\n    //你也可以使用对应的数字定义规则严重程度\n    &quot;curly&quot;: 2,\n    //如果某条规则有额外的选项，你可以使用数组字面量指定它们\n    //选项可以是字符串，也可以是对象\n    &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],\n    &quot;one-var&quot;: [&quot;error&quot;, &#123;\n      &quot;var&quot;: &quot;always&quot;,\n      &quot;let&quot;: &quot;never&quot;,\n      &quot;const&quot;: &quot;never&quot;\n    &#125;],\n    //配置插件提供的自定义规则的时候，格式为：不带前缀插件名/规则ID\n    &quot;react/curly&quot;: &quot;error&quot;\n  &#125;,\n\n  //ESLint支持在配置文件添加共享设置\n  //你可以添加settings对象到配置文件，它将提供给每一个将被执行的规则\n  //如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置\n  &quot;settings&quot;: &#123;\n    &quot;sharedData&quot;: &quot;Hello&quot;\n  &#125;,\n\n  //Eslint检测配置文件步骤：\n  //1.在要检测的文件同一目录里寻找.eslintrc.*和package.json\n  //2.紧接着在父级目录里寻找，一直到文件系统的根目录\n  //3.如果在前两步发现有root：true的配置，停止在父级目录中寻找.eslintrc\n  //4.如果以上步骤都没有找到，则回退到用户主目录~/.eslintrc中自定义的默认配置\n  &quot;root&quot;: true,\n\n  //extends属性值可以是一个字符串或字符串数组\n  //数组中每个配置项继承它前面的配置\n  //可选的配置项如下\n  //1.字符串eslint：recommended，该配置项启用一系列核心规则，这些规则报告一些常见问题，即在(规则页面)中打勾的规则\n  //2.一个可以输出配置对象的可共享配置包，如eslint-config-standard\n    //可共享配置包是一个导出配置对象的简单的npm包，包名称以eslint-config-开头，使用前要安装\n    //extends属性值可以省略包名的前缀eslint-config-\n  //3.一个输出配置规则的插件包，如eslint-plugin-react\n    //一些插件也可以输出一个或多个命名的配置\n    //extends属性值为，plugin：包名/配置名称\n  //4.一个指向配置文件的相对路径或绝对路径\n  //5.字符串eslint：all，启用当前安装的ESLint中所有的核心规则\n    //该配置不推荐在产品中使用，因为它随着ESLint版本进行更改。使用的话，请自己承担风险\n  &quot;extends&quot;: [\n    &quot;eslint:recommended&quot;,\n    &quot;standard&quot;,\n    &quot;plugin:react/recommended&quot;,\n    &quot;./node_modules/coding-standard/.eslintrc-es6&quot;,\n    &quot;eslint:all&quot;\n  ]\n&#125;\n</code></pre>\n","categories":["项目质量检测"],"tags":["质量检测"]},{"title":"自动化测试","url":"/2024/03/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","content":"<h1 id=\"5-3-自动化测试\"><a href=\"#5-3-自动化测试\" class=\"headerlink\" title=\"5-3 自动化测试\"></a>5-3 自动化测试</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>在前端界，浏览器兼容性是让工程师们头疼的问题，对于经验丰富的人来说，很清楚浏览器有哪些坑，但是对于大部分程序员，最可怕的是代码明明在这个浏览器运行得很好，但是到了另一个浏览器中就不能正常运行了。对于这部分的程序员，保障代码能正常运行的方法便是能尽早发现问题，然后将其解决。</p>\n<p><strong>前端项目如何做测试？</strong></p>\n<ul>\n<li>测试同学：功能测试，性能测试，测试用例</li>\n<li>前端同学：单元测试，常用于组件库、AP等(Jest、Mocha),上线项目如何做测试？</li>\n</ul>\n<p><strong>上线项目如何进行测试</strong></p>\n<ul>\n<li>利用前端监控，进行监控项目稳定性和性能，并上报前端日志</li>\n<li>稳定性：如ljserror、白屏检测等</li>\n<li>性能：如秒开率、首屏渲染时长、接请求时长等</li>\n<li>前端日志：如console.log、API请求记录等</li>\n</ul>\n<p><strong>为什么需要自动化测试？</strong></p>\n<p>项目经过不断的开发，最终肯定会趋于稳定，在<strong>适当的时机下</strong>引入自动化测试能及早发现问题，<strong>保证产品的质量</strong>。</p>\n<p>测试作为完整的开发流程中最后的一环，是保证产品质量重要的一环。而前端测试一般在产品开发流程中属于偏后的环节，在整个开发架构中属于较高层次，前端测试更加偏向于GUI的特性，因此前端的测试难度很大。</p>\n<p>测试的目的：</p>\n<ul>\n<li>有利于写出高质量的代码，尽早发现问题</li>\n<li>有利于代码的扩展</li>\n<li>有利于代码的维护</li>\n</ul>\n<p><strong>本课程的学习路径：</strong></p>\n<ul>\n<li>学习基础的概念，清晰测试不同的应用场景</li>\n<li>学习不同的前端测试工具，了解如何进行选择</li>\n<li>在项目中进行实践</li>\n</ul>\n<p><strong>本课程的主要内容：</strong></p>\n<ul>\n<li>介绍测试框架的分类</li>\n<li>单元测试工具介绍：Mocha，Jest，AVA，Karma</li>\n<li>E2E测试工具介绍：Nightmare</li>\n</ul>\n<p><strong>本课程的学习准备：</strong></p>\n<ul>\n<li>IDE vscode，node  LTS</li>\n<li>包管理工具：yarn, cnpm</li>\n</ul>\n<h2 id=\"前端自动化测试\"><a href=\"#前端自动化测试\" class=\"headerlink\" title=\"前端自动化测试\"></a>前端自动化测试</h2><p>测试是一个庞大的主题，包括各种分类的测试，诸如黑盒测试&#x2F;白盒测试、单元测试&#x2F;集成测试&#x2F;端到端测试等。通常程序员在测试自己的代码的时候用得最多的便是单元测试，但是因为测试也是需要代价，很多人是不喜欢写测试的，甚至是一点都不写。</p>\n<p>那么是什么原因让大家不愿意写呢？</p>\n<ol>\n<li>不熟悉</li>\n<li>浪费时间</li>\n<li>知识不成体系</li>\n<li>团队氛围</li>\n<li>缺少实践</li>\n</ol>\n<p>我们要从基础的东西学起，打消对测试的恐惧。</p>\n<h3 id=\"测试的分类\"><a href=\"#测试的分类\" class=\"headerlink\" title=\"测试的分类\"></a>测试的分类</h3><p>在多浏览器的自动化测试，我们多半是进行端到端的测试工作，一小部分是大粒度的单元测试。端到端测试测试模拟用户的行为。在 Web 应用程序中，他们会启动服务器，打开浏览器，模拟用户的行为进行点击、输入、提交等动作，断言浏览器中发生了特定的事情或者是得到了期待的结果，从而让我们相信功能可以正常的运行。</p>\n<p>而单元测试根据代码单元的公共 API 运行它们。这些测试需要创建一个类的实例，使用特定的输入调用它的方法，断言被调用的方法达到了预期的效果。在下文中我们会看到这两种测试的实践，当然有时候区分度并不大，可能无法明显地区分哪些是端对端测试哪些是单元测试，有时候他们是混合起来的，不过只要记住我们的目标是保证功能可以正常运行救足够了。</p>\n<p>按照软件工程自底而上的概念，前端测试一般分为单元测试（Unit Testing ）、集成测试（Integration Testing）和端到端测试（E2E Testing）。从下面的图可以看出，从底向上测试的复杂度将不断提高，另一方面测试的收益反而不断降低的。</p>\n<p><img data-src=\"/assets/16415de723a8d411.png\" alt=\"img\"></p>\n<blockquote>\n<p>关于软件测试分类，可见<a href=\"#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB\">软件测试的分类</a></p>\n</blockquote>\n<h3 id=\"测试工具对比\"><a href=\"#测试工具对比\" class=\"headerlink\" title=\"测试工具对比\"></a>测试工具对比</h3><p>在进行项目实践前，很重要的一项工作是选择合适的技术栈。好比在前端开发时应该选择 React，Vue 还是 Angular 作为框架一样，前端的测试工作也需要选择一套技术栈。很多时候大家在制定技术栈时容易走偏，在选择技术框架时不是选择最合适的框架，而是选择最热门的框架。当然一定程度上热门的框架能反应其受欢迎程度，可能是因为其出众的优点，如较高的开发效率、高效的渲染特性或者是活跃的社区。在前端开发中，很容易有这样的感受，就是只要半个月没有关注业界的最新动态，就感觉恍若隔世，新的解决方案层出不穷，让人喘不过气。</p>\n<p>经过几年的前端洗礼之后，就已经过了慌乱的年纪，再也不会盲目地追寻新技术，而转向关注技术背后解决的痛点，原理等。</p>\n<p><img data-src=\"/assets/v2-af09ebe8167f63a49ea49287fe04526f_hd-20190706122102737.jpg\" alt=\"img\"></p>\n<h4 id=\"如何选择测试框架\"><a href=\"#如何选择测试框架\" class=\"headerlink\" title=\"如何选择测试框架\"></a>如何选择测试框架</h4><p>测试框架基本上都做了一件事儿：</p>\n<ul>\n<li>描述你要测试的东西</li>\n<li>对其进行测试</li>\n<li>判断是否符合预期</li>\n</ul>\n<p>选择框架会考虑下面的点：</p>\n<ul>\n<li><p>测试框架是否有简明的语法与文档。</p>\n<p>Mocha、Jasmine、Jest、AVA、Karma、Nightmare</p>\n</li>\n<li><p>断言(Assertions)：用于判断结果是否符合预期。有些框架需要单独的断言库。</p>\n<p>Should.js、chai、expect.js等等，断言库提供了很多语义化的方法来对值做各种各样的判断。当然也可以不用断言库，Node.js中也可以直接使用原生assert库。</p>\n</li>\n<li><p>适合 TDD &#x2F; BDD：是否适合 测试驱动型 &#x2F; 行为驱动型 的测试风格。</p>\n<blockquote>\n<p>BDD(Bebavior Driven Developement，行为驱动测试)和TDD(Testing Driven Developement，测试驱动开发)</p>\n</blockquote>\n<p>BDD和TDD均有各自的适用场景，BDD一般更偏向于系统功能和业务逻辑的自动化测试设计，而TDD在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的。下面我们看下BDD和TDD具体的特点：</p>\n<p>BDD的特点：</p>\n<ul>\n<li>从业务逻辑的角度定义具体的输入与预期输出，以及可衡量的目标；</li>\n<li>尽可能覆盖所有的测试用例情况；</li>\n<li>描述一系列可执行的行为，根据业务的分析来定义预期输出。例如，expect, should, assert；</li>\n<li>设定关键的测试通过节点输出提示，便于测试人员理解；</li>\n<li>最大程度的交付出符合用户期望的产品，避免输出不一致带来的问题。</li>\n</ul>\n<p>TDD的特点：</p>\n<ul>\n<li>需求分析，快速编写对应的输入输出测试脚本；</li>\n<li><strong>仅在自动测试失败时才编写新代码</strong>。</li>\n<li>重构去除不必要的依赖关系，然后重复测试，最终让程序符合所有要求。</li>\n</ul>\n</li>\n<li><p>异步测试：有些框架对异步测试支持良好。</p>\n</li>\n<li><p>使用的语言：大部分 js 测试框架使用 js。</p>\n</li>\n<li><p>用于特定目的：每个框架可能会擅长处理不同的问题。</p>\n<p>是要测试单个功能、单个组件、还是集成化测试？</p>\n<p>是要测试GUI逻辑、交互？</p>\n<p>是要测试非功能性指标？兼容性？</p>\n</li>\n<li><p>社区是否活跃。</p>\n</li>\n</ul>\n<h4 id=\"测试工具的类型\"><a href=\"#测试工具的类型\" class=\"headerlink\" title=\"测试工具的类型\"></a>测试工具的类型</h4><p>测试工具可分为以下功能。有些只为我们提供了一种功能，有些功能为我们提供了一种组合。</p>\n<p>为了实现最灵活的集合功能，通常使用多种工具的组合。</p>\n<ul>\n<li><p>提供UI界面或者CLI工具：（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLw==\">Karma</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>）</p>\n<p><strong>CLI工具</strong>会给出一系列测试，以及运行这些测试所需的各种配置和脚手架（运行什么浏览器，使用什么babel插件，如何格式化输出等）</p>\n</li>\n<li><p>提供测试框架（形成文件目录）：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2NoYWpzLm9yZy8=\">Mocha</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N1Y3VtYmVyL2N1Y3VtYmVyLWpz\">Cucumber</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>)</p>\n</li>\n<li><p>提供断言：（<span class=\"exturl\" data-url=\"aHR0cDovL2NoYWlqcy5jb20v\">Chai</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3VuZXhwZWN0ZWQuanMub3JnLw==\">Unexpected</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>）</p>\n<p><strong>断言函数</strong>检查测试返回的结果是否符合预期</p>\n</li>\n<li><p>生成，展示测试结果（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2NoYWpzLm9yZy8=\">Mocha</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLw==\">Karma</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>）</p>\n</li>\n<li><p>快照测试（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YQ==\">Ava</span>）</p>\n<p>快照测试(snapshot testing)，测试 UI 或数据结构是否和之前完全一致，通常 UI 测试不在单元测试中</p>\n</li>\n<li><p>提供仿真（<span class=\"exturl\" data-url=\"aHR0cDovL3Npbm9uanMub3JnLw==\">Sinon</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>，<span class=\"exturl\" data-url=\"aHR0cDovL2FpcmJuYi5pby9lbnp5bWUvZG9jcy9hcGkv\">enzyme</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZXN0ZG91YmxlLmNvbS8=\">testdouble</span>）</p>\n<p>仿真(mocks, spies, and stubs)：获取方法的调用信息，模拟方法，模块，甚至服务器</p>\n</li>\n<li><p>生成测试覆盖率报告 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb3R3YXJsb3N0LmdpdGh1Yi5pby9pc3RhbmJ1bC8=\">Istanbul</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vamVzdC8=\">Jest</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2JsYW5rZXRqcy5vcmcv\">Blanket</span>)</p>\n</li>\n<li><p>提供类浏览器环境(<span class=\"exturl\" data-url=\"aHR0cDovL25pZ2h0d2F0Y2hqcy5vcmcv\">Nightwatch</span>, <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5uaWdodG1hcmVqcy5vcmcv\">Nightmare</span>, <span class=\"exturl\" data-url=\"aHR0cDovL3BoYW50b21qcy5vcmcv\">Phantom</span><strong>,</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9wdXBwZXRlZXI=\">Puppeteer</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmU=\">TestCafe</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=\">Cypress</span>)</p>\n</li>\n<li><p>可视化回归工具(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcHBsaXRvb2xzLmNvbS8=\">Applitools</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9wZXJjeS5pby8=\">Percy</span>, <span class=\"exturl\" data-url=\"aHR0cDovL2JiYy1uZXdzLmdpdGh1Yi5pby93cmFpdGgv\">Wraith</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dlYmRyaXZlcmlvLWJvbmV5YXJkL3dlYmRyaXZlcmNzcw==\">WebdriverCSS</span>)</p>\n</li>\n</ul>\n<h4 id=\"单元测试类工具\"><a href=\"#单元测试类工具\" class=\"headerlink\" title=\"单元测试类工具\"></a>单元测试类工具</h4><p>npm trends: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtdHJlbmRzLmNvbS9tb2NoYS12cy1qZXN0LXZzLWF2YS12cy1qYXNtaW5lLWNvcmU=\">点击链接</span></p>\n<p><img data-src=\"/assets/image-20190706101634263.png\" alt=\"/images/image-20190706101634263\"></p>\n<p><strong>Karma</strong></p>\n<p>Karma是一个Runner（即运行环境），具体详细的介绍见 <a href=\"#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83&%E5%B8%AE%E6%89%8BKarma\">后面的章节Karma</a></p>\n<blockquote>\n<p>A test runner is the library or tool that picks up an assembly (or a source code directory) that contains unit tests, and a bunch of settings, and then executes them and writes the test results to the console or log files.<br>there are many runners for different languages. See Nunit and MSTest for C#, or Junit for Java.</p>\n</blockquote>\n<p>karma 设计目标主要有下面四点：</p>\n<blockquote>\n<p>高效<br>扩展性<br>运行在真实设备<br>无缝的使用流程</p>\n</blockquote>\n<p>karma 是一个典型的 C&#x2F;S 程序，包含 client 和 server ，通讯方式基于 Http ，通常情况下，客户端和服务端基本都运行在开发者本地机器上。</p>\n<p>一个服务端实例对应一个项目，假如想同时运行多个项目，得同时开启多个服务端实例。</p>\n<p>Karma 的<strong>优点</strong>是能通过插件和配置的方式集成大部分的主流的测试框架和前端库，能方便的一次在多浏览器环境执行测试用例，并集成了测试覆盖率生成功能，生成页面形式覆盖率报告并能导出不同形式的覆盖率报告数据。</p>\n<p>它的<strong>缺点</strong>是，对测试页面环境的搭建和资源文件的加载不是常见的形式，最开始搭建环境时会有很多跟预期不一致的情况，配置不直观。</p>\n<p><strong>Jasmine</strong></p>\n<p>Jasmine 带有 assertions(断言)，spies (用来模拟函数的执行环境)和 mocks (mock 工具)，Jasmine 初始化设置简单，同时，如果你需要一些单元功能的时候你仍然可以加一些库进来。</p>\n<p><strong>Mocha</strong></p>\n<p>Mocha 是一个灵活的库，提供给开发者的只有一个基础测试结构。然后，其它功能性的功能如 assertions， spies和mocks，这些功能<strong>需要引用添加其它库</strong>&#x2F;插件来完成。</p>\n<p><strong>Jest</strong></p>\n<p>被 Facebook 和各种 React 应用推荐和使用，Jest 得到了很好的支持。Jest 也被发现是一个非常快速的测试库在平行测试报告中。</p>\n<p>对于小型项目来说你可能在开始的时候不用过多担心，而性能的提高，对于希望全天持续部署的大型应用 app 来说是非常之好的。</p>\n<p>而开发人员主要是用 Jest 去测试 React 应用，Jest 可以很容易地集成到其它应用程序中充许你使用更独特的特性在其它地方</p>\n<p>快照测试是一个非常好用的工具，去确保你的应用 UI 不会有超出预期的错误，在产品发布替换的期间发生。虽然大部分功能，专门设计都是使用在 React 上。</p>\n<p>Jest 有着很广阔的 API 。</p>\n<p><strong>AVA</strong></p>\n<p>AVA 它的优势是 JavaScript 的异步特性和并发运行测试.</p>\n<p>利用了 JavaScript 的异步特性优势，优化了在部署的时间等待</p>\n<p>保留了简单的 API 为你提供你所需要的功能。</p>\n<p>如果搭配 mocking 来使用它会显得更加友好，但是必须安装一个单独的库。</p>\n<h4 id=\"E2E测试类工具\"><a href=\"#E2E测试类工具\" class=\"headerlink\" title=\"E2E测试类工具\"></a>E2E测试类工具</h4><p>npm trends: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtdHJlbmRzLmNvbS9jeXByZXNzLXZzLW5pZ2h0bWFyZS12cy1uaWdodHdhdGNoLXZzLXRlc3RjYWZlLXZzLXdlYmRyaXZlcmlv\">点击链接</span></p>\n<p><img data-src=\"/assets/image-20190706100636750.png\" alt=\"/images/image-20190706100636750\"></p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>测试有很多好处，但不代表一上来就要写出100%场景覆盖的测试用例。</p>\n<p><strong>最佳的实践：基于投入产出比来做测试</strong></p>\n<p>由于维护测试用例也是一大笔开销（毕竟没有多少测试会专门帮前端写业务测试用例，而前端使用的流程自动化工具更是没有测试参与了）。</p>\n<p>对于像基础组件、基础模型之类的不常变更且复用较多的部分，可以考虑去写测试用例来保证质量。个</p>\n<p>先写少量的测试用例覆盖到80%+的场景，保证覆盖主要使用流程。</p>\n<p>一些极端场景出现的bug可以在迭代中形成测试用例沉淀，场景覆盖也将逐渐趋近100%。</p>\n<p>但对于迭代较快的业务逻辑以及生存时间不长的活动页面之类的就别花时间写测试用例了，维护测试用例的时间大了去了，成本太高。</p>\n<p>大型项目，可以使用Jest快速形成配置并且开始单元测试。</p>\n<p>需要测试快照，则可以选择Jest或者Ava。</p>\n<p>对于配置性要求高，对测试框架性能有要求的可以选择mocha。</p>\n<p>对模拟还原浏览器业务操作有很大的需求的，可以选择nightmare</p>\n<p>配合CI工具完成自动化测试、测试覆盖率、测试结果推送。</p>\n<h2 id=\"喜欢简单，选择Mocha\"><a href=\"#喜欢简单，选择Mocha\" class=\"headerlink\" title=\"喜欢简单，选择Mocha\"></a>喜欢简单，选择Mocha</h2><p><a href=\"https://mochajs.org/\"><code>Mocha</code></a>（发音”摩卡”）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>全局安装Mocha</p>\n<pre><code class=\"bash\">npm install -g mocha\n</code></pre>\n<p>项目中也安装Mocha</p>\n<pre><code class=\"bash\">npm install --save-dev mocha\n</code></pre>\n<p>在package.json中加入下面脚本：</p>\n<pre><code class=\"bash\">&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;mocha&quot;\n&#125;\n</code></pre>\n<p>Chai 是一个针对 Node.js 和浏览器的行为驱动测试和测试驱动测试的<strong>断言库</strong>，可与任何 JavaScript 测试框架集成。它是Mocha的好帮手~~</p>\n<pre><code class=\"bash\">npm install --save-dev chai\n</code></pre>\n<p>在package.json中加入下面脚本：</p>\n<pre><code class=\"javascripton\">&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;mocha&quot;\n&#125;\n</code></pre>\n<h3 id=\"关于断言\"><a href=\"#关于断言\" class=\"headerlink\" title=\"关于断言\"></a>关于断言</h3><p><code>expect</code>断言的优点是很接近自然语言，下面是一些例子。</p>\n<pre><code class=\"javascript\">// 相等或不相等\nexpect(4 + 5).to.be.equal(9);\nexpect(4 + 5).to.be.not.equal(10);\nexpect(foo).to.be.deep.equal(&#123; bar: &#39;baz&#39; &#125;);\n\n// 布尔值为true\nexpect(&#39;everthing&#39;).to.be.ok;\nexpect(false).to.not.be.ok;\n\n// typeof\nexpect(&#39;test&#39;).to.be.a(&#39;string&#39;);\nexpect(&#123; foo: &#39;bar&#39; &#125;).to.be.an(&#39;object&#39;);\nexpect(foo).to.be.an.instanceof(Foo);\n\n// include\nexpect([1,2,3]).to.include(2);\nexpect(&#39;foobar&#39;).to.contain(&#39;foo&#39;);\nexpect(&#123; foo: &#39;bar&#39;, hello: &#39;universe&#39; &#125;).to.include.keys(&#39;foo&#39;);\n\n// empty\nexpect([]).to.be.empty;\nexpect(&#39;&#39;).to.be.empty;\nexpect(&#123;&#125;).to.be.empty;\n\n// match\nexpect(&#39;foobar&#39;).to.match(/^foo/);\n</code></pre>\n<p>两种使用方式：</p>\n<pre><code class=\"javascript\">// commonjs\nconst expect = require(&#39;chai&#39;).expect\n\n// es6\nimport &#123; expect &#125; from &#39;chai&#39;\n</code></pre>\n<h3 id=\"测试案例\"><a href=\"#测试案例\" class=\"headerlink\" title=\"测试案例\"></a>测试案例</h3><p>其中index.js为我们的被测试代码：</p>\n<pre><code class=\"javascript\">/**\n * 加法函数\n * @param &#123;第一个数&#125; a \n * @param &#123;第二个数&#125; b \n */\nfunction addNum(a,b)&#123;\n    return a+b;\n&#125;\nmodule.exports=addNum;\n</code></pre>\n<p>新建测试脚本<code>test/demo.js</code></p>\n<pre><code class=\"javascript\">const expect = require(&#39;chai&#39;).expect;\nconst addNum = require(&#39;../src/index&#39;)\n\ndescribe(&#39;测试index.js&#39;, function() &#123;\n  describe(&#39;测试addNum函数&#39;, function() &#123;\n    it(&#39;两数相加结果为两个数字的和&#39;, function() &#123;\n      expect(addNum(1,2)).to.be.equal(3);\n      // 以上语法为chai的expect语法，它还有should语法和asset语法。\n    &#125;);\n  &#125;);\n&#125;);\n\n\n// 等价的意思\nvar addNum=require(&#39;../src/index&#39;)\n\ndescribe(&#39;测试index.js&#39;, function() &#123;\n  describe(&#39;测试addNum函数&#39;, function() &#123;\n    it(&#39;两数相加结果为两个数字的和&#39;, function() &#123;\n       if(addNum(1,2)!==3)&#123;\n         throw new Error(&quot;两数相加结果不为两个数字的和&quot;)；\n       &#125;\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<h3 id=\"Mocha测试命令\"><a href=\"#Mocha测试命令\" class=\"headerlink\" title=\"Mocha测试命令\"></a>Mocha测试命令</h3><p>如果想测试单一的测试js，可以用：</p>\n<pre><code class=\"bash\">mocha test/index.test.js\n</code></pre>\n<p>或者多个js</p>\n<pre><code class=\"bash\">mocha test/index.test.js test/add.test.js\n</code></pre>\n<p>当然也可以用通配符测试某个文件夹下所有的js和jsx：</p>\n<pre><code class=\"bash\"># node 通配符\nmocha &#39;test/some/*.@(js|jsx)&#39;\n\n# shell 通配符\nmocha test/unit/*.js\n\nmocha spec/&#123;my,awesome&#125;.js\n</code></pre>\n<h3 id=\"ES6语法支持\"><a href=\"#ES6语法支持\" class=\"headerlink\" title=\"ES6语法支持\"></a>ES6语法支持</h3><p>在上面我们用的并非是ES6的语法，那么让我们把其中的代码都改为ES6的语法。<br> 其中index.js为：</p>\n<pre><code class=\"javascript\">/**\n * 加法函数\n * @param &#123;第一个数&#125; a \n * @param &#123;第二个数&#125; b \n */\nfunction addNum(a, b) &#123;\n  return a + b\n&#125;\n\nexport &#123;\n  addNum\n&#125; \n</code></pre>\n<p>而index.test.js为：</p>\n<pre><code class=\"javascript\">import &#123; expect &#125; from &#39;chai&#39;\nimport &#123; addNum &#125; from &#39;../src/index&#39;\n\ndescribe(&#39;测试index.js&#39;, function () &#123;\n  describe(&#39;测试addNum函数&#39;, function () &#123;\n    it(&#39;两个参数相加结果为两个数字的和&#39;, function () &#123;\n      expect(addNum(1, 2)).to.be.equal(3);\n    &#125;)\n    it(&#39;两个参数相加结果不为和以外的数&#39;, function () &#123;\n      expect(addNum(1, 2)).to.be.not.equal(4);\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<p>此时直接运行mocha肯定是不行的，我们现需要安装一下babel：</p>\n<pre><code class=\"bash\">npm install --save-dev @babel/cli @babel/core @babel/node @babel/register @babel/preset-env chai mocha nodemon\n</code></pre>\n<p>然后，在项目目录下面，新建一个.babelrc文件：</p>\n<pre><code class=\"javascripton\">&#123;\n  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n&#125;\n</code></pre>\n<p>接着讲package.json中的脚本改为：</p>\n<pre><code class=\"javascripton\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;mocha --require @babel/register&quot;\n&#125;,\n</code></pre>\n<p>命令变得更加简单了</p>\n<h3 id=\"更多用法\"><a href=\"#更多用法\" class=\"headerlink\" title=\"更多用法\"></a>更多用法</h3><h4 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h4><pre><code class=\"bash\">  --timeout, -t, --timeouts  Specify test timeout threshold (in milliseconds)\n                                                        [number] [default: 2000]\n</code></pre>\n<p>官方默认的超时是2000毫秒，即2s。</p>\n<p>有三种方式来修改超时：</p>\n<p><code>--no-timeout</code>参数或者<code>debug</code>模式中，全局禁用了超时；</p>\n<p><code>--timeout</code>后面接时间（毫秒），全局修改了本次执行测试用例的超时时间；</p>\n<p>在测试用例里面，使用<code>this.timeout</code>方法：</p>\n<pre><code class=\"javascript\">it(&#39;should take less than 500ms&#39;, function(done) &#123;\n  this.timeout(500);\n  setTimeout(done, 300);\n&#125;);\n</code></pre>\n<p>在<a href=\"#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%89\">钩子方法</a>里面使用：</p>\n<pre><code class=\"javascript\">describe(&#39;a suite of tests&#39;, function() &#123;\n  beforeEach(function(done) &#123;\n    this.timeout(3000); // A very long environment setup.\n    setTimeout(done, 2500);\n  &#125;);\n&#125;);\n</code></pre>\n<blockquote>\n<p>同样，可以使用&#96;&#96;this.timeout(0)<code> </code>去禁用超时。</p>\n</blockquote>\n<h4 id=\"钩子方法（生命周期函数）\"><a href=\"#钩子方法（生命周期函数）\" class=\"headerlink\" title=\"钩子方法（生命周期函数）\"></a>钩子方法（生命周期函数）</h4><p>Mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。</p>\n<pre><code class=\"javascript\">describe(&#39;测试index.js&#39;,()=&gt; &#123;\n  before(()=&gt;console.info(&quot;在本区块的所有测试用例之前执行&quot;))\n\n  after(()=&gt;console.info(&quot;在本区块的所有测试用例之后执行&quot;))\n\n  beforeEach(()=&gt;console.info(&quot;在本区块的每个测试用例之前执行&quot;))\n\n  afterEach(()=&gt;console.info(&quot;在本区块的每个测试用例之后执行&quot;))\n\n  describe(&#39;测试addNum函数&#39;, ()=&gt; &#123;\n    it(&#39;两数相加结果为两个数字的和&#39;, ()=&gt; &#123;\n      assert.equal(addNum(1,2),3)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<h4 id=\"异步测试\"><a href=\"#异步测试\" class=\"headerlink\" title=\"异步测试\"></a>异步测试</h4><p>Mocha本身是支持异步测试的。只需要为<code>describe</code>回调函数添加一个<code>done</code>参数， 成功时调用<code>done()</code>，失败时调用<code>done(err)</code>。例如：</p>\n<pre><code class=\"javascript\">var expect = require(&#39;chai&#39;).expect;\ndescribe(&#39;db&#39;, function() &#123;\n    it(&#39;#get&#39;, function(done) &#123;\n        db.get(&#39;foo&#39;, function(err, foo)&#123;\n            if(err) done(err);        \n            expect(foo).to.equal(&#39;bar&#39;);\n            done();\n        &#125;);\n    &#125;);\n&#125;);\n</code></pre>\n<ul>\n<li>如果未调用<code>done</code>函数，Mocha会一直等待直到超时。</li>\n<li>如果未添加<code>done</code>参数，Mocha会直接返回成功，不会捕获到异步的断言失败。例如：</li>\n</ul>\n<pre><code class=\"javascript\">it(&#39;#get&#39;, function()&#123;\n    setTimeout(function()&#123;\n        expect(1).to.equal(2);\n    &#125;, 100);\n&#125;);\n</code></pre>\n<p>运行上述测试<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb2NoYWpzLm9yZy8=\">Mocha</span>总会提示Passing。</p>\n<blockquote>\n<p>Mocha怎么知道是否要等待异步断言呢？因为JavaScript中的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24=\">Function</span>有一个<code>length</code>属性， 通过它可以获得该函数的形参个数。Mocha通过传入回调的<code>length</code>来判断是否需要等待。</p>\n</blockquote>\n<p>或者，<code>done()</code>您可以返回<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZQ==\">Promise</span>，而不是使用回调。如果您正在测试的API返回promises而不是回调，可以这样进行使用：</p>\n<pre><code class=\"javascript\">beforeEach(function() &#123;\n  return db.clear().then(function() &#123;\n    return db.save([tobi, loki, jane]);\n  &#125;);\n&#125;);\n\ndescribe(&#39;#find()&#39;, function() &#123;\n  it(&#39;respond with matching records&#39;, function() &#123;\n    return db.find(&#123;type: &#39;User&#39;&#125;).should.eventually.have.length(3);\n  &#125;);\n&#125;);\n</code></pre>\n<p>同样，可以使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9hc3luY19mdW5jdGlvbg==\">async &#x2F; await</span>，您还可以编写如下的异步测试：</p>\n<pre><code class=\"javascript\">beforeEach(async function() &#123;\n  await db.clear();\n  await db.save([tobi, loki, jane]);\n&#125;);\n\ndescribe(&#39;#find()&#39;, function() &#123;\n  it(&#39;responds with matching records&#39;, async function() &#123;\n    const users = await db.find(&#123;type: &#39;User&#39;&#125;);\n    users.should.have.length(3);\n  &#125;);\n&#125;);\n</code></pre>\n<blockquote>\n<p>需要Babel支持~~~</p>\n</blockquote>\n<h3 id=\"示例项目\"><a href=\"#示例项目\" class=\"headerlink\" title=\"示例项目\"></a>示例项目</h3><h4 id=\"创建项目-amp-安装依赖\"><a href=\"#创建项目-amp-安装依赖\" class=\"headerlink\" title=\"创建项目&amp;安装依赖\"></a>创建项目&amp;安装依赖</h4><pre><code class=\"bash\">// 初始化一个nodejs项目\nnpm init -y\n\n// 安装依赖\nnpm install --save-dev @babel/cli @babel/core @babel/node @babel/register @babel/preset-env chai mocha nodemon\n</code></pre>\n<p>形成package.json</p>\n<pre><code class=\"javascripton\">&#123;\n  &quot;name&quot;: &quot;projects&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@babel/cli&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/core&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/node&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/preset-env&quot;: &quot;^7.5.0&quot;,\n    &quot;@babel/register&quot;: &quot;^7.4.4&quot;,\n    &quot;chai&quot;: &quot;^4.2.0&quot;,\n    &quot;mocha&quot;: &quot;^6.1.4&quot;,\n    &quot;nodemon&quot;: &quot;^1.19.1&quot;\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"测试过程\"><a href=\"#测试过程\" class=\"headerlink\" title=\"测试过程\"></a>测试过程</h4><p>新建一个待测试的方法<code>./src/index.js</code></p>\n<pre><code class=\"javascript\">const sayHello = () =&gt; &quot;Hello world!!!&quot;\n\nconsole.log(sayHello())\n\n// ES6语法\nexport default sayHello\n</code></pre>\n<p>测试脚本<code>./test/index.spec.js</code></p>\n<pre><code class=\"javascript\">import &#123; expect &#125; from &quot;chai&quot;\nimport sayHello from &quot;../src/index&quot;\n\ndescribe(&quot;index test&quot;, () =&gt; &#123;\n  describe(&quot;sayHello function&quot;, () =&gt; &#123;\n    it(&quot;should say Hello guys!&quot;, () =&gt; &#123;\n\n      const str = sayHello();\n      expect(str).to.equal(&quot;Hello guys!&quot;)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<p><code>package.json</code>中的脚本：</p>\n<pre><code class=\"javascripton\">  &quot;scripts&quot;: &#123;\n    // &quot;start&quot;: &quot;nodemon ./src/index.js&quot;,  // 针对ES5语法\n    &quot;start:babel&quot;: &quot;nodemon --exec babel-node ./src/index.js&quot;,\n    &quot;test:watch&quot;: &quot;mocha --require @babel/register --watch&quot;,\n    &quot;test&quot;: &quot;mocha --require @babel/register&quot;,\n    &quot;build&quot;: &quot;babel src --out-dir ./dist --source-maps&quot;,\n    &quot;serve&quot;: &quot;node ./dist/index.js&quot;,\n    &quot;debug&quot;: &quot;node --inspect-brk ./dist/index.js&quot;\n  &#125;,\n</code></pre>\n<p>开始测试：<code>npm run test</code></p>\n<p>报错了，因为期望的值与实际值不一致。</p>\n<pre><code class=\"bash\">Hello world!!!\n\n\n  index test\n    sayHello function\n      1) should say Hello guys!\n\n\n  0 passing (9ms)\n  1 failing\n\n  1) index test\n       sayHello function\n         should say Hello guys!:\n\n      AssertionError: expected &#39;Hello world!!!&#39; to equal &#39;Hello guys!&#39;\n      + expected - actual\n\n      -Hello world!!!\n      +Hello guys!\n      \n      at Context.equal (test/index.spec.js:9:22)\n</code></pre>\n<p>修改测试脚本，或者修改index.js文件：</p>\n<p>修改<code>./test/index.spec.js</code></p>\n<pre><code class=\"javascript\">import &#123; expect &#125; from &quot;chai&quot;\nimport sayHello from &quot;../src/index&quot;\n\ndescribe(&quot;index test&quot;, () =&gt; &#123;\n  describe(&quot;sayHello function&quot;, () =&gt; &#123;\n    it(&quot;should say Hello world!!!&quot;, () =&gt; &#123;\n\n      const str = sayHello();\n      expect(str).to.equal(&quot;Hello world!!!&quot;)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<p>再次测试：</p>\n<pre><code class=\"bash\">&gt; mocha --require @babel/register\n\nHello world!!!\n\n\n  index test\n    sayHello function\n      ✓ should say Hello world!!!\n\n\n  1 passing (6ms)\n</code></pre>\n<p>使用<code>mochawesome</code>展示你的测试结果：</p>\n<pre><code class=\"bash\">npm install --save-dev mochawesome\n</code></pre>\n<p>然后在<code>package.json</code>的<code>scripts</code>中添加如下内容，</p>\n<pre><code class=\"javascripton\">&#123;\n    &quot;report&quot;: &quot;mocha --require @babel/register --reporter mochawesome&quot;,\n&#125;\n</code></pre>\n<p>使用方式：</p>\n<pre><code class=\"bash\">npm run report\n</code></pre>\n<p>形成出来的报告在浏览器中打开：</p>\n<p><img data-src=\"/assets/image-20190707212821248.png\" alt=\"/images/image-20190707212821248\"></p>\n<p>在Vscode中可以安装Live Server这个插件快速打开：</p>\n<p><img data-src=\"/assets/image-20190707212923919.png\" alt=\"/images/image-20190707212923919\"></p>\n<h2 id=\"开箱即用Jest\"><a href=\"#开箱即用Jest\" class=\"headerlink\" title=\"开箱即用Jest\"></a>开箱即用Jest</h2><p>Jest是由Facebook发布的开源的、基于<span class=\"exturl\" data-url=\"aHR0cDovL2phc21pbmUuZ2l0aHViLmlvLw==\">Jasmine</span>的JavaScript单元测试框架。Jest源于Facebook的构想，用于快速、可靠地测试Web聊天应用。它吸引了公司内部的兴趣，Facebook的一名软件工程师Jeff Morrison半年前又重拾这个项目，改善它的性能，并将其开源。Jest的目标是减少开始测试一个项目所要花费的时间和认知负荷，因此它提供了大部分你需要的现成工具：快速的命令行接口、Mock工具集以及它的自动模块Mock系统。此外，如果你在寻找隔离工具例如Mock库，大部分其它工具将让你在测试中（甚至经常在你的主代码中）写一些不尽如人意的样板代码，以使其生效。Jest与Jasmine框架的区别是在后者之上增加了一些层。最值得注意的是，运行测试时，Jest会自动模拟依赖。Jest自动为每个依赖的模块生成Mock，并默认提供这些Mock，这样就可以很容易地隔离模块的依赖。</p>\n<p>Jest支持Babel，我们将很轻松的使用ES6的高级语法</p>\n<p>Jest支持webpack，非常方便的使用它来管理我们的项目</p>\n<p>Jest支持TypeScript，书写测试用例更加严谨</p>\n<ol>\n<li><p>简化API</p>\n<p>Jest既简单又强大，内置支持以下功能：</p>\n<ul>\n<li>灵活的配置：比如，可以用文件名通配符来检测测试文件。</li>\n<li>测试的事前步骤(Setup)和事后步骤(Teardown)，同时也包括测试范围。</li>\n<li>匹配表达式(Matchers)：能使用期望<code>expect</code>句法来验证不同的内容。</li>\n<li>测试异步代码：支持承诺(promise)数据类型和异步等待<code>async</code> &#x2F; <code>await</code>功能。</li>\n<li>模拟函数：可以修改或监查某个函数的行为。</li>\n<li>手动模拟：测试代码时可以忽略模块的依存关系。</li>\n<li>虚拟计时：帮助控制时间推移。</li>\n</ul>\n</li>\n<li><p>性能与隔离</p>\n<p>Jest文档里写道：</p>\n<p>Jest能运用所有的工作部分，并列运行测试，使性能最大化。终端上的信息经过缓冲，最后与测试结果一起打印出来。沙盒中生成的测试文件，以及自动全局状态在每个测试里都会得到重置，这样就不会出现两个测试冲突的情况。</p>\n<p>Mocha用一个进程运行所有的测试，和它比较起来，Jest则完全不同。要在测试之间模拟出隔离效果，我们必须要引入几个测试辅助函数来妥善管理清除工作。这种做法虽然不怎么理想，但99%的情况都可以用，因为测试是按顺序进行的。</p>\n</li>\n<li><p>沉浸式监控模式</p>\n<p>快速互动式监控模式可以监控到哪些测试文件有过改动，只运行与改动过的文件相关的测试，并且由于优化作用，能迅速放出监控信号。设置起来非常简单，而且还有一些别的选项，可以用文件名或测试名来过滤测试。我们用Mocha时也有监控模式，不过没有那么强大，要运行某个特定的测试文件夹或文件，就不得不自己创造解决方法，而这些功能Jest本身就已经提供了，不用花力气。</p>\n</li>\n<li><p>代码覆盖率&amp;测试报告</p>\n<p>Jest内置有代码覆盖率报告功能，设置起来易如反掌。可以在整个项目范围里收集代码覆盖率信息，包括未经受测试的文件。</p>\n<p>要使完善Circle CI整合，只需要一个自定义报告功能。有了Jest，用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWxsZWVhbGxlbi9qZXN0LWp1bml0LXJlcG9ydGVy\">jest-junit-reporter</span>就可以做到，其用法和Mocha几乎相同。</p>\n</li>\n<li><p>快照功能</p>\n<p>快照测试的目的不是要替换现有的单元测试，而是要使之更有价值，让测试更轻松。在某些情况下，某些功能比如React组件功能，有了快照测试意味着无需再做单元测试，但同样这两者不是非此即彼。</p>\n</li>\n</ol>\n<h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>新建文件夹然后通过npm 命令安装：</p>\n<pre><code class=\"bash\">npm install --save-dev jest\n</code></pre>\n<p>或者通过yarn来安装：</p>\n<pre><code class=\"bash\">yarn add --dev jest\n</code></pre>\n<p>然后就可以开始测试了</p>\n<p>也可用<code>npm install -g jest</code>进行全局安装；并在 package.json 中指定 test 脚本：</p>\n<pre><code class=\"javascripton\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;jest&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>Jest 的测试脚本名形如<code>.test.js</code>，不论 Jest 是全局运行还是通过<code>npm test</code>运行，它都会执行当前目录下所有的<code>*.test.js</code> 或 <code>*.spec.js</code> 文件、完成测试。</p>\n<p>ES6语法支持：</p>\n<ol>\n<li>安装依赖</li>\n</ol>\n<pre><code class=\"bash\">yarn add --dev babel-jest @babel/core @babel/preset-env\n</code></pre>\n<ol start=\"2\">\n<li>配置<code>.babelrc</code></li>\n</ol>\n<pre><code class=\"javascripton\">&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &#123;\n          &quot;node&quot;: &quot;current&quot;\n        &#125;\n      &#125;\n    ]\n  ]\n&#125;\n</code></pre>\n<p>接下来就可以使用ES6的语法了~~~</p>\n<p>更多高阶的ES6&#x2F;7&#x2F;8…语法，可以参见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWJlbGpzLmlvLw==\">babel官网</span></p>\n<p>关于Typescript的支持，可以参见 ：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9nZXR0aW5nLXN0YXJ0ZWQjdXNpbmctdHlwZXNjcmlwdA==\">Using Typescript</span></p>\n<h3 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h3><p>关于test suite与test case：</p>\n<p><img data-src=\"/assets/w80140jb42.jpg\" alt=\"img\"></p>\n<p>describe属于 test suite 的描述，而每个 test 或者 it 则描述了每个 test case。</p>\n<p>例如：<code>math.js</code></p>\n<pre><code class=\"javascript\">export const add = (a, b) =&gt; a + b;\n\nexport const multiple = (a, b) =&gt; a * b;\n</code></pre>\n<p>测试脚本：<code>math.test.js</code></p>\n<pre><code class=\"javascript\">const math = require(&#39;./src/math&#39;)\n\ndescribe(&quot;math&quot;, () =&gt; &#123;\n  let a\n  let b\n\n  beforeEach(function () &#123;\n    a = 2;\n    b = 3;\n  &#125;);\n\n  test(&quot;#should return result as a+b&quot;, () =&gt; &#123;\n    // test code\n    const result = math.add(a, b)\n    expect(result).toEqual(5)\n  &#125;);\n\n  it(&quot;#should return result as a*b&quot;, () =&gt; &#123;\n    //test code\n    const result = math.multiple(a, b)\n    expect(result).toEqual(6)\n  &#125;);\n&#125;);\n</code></pre>\n<p> test suite 可以进行嵌套：</p>\n<pre><code class=\"javascript\">describe(&quot;foo&quot;, () =&gt; &#123;\n  describe(&quot;bar&quot;, () =&gt; &#123;\n    it(&quot;foo bar&quot;, () =&gt; &#123;\n      //test code\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<p>test case 也可以脱离 test suite 独立运行：</p>\n<pre><code class=\"javascript\">// hello.js\nmodule.exports = () =&gt; &#39;Hello world&#39;\n\n// hello.test.js\nlet hello = require(&#39;hello.js&#39;)\n\ntest(&#39;should get &quot;Hello world&quot;&#39;, () =&gt; &#123;\n    expect(hello()).toBe(&#39;Hello world&#39;) // 测试成功\n// expect(hello()).toBe(&#39;Hello&#39;) // 测试失败\n&#125;)\n</code></pre>\n<h3 id=\"Mock与Spy\"><a href=\"#Mock与Spy\" class=\"headerlink\" title=\"Mock与Spy\"></a>Mock与Spy</h3><p><strong>mock</strong>测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。</p>\n<p>Mock 是单元测试中经常使用的一种技术。单元测试，顾名思义测试的重点是某个具体单元。但是在实际代码中，代码与代码之间，模块与模块之间总是会存在着相互引用。这个时候，剥离出这种单元的依赖，让测试更加独立，使用到的技术就是 Mock。</p>\n<p><strong>为什么要使用Mock函数？</strong></p>\n<p>在项目中，一个模块的方法内常常会去调用另外一个模块的方法。在单元测试中，我们可能并不需要关心内部调用的方法的执行过程和结果，只想知道它是否被正确调用即可，甚至会指定该函数的返回值。此时，使用Mock函数是十分有必要。</p>\n<p>Mock函数提供的以下三种特性，在我们写测试代码时十分有用：</p>\n<ul>\n<li>捕获函数调用情况</li>\n<li>设置函数返回值</li>\n<li>改变函数的内部实现</li>\n</ul>\n<p><img data-src=\"/assets/8u3cp5kz2s.png\" alt=\"img\"></p>\n<p>举个例子：</p>\n<pre><code class=\"javascript\">// math.js\nexport const getFooResult = () =&gt; &#123;\n  // foo logic here\n&#125;;\nexport const getBarResult = () =&gt; &#123;\n  // bar logic here\n&#125;;\n\n// caculate.js\nimport &#123; getFooResult, getBarResult &#125; from &quot;./math&quot;;\n\nexport const getFooBarResult = () =&gt; getFooResult() + getBarResult();\n</code></pre>\n<p>此时，getFooResult() 和 getBarResult() 就是 getFooBarResult 这个函数的依赖。如果我们关注的点是 getFooBarResult 这个函数，我们就应该把 getFooResult 和 getBarResult Mock 掉，剥离这种依赖。下面是一个使用 Jest 进行 Mock 的例子。</p>\n<p><code>jest.fn()</code>是\b创建Mock函数最简单的方式，如果没有定义函数内部的实现，<code>jest.fn()</code>会返回<code>undefined</code>作为返回值。</p>\n<pre><code class=\"javascript\">test(&#39;测试jest.fn()调用&#39;, () =&gt; &#123;\n  let mockFn = jest.fn();\n  let result = mockFn(1, 2, 3);\n\n  // 断言mockFn的执行后返回undefined\n  expect(result).toBeUndefined();\n  // 断言mockFn被调用\n  expect(mockFn).toBeCalled();\n  // 断言mockFn被调用了一次\n  expect(mockFn).toBeCalledTimes(1);\n  // 断言mockFn传入的参数为1, 2, 3\n  expect(mockFn).toHaveBeenCalledWith(1, 2, 3);\n&#125;)\n</code></pre>\n<p><strong>情景一：设置函数 的返回值</strong></p>\n<pre><code class=\"javascript\">// calculate.test.js\nimport &#123; getFooBarResult &#125; from &quot;./calculate&quot;;\nimport * as fooBar from &#39;./math&#39;;\n\ntest(&#39;getResult should return result getFooResult() + getBarResult()&#39;, () =&gt; &#123;\n  // mock add方法和multiple方法\n  fooBar.getFooBarResult = jest.fn(() =&gt; 10);\n  fooBar.getBarResult = jest.fn(() =&gt; 5);\n\n  const result = getFooBarResult();\n\n  expect(result).toEqual(15);\n&#125;);\n</code></pre>\n<p>Mock其实就是一种Spies，在Jest中使用spies来“spy”(窥探)一个函数的行为。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9tb2NrLWZ1bmN0aW9uLWFwaS5odG1sI2NvbnRlbnQ=\">Jest文档</span>对于spies的解释:</p>\n<blockquote>\n<p>Mock函数也称为“spies”，因为它们让你窥探一些由其他代码间接调用的函数的行为，而不仅仅是测试输出。你可以通过使用 <code>jest.fn()</code> 创建一个mock函数。</p>\n</blockquote>\n<p>简单来说，一个spy是另一个内置的能够记录对其调用细节的函数：调用它的次数，使用什么参数。</p>\n<pre><code class=\"javascript\">// calculate.test.js\nimport &#123; getFooBarResult &#125; from &quot;./calculate&quot;;\nimport * as fooBar from &#39;./math&#39;;\n\ntest(&#39;getResult should return result getFooResult() + getBarResult()&#39;, () =&gt; &#123;\n  // mock add方法和multiple方法\n  fooBar.getFooResult = jest.fn(() =&gt; 10);\n  fooBar.getBarResult = jest.fn(() =&gt; 5);\n\n  const result = getFooBarResult();\n\n  // 监控getFooResult和getBarResult的调用情况.\n  expect(fooBar.getFooResult).toHaveBeenCalled();\n  expect(fooBar.getBarResult).toHaveBeenCalled();\n&#125;);\n</code></pre>\n<p><strong>情景二：捕获函数调用情况</strong></p>\n<pre><code class=\"javascript\">// bot method\nconst bot = &#123;\n  sayHello: name =&gt; &#123;\n    console.log(`Hello $&#123;name&#125;!`);\n  &#125;\n&#125;;\n\n// test.js\ndescribe(&quot;bot&quot;, () =&gt; &#123;\n  it(&quot;should say hello&quot;, () =&gt; &#123;\n    const spy = jest.spyOn(bot, &quot;sayHello&quot;);\n\n    bot.sayHello(&quot;Michael&quot;);\n\n    expect(spy).toHaveBeenCalledWith(&quot;Michael&quot;);\n\n    spy.mockRestore();\n  &#125;);\n&#125;);\n</code></pre>\n<p>我们通过 <code>jest.spyOn</code> 创建了一个监听 <code>bot</code> 对象的 <code>sayHello</code> 方法的 spy。它就像间谍一样监听了所有对 <code>bot#sayHello</code> 方法的调用。由于创建 spy 时，Jest 实际上修改了 <code>bot</code> 对象的 <code>sayHello</code> 属性，所以在断言完成后，我们还要通过 <code>mockRestore</code> 来恢复 <code>bot</code> 对象原本的 <code>sayHello</code>方法。</p>\n<p>Jest的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9qZXN0LW9iamVjdCNqZXN0c3B5b25vYmplY3QtbWV0aG9kbmFtZQ==\">spyOn介绍</span></p>\n<p><strong>情景三：修改函数的内容实现</strong></p>\n<pre><code class=\"javascript\">const bot = &#123;\n  sayHello: name =&gt; &#123;\n    console.log(`Hello $&#123;name&#125;!`);\n  &#125;\n&#125;;\n\ndescribe(&quot;bot&quot;, () =&gt; &#123;\n  it(&quot;should say hello&quot;, () =&gt; &#123;\n    const spy = jest.spyOn(bot, &quot;sayHello&quot;).mockImplementation(name =&gt; &#123;\n      console.log(`Hello mix $&#123;name&#125;`)\n    &#125;);\n\n    bot.sayHello(&quot;Michael&quot;);\n\n    expect(spy).toHaveBeenCalledWith(&quot;Michael&quot;);\n\n    spy.mockRestore();\n  &#125;);\n&#125;);\n</code></pre>\n<p>使用spyOn方法，还可以去修改Math.random这样的函数</p>\n<pre><code class=\"javascript\">jest.spyOn(Math, &quot;random&quot;).mockImplementation(() =&gt; 0.9);\n</code></pre>\n<p>举个例子：</p>\n<pre><code class=\"javascript\">// getNum.js\nconst arr = [1,2,3,4,5,6];\n\nconst getNum = index =&gt; &#123;\n  if (index) &#123;\n    return arr[index % 6];\n  &#125; else &#123;\n    return arr[Math.floor(Math.random() * 6)];\n  &#125;\n&#125;;\n\n// num.test.js\nimport &#123; getNum &#125; from &#39;../src/getNum&#39;\n\ndescribe(&quot;getNum&quot;, () =&gt; &#123;\n  it(&quot;should select numbber based on index if provided&quot;, () =&gt; &#123;\n    expect(getNum(1)).toBe(2);\n  &#125;);\n\n  it(&quot;should select a random number based on Math.random if skuId not available&quot;, () =&gt; &#123;\n    const spy = jest.spyOn(Math, &quot;random&quot;).mockImplementation(() =&gt; 0.9);\n\n    expect(getNum()).toBe(6);\n    expect(spy).toHaveBeenCalled();\n\n    spy.mockRestore();\n  &#125;);\n&#125;);\n</code></pre>\n<h3 id=\"CLI命令\"><a href=\"#CLI命令\" class=\"headerlink\" title=\"CLI命令\"></a>CLI命令</h3><pre><code>➜ npx jest --help\nUsage: jest [--config=&lt;pathToConfigFile&gt;] [TestPathPattern]\n\n选项：\n  --help, -h                    显示帮助信息                              [布尔]\n  --version, -v                 Print the version and exit                [布尔]\n  --config, -c                  The path to a jest config file specifying how to\n                                find and execute tests. If no rootDir is set in\n                                the config, the directory containing the config\n                                file is assumed to be the rootDir for the\n                                project.This can also be a JSON encoded value\n                                which Jest will use as configuration.   [字符串]\n  --coverage                    Indicates that test coverage information should\n                                be collected and reported in the output.  [布尔] \n  --timers                      Setting this value to fake allows the use of\n                                fake timers for functions such as setTimeout.\n                                                                        [字符串]\n  --verbose                     Display individual test results with the test\n                                suite hierarchy.                          [布尔]\n  --watch                       Watch files for changes and rerun tests related\n                                to changed files. If you want to re-run all\n                                tests when a file has changed, use the\n                                `--watchAll` option.                      [布尔]\n  --watchAll                    Watch files for changes and rerun all tests. If\n                                you want to re-run only the tests related to the\n                                changed files, use the `--watch` option.  [布尔]\n...\n</code></pre>\n<p>常见使用：</p>\n<p><code>--verbose</code>显示详细的测试信息，包括测试suite和case：</p>\n<pre><code class=\"bash\">➜ npx jest --verbose\n PASS  test/mock.test.js\n  bot\n    ✓ should say hello (7ms)\n\n  console.log test/mock.test.js:10\n    Hello mix Michael\n\n PASS  test/domain.test.js\n  getImageDomain\n    ✓ should select domain based on skuId if provided (1ms)\n    ✓ should select a random domain based on Math.random if skuId not available (1ms)\n\n  console.log test/sayhello.test.js:3\n    Hello Michael!\n\n PASS  test/sayhello.test.js\n  bot\n    ✓ should say hello (6ms)\n\n PASS  test/num.test.js\n  getNum\n    ✓ should select numbber based on index if provided (1ms)\n    ✓ should select a random number based on Math.random if skuId not available\n\n PASS  test/math.test.js\n  math\n    ✓ #should return result as a+b (1ms)\n    ✓ #should return result as a*b (4ms)\n\nTest Suites: 5 passed, 5 total\nTests:       8 passed, 8 total\nSnapshots:   0 total\nTime:        1.075s\nRan all test suites.\n</code></pre>\n<p><code>--watch</code>和<code>--watchAll</code>用来监听测试文件的变化 </p>\n<pre><code class=\"bash\">Ran all test suites.\n\nWatch Usage\n › Press f to run only failed tests.\n › Press o to only run tests related to changed files.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press q to quit watch mode.\n › Press Enter to trigger a test run.\n</code></pre>\n<p><code>--coverage</code>用来形成测试覆盖率报告</p>\n<pre><code class=\"bash\">-----------|----------|----------|----------|----------|-------------------|\nFile       |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\n-----------|----------|----------|----------|----------|-------------------|\nAll files  |      100 |      100 |      100 |      100 |                   |\n getNum.js |      100 |      100 |      100 |      100 |                   |\n math.js   |      100 |      100 |      100 |      100 |                   |\n-----------|----------|----------|----------|----------|-------------------|\n\nTest Suites: 5 passed, 5 total\nTests:       8 passed, 8 total\nSnapshots:   0 total\nTime:        1.497s\n</code></pre>\n<h3 id=\"Jest在React、Vue项目中的应用\"><a href=\"#Jest在React、Vue项目中的应用\" class=\"headerlink\" title=\"Jest在React、Vue项目中的应用\"></a>Jest在React、Vue项目中的应用</h3><p>在<code>create-react-app</code>中的应用：</p>\n<p>安装对应的依赖：</p>\n<pre><code>npm install react-test-renderer enzyme enzyme-adapter-react-16 \n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9lbnp5bWU=\">Enzyme</span>是一个非常棒的React组件测试测试库。</p>\n<blockquote>\n<p>Enzyme is a JavaScript Testing utility for React that makes it easier to test your React Components’ output. You can also manipulate, traverse, and in some ways simulate runtime given the output.</p>\n<p>Enzyme’s API is meant to be intuitive and flexible by mimicking jQuery’s API for DOM manipulation and traversal</p>\n</blockquote>\n<p>需要注意的两点是：</p>\n<ul>\n<li>需要配置Adapter，不同的React的Adapter不同</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Enzyme Adapter Package</th>\n<th>React semver compatibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>enzyme-adapter-react-16</code></td>\n<td><code>^16.4.0-0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-16.3</code></td>\n<td><code>~16.3.0-0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-16.2</code></td>\n<td><code>~16.2</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-16.1</code></td>\n<td>&#96;~16.0.0-0</td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-15</code></td>\n<td><code>^15.5.0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-15.4</code></td>\n<td><code>15.0.0-0 - 15.4.x</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-14</code></td>\n<td><code>^0.14.0</code></td>\n</tr>\n<tr>\n<td><code>enzyme-adapter-react-13</code></td>\n<td><code>^0.13.0</code></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>需要初始化配置<code>setUpTests.js</code></p>\n<p>官方文档在Package.json中设置jest配置，已经过时，Jest框架最新会默认加载文件<code>src/setUpTests.js</code></p>\n</li>\n<li><pre><code class=\"react\">import &#123; configure &#125; from &#39;enzyme&#39;;\nimport Adapter from &#39;enzyme-adapter-react-16&#39;\n\nconfigure(&#123; adapter: new Adapter() &#125;)\n</code></pre>\n</li>\n</ul>\n<p>在vue工程化项目中：</p>\n<pre><code class=\"javascripton\">&quot;devDependencies&quot;: &#123;\n  &quot;@vue/cli-plugin-unit-jest&quot;: &quot;^3.9.0&quot;,\n  &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;,\n  &quot;babel-core&quot;: &quot;7.0.0-bridge.0&quot;,\n  &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,\n  &quot;babel-jest&quot;: &quot;^23.6.0&quot;,\n  &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,\n&#125;,\n</code></pre>\n<p>添加如上依赖，</p>\n<p>配置scripts:</p>\n<pre><code class=\"javascript\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;vue-cli-service test:unit&quot;\n&#125;,\n</code></pre>\n<p>配置<code>jest.config.js</code></p>\n<pre><code class=\"javascript\">module.exports = &#123;\n  // 处理vue结尾的文件\n  moduleFileExtensions: [\n    &#39;js&#39;,\n    &#39;jsx&#39;,\n    &#39;json&#39;,\n    &#39;vue&#39;\n  ],\n  // es6转义\n  transform: &#123;\n    &#39;^.+\\\\.vue$&#39;: &#39;vue-jest&#39;,\n    &#39;.+\\\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$&#39;: &#39;jest-transform-stub&#39;,\n    &#39;^.+\\\\.jsx?$&#39;: &#39;babel-jest&#39;\n  &#125;,\n  transformIgnorePatterns: [\n    &#39;/node_modules/&#39;\n  ],\n  // cli配置了webpack别名\n  moduleNameMapper: &#123;\n    &#39;^@/(.*)$&#39;: &#39;&lt;rootDir&gt;/src/$1&#39;\n  &#125;,\n  snapshotSerializers: [\n    &#39;jest-serializer-vue&#39;\n  ],\n  testMatch: [\n    &#39;**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)&#39;\n  ],\n  testURL: &#39;http://localhost/&#39;,\n  watchPlugins: [\n    &#39;jest-watch-typeahead/filename&#39;,\n    &#39;jest-watch-typeahead/testname&#39;\n  ]\n&#125;\n</code></pre>\n<p>写一个测试用例：</p>\n<pre><code>\n</code></pre>\n<h2 id=\"简约之美AVA\"><a href=\"#简约之美AVA\" class=\"headerlink\" title=\"简约之美AVA\"></a>简约之美AVA</h2><p>简单的说ava是mocha的替代品：</p>\n<ul>\n<li>es6语法支持更好，对aysnc&#x2F;await有支持</li>\n<li>执行效率更高，使用io并发，就必须保证测试的原子性</li>\n<li>语义上更简单，集众家之长</li>\n</ul>\n<p>虽然 JavaScript 是单线程，但在 Node.js 里由于其异步的特性使得 IO 可以并行。AVA 利用这个优点让你的测试可以并发执行，这对于 IO 繁重的测试特别有用。另外，测试文件可以在不同的进程里并行运行，让每一个测试文件可以获得更好的性能和独立的环境。</p>\n<h3 id=\"AVA特点\"><a href=\"#AVA特点\" class=\"headerlink\" title=\"AVA特点\"></a>AVA特点</h3><ul>\n<li><p>轻量和高效</p>\n</li>\n<li><p>简单的测试语法</p>\n</li>\n<li><p>并发运行测试</p>\n</li>\n<li><p>强制编写<strong>原子测试</strong></p>\n<p>一旦开始，就一直运行到结束，中间不会切换到另一个测试</p>\n</li>\n<li><p>没有隐藏的全局变量</p>\n</li>\n<li><p>为每个测试文件隔离环境</p>\n</li>\n<li><p><strong>用 ES2015 编写测试</strong></p>\n</li>\n<li><p>支持 Promise</p>\n</li>\n<li><p>支持 Generator</p>\n</li>\n<li><p>支持 Async</p>\n</li>\n<li><p>支持 Observable</p>\n</li>\n<li><p>强化断言信息</p>\n</li>\n<li><p>可选的 TAP 输出显示</p>\n<p><img data-src=\"/assets/tap-reporter.png\" alt=\"img\"></p>\n</li>\n<li><p>简明的堆栈跟踪</p>\n</li>\n</ul>\n<h3 id=\"安装-amp-开始\"><a href=\"#安装-amp-开始\" class=\"headerlink\" title=\"安装&amp;开始\"></a>安装&amp;开始</h3><p>情景一：</p>\n<pre><code class=\"bash\">// 创建一个ava项目\nnpm init ava\n</code></pre>\n<p>形成package.json</p>\n<pre><code class=\"javascripton\">&#123;\n    &quot;name&quot;: &quot;awesome-package&quot;, \n    &quot;scripts&quot;: &#123;\n        &quot;test&quot;: &quot;ava&quot;\n    &#125;,\n    &quot;devDependencies&quot;: &#123;\n        &quot;ava&quot;: &quot;^1.0.0&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>情景二：（推荐）</p>\n<pre><code class=\"bash\">npm init -y\n\n// npm &amp; cnpm\nnpm install -D ava\n\n// yarn \nyarn add ava -D\n</code></pre>\n<p>测试ava正常安装：</p>\n<pre><code class=\"bash\">➜ npx ava --version\n2.2.0\n</code></pre>\n<h3 id=\"第一个ava测试例子\"><a href=\"#第一个ava测试例子\" class=\"headerlink\" title=\"第一个ava测试例子\"></a>第一个ava测试例子</h3><p>流程：</p>\n<ol>\n<li>引用ava的测试API</li>\n<li>执行测试</li>\n<li>使用断言</li>\n</ol>\n<p>创建<code>test.js</code>文件</p>\n<pre><code class=\"javascript\">import test from &#39;ava&#39;;\n\nconst testfn = (a, b) =&gt; a + b\n\ntest(&#39;hello ava&#39;, t =&gt; &#123;\n  t.pass();\n&#125;);\n\ntest(&#39;my first test&#39;, async t =&gt; &#123;\n  const str = &#39;hello ava!!!!&#39;\n  t.is(str, &#39;hello ava!!!!&#39;)\n&#125;);\n\ntest(&#39;add method&#39;, async t =&gt; &#123;\n  const result = testfn(3, 4)\n  t.is(result, 7)\n&#125;);\n</code></pre>\n<p>ava自动搜索如下文件结尾的文件：</p>\n<ul>\n<li><code>**/test.js</code></li>\n<li><code>**/test-*.js</code></li>\n<li><code>**/*.spec.js</code></li>\n<li><code>**/*.test.js</code></li>\n<li><code>**/test/**/*.js</code></li>\n<li><code>**/tests/**/*.js</code></li>\n<li><code>**/__tests__/**/*.js</code></li>\n</ul>\n<p>ava中的断言：</p>\n<pre><code class=\"javascripton\">.pass([message])\n.fail([message])\n.assert(value, [message])\n.truthy(value, [message])\n.falsy(value, [message])\n.true(value, [message])\n.false(value, [message])\n.is(value, expected, [message])\n.not(value, expected, [message])\n.deepEqual(value, expected, [message])\n.notDeepEqual(value, expected, [message])\n.deepEqual()。\n.throws(fn, [expected, [message]])\n.throwsAsync(thrower, [expected, [message]])\n.notThrows(fn, [message])\n.notThrowsAsync(nonThrower, [message])\n.regex(contents, regex, [message])\n.notRegex(contents, regex, [message])\n.snapshot(expected, [message])\n.snapshot(expected, [options], [message])\n</code></pre>\n<h3 id=\"CLI命令-1\"><a href=\"#CLI命令-1\" class=\"headerlink\" title=\"CLI命令\"></a>CLI命令</h3><p>使用<code>--help</code>命令去查看ava支持的cli参数 </p>\n<pre><code class=\"bash\">➜ npx ava --help\n\n  Testing can be a drag. AVA helps you get it done.\n\n  Usage\n    ava [&lt;file&gt; ...]\n\n  Options\n    --watch, -w             Re-run tests when tests and source files change\n    --match, -m             Only run tests with matching title (Can be repeated)\n    --update-snapshots, -u  Update snapshots\n    --fail-fast             Stop after first test failure\n    --timeout, -T           Set global timeout (milliseconds or human-readable, e.g. 10s, 2m)\n    --serial, -s            Run tests serially\n    --concurrency, -c       Max number of test files running at the same time (Default: CPU cores)\n    --verbose, -v           Enable verbose output\n    --tap, -t               Generate TAP output\n    --color                 Force color output\n    --no-color              Disable color output\n    --reset-cache           Reset AVA&#39;s compilation cache and exit\n    --config                JavaScript file for AVA to read its config from, instead of using package.json\n                            or ava.config.js files\n\n  Examples\n    ava\n    ava test.js test2.js\n    ava test-*.js\n    ava test\n\n  The above relies on your shell expanding the glob patterns.\n  Without arguments, AVA uses the following patterns:\n    **/test.js **/test-*.js **/*.spec.js **/*.test.js **/test/**/*.js **/tests/**/*.js **/__tests__/**/*.js\n</code></pre>\n<h4 id=\"文件匹配\"><a href=\"#文件匹配\" class=\"headerlink\" title=\"文件匹配\"></a>文件匹配</h4><p>使用<code>match</code>指令，匹配对应需要测试的文件：</p>\n<p>匹配标题以<code>foo</code>：结尾</p>\n<pre><code>npx ava --match =&#39;* foo&#39;\n</code></pre>\n<p>匹配标题以<code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;foo *&#39;\n</code></pre>\n<p>匹配标题包含<code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;* foo *&#39;\n</code></pre>\n<p>匹配是完全相同 <code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;foo&#39;\n</code></pre>\n<p>匹配标题不包含<code>foo</code>：</p>\n<pre><code>npx ava --match =&#39;！* foo *&#39;\n</code></pre>\n<p>匹配以下<code>foo</code>结尾的标题<code>bar</code>：</p>\n<pre><code>npx ava --match =&#39;foo * bar&#39;\n</code></pre>\n<p>匹配<code>foo</code>以<code>bar</code>：开头或结尾的标题：</p>\n<pre><code>npx ava --match =&#39;foo *&#39; -  match =&#39;* bar&#39;\n</code></pre>\n<h4 id=\"关于reporter\"><a href=\"#关于reporter\" class=\"headerlink\" title=\"关于reporter\"></a>关于reporter</h4><p>默认情况下，AVA使用最小的报告：</p>\n<p><a href=\"https://github.com/avajs/ava/blob/master/media/mini-reporter.gif\"><img data-src=\"/assets/mini-reporter.gif\" alt=\"img\"></a></p>\n<p>使用该<code>--verbose</code>标志启用详细的报告者。除非启用TAP报告，否则始终在CI环境中使用此选项。</p>\n<p><a href=\"https://github.com/avajs/ava/blob/master/media/verbose-reporter.png\"><img data-src=\"/assets/verbose-reporter.png\" alt=\"img\"></a></p>\n<p><strong>TAP报告（推荐）</strong></p>\n<p>AVA支持TAP格式，因此与任何TAP报告器兼容。使用该<code>--tap</code>标志启用TAP输出。</p>\n<pre><code class=\"bash\">$ npx ava --tap | npx tap-nyan\n</code></pre>\n<p><a href=\"https://github.com/avajs/ava/blob/master/media/tap-reporter.png\"><img data-src=\"/assets/tap-reporter-20190709154342692.png\" alt=\"img\"></a></p>\n<p>这里有一些格式：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RhcC1kb3Q=\">tap-dot</span> - Dotted output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RhcC1zcGVj\">tap-spec</span> - Mocha-like spec reporter.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NhbHZpbm1ldGNhbGYvdGFwLW55YW4=\">tap-nyan</span> - Nyan cat.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1bW1lc3Nvbi90YXAtbWlu\">tap-min</span> - Minimal output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25hbXVvbC90YXAtZGlmZmxldA==\">tap-difflet</span> - Minimal output with diffing.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F4cm9zcy90YXAtZGlmZg==\">tap-diff</span> - Human-friendly output with diffing.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2pvZXliYWtlci90YXAtc2ltcGxl\">tap-simple</span> - Simple output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2ZhdWNldA==\">faucet</span> - Human-readable summarizer.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90YXAtbW9jaGEtcmVwb3J0ZXI=\">tap-mocha-reporter</span> - Use any of the <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90YXAtbW9jaGEtcmVwb3J0ZXIvdHJlZS9tYXN0ZXIvbGliL3JlcG9ydGVycw==\">Mocha reporters</span>.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3pvdWJpbi90YXAtc3VtbWFyeQ==\">tap-summary</span> - Summarized output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NsdXgvdGFwLXBlc3NpbWlzdA==\">tap-pessimist</span> - Only shows failed tests.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Rvb2xuZXNzL3RhcC1wcmV0dGlmeQ==\">tap-prettify</span> - Nice readable output with diffing.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3RhcC1jb2xvcml6ZQ==\">tap-colorize</span> - Colorize the output while preserving machine-readability.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdydWJlci90YXAtYmFpbA==\">tap-bail</span> - Bail out when the first test fails.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F4cm9zcy90YXAtbm90aWZ5\">tap-notify</span> - Notifier for macOS, Linux and Windows.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2d1bW1lc3Nvbi90YXAtanNvbg==\">tap-json</span> - JSON output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3lvdmFzeDIvYXZhLXRhcC1qc29u\">ava-tap-json</span> - JSON output with AVA compatibility.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FnaGFzc2VtaS90YXAteHVuaXQ=\">tap-xunit</span> - xUnit output.</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Ntb2NrbGUvdGFwLXRlYW1jaXR5\">tap-teamcity</span> - Output for TeamCity.</li>\n</ul>\n<h4 id=\"快照功能\"><a href=\"#快照功能\" class=\"headerlink\" title=\"快照功能\"></a>快照功能</h4><p>ava自动进行项目测试快照，如果文件放置在<code>test</code>或者<code>tests</code>目录，则快照会放置在<code>snapshots</code>目录。如果测试放置在<code>__test__</code>目录，则快照放置在<code>__snapshots__</code>目录</p>\n<pre><code class=\"bash\">ava --update-snapshots\n</code></pre>\n<p>可以指定一个固定位置，以便在AVA的<code>package.json</code>配置中存储快照文件：</p>\n<p><strong>package.json：</strong></p>\n<pre><code class=\"javascripton\">&#123;\n     &quot;ava&quot;：&#123;\n         &quot;snapshotDir&quot;：&quot;自定义目录&quot;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"设置超时\"><a href=\"#设置超时\" class=\"headerlink\" title=\"设置超时\"></a>设置超时</h4><p>AVA中的超时行为与其他测试框架中的行为不同。AVA在每次测试后重置计时器，如果在指定的超时内没有收到新的测试结果，则强制测试退出。这可用于处理停滞的测试。</p>\n<p><em>没有默认超时。</em></p>\n<p>您可以配置使用超时<code>--timeout</code> 命令行选项，或配置文件中设置。它们可以以人类可读的方式设置：</p>\n<pre><code class=\"bash\"># 10秒\nnpx ava --timeout = 10s \n\n# 2分钟\nnpx ava --timeout = 2m \n\n# 100毫秒\nnpx ava --timeout = 100\n</code></pre>\n<p>还可以为每个测试单独设置超时。每次进行断言时都会重置这些超时。</p>\n<pre><code class=\"javascript\">test(&#39;foo&#39;, t =&gt; &#123;\n    t.timeout(100); // 100 milliseconds\n    // Write your assertions here\n&#125;);\n</code></pre>\n<h3 id=\"其他ava设置相关\"><a href=\"#其他ava设置相关\" class=\"headerlink\" title=\"其他ava设置相关\"></a>其他ava设置相关</h3><h4 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h4><p>如果使用了ESLint，请添加<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2VzbGludC1wbHVnaW4tYXZh\">eslint-plugin-ava</span></p>\n<pre><code class=\"javascripton\">&#123;\n    plugins: [\n        &quot;ava&quot;\n    ]\n&#125;\n</code></pre>\n<h4 id=\"异步相关\"><a href=\"#异步相关\" class=\"headerlink\" title=\"异步相关\"></a>异步相关</h4><p>如果异步操作使用promises，则应返回promise：</p>\n<pre><code class=\"javascript\">test(&#39;fetches foo&#39;, t =&gt; &#123;\n    return fetch().then(data =&gt; &#123;\n        t.is(data, &#39;foo&#39;);\n    &#125;);\n&#125;);\n</code></pre>\n<p>更好的是，使用<code>async</code>&#x2F; <code>await</code>：</p>\n<pre><code class=\"javascript\">test(&#39;fetches foo&#39;, async t =&gt; &#123;\n    const data = await fetch();\n    t.is(data, &#39;foo&#39;);\n&#125;);\n</code></pre>\n<h2 id=\"测试环境-amp-帮手Karma\"><a href=\"#测试环境-amp-帮手Karma\" class=\"headerlink\" title=\"测试环境&amp;帮手Karma\"></a>测试环境&amp;帮手Karma</h2><p>Karma 是一个基于 Node.js 的 JavaScript 测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流 Web 浏览器，也可以集成到 CI（Continuous integration）工具，还可以和其他代码编辑器一起使用。</p>\n<p>Karma 会监控配置文件中所指定的每一个文件，每当文件发生改变，它都会向测试服务器发送信号，来通知所有的浏览器再次运行测试代码。此时，浏览器会重新加载源文件，并执行测试代码。其结果会传递回服务器，并以某种形式显示给开发者。</p>\n<p>访问浏览器执行结果，可通过以下的方式</p>\n<ul>\n<li>手工方式 - 通过浏览器</li>\n<li>自动方式 - 让 karma 来启动对应的浏览器</li>\n</ul>\n<h3 id=\"工作原理简介\"><a href=\"#工作原理简介\" class=\"headerlink\" title=\"工作原理简介\"></a>工作原理简介</h3><p><code>karma</code> 是一个典型的 <code>C/S</code> 程序，包含 client 和 server ，通讯方式基于 <code>Http</code> ，通常情况下，客户端和服务端基本都运行在开发者本地机器上。</p>\n<p>一个服务端实例对应一个项目，假如想同时运行多个项目，得同时开启多个服务端实例。</p>\n<p><strong>Server</strong></p>\n<p><code>Server</code> 是框架的主要组成部分之一，它内部保存了所有的程序运行状态，比如 client 连接，当前运行的单测文件，根据这些数据状态，它提供了下面几个功能， 下图是 server 的结构</p>\n<p><img data-src=\"/assets/TB13X9xLXXXXXXoaXXXDUoU9pXX-902-329.png\" alt=\"karma_server\"></p>\n<ul>\n<li>监听文件</li>\n<li>与 client 进行通讯</li>\n<li>向开发者输出测试结果</li>\n<li>提供 client 端所需的资源文件</li>\n</ul>\n<p><strong>Client</strong></p>\n<p>client 是单测最终运行的地方，类似一个 web app ， 跟 server 端通讯利用 <code>socket.io</code>， 执行单测在一个独立的 <code>iframe</code> 中。下面是它的结构图</p>\n<p><img data-src=\"/assets/TB1jTKwLXXXXXX.aXXX0KhCSFXX-619-472.png\" alt=\"karma_impl_client\"></p>\n<p>client 和 server 端通讯采用 <code>socket.io</code></p>\n<ul>\n<li>client 端会发送这些消息</li>\n</ul>\n<p><img data-src=\"/assets/TB1XXuILXXXXXcAXFXX.hdJKpXX-918-179.png\" alt=\"karma_impl_client_message_c\"></p>\n<ul>\n<li>server 端会发送这些消息</li>\n</ul>\n<p><img data-src=\"/assets/TB1PvisLXXXXXcqaXXXEHlCNpXX-896-103.png\" alt=\"karma_impl_client_message_s\"></p>\n<h3 id=\"安装Karma\"><a href=\"#安装Karma\" class=\"headerlink\" title=\"安装Karma\"></a>安装Karma</h3><p>对于Nodejs版本的要求：</p>\n<blockquote>\n<p>Karma currently works on Node.js <strong>6.x</strong>, <strong>8.x</strong>, and <strong>10.x</strong>. See <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLzQuMC9pbnRyby9mYXEuaHRtbA==\">FAQ</span> for more info.</p>\n</blockquote>\n<ol>\n<li><p>全局安装</p>\n<pre><code>$npm install -g karma\n</code></pre>\n<p>安装 Karma 命令会到全局的 <code>node_modules</code> 目录下，我们可以在任何位置直接运行 karma 命令。</p>\n<pre><code>npm install -g karma-cli\n</code></pre>\n<p>此命令用来安装 <code>karma-cli</code>，它会在当前目录下寻找 karma 的可执行文件。这样我们就可以在一个系统内运行多个版本的 Karma。</p>\n</li>\n<li><p>本地安装</p>\n<pre><code>$ npm install karma --save-dev\n</code></pre>\n<p>安装 Karma 命令到当前 <code>node_modules</code> 目录下，此时，如果需要执行 karma 命令，就需要这样 </p>\n<pre><code>./node_modules/.bin/karma\n\nnpx karma --version\n</code></pre>\n</li>\n</ol>\n<h3 id=\"配置Karma\"><a href=\"#配置Karma\" class=\"headerlink\" title=\"配置Karma\"></a>配置Karma</h3><p>karma配置文件可以用JavaScript，CoffeeScript或TypeScript编写，并作为常规Node.js模块加载。</p>\n<p>除非作为参数提供，否则Karma CLI将在以下位置以该顺序(从上至下)查找配置文件</p>\n<ul>\n<li><code>./karma.conf.js</code></li>\n<li><code>./karma.conf.coffee</code></li>\n<li><code>./karma.conf.ts</code></li>\n<li><code>./.config/karma.conf.js</code></li>\n<li><code>./.config/karma.conf.coffee</code></li>\n<li><code>./.config/karma.conf.ts</code></li>\n</ul>\n<p>在配置文件中，配置代码通过设置<code>module.exports</code>指向一个接受一个参数的函数：配置对象。</p>\n<pre><code class=\"javascript\">// karma.conf.js\nmodule.exports = function(config) &#123;\n  config.set(&#123;\n    basePath: &#39;../..&#39;,\n    frameworks: [&#39;jasmine&#39;],\n    //...\n  &#125;);\n&#125;;\n# karma.conf.coffee\nmodule.exports = (config) -&gt;\n  config.set\n    basePath: &#39;../..&#39;\n    frameworks: [&#39;jasmine&#39;]\n    # ...\n// karma.conf.ts\nmodule.exports = (config) =&gt; &#123;\n  config.set(&#123;\n    basePath: &#39;../..&#39;,\n    frameworks: [&#39;jasmine&#39;],\n    //...\n  &#125;);\n&#125;\n</code></pre>\n<blockquote>\n<p>关于typescript的支持，需要使用到<code>ts-node</code>，配置ts-node以使用<code>commonjs</code>模块格</p>\n</blockquote>\n<p>配置文件中的基本的属性介绍：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rYXJtYS1ydW5uZXIuZ2l0aHViLmlvLzQuMC9jb25maWcvY29uZmlndXJhdGlvbi1maWxlLmh0bWw=\">Overview</span></p>\n<p>使用CLI工具，快速创建配置</p>\n<p>开始配置</p>\n<pre><code class=\"bash\">~/Downloads/Demo is 📦 v1.0.0 via ⬢ v10.16.0 \n➜ npx karma init\n\n# 如果在应用中用到了其它的测试框架，那就需要我们安装它们所对应的插件，并在配置文件中标注它们（详见 karma.conf.js 中的 plugins 项）\nWhich testing framework do you want to use ?\nPress tab to list possible options. Enter to move to the next question.\n&gt; jasmine\n# mocha\n# qunit\n# nodeunit\n# nunit\n\n# Require.js 是异步加载规范（AMD）的实现。常被作为基础代码库，应用在了很多的项目与框架之中，例如 Dojo, AngularJs 等\nDo you want to use Require.js ?\nThis will add Require.js plugin.\nPress tab to list possible options. Enter to move to the next question.\n&gt; no\n# yes\n\n# 选择需要运行测试用例的浏览器。需要注意的就是，必须保证所对应的浏览器插件已经安装成功。\nDo you want to capture any browsers automatically ?\nPress tab to list possible options. Enter empty string to move to the next question.\n&gt; Chrome\n# ChromeHeadless\n# ChromeCanary\n# Firefox\n# Safari\n# PhantomJS\n# Opera\n# IE\n\n# 选择测试用例所在的目录位置。Karma 支持通配符的方式配置文件或目录，例如 *.js, test/**/*.js 等。如果目录或文件使用相对位置，要清楚地是，此时的路径是相对于当前运行 karma 命令时所在的目录。\nWhat is the location of your source and test files ?\nYou can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.\nEnter empty string to move to the next question.\n&gt; src/*js\n\n# 目录中不包括的那些文件。\nShould any of the files included by the previous patterns be excluded ?\nYou can use glob patterns, eg. &quot;**/*.swp&quot;.\nEnter empty string to move to the next question.\n\n# 是否需要 Karma 自动监听文件？并且文件一旦被修改，就重新运行测试用例？\nDo you want Karma to watch all the files and run the tests on change ?\nPress tab to list possible options.\n&gt; yes\n</code></pre>\n<p>生成了一个<code>karma.conf.js</code>文件：</p>\n<pre><code class=\"javascript\">// Karma configuration\n// Generated on Wed Jul 10 2019 22:46:32 GMT+0800 (GMT+08:00)\n\nmodule.exports = function(config) &#123;\n  config.set(&#123;\n\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: &#39;&#39;,\n\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [&#39;mocha&#39;],\n\n\n    // list of files / patterns to load in the browser\n    files: [\n      &#39;src/*js&#39;\n    ],\n\n\n    // list of files / patterns to exclude\n    exclude: [\n    ],\n\n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: &#123;\n    &#125;,\n\n\n    // test results reporter to use\n    // possible values: &#39;dots&#39;, &#39;progress&#39;\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n    reporters: [&#39;progress&#39;],\n\n\n    // web server port\n    port: 9876,\n\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_INFO,\n\n\n    // enable / disable watching file and executing tests whenever any file changes\n    autoWatch: true,\n\n\n    // start these browsers\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n    browsers: [&#39;Chrome&#39;],\n\n\n    // Continuous Integration mode\n    // if true, Karma captures browsers, runs the tests and exits\n    singleRun: false,\n\n    // Concurrency level\n    // how many browser should be started simultaneous\n    concurrency: Infinity\n  &#125;)\n&#125;\n</code></pre>\n<h3 id=\"karma示例\"><a href=\"#karma示例\" class=\"headerlink\" title=\"karma示例\"></a>karma示例</h3><p>目标 ：</p>\n<ul>\n<li>babel支持，ES6语法支持</li>\n<li>mocha与chai支持</li>\n<li>karma与chrome、webpack对接</li>\n</ul>\n<p>说明：</p>\n<p>Karma对babel支持的，一个可选项：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2thcm1hLWJhYmVsLXByZXByb2Nlc3Nvcg==\">karma-babel-preprocessor</span>，但是：</p>\n<blockquote>\n<p>babel and karma-babel-preprocessor only convert ES6 modules to CommonJS&#x2F;AMD&#x2F;SystemJS&#x2F;UMD**. If you choose CommonJS, you still need to resolve and concatenate CommonJS modules on your own**. We recommend <strong>karma-browserify + babelify</strong> or <strong>webpack + babel-loader</strong> in such cases.</p>\n</blockquote>\n<p>所以，我们选择了webpack</p>\n<ol>\n<li><p>安装依赖</p>\n<pre><code>npm install @babel/core @babel/preset-env chai mocha webpack webpack-cli babel-loader -D\n</code></pre>\n</li>\n<li><p>安装karma的适配器</p>\n<pre><code>npm install karma-webpack karma-chrome-launcher karma-mocha karma-chai -D\n</code></pre>\n</li>\n<li><p>配置<code>karma.config.js</code></p>\n<pre><code class=\"javascript\">// Karma configuration\n// Generated on Thu Jul 11 2019 23:23:44 GMT+0800 (GMT+08:00)\n\nmodule.exports = function (config) &#123;\n  config.set(&#123;\n\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: &#39;&#39;,\n\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [&#39;mocha&#39;],\n\n\n    // list of files / patterns to load in the browser\n    files: [\n      &#39;src/**/*.js&#39;,\n      &#39;test/**/*.js&#39;\n    ],\n\n \n    // ....\n    \n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: &#123;\n      &#39;src/**/*.js&#39;: [&#39;webpack&#39;],\n      &#39;test/**/*.js&#39;: [&#39;webpack&#39;]\n    &#125;,\n\n    webpack: &#123;\n      mode: &quot;none&quot;,\n      node: &#123;\n        fs: &#39;empty&#39;\n      &#125;,\n      module: &#123;\n        rules: [\n          &#123; test: /\\.js?$/, loader: &quot;babel-loader&quot;, options: &#123; presets: [&quot;@babel/env&quot;] &#125;, &#125;\n        ]\n      &#125;\n    &#125;,\n \n    // ....\n    \n    plugins: [\n      &#39;karma-mocha&#39;,\n      &#39;karma-chai&#39;,\n      &#39;karma-chrome-launcher&#39;,\n      &#39;karma-webpack&#39;\n    ]\n  &#125;)\n&#125;\n</code></pre>\n</li>\n<li><p>书写测试用例<code>test.js</code>：</p>\n<pre><code class=\"javascript\">import &#123; describe &#125; from &quot;mocha&quot;;\nimport &#123; expect &#125; from &#39;chai&#39;\n\ndescribe(&#39;first test&#39;, () =&gt; &#123;\n  it(&#39;hello mocha and karma&#39;, () =&gt; &#123;\n    console.log(&#39;hello mocha&#39;)\n    expect(true).to.be.equal(true)\n  &#125;)\n&#125;)\n</code></pre>\n</li>\n<li><p>开始测试：</p>\n<pre><code class=\"bash\">npx karma start\n</code></pre>\n<p>添加到<code>package.json</code></p>\n<pre><code class=\"javascripton\">&quot;scripts&quot;: &#123;\n  &quot;karma&quot;: &quot;karma start&quot;\n&#125;,\n</code></pre>\n<p>然后使用，<code>npm run karma</code></p>\n<pre><code class=\"bash\">➜ npx karma start\nℹ ｢wdm｣: Hash: 9d2c943b68425fd58dd0\nVersion: webpack 4.35.3\nTime: 53ms\nBuilt at: 2019-07-12 5:07:49 PM\nℹ ｢wdm｣: Compiled successfully.\nℹ ｢wdm｣: Compiling...\n⚠ ｢wdm｣: Hash: cca8316f4bd5855fc4de\nVersion: webpack 4.35.3\nTime: 2414ms\nBuilt at: 2019-07-12 5:07:52 PM\n       Asset      Size  Chunks             Chunk Names\nsrc/index.js  3.62 KiB       0  [emitted]  src/index\ntest/test.js  1010 KiB       1  [emitted]  test/test\nEntrypoint src/index = src/index.js\nEntrypoint test/test = test/test.js\n  [0] ./src/index.js 27 bytes &#123;0&#125; [built]\n  [1] ./test/test.js 223 bytes &#123;1&#125; [built]\n  [2] ./node_modules/mocha/browser-entry.js 4.19 KiB &#123;1&#125; [built]\n  [3] ./node_modules/process/browser.js 4.96 KiB &#123;1&#125; [built]\n  [4] (webpack)/buildin/global.js 878 bytes &#123;1&#125; [built]\n  [5] ./node_modules/browser-stdout/index.js 662 bytes &#123;1&#125; [built]\n  [6] ./node_modules/stream-browserify/index.js 3.53 KiB &#123;1&#125; [built]\n [36] ./node_modules/util/util.js 19 KiB &#123;1&#125; [built]\n [38] ./node_modules/mocha/lib/mocha.js 21.8 KiB &#123;1&#125; [built]\n [39] (webpack)/buildin/module.js 552 bytes &#123;1&#125; [built]\n [40] ./node_modules/escape-string-regexp/index.js 230 bytes &#123;1&#125; [built]\n [41] path (ignored) 15 bytes &#123;1&#125; [built]\n [42] ./node_modules/mocha/lib/reporters/index.js 945 bytes &#123;1&#125; [built]\n[105] ./node_modules/chai/index.js 39 bytes &#123;1&#125; [built]\n[106] ./node_modules/chai/lib/chai.js 1.22 KiB &#123;1&#125; [built]\n    + 128 hidden modules\n\nWARNING in ./node_modules/mocha/lib/mocha.js 217:20-37\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 222:24-70\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 266:24-35\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 313:35-48\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 329:23-44\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\nℹ ｢wdm｣: Compiled with warnings.\n12 07 2019 17:07:52.761:WARN [karma]: No captured browser, open http://localhost:9876/\n12 07 2019 17:07:52.770:INFO [karma-server]: Karma v4.1.0 server started at http://0.0.0.0:9876/\n12 07 2019 17:07:52.770:INFO [launcher]: Launching browsers Chrome with concurrency unlimited\n12 07 2019 17:07:52.773:INFO [launcher]: Starting browser Chrome\n12 07 2019 17:07:54.135:INFO [Chrome 75.0.3770 (Mac OS X 10.14.5)]: Connected on socket R9R31QB1GtR_kayNAAAA with id 55412577\nChrome 75.0.3770 (Mac OS X 10.14.5) LOG: &#39;hello karma&#39;\n\nLOG: &#39;hello mocha&#39;\nChrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0 secs / 0.001 secs\n~/Downloads/karma-demo is 📦 v1.0.0 via ⬢ v10.16.0 \n➜ npm run karma\n\n&gt; karma-demo@1.0.0 karma /Users/itheima/Downloads/karma-demo\n&gt; karma start\n\nℹ ｢wdm｣: Hash: 9d2c943b68425fd58dd0\nVersion: webpack 4.35.3\nTime: 48ms\nBuilt at: 2019-07-12 5:24:02 PM\nℹ ｢wdm｣: Compiled successfully.\nℹ ｢wdm｣: Compiling...\n⚠ ｢wdm｣: Hash: cca8316f4bd5855fc4de\nVersion: webpack 4.35.3\nTime: 2307ms\nBuilt at: 2019-07-12 5:24:04 PM\n       Asset      Size  Chunks             Chunk Names\nsrc/index.js  3.62 KiB       0  [emitted]  src/index\ntest/test.js  1010 KiB       1  [emitted]  test/test\nEntrypoint src/index = src/index.js\nEntrypoint test/test = test/test.js\n  [0] ./src/index.js 27 bytes &#123;0&#125; [built]\n  [1] ./test/test.js 223 bytes &#123;1&#125; [built]\n  [2] ./node_modules/mocha/browser-entry.js 4.19 KiB &#123;1&#125; [built]\n  [3] ./node_modules/process/browser.js 4.96 KiB &#123;1&#125; [built]\n  [4] (webpack)/buildin/global.js 878 bytes &#123;1&#125; [built]\n  [5] ./node_modules/browser-stdout/index.js 662 bytes &#123;1&#125; [built]\n  [6] ./node_modules/stream-browserify/index.js 3.53 KiB &#123;1&#125; [built]\n [36] ./node_modules/util/util.js 19 KiB &#123;1&#125; [built]\n [38] ./node_modules/mocha/lib/mocha.js 21.8 KiB &#123;1&#125; [built]\n [39] (webpack)/buildin/module.js 552 bytes &#123;1&#125; [built]\n [40] ./node_modules/escape-string-regexp/index.js 230 bytes &#123;1&#125; [built]\n [41] path (ignored) 15 bytes &#123;1&#125; [built]\n [42] ./node_modules/mocha/lib/reporters/index.js 945 bytes &#123;1&#125; [built]\n[105] ./node_modules/chai/index.js 39 bytes &#123;1&#125; [built]\n[106] ./node_modules/chai/lib/chai.js 1.22 KiB &#123;1&#125; [built]\n    + 128 hidden modules\n\nWARNING in ./node_modules/mocha/lib/mocha.js 217:20-37\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 222:24-70\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 266:24-35\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 313:35-48\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\n\nWARNING in ./node_modules/mocha/lib/mocha.js 329:23-44\nCritical dependency: the request of a dependency is an expression\n @ ./node_modules/mocha/browser-entry.js\n @ ./test/test.js\nℹ ｢wdm｣: Compiled with warnings.\n12 07 2019 17:24:04.905:WARN [karma]: No captured browser, open http://localhost:9876/\n12 07 2019 17:24:04.914:INFO [karma-server]: Karma v4.1.0 server started at http://0.0.0.0:9876/\n12 07 2019 17:24:04.914:INFO [launcher]: Launching browsers Chrome with concurrency unlimited\n12 07 2019 17:24:04.922:INFO [launcher]: Starting browser Chrome\n12 07 2019 17:24:06.289:INFO [Chrome 75.0.3770 (Mac OS X 10.14.5)]: Connected on socket EbCCSbQRPbxHbq3OAAAA with id 92342032\nChrome 75.0.3770 (Mac OS X 10.14.5) LOG: &#39;hello karma&#39;\n\nLOG: &#39;hello mocha&#39;\nChrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0 secs / 0.001 secs\nChrome 75.0.3770 (Mac OS X 10.14.5): Executed 1 of 1 SUCCESS (0.006 secs / 0.001 \nsecs)\nTOTAL: 1 SUCCESS\n</code></pre>\n</li>\n</ol>\n<h2 id=\"UI测试利器Nightmare\"><a href=\"#UI测试利器Nightmare\" class=\"headerlink\" title=\"UI测试利器Nightmare\"></a>UI测试利器Nightmare</h2><p>Nightmare是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50LmNvbS8=\">Segment</span>的高级浏览器自动化库。</p>\n<p>目标是公开一些模仿用户操作（例如<code>goto</code>，<code>type</code>和<code>click</code>）的简单方法，使用对每个脚本块感觉同步的API，而不是深层嵌套的回调。它最初设计用于在没有API的站点之间自动执行任务，但最常用于UI测试和爬网。</p>\n<p>它使用<span class=\"exturl\" data-url=\"aHR0cDovL2VsZWN0cm9uLmF0b20uaW8v\">Electron</span>，它与<span class=\"exturl\" data-url=\"aHR0cDovL3BoYW50b21qcy5vcmcv\">PhantomJS</span>类似，但大约<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUvaXNzdWVzLzQ4NCNpc3N1ZWNvbW1lbnQtMTg0NTE5NTkx\">快两倍</span>，更现代。</p>\n<h3 id=\"安装与起步\"><a href=\"#安装与起步\" class=\"headerlink\" title=\"安装与起步\"></a>安装与起步</h3><ol>\n<li><p>安装<code>nightmare</code></p>\n</li>\n<li><pre><code>// 初始化项目\nnpm init -y\n\nnpm install --save-dev nightmare\n</code></pre>\n</li>\n</ol>\n<p>npm install –save-dev mocha</p>\n<pre><code>\n2. 淘宝源加速\n</code></pre>\n<p>   &#x2F;&#x2F; 使用淘宝源加速electron的安装<br>   export ELECTRON_MIRROR&#x3D;”<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2VsZWN0cm9uLw==\">https://npm.taobao.org/mirrors/electron/</span>“</p>\n<pre><code>\n3. 起步测试：\n\n```javascript\nconst Nightmare = require(&#39;nightmare&#39;)\nconst assert = require(&#39;assert&#39;)\n\ndescribe(&#39;Load a Page&#39;, function () &#123;\n  // Recommended: 5s locally, 10s to remote server, 30s from airplane ¯\\_(ツ)_/¯\n  this.timeout(&#39;30s&#39;)\n\n  let nightmare = null\n  beforeEach(() =&gt; &#123;\n    nightmare = new Nightmare()\n  &#125;)\n\n  describe(&#39;/ (Home Page)&#39;, () =&gt; &#123;\n    it(&#39;should load without error&#39;, done =&gt; &#123;\n      // your actual testing urls will likely be `http://localhost:port/path`\n      nightmare.goto(&#39;https://www.baidu.com&#39;)\n        .end()\n        .then(function (result) &#123;\n          done()\n        &#125;)\n        .catch(done)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n<h3 id=\"nightmare配合mocha测试\"><a href=\"#nightmare配合mocha测试\" class=\"headerlink\" title=\"nightmare配合mocha测试\"></a>nightmare配合mocha测试</h3><p>nightmare可以进行网页的抓取，配合mocha进行页面的测试：</p>\n<p>安装<code>mocha</code></p>\n<pre><code class=\"bash\">npm install --save-dev mocha\n</code></pre>\n<blockquote>\n<p>还可以安装一些断言库，如：<code>chai</code></p>\n</blockquote>\n<p>新建测试：</p>\n<pre><code class=\"javascript\">const Nightmare = require(&#39;nightmare&#39;)\nconst assert = require(&#39;assert&#39;)\n\ndescribe(&#39;Search nightmare&#39;, () =&gt; &#123;\n  this.timeout(&#39;30s&#39;)\n\n  let nightmare = null\n  \n  beforeEach(() =&gt; &#123;\n    nightmare = new Nightmare()\n  &#125;)\n\n  it(&#39;should load with result nightmare&#39;, done =&gt; &#123;\n    const selector = &#39;em&#39;\n    nightmare.goto(&#39;https://www.baidu.com&#39;)\n      .type(&#39;#kw&#39;, &#39;nightmare&#39;)\n      .click(&#39;#su&#39;)\n      .wait(&#39;em&#39;)\n      .evaluate(selector =&gt; &#123;\n      // now we&#39;re executing inside the browser scope.\n      return document.querySelector(selector).innerText\n    &#125;, selector) // &lt;-- that&#39;s how you pass parameters from Node scope to browser scope\n      .end()\n      .then(function (result) &#123;\n      console.log(result)\n      assert.equal(result, &#39;nightmare&#39;)\n      done()\n    &#125;)\n      .catch(done)\n  &#125;)\n&#125;)\n</code></pre>\n<p>将mocha作为测试脚本添加到您的  <code>package.json</code>：</p>\n<pre><code class=\"javascripton\">&quot;scripts&quot;: &#123;\n  &quot;test&quot;: &quot;mocha&quot;\n&#125;\n</code></pre>\n<h3 id=\"API介绍\"><a href=\"#API介绍\" class=\"headerlink\" title=\"API介绍\"></a>API介绍</h3><h4 id=\"nightmare的配置项\"><a href=\"#nightmare的配置项\" class=\"headerlink\" title=\"nightmare的配置项\"></a>nightmare的配置项</h4><pre><code>waitTimeout (default: 30s)\ngotoTimeout (default: 30s)\nloadTimeout (default: infinite)\nexecutionTimeout (default: 30s)\npaths\nswitches\nelectronPath\ndock\nopenDevTools\ntypeInterval (default: 100ms)\npollInterval (default: 250ms)\nmaxAuthRetries (default: 3)\ncertificateSubjectName\n.engineVersions()\n.useragent(useragent)\n.authentication(user, password)\n.authentication(user, password)\n.halt(error, done)\n</code></pre>\n<p>配置链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjbmlnaHRtYXJlb3B0aW9ucw==\">https://github.com/segmentio/nightmare#nightmareoptions</span></p>\n<h4 id=\"页面交互相关\"><a href=\"#页面交互相关\" class=\"headerlink\" title=\"页面交互相关\"></a>页面交互相关</h4><pre><code>.back()\n.forward()\n.refresh()\n.click(selector)\n.mousedown(selector)\n.mouseup(selector)\n.mouseover(selector)\n.mouseout(selector)\n.type(selector[, text])\n.insert(selector[, text])\n.check(selector)\n.uncheck(selector)\n.select(selector, option)\n.scrollTo(top, left)\n.viewport(width, height)\n.inject(type, file)\n.evaluate(fn[, arg1, arg2,...])\n.wait(ms)\n.wait(selector)\n.wait(fn[, arg1, arg2,...])\n.header(header, value)\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjaW50ZXJhY3Qtd2l0aC10aGUtcGFnZQ==\">配置参考链接</span></p>\n<h4 id=\"页面提取\"><a href=\"#页面提取\" class=\"headerlink\" title=\"页面提取\"></a>页面提取</h4><pre><code>.exists(selector)\n.visible(selector)\n.on(event, callback)\n.once(event, callback)\n.removeListener(event, callback)\n.screenshot([path][, clip])\n.html(path, saveType)\n.pdf(path, options)\n.title()\n.url()\n.path()\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9uaWdodG1hcmUjZXh0cmFjdC1mcm9tLXRoZS1wYWdl\">配置参考链接</span></p>\n<h2 id=\"补充学习\"><a href=\"#补充学习\" class=\"headerlink\" title=\"补充学习\"></a>补充学习</h2><h3 id=\"补充资料\"><a href=\"#补充资料\" class=\"headerlink\" title=\"补充资料\"></a>补充资料</h3><h4 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h4><p><strong>第一部分：软件测试的分类</strong></p>\n<ul>\n<li><p>按测试执行阶段划分</p>\n<p>单元测试、集成测试、系统测试、验收测试（正式验收测试、Alpha测试、Beta测试）</p>\n</li>\n<li><p>按测试技术划分</p>\n<p>白盒测试、黑盒测试、灰盒测试</p>\n</li>\n<li><p>被测试对象是否运行划分</p>\n<p>动态测试、静态测试（文档检查、代码走查、界面检查）</p>\n</li>\n<li><p>按不同的测试手段划分</p>\n<p>手工测试、自动化测试</p>\n</li>\n<li><p>按测试包含的内容划分</p>\n<p>功能测试、界面测试、安全测试、兼容性测试、易用性测试、性能测试、压力测试、负载测试、恢复测试</p>\n</li>\n<li><p>其他测试</p>\n<p>冒烟测试、回归测试、探索性测试&#x2F;自由测试（测试思维）</p>\n</li>\n</ul>\n<p><strong>第二部分：接下来对软件测试分类进行一个说明</strong></p>\n<p><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-889a2848a1b2a8eeccae000be23c247a_hd.jpg\" alt=\"img\"></p>\n<p><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-f831b8041976b50aad7c2425aada44e2_hd-1561454378198.jpg\" alt=\"img\"><img data-src=\"/../../5-2%20%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%9B%91%E6%B5%8B/resource/assets/v2-f831b8041976b50aad7c2425aada44e2_hd.jpg\" alt=\"img\"></p>\n<p><strong>第三部分：测试工具</strong></p>\n<p>SVN，Git——&gt;版本控制管理工具</p>\n<p>禅道——&gt;Bug管理工具</p>\n<p>Fiddler——&gt;抓包，定位问题你</p>\n<p>postman，jmeter，soapui——&gt;接口测试</p>\n<p>Loadrunner，Jmeter——&gt;性能，压力测试</p>\n<h4 id=\"2019年Javascript测试概览\"><a href=\"#2019年Javascript测试概览\" class=\"headerlink\" title=\"2019年Javascript测试概览\"></a>2019年Javascript测试概览</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL3dlbGxkb25lLXNvZnR3YXJlL2FuLW92ZXJ2aWV3LW9mLWphdmFzY3JpcHQtdGVzdGluZy1pbi0yMDE5LTI2NGUxOTUxNGQwYQ==\">https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2019-264e19514d0a</span></p>\n<p>这是一篇非常好的国外的博文，同时也是2018年Javascript测试概览的作者。这里有2018年的译文：</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjcwMjQyMQ==\">展望 2018 年 JavaScript Testing</span></p>\n<p>在文中很好介绍到了测试类型，并举了大量的例子，非常全面。</p>\n<h4 id=\"什么是TDD？\"><a href=\"#什么是TDD？\" class=\"headerlink\" title=\"什么是TDD？\"></a>什么是TDD？</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzNlNzM4NzZmYjlhMDQ5ZDM3ZjVkYjE=\">测试驱动开发（TDD）总结——原理篇</span></p>\n<p>TDD （Test Driven Development） 在不同的圈子、不同的角色的认知中可能会有不同的理解，有人可能会理解成 ATDD（Acceptance Test Driven Development），也有人可能会理解成 UTDD（Unit Test Driven Development），为了避免产生歧义，<strong>文章涉及到 TDD 专指 UTDD（Unit Test Driven Development），即 「单元测试驱动开发」</strong>。</p>\n<p>TDD 的目标</p>\n<blockquote>\n<p>Kent Beck 在他的著作《Test-Driven Development》一书中提到：“<strong>代码简洁可用</strong>这句言简意赅的话，正是 TDD 所追求的目标”。</p>\n</blockquote>\n<p><strong>对于如何保证“代码简洁可用”可以使用分而治之的方法，先达到“可用”目标，再追求“简洁”目标。</strong></p>\n<p><strong>可用：</strong> 保证代码通过自动化测试。</p>\n<p><strong>代码简洁：</strong> 在不同阶段人们对简洁的理解程度也不一样，不过遵循的原则差不多，例如 OOD 的 SOLID 原则，Kent Beck 的 Simple Design 原则等。</p>\n<p>虽然有很多因素妨碍我们得到整洁的代码，甚至可用的代码，无需征求太多意见，只需要采用 TDD 的开发方式来驱动出简洁可用的代码。</p>\n<h4 id=\"Karma的前世今生\"><a href=\"#Karma的前世今生\" class=\"headerlink\" title=\"Karma的前世今生\"></a>Karma的前世今生</h4><p>2016年的文章，由淘宝前端团队书写：<span class=\"exturl\" data-url=\"aHR0cDovL3Rhb2Jhb2ZlZC5vcmcvYmxvZy8yMDE2LzAxLzA4L2thcm1hLW9yaWdpbi8=\">http://taobaofed.org/blog/2016/01/08/karma-origin/</span></p>\n<p>通篇介绍了karma的工作原理及实现原理，非常有价值的文章。</p>\n<h3 id=\"ava框架的配置文件\"><a href=\"#ava框架的配置文件\" class=\"headerlink\" title=\"ava框架的配置文件\"></a>ava框架的配置文件</h3><pre><code class=\"javascripton\">&#123;\n    &quot;ava&quot;: &#123;\n        &quot;files&quot;: [\n            &quot;test/**/*&quot;,\n            &quot;!test/exclude-files-in-this-directory&quot;,\n            &quot;!**/exclude-files-with-this-name.*&quot;\n        ],\n        &quot;helpers&quot;: [\n            &quot;**/helpers/**/*&quot;\n        ],\n        &quot;sources&quot;: [\n            &quot;src/**/*&quot;\n        ],\n        &quot;match&quot;: [\n            &quot;*oo&quot;,\n            &quot;!foo&quot;\n        ],\n        &quot;cache&quot;: true,\n        &quot;concurrency&quot;: 5,\n        &quot;failFast&quot;: true,\n        &quot;failWithoutAssertions&quot;: false,\n        &quot;environmentVariables&quot;: &#123;\n            &quot;MY_ENVIRONMENT_VARIABLE&quot;: &quot;some value&quot;\n        &#125;,\n        &quot;tap&quot;: true,\n        &quot;verbose&quot;: true,\n        &quot;compileEnhancements&quot;: false,\n        &quot;require&quot;: [\n            &quot;@babel/register&quot;\n        ],\n        &quot;babel&quot;: &#123;\n            &quot;extensions&quot;: [&quot;js&quot;, &quot;jsx&quot;],\n            &quot;testOptions&quot;: &#123;\n                &quot;babelrc&quot;: false\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li><code>files</code>：用于选择测试文件的glob模式数组。带有下划线前缀的文件将被忽略。默认情况下，仅选择具有<code>js</code>扩展名的文件，即使该模式与其他文件匹配。指定<code>extensions</code>并<code>babel.extensions</code>允许其他文件扩展名</li>\n<li><code>helpers</code>：用于选择帮助文件的glob模式数组。这里匹配的文件永远不会被视为测试。默认情况下，仅选择具有<code>js</code>扩展名的文件，即使该模式与其他文件匹配。指定<code>extensions</code>并<code>babel.extensions</code>允许其他文件扩展名</li>\n<li><code>sources</code>：一组glob模式，用于匹配文件，这些文件在更改时会导致重新运行测试（在监视模式下）。有关详细信息，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzL3JlY2lwZXMvd2F0Y2gtbW9kZS5tZCNzb3VyY2UtZmlsZXMtYW5kLXRlc3QtZmlsZXM=\">请参阅</span></li>\n<li><code>match</code>：通常在<code>package.json</code>配置中没用，但等同于在CLI上指定<code>--match</code></li>\n<li><code>cache</code>：缓存编译的测试和帮助文件<code>node_modules/.cache/ava</code>。如果<code>false</code>，文件缓存在临时目录中</li>\n<li><code>failFast</code>：一旦测试失败，停止运行进一步的测试</li>\n<li><code>failWithoutAssertions</code>：如果设置成<code>false</code>，那么如果没有运行断言，则测试失败</li>\n<li><code>environmentVariables</code>：指定要供测试使用的环境变量。此处定义的环境变量会覆盖其中的环境变量<code>process.env</code></li>\n<li><code>tap</code>：设置成 <code>true</code>，启用TAP报告</li>\n<li><code>verbose</code>：设置成 <code>true</code>，启用详细输出</li>\n<li><code>snapshotDir</code>：指定用于存储快照文件的固定位置。如果快照最终位于错误的位置，请使用此选项</li>\n<li><code>compileEnhancements</code>：设置成 <code>false</code>，禁用了 <a href=\"https://github.com/avajs/ava/blob/master/docs/03-assertions.md#enhanced-assertion-messages\"><code>power-assert</code></a>，否则有助于提供更具描述性的错误消息， 并检测<code>t.throws()</code>断言的不当使用</li>\n<li><code>extensions</code>：未使用AVA的Babel预设进行预编译的测试文件的扩展名。请注意，文件仍然会被编译为启用<code>power-assert</code>和其他功能，因此您可能还需要设置<code>compileEnhancements</code>为<code>false</code>文件是否为有效的JavaScript。设置此<code>&quot;js&quot;</code>值会覆盖默认值，因此请确保在列表中包含该扩展名，只要它不包含在内<code>babel.extensions</code></li>\n<li><code>require</code>：在运行测试之前需要额外的模块。工作进程中需要模块</li>\n<li><code>babel</code>：测试文件特定的Babel选项。有关详细信息，请参阅<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzL3JlY2lwZXMvYmFiZWwubWQjY29uZmlndXJpbmctYmFiZWw=\">Babel配置</span></li>\n<li><code>babel.extensions</code>：将使用AVA的Babel预设进行预编译的测试文件的扩展。设置此选项会覆盖默认<code>&quot;js&quot;</code>值，因此请确保在列表中包含该扩展名。</li>\n<li><code>timeout</code>：AVA中的超时行为与其他测试框架中的行为不同。AVA在每次测试后重置计时器，如果在指定的超时内没有收到新的测试结果，则强制测试退出。这可用于处理停滞的测试。请参阅我们的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F2YWpzL2F2YS9ibG9iL21hc3Rlci9kb2NzLzA3LXRlc3QtdGltZW91dHMubWQ=\">超时文档</span>以获取更多选</li>\n</ul>\n<p>请注意，在CLI上提供文件会覆盖该<code>files</code>选项。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NzAwOTY2NA==\">使用Jest测试JavaScript(Mock篇)</span></li>\n</ul>\n","categories":["自动化测试"],"tags":["自动化测试"]},{"title":"算法与数据结构","url":"/2023/12/02/%E7%AE%97%E6%B3%95/","content":"<h1 id=\"数据结构视频：\"><a href=\"#数据结构视频：\" class=\"headerlink\" title=\"数据结构视频：\"></a>数据结构视频：</h1><h1 id=\"栈：后进先出\"><a href=\"#栈：后进先出\" class=\"headerlink\" title=\"栈：后进先出\"></a>栈：后进先出</h1><p>（JS 中可以使用 array 模拟栈）</p>\n<p>【1】十进制转二进制【2】编辑器检查括号是否有效【3】JS 函数调用堆栈（相互调用的函数，最后一个函数先执行完） 、等等</p>\n<p>【练习：20 有效的括号】（栈）</p>\n<pre><code class=\"typescript\">function isValid(s: string): boolean &#123;\n  if (s.length % 2 === 1) return false;\n  const arr: Array&lt;string&gt; = [];\n  for (let i = 0; i &lt; s.length; i++) &#123;\n    if (s[i] === &quot;(&quot; || s[i] === &quot;&#123;&quot; || s[i] === &quot;[&quot;) &#123;\n      arr.push(s[i]);\n    &#125; else &#123;\n      if (\n        (arr[arr.length - 1] === &quot;(&quot; &amp;&amp; s[i] === &quot;)&quot;) ||\n        (arr[arr.length - 1] === &quot;[&quot; &amp;&amp; s[i] === &quot;]&quot;) ||\n        (arr[arr.length - 1] === &quot;&#123;&quot; &amp;&amp; s[i] === &quot;&#125;&quot;)\n      ) &#123;\n        arr.pop();\n      &#125; else &#123;\n        return false;\n      &#125;\n    &#125;\n  &#125;\n  return arr.length === 0;\n&#125;\n</code></pre>\n<h1 id=\"队列：先进先出\"><a href=\"#队列：先进先出\" class=\"headerlink\" title=\"队列：先进先出\"></a>队列：先进先出</h1><p>（JS 中可以使用 array 模拟队列）</p>\n<p>【1】排队打饭【2】JS 异步中的任务队列（JS 是单线程的）【3】计算最近请求次数</p>\n<p>【练习：请求最近的请求次数】（队列）</p>\n<pre><code class=\"typescript\">class RecentCounter &#123;\n  stack: number[] = [];\n  ping(t: number): number &#123;\n    this.stack.push(t);\n    while (t - this.stack[0] &gt; 3000) &#123;\n      this.stack.shift();\n    &#125;\n    return this.stack.length;\n  &#125;\n&#125;\n</code></pre>\n<h1 id=\"链表：非连续存储\"><a href=\"#链表：非连续存储\" class=\"headerlink\" title=\"链表：非连续存储\"></a>链表：非连续存储</h1><p>【1】JS 中的原型链（<strong>构造函数实例的</strong> proto <strong>指向构造函数的 prototype</strong> , 是一个链表）</p>\n<p>一、<strong>实例的原型(_ _ proto _ _)就是其构造函数的原型对象(prototype)</strong></p>\n<p>二、<strong>如果 A 沿着原型链能找到 B 的 prototype,那么 A instanceof B 为 true</strong></p>\n<p>三、<strong>如果在 A 对象上没有找到 x 属性，那么会沿着原型链找 x 属性</strong></p>\n<p>【面试题】</p>\n<p>一、instanceof 的原理，并使用代码实现</p>\n<pre><code class=\"javascript\">const instanceof1 = (A, B) =&gt; &#123;\n  let p = A;\n  while (p) &#123;\n    if (p === B.prototype) &#123;\n      return true;\n    &#125;\n    p = p.__proto__;\n  &#125;\n  return false;\n&#125;;\n</code></pre>\n<p>二、代码演示对象属性会沿着原型链进行查找</p>\n<pre><code class=\"javascript\">let foo = &#123;&#125;,\n  F = function () &#123;&#125;;\nObject.prototype.a = &quot;value a&quot;;\nFunction.prototype.b = &quot;value b&quot;;\nconsole.log(foo); //&#123;&#125;\nconsole.log(foo.a); //value a\nconsole.log(foo.b); //undefined\nconsole.log(F.a); //value a\nconsole.log(F.b); //value b\n</code></pre>\n<p>【原型链图解】<br><img data-src=\"/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"javascript\">obj.__proto__------Object.prototype-------null\nfunc.__proto__--------Function.prototype-------Object.prototype----------null\n（其中：func.__proto__.__proto__ === Object.prototype   ； func也是Object的实例（instanceof））\narr.__proto__ -------------Array.prototype---------Object.prototype---------null\n</code></pre>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A8.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【练习】（JS 中可以使用对象 object 模拟链表 ，值得注意的是：<strong>链表由于只给一个头节点，所以不知道链表的长度（一般使用 while 循环遍历）</strong>）</p>\n<p>【练习：237 删除链表中的节点】</p>\n<pre><code class=\"typescript\">function deleteNode(node: ListNode | null): void &#123;\n  //将下一个节点的值赋值给当前节点值（相当于移动）\n  node.val = node.next.val;\n  //跳过下一个节点（跳过的是下一个节点，效果是删除了当前节点）\n  node.next = node.next.next;\n&#125;\n</code></pre>\n<p>【练习：206 反转链表】（双指针）</p>\n<pre><code class=\"typescript\">//双指针法\nfunction reverseList(head: ListNode | null): ListNode | null &#123;\n  let p1: ListNode | null = head;\n  let p2: ListNode | null = null;\n  let tmp;\n  while (p1) &#123;\n    tmp = p1.next;\n    p1.next = p2;\n    p2 = p1;\n    p1 = tmp;\n  &#125;\n  return p2;\n&#125;\n</code></pre>\n<pre><code class=\"typescript\">//标志变量法\nlet pre;\nvar reverseList = function (head) &#123;\n  // 遍历节点,进行迭代\n  if (head === null) &#123;\n    const a = pre;\n    pre = undefined;\n    return a || head;\n  &#125;\n  const tem = head.next;\n  head.next = pre || null;\n  pre = head;\n  return reverseList(tem);\n&#125;;\n</code></pre>\n<p>【练习：2 两数相加】</p>\n<pre><code class=\"javascript\">var addTwoNumbers = function (l1, l2) &#123;\n  let l3 = new ListNode(0);\n  let p3 = l3;\n  let carry = 0;\n  while (l1 || l2) &#123;\n    const v1 = l1 ? l1.val : 0;\n    const v2 = l2 ? l2.val : 0;\n    const sum = v1 + v2 + carry;\n    carry = Math.floor(sum / 10);\n    p3.next = new ListNode(sum % 10);\n    if (l1) l1 = l1.next;\n    if (l2) l2 = l2.next;\n    p3 = p3.next;\n  &#125;\n  if (carry) &#123;\n    p3.next = new ListNode(carry);\n  &#125;\n  return l3.next;\n&#125;;\n</code></pre>\n<p>【练习：83 删除排序链表中的重复元素】</p>\n<pre><code class=\"javascript\">var deleteDuplicates = function (head) &#123;\n  let firstNode = head;\n  while (head &amp;&amp; head.next) &#123;\n    if (head.val == head.next.val) &#123;\n      head.next = head.next.next;\n    &#125; else &#123;\n      head = head.next;\n    &#125;\n  &#125;\n  return firstNode;\n&#125;;\n</code></pre>\n<p>【练习：141 环形链表】（快慢指针）</p>\n<p>注意链表由于只给一个头节点，所以不知道链表的长度，此时不能直接拿到最后一个节点，一直在遍历过程中时无法确定是由于链表太长尚未遍历完还是由于是环形链表。</p>\n<pre><code class=\"javascript\">//快慢指针\nvar hasCycle = function (head) &#123;\n  let p1 = head;\n  let p2 = head;\n  while (p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;\n    p1 = p1.next;\n    p2 = p2.next.next;\n    if (p1 === p2) &#123;\n      return true;\n    &#125;\n  &#125;\n  return false;\n&#125;;\n</code></pre>\n<h1 id=\"集合：无序且唯一\"><a href=\"#集合：无序且唯一\" class=\"headerlink\" title=\"集合：无序且唯一\"></a>集合：无序且唯一</h1><p>JS 中有 set 集合，内部有 has、add、delete、clear、entries、forEach、kyes、values、intersection（求交集）、difference（求非交集）、union（联合）等方法，可以用于数组去重等。</p>\n<p>【练习：349 两个数组的交集】</p>\n<pre><code class=\"javascript\">var intersection = function (nums1, nums2) &#123;\n  return [...new Set(nums1)].filter((item) =&gt; nums2.includes(item));\n&#125;;\n</code></pre>\n<p>【前端中的 set 集合】</p>\n<p>set 集合使用 for of 遍历（因为 set 集合中不包含属性）， 使用 Array.from 方法可以将 set 集合转为 array 数组，使用 new Set([])可以将数组转为 set 集合。</p>\n<h1 id=\"字典：键值对映射（键不重复）\"><a href=\"#字典：键值对映射（键不重复）\" class=\"headerlink\" title=\"字典：键值对映射（键不重复）\"></a>字典：键值对映射（键不重复）</h1><p>JS 中有 map 集合，内部有 set、delete 和 clear 等方法。</p>\n<p>【优化：349 两个数组的交集】</p>\n<p>此方法利用了 map 集合的特点（键不重复，还有数据量很小的情况下：map.get 方法的性能相比于 arr.includes 方法的性能更好）,此方法性能更好，时间复杂度为 O(n)或 O(m)</p>\n<pre><code class=\"javascript\">var intersection = function (nums1, nums2) &#123;\n  const res = [];\n  const map = new Map();\n  nums1.forEach((item) =&gt; &#123;\n    map.set(item, true);\n  &#125;);\n  nums2.forEach((item) =&gt; &#123;\n    if (map.get(item)) &#123;\n      res.push(item);\n      map.delete(item);\n    &#125;\n  &#125;);\n  return res;\n&#125;;\n</code></pre>\n<p>【优化：20 有效的括号】</p>\n<pre><code class=\"javascript\">var isValid = function (s) &#123;\n  if (s.length % 2 === 1) return false;\n  const map = new Map();\n  map.set(&quot;(&quot;, &quot;)&quot;);\n  map.set(&quot;&#123;&quot;, &quot;&#125;&quot;);\n  map.set(&quot;[&quot;, &quot;]&quot;);\n  const stack = [];\n  for (let i = 0; i &lt; s.length; i++) &#123;\n    const c = s[i];\n    if (map.has(c)) &#123;\n      stack.push(c);\n    &#125; else &#123;\n      const t = stack[stack.length - 1];\n      if (map.get(t) === c) &#123;\n        stack.pop();\n      &#125; else &#123;\n        return false;\n      &#125;\n    &#125;\n  &#125;\n  return !stack.length;\n&#125;;\n</code></pre>\n<p>【练习：1 两数之和】</p>\n<pre><code class=\"javascript\">var twoSum = function (nums, target) &#123;\n  const map = new Map();\n  for (let i = 0; i &lt; nums.length; i += 1) &#123;\n    const n = nums[i];\n    const n2 = target - n;\n    if (map.has(n2)) &#123;\n      return [map.get(n2), i];\n    &#125; else &#123;\n      map.set(n, i);\n    &#125;\n  &#125;\n&#125;;\n</code></pre>\n<p>【练习：3 无重复字符的最长子串】</p>\n<pre><code class=\"javascript\">var lengthOfLongestSubstring = function (s) &#123;\n  let l = 0;\n  let num = 0;\n  let map = new Map();\n  for (let r = 0; r &lt; s.length; r++) &#123;\n    if (map.has(s[r]) &amp;&amp; map.get(s[r]) &gt;= l) &#123;\n      l = map.get(s[r]) + 1;\n    &#125;\n    map.set(s[r], r);\n    num = Math.max(num, r - l + 1);\n  &#125;\n  return num;\n&#125;;\n</code></pre>\n<p>【练习：76 最小覆盖子串】</p>\n<pre><code class=\"javascript\">var minWindow = function (s, t) &#123;\n  let l = 0,\n    r = 0,\n    need = new Map();\n  for (let item of t) &#123;\n    need.set(item, need.has(item) ? need.get(item) + 1 : 1);\n  &#125;\n  let needType = need.size; //定义需要类型\n  let res = &quot;&quot;; //定义结果字符串\n  while (r &lt; s.length) &#123;\n    const c = s[r]; //定义又字符\n    if (need.has(c)) &#123;\n      need.set(c, need.get(c) - 1);\n      if (need.get(c) === 0) needType -= 1; //如果说当前的数值为0，标识减一\n    &#125;\n    //遍历左边指针，如果needType为0,说明当前包含全部字符，遍历取最小长度\n    while (needType === 0) &#123;\n      const newRes = s.substring(l, r + 1);\n      if (!res || newRes.length &lt; res.length) res = newRes;\n      const c2 = s[l];\n      if (need.has(c2)) &#123;\n        need.set(c2, need.get(c2) + 1);\n        if (need.get(c2) === 1) needType += 1;\n      &#125;\n      l += 1;\n    &#125;\n    r += 1;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<h1 id=\"哈希表-散列的数组\"><a href=\"#哈希表-散列的数组\" class=\"headerlink\" title=\"哈希表:散列的数组\"></a>哈希表:散列的数组</h1><p>哈希表通常基于数组实现，对下标值进行变换（哈希函数），基本可以瞬间查找到想要的元素，但是哈希表中的数据是没有顺序的，所以不能以一种固定的方式来遍历元素。</p>\n<p>【例子：员工信息，用数组存储增删数据较慢，用链表存储查找较慢。】</p>\n<p>1、哈希化：将大数字转化为数组范围内的下标的过程。</p>\n<p>2、哈希函数：通常会将单词转化为大数字，将大数字进行哈希化的函数就是哈希函数，哈希算法得到的也可能会有相同的值（冲突），对此有很多解决方案。</p>\n<p>3、哈希表：对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。</p>\n<pre><code class=\"javascript\">//封装哈希表类\nfunction HashTable() &#123;\n  //属性\n  this.storage = [];\n  this.count = 0; //计算已经存储的元素个数\n  //装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量\n  this.limit = 7; //初始长度\n\n  //方法\n  //哈希函数\n  HashTable.prototype.hashFunc = function (str, size) &#123;\n    //1.定义hashCode变量\n    let hashCode = 0;\n\n    //2.霍纳法则，计算hashCode的值\n    //cats -&gt; Unicode编码\n    for (let i = 0; i &lt; str.length; i++) &#123;\n      // str.charCodeAt(i)//获取某个字符对应的unicode编码\n      hashCode = 37 * hashCode + str.charCodeAt(i);\n    &#125;\n\n    //3.取余操作\n    let index = hashCode % size;\n    return index;\n  &#125;;\n\n  //一.插入&amp;修改操作\n  HashTable.prototype.put = function (key, value) &#123;\n    //1.根据key获取对应的index\n    let index = this.hashFunc(key, this.limit);\n\n    //2.根据index取出对应的bucket\n    let bucket = this.storage[index];\n\n    //3.判断该bucket是否为null\n    if (bucket == null) &#123;\n      bucket = [];\n      this.storage[index] = bucket;\n    &#125;\n\n    //4.判断是否是修改数据\n    for (let i = 0; i &lt; bucket.length; i++) &#123;\n      let tuple = bucket[i];\n      if (tuple[0] == key) &#123;\n        tuple[1] = value;\n        return; //不用返回值\n      &#125;\n    &#125;\n\n    //5.进行添加操作\n    bucket.push([key, value]);\n    this.count += 1;\n\n    //6.判断是否需要扩容操作\n    if (this.count &gt; this.limit * 0.75) &#123;\n      let newSize = this.limit * 2;\n      let newPrime = this.getPrime(newSize);\n      this.resize(newPrime);\n    &#125;\n  &#125;;\n\n  //二.获取操作\n  HashTable.prototype.get = function (key) &#123;\n    //1.根据key获取对应的index\n    let index = this.hashFunc(key, this.limit);\n\n    //2.根据index获取对应的bucket\n    let bucket = this.storage[index];\n\n    //3.判断bucket是否等于null\n    if (bucket == null) &#123;\n      return null;\n    &#125;\n\n    //4.有bucket，那么就进行线性查找\n    for (let i = 0; i &lt; bucket.length; i++) &#123;\n      let tuple = bucket[i];\n      if (tuple[0] == key) &#123;\n        //tuple[0]存储key，tuple[1]存储value\n        return tuple[1];\n      &#125;\n    &#125;\n\n    //5.依然没有找到，那么返回null\n    return null;\n  &#125;;\n\n  //三.删除操作\n  HashTable.prototype.remove = function (key) &#123;\n    //1.根据key获取对应的index\n    let index = this.hashFunc(key, this.limit);\n\n    //2.根据index获取对应的bucket\n    let bucket = this.storage[index];\n\n    //3.判断bucket是否为null\n    if (bucket == null) &#123;\n      return null;\n    &#125;\n\n    //4.有bucket,那么就进行线性查找并删除\n    for (let i = 0; i &lt; bucket.length; i++) &#123;\n      let tuple = bucket[i];\n      if (tuple[0] == key) &#123;\n        bucket.splice(i, 1);\n        this.count -= 1;\n        return tuple[1];\n\n        //6.缩小容量\n        if (this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;\n          let newSize = Math.floor(this.limit / 2);\n          let newPrime = this.getPrime(newSize);\n          this.resize(newPrime);\n        &#125;\n      &#125;\n    &#125;\n\n    //5.依然没有找到，返回null\n    return null;\n  &#125;;\n\n  /*------------------其他方法--------------------*/\n  //判断哈希表是否为null\n  HashTable.prototype.isEmpty = function () &#123;\n    return this.count == 0;\n  &#125;;\n\n  //获取哈希表中元素的个数\n  HashTable.prototype.size = function () &#123;\n    return this.count;\n  &#125;;\n\n  //哈希表扩容\n  HashTable.prototype.resize = function (newLimit) &#123;\n    //1.保存旧的storage数组内容\n    let oldStorage = this.storage;\n\n    //2.重置所有的属性\n    this.storage = [];\n    this.count = 0;\n    this.limit = newLimit;\n\n    //3.遍历oldStorage中所有的bucket\n    for (let i = 0; i &lt; oldStorage.length; i++) &#123;\n      //3.1.取出对应的bucket\n      const bucket = oldStorage[i];\n\n      //3.2.判断bucket是否为null\n      if (bucket == null) &#123;\n        continue;\n      &#125;\n\n      //3.3.bucket中有数据，就取出数据重新插入\n      for (let j = 0; j &lt; bucket.length; j++) &#123;\n        const tuple = bucket[j];\n        this.put(tuple[0], tuple[1]); //插入数据的key和value\n      &#125;\n    &#125;\n  &#125;;\n\n  //判断传入的num是否质数\n  HashTable.prototype.isPrime = function (num) &#123;\n    if (num &lt;= 1) &#123;\n      return false;\n    &#125;\n    //1.获取num的平方根:Math.sqrt(num)\n    //2.循环判断\n    for (var i = 2; i &lt;= Math.sqrt(num); i++) &#123;\n      if (num % i == 0) &#123;\n        return false;\n      &#125;\n    &#125;\n    return true;\n  &#125;;\n\n  //获取质数的方法\n  HashTable.prototype.getPrime = function (num) &#123;\n    //7*2=14,+1=15,+1=16,+1=17(质数)\n    while (!this.isPrime(num)) &#123;\n      num++;\n    &#125;\n    return num;\n  &#125;;\n&#125;\n</code></pre>\n<h1 id=\"哈希算法-任意长度输入转为固定长度输出\"><a href=\"#哈希算法-任意长度输入转为固定长度输出\" class=\"headerlink\" title=\"哈希算法:任意长度输入转为固定长度输出\"></a>哈希算法:任意长度输入转为固定长度输出</h1><p>hash（散列），是将任意长度输入通过散列算法转变成固定长度的输出，该输出就是散列值。这种转换是一种<strong>压缩映射</strong>，映射表达的是一种一一对应的关系。散列值的空间通常空间会小于输出的空间。</p>\n<p>哈希算法：</p>\n<p>1、不可逆：哈希算法不能从结果去推算出输入</p>\n<p>2、计算快</p>\n<p>【例子：md5 加密、webpack 热更新检测文件是否变化】</p>\n<h1 id=\"树：分层抽象数据模型\"><a href=\"#树：分层抽象数据模型\" class=\"headerlink\" title=\"树：分层抽象数据模型\"></a>树：分层抽象数据模型</h1><p>【前端】DOM 树、级联选择、树形控件。</p>\n<p>JS 中没有树，但是可以使用 Object 和 Array 来模拟构建树。</p>\n<p>【树的常用操作】：深度&#x2F;广度优先遍历、先序（后序遍历）</p>\n<p>【树】</p>\n<pre><code class=\"javascript\">const tree = &#123;\n  val: &quot;a&quot;,\n  children: [\n    &#123;\n      val: &quot;b&quot;,\n      children: [\n        &#123;\n          val: &quot;c&quot;,\n          children: [],\n        &#125;,\n      ],\n    &#125;,\n    &#123;\n      val: &quot;d&quot;,\n      children: [\n        &#123;\n          val: &quot;e&quot;,\n          children: [],\n        &#125;,\n        &#123;\n          val: &quot;f&quot;,\n          children: [],\n        &#125;,\n      ],\n    &#125;,\n  ],\n&#125;;\n</code></pre>\n<p>【1】深度优先遍历：</p>\n<p>尽可能深的搜索树的分支。（相当于一本书，一页一页翻着看）</p>\n<pre><code class=\"javascript\">// 深度优先遍历\nconst dfs = function (root) &#123;\n  console.log(root.val, &quot;还好&quot;);\n  root.children.forEach(dfs); //forEach回调不传参数，默认穿的参数就是item项\n&#125;;\n</code></pre>\n<p>【2】广度优先遍历：</p>\n<p>先访问离根节点最近的节点。（相当于一本书，先看章节再看对应页）</p>\n<pre><code class=\"javascript\">//广度优先遍历\nconst bfs = (root) =&gt; &#123;\n  const q = [root];\n  while (q.length &gt; 0) &#123;\n    const n = q.shift();\n    n.children.forEach((item) =&gt; &#123;\n      q.push(item);\n    &#125;);\n  &#125;\n&#125;;\n</code></pre>\n<h2 id=\"【二叉树】\"><a href=\"#【二叉树】\" class=\"headerlink\" title=\"【二叉树】\"></a>【二叉树】</h2><p>JS 中使用 Object 来模拟二叉树</p>\n<p>【二叉树】</p>\n<pre><code class=\"javascript\">const bt = &#123;\n  val: 1,\n  left: &#123;\n    val: 2,\n    left: &#123;&#125;,\n    right: &#123;&#125;,\n  &#125;,\n  right: &#123;\n    val: 3,\n    left: &#123;\n      val: 4,\n      left: &#123;&#125;,\n      right: &#123;&#125;,\n    &#125;,\n    right: &#123;\n      val: 5,\n      left: &#123;&#125;,\n      right: &#123;&#125;,\n    &#125;,\n  &#125;,\n&#125;;\n</code></pre>\n<p>【1】递归版二叉树的先中后序遍历</p>\n<p>（1）先序遍历：（中、左、右 向下递归）</p>\n<pre><code class=\"javascript\">//先序遍历\nconst preOrder = (root) =&gt; &#123;\n  if (!root) return;\n  console.log(root.val);\n  preOrder(root.left);\n  preOrder(root.right);\n&#125;;\n</code></pre>\n<p>（2）中序遍历：（左、中、右 向下递归）</p>\n<pre><code class=\"javascript\">//中序遍历\nconst centerOrder = (root) =&gt; &#123;\n  if (!root) return;\n  centerOrder(root.left);\n  console.log(root.val);\n  centerOrder(root.right);\n&#125;;\n</code></pre>\n<p>（3）后序遍历：（左、右、中 向下递归）</p>\n<pre><code class=\"javascript\">//后序遍历\nconst postOrder = (root) =&gt; &#123;\n  if (!root) return;\n  postOrder(root.left);\n  postOrder(root.right);\n  console.log(root.val);\n&#125;;\n</code></pre>\n<p>【2】函数调用栈版二叉树的先中后序遍历</p>\n<p>此方法原理和函数递归相似，其实就是模拟函数递归调用时，调用栈的执行（通过栈结构）来模拟执行的全过程。</p>\n<p><strong>（1）先序遍历（重要）：</strong></p>\n<pre><code class=\"javascript\">const preOrder = (root) =&gt; &#123;\n  const stack = [root];\n  while (stack.length) &#123;\n    const n = stack.pop();\n    console.log(n.val);\n    if (n.right) stack.push(n.right);\n    if (n.left) stack.push(n.left);\n  &#125;\n&#125;;\n</code></pre>\n<p><strong>（2）中序遍历（重要）：</strong></p>\n<pre><code class=\"javascript\">const centerOrder = (root) =&gt; &#123;\n  const stack = [];\n  let p = root;\n  while (stack.length || p) &#123;\n    while (p) &#123;\n      stack.push(p);\n      p = p.left;\n    &#125;\n    //到此将全部的左节点推入栈中\n    const n = stack.pop();\n    //弹出栈，输出\n    console.log(n.val);\n    //将右子节点赋值为p，当右子节点没有左子节点时，直接输出\n    p = n.right;\n  &#125;\n&#125;;\n</code></pre>\n<p><strong>（3）后序遍历（重要）：</strong></p>\n<pre><code class=\"javascript\">//函数调用栈进行后序遍历（巧妙借鉴先序遍历（将输出变为存到另一个栈中））\nconst postOrder = (root) =&gt; &#123;\n  const stack = [root];\n  const outputStack = [];\n  while (stack.length) &#123;\n    const n = stack.pop();\n    outputStack.push(n);\n    if (n.left) stack.push(n.left);\n    if (n.right) stack.push(n.right);\n  &#125;\n  while (outputStack.length) &#123;\n    const n = outputStack.pop();\n    console.log(n.val);\n  &#125;\n&#125;;\n</code></pre>\n<p>【练习：104 二叉树的最大深度】</p>\n<pre><code class=\"javascript\">var maxDepth = function (root) &#123;\n  let res = 0;\n  //定义深度优先遍历\n  const dfs = (root, l) =&gt; &#123;\n    if (!root) return;\n    if (!root.left &amp;&amp; !root.right) &#123;\n      res = Math.max(res, l);\n    &#125;\n    dfs(root.left, l + 1);\n    dfs(root.right, l + 1);\n  &#125;;\n  dfs(root, 1);\n  return res;\n&#125;;\n</code></pre>\n<p>【练习：111 二叉树的最小深度】</p>\n<pre><code class=\"javascript\">var minDepth = function (root) &#123;\n  if (!root) return 0;\n  //使用广度优先遍历，注意使用队列，因为广度优先。\n  let queue = [[root, 1]];\n  while (queue.length) &#123;\n    const [n, l] = queue.shift();\n    if (!n.left &amp;&amp; !n.right) &#123;\n      return l;\n    &#125;\n    if (n.left) queue.push([n.left, l + 1]);\n    if (n.right) queue.push([n.right, l + 1]);\n  &#125;\n&#125;;\n</code></pre>\n<p>【练习：102 二叉树的层序遍历】</p>\n<p>方法一：</p>\n<pre><code class=\"javascript\">var levelOrder = function (root) &#123;\n  //使用广度优先遍历算法\n  let queue = [[root, 1]];\n  if (!root) return [];\n  let res = [];\n  while (queue.length) &#123;\n    const [n, l] = queue.shift();\n    if (res.length &lt; l) &#123;\n      res.push([n.val]);\n    &#125; else &#123;\n      res[l - 1].push(n.val);\n    &#125;\n    if (n.left) queue.push([n.left, l + 1]);\n    if (n.right) queue.push([n.right, l + 1]);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>方法二：（性能更好&#x3D;&#x3D;）</p>\n<pre><code class=\"javascript\">var levelOrder = function (root) &#123;\n  if (!root) return [];\n  let queue = [root];\n  let res = [];\n  while (queue.length) &#123;\n    let n = queue.length;\n    const item = [];\n    while (n) &#123;\n      const i = queue.shift();\n      item.push(i.val);\n      if (i.left) queue.push(i.left);\n      if (i.right) queue.push(i.right);\n      n--;\n    &#125;\n    res.push(item);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【练习：94 二叉树的中序遍历】</p>\n<pre><code class=\"javascript\">//递归版实现\nvar inorderTraversal = function (root) &#123;\n  let res = [];\n  //定义递归函数，进行执行\n  const rec = (n) =&gt; &#123;\n    if (!n) return;\n    rec(n.left);\n    res.push(n.val);\n    rec(n.right);\n  &#125;;\n  rec(root);\n  return res;\n&#125;;\n</code></pre>\n<pre><code class=\"javascript\">//模拟栈实现\nvar inorderTraversal = function (root) &#123;\n  let stack = [];\n  let res = [];\n  let p = root;\n  while (stack.length || p) &#123;\n    // 中序遍历首先是将全部的左子节点进行添加\n    while (p) &#123;\n      stack.push(p);\n      p = p.left;\n    &#125;\n    //从栈中弹出\n    const n = stack.pop();\n    res.push(n.val);\n    //将右子节点添加进数组，此时为中序顺序添加\n    p = n.right;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【练习：112 路径总和】</p>\n<pre><code class=\"javascript\">var hasPathSum = function (root, targetSum) &#123;\n  if (!root) return false;\n  let res = false;\n  //使用深度优先遍历\n  let dfs = (root, sum) =&gt; &#123;\n    if (!root.left &amp;&amp; !root.right &amp;&amp; sum == targetSum) &#123;\n      res = true;\n    &#125;\n    // 深度优先遍历\n    if (root.left) dfs(root.left, sum + root.left.val);\n    if (root.right) dfs(root.right, sum + root.right.val);\n  &#125;;\n  dfs(root, root.val);\n  return res;\n&#125;;\n</code></pre>\n<p>【前端与树—遍历 JSON】</p>\n<pre><code class=\"javascript\">// 前端与树----json的遍历\nconst json = &#123;\n  a: &#123; b: &#123; c: 1 &#125; &#125;,\n  d: [1, 2],\n&#125;;\nconst dfs = (n, path) =&gt; &#123;\n  console.log(n, path);\n  Object.keys(n).forEach((item) =&gt; &#123;\n    dfs(n[item], path.concat(item));\n  &#125;);\n&#125;;\ndfs(json, []);\n</code></pre>\n<p>【前端与树—渲染 Antd 中的树组件】</p>\n<pre><code class=\"tsx\">const json = [\n  &#123;\n    title: &quot;一&quot;,\n    key: &quot;1&quot;,\n    children: [&#123; title: &quot;三&quot;, key: &quot;3&quot;, children: [] &#125;],\n  &#125;,\n  &#123;\n    title: &quot;二&quot;,\n    key: &quot;2&quot;,\n    children: [&#123; title: &quot;四&quot;, key: &quot;4&quot;, children: [] &#125;],\n  &#125;,\n];\nclass Demo extends React.Component &#123;\n  dfs = (n) =&gt; &#123;\n    return (\n      &lt;TreeNode title=&#123;n.title&#125; key=&#123;n.key&#125;&gt;\n        &#123;n.children.map(this.dfs)&#125;\n      &lt;/TreeNode&gt;\n    );\n  &#125;;\n  render() &#123;\n    return &lt;Tree&gt;&#123;json.map(this.dfs)&#125;&lt;/Tree&gt;;\n  &#125;\n&#125;\nReactDOM.render(&lt;Demo /&gt;, mountNode);\n</code></pre>\n<h1 id=\"图：网络结构抽象模型\"><a href=\"#图：网络结构抽象模型\" class=\"headerlink\" title=\"图：网络结构抽象模型\"></a>图：网络结构抽象模型</h1><p>【理解：图相当于可以跨越多个父级和子级和相互指对的树。】</p>\n<p>JS 中没有图，但是可以使用 Object 和 Array 来构建图。</p>\n<p>【图的表示】</p>\n<p>一、临接矩阵（可连接则为 1）</p>\n<p><img data-src=\"/images/%E5%9B%BE.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>二、邻接表（对象键的数组中表示可连接的值）</p>\n<p><img data-src=\"/images/%E5%9B%BE1.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【图的操作】</p>\n<p>【1】深度优先遍历</p>\n<p><img data-src=\"/images/%E5%9B%BE2.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"javascript\">// 图的深度优先遍历\nconst graph = &#123;\n  0: [1, 2],\n  1: [2],\n  2: [0, 3],\n  3: [3],\n&#125;;\n//定义集合用于存储已经访问过的节点\nconst visited = new Set();\nconst dfs = (n) =&gt; &#123;\n  console.log(n);\n  visited.add(n);\n  graph[n].forEach((item) =&gt; &#123;\n    if (!visited.has(item)) dfs(item);\n  &#125;);\n&#125;;\ndfs(2);\n</code></pre>\n<p>【2】广度优先遍历</p>\n<p><img data-src=\"/images/%E5%9B%BE3.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"javascript\">// 图的广度优先遍历\nconst graph = &#123;\n  0: [1, 2],\n  1: [2],\n  2: [0, 3],\n  3: [3],\n&#125;;\n//图的广度优先遍历\nconst bfs = (n) =&gt; &#123;\n  //定义集合存储访问过的变量\n  const visited = new Set([n]);\n  //定义队列，取出访问\n  const queue = [n];\n  while (queue.length) &#123;\n    const i = queue.shift();\n    console.log(i);\n    graph[i].forEach((item) =&gt; &#123;\n      if (!visited.has(item)) &#123;\n        queue.push(item);\n        //推入队列中就会执行，表示已经访问过了\n        visited.add(item);\n      &#125;\n    &#125;);\n  &#125;\n&#125;;\nbfs(2);\n</code></pre>\n<p>【练习：65 有效的数字】</p>\n<pre><code class=\"javascript\">var isNumber = function (s) &#123;\n  const graph = &#123;\n    0: &#123; blank: 0, sign: 1, &quot;.&quot;: 2, digit: 6 &#125;,\n    1: &#123; digit: 6, &quot;.&quot;: 2 &#125;,\n    2: &#123; digit: 3 &#125;,\n    3: &#123; digit: 3, e: 4 &#125;,\n    4: &#123; digit: 5, sign: 7 &#125;,\n    5: &#123; digit: 5 &#125;,\n    6: &#123; digit: 6, &quot;.&quot;: 3, e: 4 &#125;,\n    7: &#123; digit: 5 &#125;,\n  &#125;;\n  let state = 0;\n  for (let str of s.trim()) &#123;\n    if (str &gt;= 0 &amp;&amp; str &lt;= 9) &#123;\n      str = &quot;digit&quot;;\n    &#125; else if (str === &quot; &quot;) &#123;\n      str = &quot;blank&quot;;\n    &#125; else if (str === &quot;+&quot; || str === &quot;-&quot;) &#123;\n      str = &quot;sign&quot;;\n    &#125; else if (str === &quot;E&quot;) &#123;\n      str = &quot;e&quot;;\n    &#125;\n    state = graph[state][str];\n    if (state === undefined) return false;\n  &#125;\n  if (state == 3 || state == 5 || state == 6) return true;\n  return false;\n&#125;;\n</code></pre>\n<p>【练习：417 太平洋大西洋水流问题】</p>\n<pre><code class=\"javascript\">var pacificAtlantic = function (matrix) &#123;\n  if (!matrix || !matrix[0]) return [];\n  const m = matrix.length;\n  const n = matrix[0].length;\n  const flow1 = Array.from(&#123; length: m &#125;, () =&gt; new Array(n).fill(false));\n  const flow2 = Array.from(&#123; length: m &#125;, () =&gt; new Array(n).fill(false));\n  const dfs = (r, c, flow) =&gt; &#123;\n    //在flow中，将当前节点设置为true\n    flow[r][c] = true;\n    //遍历当前项的四周节点\n    [\n      [r - 1, c],\n      [r + 1, c],\n      [r, c - 1],\n      [r, c + 1],\n    ].forEach(([nr, nc]) =&gt; &#123;\n      if (\n        //保证遍历的项在矩阵中,并且遍历项海拔大于当前节点海拔\n        nr &gt;= 0 &amp;&amp;\n        nr &lt; m &amp;&amp;\n        nc &gt;= 0 &amp;&amp;\n        nc &lt; n &amp;&amp;\n        !flow[nr][nc] &amp;&amp;\n        matrix[nr][nc] &gt;= matrix[r][c]\n      ) &#123;\n        dfs(nr, nc, flow);\n      &#125;\n    &#125;);\n  &#125;;\n  // 沿着两个海洋遍历节点，能到达的节点为true（海岸线使用flow1，大西洋使用flow2）\n  for (let r = 0; r &lt; m; r++) &#123;\n    dfs(r, 0, flow1);\n    dfs(r, n - 1, flow2);\n  &#125;\n  for (let c = 0; c &lt; n; c++) &#123;\n    dfs(0, c, flow1);\n    dfs(m - 1, c, flow2);\n  &#125;\n  //收集到能留到两个大洋里的坐标\n  const res = [];\n  for (let r = 0; r &lt; m; r++) &#123;\n    for (let c = 0; c &lt; n; c++) &#123;\n      if (flow1[r][c] &amp;&amp; flow2[r][c]) &#123;\n        res.push([r, c]);\n      &#125;\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【练习：133 克隆图】</p>\n<pre><code class=\"javascript\">//深度优先遍历方法\nvar cloneGraph = function (node) &#123;\n  if (!node) return;\n  //深优先遍历图，将节点和拷贝的节点存起来\n  const visited = new Map();\n  const dfs = (node) =&gt; &#123;\n    const cloneNode = new Node(node.val);\n    visited.set(node, cloneNode);\n    (node.neighbors || []).forEach((item) =&gt; &#123;\n      if (!visited.has(item)) &#123;\n        dfs(item);\n      &#125;\n      cloneNode.neighbors.push(visited.get(item));\n    &#125;);\n  &#125;;\n  dfs(node);\n  return visited.get(node);\n&#125;;\n</code></pre>\n<h1 id=\"堆：特殊的完全二叉树\"><a href=\"#堆：特殊的完全二叉树\" class=\"headerlink\" title=\"堆：特殊的完全二叉树\"></a>堆：特殊的完全二叉树</h1><p><img data-src=\"/images/%E5%A0%86.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><img data-src=\"/images/%E5%A0%861.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><img data-src=\"/images/%E5%A0%862.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【JS 实现最小堆类】</p>\n<pre><code class=\"javascript\">// 最小堆类\nclass MinHeap &#123;\n  constructor() &#123;\n    this.heap = [];\n  &#125;\n  // 交换两个节点位置\n  swap(i1, i2) &#123;\n    const temp = this.heap[i1];\n    this.heap[i1] = this.heap[i2];\n    this.heap[i2] = temp;\n  &#125;\n  // 得到父元素索引\n  getParentIndex(i) &#123;\n    return (i - 1) &gt;&gt; 1;\n  &#125;\n  //获取左侧子节点\n  getLeftIndex(i) &#123;\n    return i * 2 + 1;\n  &#125;\n  //获取右侧子节点\n  getRightIndex(i) &#123;\n    return i * 2 + 2;\n  &#125;\n  //比较大小值确定位置\n  shiftup(index) &#123;\n    if (index == 0) return;\n    const parentIndex = this.getParentIndex(index);\n    if (this.heap[parentIndex] &gt; this.heap[index]) &#123;\n      this.swap(parentIndex, index);\n      this.shiftup(parentIndex);\n    &#125;\n  &#125;\n  //插入节点，并放置到正确的位置\n  insert(value) &#123;\n    this.heap.push(value);\n    this.shiftup(this.heap.length - 1);\n  &#125;\n  //下移操作\n  shiftDown(index) &#123;\n    const leftIndex = this.getLeftIndex(index);\n    const rightIndex = this.getRightIndex(index);\n    if (this.heap[leftIndex] &lt; this.heap[index]) &#123;\n      this.swap(leftIndex, index);\n      this.shiftDown(leftIndex);\n    &#125;\n    if (this.heap[rightIndex] &lt; this.heap[index]) &#123;\n      this.swap(rightIndex, index);\n      this.shiftDown(rightIndex);\n    &#125;\n  &#125;\n  //删除操作\n  pop() &#123;\n    this.heap[0] = this.heap.pop();\n    this.shiftDown(0);\n  &#125;\n  peek() &#123;\n    return this.heap[0];\n  &#125;\n  size() &#123;\n    return this.heap.length;\n  &#125;\n&#125;\nconst h = new MinHeap();\nh.insert(3);\nh.insert(2);\nh.insert(1);\nh.pop();\n</code></pre>\n<p>【练习：215 数组中的第 K 个最大元素】</p>\n<pre><code class=\"javascript\">class MinHeap &#123;\n  constructor() &#123;\n    this.heap = [];\n  &#125;\n  // 交换两个节点位置\n  swap(i1, i2) &#123;\n    [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];\n  &#125;\n  // 得到父元素索引\n  getParentIndex(i) &#123;\n    return (i - 1) &gt;&gt; 1;\n  &#125;\n  //获取左侧子节点\n  getLeftIndex(i) &#123;\n    return i * 2 + 1;\n  &#125;\n  //获取右侧子节点\n  getRightIndex(i) &#123;\n    return i * 2 + 2;\n  &#125;\n  //比较大小值确定位置\n  shiftup(index) &#123;\n    if (index == 0) return;\n    const parentIndex = this.getParentIndex(index);\n    if (this.heap[parentIndex] &gt; this.heap[index]) &#123;\n      this.swap(parentIndex, index);\n      this.shiftup(parentIndex);\n    &#125;\n  &#125;\n  //插入节点，并放置到正确的位置\n  insert(value) &#123;\n    this.heap.push(value);\n    this.shiftup(this.heap.length - 1);\n  &#125;\n  //下移操作\n  shiftDown(index) &#123;\n    const leftIndex = this.getLeftIndex(index);\n    const rightIndex = this.getRightIndex(index);\n    if (this.heap[leftIndex] &lt; this.heap[index]) &#123;\n      this.swap(leftIndex, index);\n      this.shiftDown(leftIndex);\n    &#125;\n    if (this.heap[rightIndex] &lt; this.heap[index]) &#123;\n      this.swap(rightIndex, index);\n      this.shiftDown(rightIndex);\n    &#125;\n  &#125;\n  //删除操作\n  pop() &#123;\n    this.heap[0] = this.heap.pop();\n    this.shiftDown(0);\n  &#125;\n  peek() &#123;\n    return this.heap[0];\n  &#125;\n  size() &#123;\n    return this.heap.length;\n  &#125;\n&#125;\n//算法使用创建的最小堆类\nvar findKthLargest = function (nums, k) &#123;\n  const h = new MinHeap();\n  nums.forEach((item) =&gt; &#123;\n    h.insert(item);\n    if (h.size() &gt; k) &#123;\n      h.pop();\n    &#125;\n  &#125;);\n  return h.peek();\n&#125;;\n</code></pre>\n<p>【练习：347 前 K 个最大元素】</p>\n<pre><code class=\"javascript\">//方法一：暴力解法（里面有排序算法，时间复杂度较高，至少为：O(n*log(n)) ）\nvar topKFrequent = function (nums, k) &#123;\n  const map = new Map();\n  nums.forEach((item) =&gt; &#123;\n    map.has(item) ? map.set(item, map.get(item) + 1) : map.set(item, 1);\n  &#125;);\n  return Array.from(map)\n    .sort((a, b) =&gt; b[1] - a[1])\n    .slice(0, k)\n    .map((item) =&gt; item[0]);\n&#125;;\n</code></pre>\n<pre><code class=\"javascript\">//方法二：使用堆\nclass MinHeap &#123;\n  constructor() &#123;\n    this.heap = [];\n  &#125;\n  // 交换两个节点位置\n  swap(i1, i2) &#123;\n    [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];\n  &#125;\n  // 得到父元素索引\n  getParentIndex(i) &#123;\n    return (i - 1) &gt;&gt; 1;\n  &#125;\n  //获取左侧子节点\n  getLeftIndex(i) &#123;\n    return i * 2 + 1;\n  &#125;\n  //获取右侧子节点\n  getRightIndex(i) &#123;\n    return i * 2 + 2;\n  &#125;\n  //比较大小值确定位置\n  shiftup(index) &#123;\n    if (index == 0) return;\n    const parentIndex = this.getParentIndex(index);\n    if (this.heap[parentIndex].value &gt; this.heap[index].value) &#123;\n      this.swap(parentIndex, index);\n      this.shiftup(parentIndex);\n    &#125;\n  &#125;\n  //插入节点，并放置到正确的位置\n  insert(value) &#123;\n    this.heap.push(value);\n    this.shiftup(this.heap.length - 1);\n  &#125;\n  //下移操作\n  shiftDown(index) &#123;\n    const leftIndex = this.getLeftIndex(index);\n    const rightIndex = this.getRightIndex(index);\n    if (\n      this.heap[leftIndex] &amp;&amp;\n      this.heap[leftIndex].value &lt; this.heap[index].value\n    ) &#123;\n      this.swap(leftIndex, index);\n      this.shiftDown(leftIndex);\n    &#125;\n    if (\n      this.heap[rightIndex] &amp;&amp;\n      this.heap[rightIndex].value &lt; this.heap[index].value\n    ) &#123;\n      this.swap(rightIndex, index);\n      this.shiftDown(rightIndex);\n    &#125;\n  &#125;\n  //删除操作\n  pop() &#123;\n    this.heap[0] = this.heap.pop();\n    this.shiftDown(0);\n  &#125;\n  peek() &#123;\n    return this.heap[0];\n  &#125;\n  size() &#123;\n    return this.heap.length;\n  &#125;\n&#125;\nvar findKthLargest = function (nums, k) &#123;\n  const h = new MinHeap();\n  nums.forEach((item) =&gt; &#123;\n    h.insert(item);\n    if (h.size() &gt; k) &#123;\n      h.pop();\n    &#125;\n  &#125;);\n  return h.peek();\n&#125;;\nvar topKFrequent = function (nums, k) &#123;\n  const map = new Map();\n  nums.forEach((item) =&gt; &#123;\n    map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n  &#125;);\n  const h = new MinHeap();\n  map.forEach((value, key) =&gt; &#123;\n    h.insert(&#123; value, key &#125;);\n    if (h.size() &gt; k) &#123;\n      h.pop();\n    &#125;\n  &#125;);\n  return h.heap.map((item) =&gt; item.key);\n&#125;;\n</code></pre>\n<p>【练习：23 合并 K 个排序链表】</p>\n<pre><code class=\"javascript\">class minHeap &#123;\n  constructor() &#123;\n    this.heap = [];\n  &#125;\n  //移动两个元素的位置\n  swap(i1, i2) &#123;\n    [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];\n  &#125;\n  //得到父元素下标\n  getParentIndex(i) &#123;\n    return (i - 1) &gt;&gt; 1;\n  &#125;\n  //得到左侧子节点下标\n  getLeftIndex(i) &#123;\n    return i * 2 + 1;\n  &#125;\n  //得到右侧子节点下标\n  getRightIndex(i) &#123;\n    return i * 2 + 2;\n  &#125;\n  //根据索引调整元素位置(冒泡将最小元素上移)\n  shiftup(index) &#123;\n    if (index == 0) return;\n    const parentIndex = this.getParentIndex(index);\n    if (\n      this.heap[parentIndex] &amp;&amp;\n      this.heap[parentIndex].val &gt; this.heap[index].val\n    ) &#123;\n      this.swap(index, parentIndex);\n      this.shiftup(parentIndex);\n    &#125;\n  &#125;\n  //插入\n  insert(value) &#123;\n    this.heap.push(value);\n    this.shiftup(this.heap.length - 1);\n  &#125;\n  //删除操作\n  pop() &#123;\n    if (this.size() === 1) return this.heap.shift();\n    const top = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.shiftDown(0);\n    return top;\n  &#125;\n  //下沉操作\n  shiftDown(index) &#123;\n    const leftIndex = this.getLeftIndex(index);\n    const rightIndex = this.getRightIndex(index);\n    if (\n      this.heap[leftIndex] &amp;&amp;\n      this.heap[leftIndex].val &lt; this.heap[index].val\n    ) &#123;\n      this.swap(leftIndex, index);\n      this.shiftDown(leftIndex);\n    &#125;\n    if (\n      this.heap[rightIndex] &amp;&amp;\n      this.heap[rightIndex].val &lt; this.heap[index].val\n    ) &#123;\n      this.swap(rightIndex, index);\n      this.shiftDown(rightIndex);\n    &#125;\n  &#125;\n  //选取\n  peek() &#123;\n    return this.heap[0];\n  &#125;\n  size() &#123;\n    return this.heap.length;\n  &#125;\n&#125;\n\nclass ListNode &#123;\n  constructor(value) &#123;\n    this.val = value;\n    this.next = null;\n  &#125;\n&#125;\nvar mergeKLists = function (lists) &#123;\n  const res = new ListNode(0);\n  let p = res;\n  const h = new minHeap();\n  lists.forEach((item) =&gt; &#123;\n    if (item) h.insert(item);\n  &#125;);\n  while (h.size()) &#123;\n    const n = h.pop();\n    if (p) &#123;\n      p.next = n;\n      p = p.next;\n    &#125;\n    if (n &amp;&amp; n.next) h.insert(n.next);\n  &#125;\n  return res.next;\n&#125;;\n</code></pre>\n<h1 id=\"排序和搜索\"><a href=\"#排序和搜索\" class=\"headerlink\" title=\"排序和搜索\"></a>排序和搜索</h1><p>【排序算法】</p>\n<p>1、冒泡排序：</p>\n<p>冒泡排序比较所有相邻元素，如果第一个比第二个大，就交换他们，一轮下来可以保证最后一个数是最大的，则执行 n-1 轮之后可以实现排序，时间复杂度为 O(n**2)</p>\n<pre><code class=\"javascript\">//冒泡排序\nArray.prototype.bubbleSort = function () &#123;\n  for (let i = 0; i &lt; this.length - 1; i++) &#123;\n    for (let j = 0; j &lt; this.length - 1 - i; j++) &#123;\n      if (this[j] &gt; this[j + 1]) &#123;\n        [this[j], this[j + 1]] = [this[j + 1], this[j]];\n      &#125;\n    &#125;\n  &#125;\n  return this;\n&#125;;\n</code></pre>\n<p>2、选择排序：</p>\n<p>选择排序找到数组中的最小值，选中它并将其放置在第一位，接着找到第二小的值，选中它并将其放置在第二位，以此类推执行 n-1 轮，时间复杂度为 O(n**2)</p>\n<pre><code class=\"javascript\">//选择排序\nArray.prototype.selectionSort = function () &#123;\n  for (let i = 0; i &lt; this.length; i++) &#123;\n    for (let j = i + 1; j &lt; this.length; j++) &#123;\n      if (this[j] &lt; this[i]) &#123;\n        [this[j], this[i]] = [this[i], this[j]];\n      &#125;\n    &#125;\n  &#125;\n  return this;\n&#125;;\n</code></pre>\n<p>3、插入排序：</p>\n<p>插入排序会从第二个数开始往前比，比他大就往后排，以此类推进行到最后一个数。时间复杂度为： O(n**2)</p>\n<pre><code class=\"javascript\">//插入排序\nArray.prototype.insertSort = function () &#123;\n  for (let i = 1; i &lt; this.length; i++) &#123;\n    const temp = this[i];\n    let j = i;\n    while (j &gt; 0) &#123;\n      if (this[j - 1] &gt; temp) &#123;\n        this[j] = this[j - 1];\n      &#125; else &#123;\n        break;\n      &#125;\n      j -= 1;\n    &#125;\n    this[j] = temp;\n  &#125;\n&#125;;\n</code></pre>\n<p>4、归并排序（火狐浏览器 sort）</p>\n<p>归：将数组分为两半，再递归的对子数组进行分操作，直到分成一个个单独的数。</p>\n<p>并：将两个数合并成一个有序数组，再对有序数组进行合并，直到全部子数合并成一个完整数组。</p>\n<p>时间复杂度为：O(nlogn)</p>\n<pre><code class=\"javascript\">Array.prototype.mergeSort = function () &#123;\n  const rec = (arr) =&gt; &#123;\n    if (arr.length === 1) return arr;\n    const mid = arr.length &gt;&gt; 1;\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid, arr.length);\n    const orderLeft = rec(left);\n    const orderRight = rec(right);\n    const res = [];\n    while (orderLeft.length || orderRight.length) &#123;\n      if (orderLeft.length &amp;&amp; orderRight.length) &#123;\n        res.push(\n          orderLeft[0] &lt; orderRight[0] ? orderLeft.shift() : orderRight.shift()\n        );\n      &#125; else if (orderLeft.length) &#123;\n        res.push(orderLeft.shift());\n      &#125; else if (orderRight.length) &#123;\n        res.push(orderRight.shift());\n      &#125;\n    &#125;\n    return res;\n  &#125;;\n  const res = rec(this);\n  res.forEach((item, index) =&gt; &#123;\n    this[index] = item;\n  &#125;);\n  return this;\n&#125;;\nlet ate = [2, 3, 1, -1, 4, 6, 8, 5, -3, -2];\nconsole.log(ate.mergeSort());\n</code></pre>\n<p>5、快速排序（Chrome 浏览器之前的 sort）</p>\n<p><strong>首先分区</strong>：从数组中任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面。</p>\n<p><strong>然后递归</strong>：递归地对基准前后的子数组进行分区。</p>\n<p>时间复杂度：O(nlogn)</p>\n<pre><code class=\"javascript\">Array.prototype.quickSort = function () &#123;\n  const rec = (arr) =&gt; &#123;\n    if (arr.length &lt;= 1) &#123;\n      return arr;\n    &#125;\n    const left = [];\n    const right = [];\n    const mid = arr[0];\n    for (let i = 1; i &lt; arr.length; i++) &#123;\n      if (arr[i] &lt; mid) &#123;\n        left.push(arr[i]);\n      &#125; else &#123;\n        right.push(arr[i]);\n      &#125;\n    &#125;\n    return [...rec(left), mid, ...rec(right)];\n  &#125;;\n  const res = rec(this);\n  res.forEach((item, index) =&gt; &#123;\n    this[index] = item;\n  &#125;);\n  return this;\n&#125;;\nconst a2 = [-2, -4, 0, 3, 5];\nconsole.log(a2.quickSort());\n</code></pre>\n<p>【搜索算法】</p>\n<p>1、顺序搜索</p>\n<p>首先遍历数组，找到跟目标值相等的元素就返回下标，遍历结束后如果没有找到搜索的目标值，就返回-1</p>\n<p>时间复杂度为 O(n)</p>\n<pre><code class=\"javascript\">Array.prototype.sequentialSearch = function (num) &#123;\n  for (let i = 0; i &lt; this.length; i++) &#123;\n    if (this[i] === num) &#123;\n      return i;\n    &#125;\n  &#125;\n  return -1;\n&#125;;\nconst a = [-2, -4, 0, 3, 5];\nconsole.log(a.sequentialSearch(5));\n</code></pre>\n<p>2、二分搜索（前提是数组有序）</p>\n<p>从数组的中间元素开始，如果中间元素正好是目标值，则索引结束，如果目标值大于或者等于中间元素，则在大于或小于中间元素的那一半数组中搜索。</p>\n<p>时间复杂度为 O(logn)</p>\n<pre><code class=\"javascript\">Array.prototype.bannerySearch = function (num) &#123;\n  let head = 0;\n  let tail = this.length - 1;\n  while (head &lt;= tail) &#123;\n    const mid = (head + tail) &gt;&gt; 1;\n    const item = this[mid];\n    if (num &lt; item) &#123;\n      tail = mid - 1;\n    &#125; else if (num &gt; item) &#123;\n      head = mid + 1;\n    &#125; else &#123;\n      return mid;\n    &#125;\n  &#125;\n  return -1;\n&#125;;\nconst a = [-2, 0, 3, 4, 9, 11];\nconsole.log(a.bannerySearch(11));\n</code></pre>\n<p>【练习：21 合并两个有序链表】</p>\n<p>时间复杂度为：O(m+n)</p>\n<pre><code class=\"javascript\">var mergeTwoLists = function (list1, list2) &#123;\n  let list = new ListNode(0);\n  const firstNode = list;\n  let p1 = list1;\n  let p2 = list2;\n  while (p1 &amp;&amp; p2) &#123;\n    if (p1.val &gt; p2.val) &#123;\n      list.next = p2;\n      p2 = p2.next;\n    &#125; else &#123;\n      list.next = p1;\n      p1 = p1.next;\n    &#125;\n    list = list.next;\n  &#125;\n  if (p1) &#123;\n    list.next = p1;\n  &#125;\n  if (p2) &#123;\n    list.next = p2;\n  &#125;\n  return firstNode.next;\n&#125;;\n</code></pre>\n<p>【练习：374 猜数字大小】</p>\n<pre><code class=\"javascript\">var guessNumber = function (n) &#123;\n  let head = 1;\n  let tail = n;\n  while (head &lt; tail) &#123;\n    const mid = head + ((tail - head) &gt;&gt; 1);\n    if (guess(mid) &lt;= 0) &#123;\n      tail = mid;\n    &#125; else &#123;\n      head = mid + 1;\n    &#125;\n  &#125;\n  return head;\n&#125;;\n</code></pre>\n<p>【练习：69x 的平方】</p>\n<pre><code class=\"javascript\">var mySqrt = function (x) &#123;\n  let left = 1,\n    right = x;\n  while (left &lt;= right) &#123;\n    let mid = left + ((right - left) &gt;&gt; 1);\n    if (mid * mid &lt;= x) &#123;\n      if ((mid + 1) * (mid + 1) &gt; x) &#123;\n        return mid;\n      &#125;\n      left = mid + 1;\n    &#125; else &#123;\n      right = mid - 1;\n    &#125;\n  &#125;\n  return 0;\n&#125;;\n</code></pre>\n<h1 id=\"算法设计思想\"><a href=\"#算法设计思想\" class=\"headerlink\" title=\"算法设计思想\"></a>算法设计思想</h1><h3 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h3><p>分而治之是算法设计中的一种方法（思想），</p>\n<p>分而治之将一个问题分为多个和原问题相似的<strong>相互独立的子问题</strong>，递归解决小问题，再将结果合并已解决原来的问题。应用场景有：归并排序、快速排序和二分搜索。</p>\n<p>【练习：374 猜数字大小】</p>\n<p>时间复杂度为：O(logn),空间复杂度为：O(logn)空间复杂度不如直接使用循环。</p>\n<pre><code class=\"javascript\">var guessNumber = function (n) &#123;\n  const rec = (head, tail) =&gt; &#123;\n    const mid = head + ((tail - head) &gt;&gt; 1);\n    const res = guess(mid);\n    if (res === 0) &#123;\n      return mid;\n    &#125; else if (res === 1) &#123;\n      return rec(mid + 1, tail);\n    &#125; else &#123;\n      return rec(head, mid - 1);\n    &#125;\n  &#125;;\n  return rec(1, n);\n&#125;;\n</code></pre>\n<p>【练习：226 翻转二叉树】</p>\n<pre><code class=\"javascript\">var invertTree = function (root) &#123;\n  if (!root) return null;\n  return &#123;\n    val: root.val,\n    left: invertTree(root.right),\n    right: invertTree(root.left),\n  &#125;;\n&#125;;\n</code></pre>\n<p>【练习：100 相同的树】</p>\n<p>时间复杂度为：O(n) , 空间复杂度为：O(n)</p>\n<pre><code class=\"javascript\">var isSameTree = function (p, q) &#123;\n  if (!p &amp;&amp; !q) return true;\n  if (\n    p &amp;&amp;\n    q &amp;&amp;\n    p.val === q.val &amp;&amp;\n    isSameTree(p.left, q.left) &amp;&amp;\n    isSameTree(p.right, q.right)\n  ) &#123;\n    return true;\n  &#125;\n&#125;;\n</code></pre>\n<p>【练习：101 对称二叉树】</p>\n<pre><code class=\"javascript\">var isSymmetric = function (root) &#123;\n  if (!root) return true;\n  const isMirror = (l, r) =&gt; &#123;\n    if (!l &amp;&amp; !r) return true;\n    if (\n      l &amp;&amp;\n      r &amp;&amp;\n      l.val === r.val &amp;&amp;\n      isMirror(l.left, r.right) &amp;&amp;\n      isMirror(l.right, r.left)\n    ) &#123;\n      return true;\n    &#125;\n    return false;\n  &#125;;\n  return isMirror(root.left, root.right);\n&#125;;\n</code></pre>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><p>动态规划是算法设计中的一种方法，</p>\n<p>动态规划将一个问题分解为<strong>相互重叠的子问题</strong>，通过反复求解子问题来解决原来的问题。</p>\n<p>关键：找出<strong>状态转移方程</strong>。</p>\n<p>【练习：70 爬楼梯】</p>\n<pre><code class=\"javascript\">var climbStairs = function (n) &#123;\n  if (n &lt; 2) return 1;\n  let dp0 = 1;\n  let dp1 = 1;\n  for (let i = 2; i &lt;= n; i++) &#123;\n    const temp = dp0;\n    dp0 = dp1;\n    dp1 += temp;\n  &#125;\n  return dp1;\n&#125;;\n</code></pre>\n<p>【练习：198 打家劫舍】</p>\n<pre><code class=\"javascript\">var rob = function (nums) &#123;\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  let dp0 = 0,\n    dp1 = nums[0];\n  for (let i = 2; i &lt;= nums.length; i++) &#123;\n    const dp2 = Math.max(dp0 + nums[i - 1], dp1);\n    dp0 = dp1;\n    dp1 = dp2;\n  &#125;\n  return dp1;\n&#125;;\n</code></pre>\n<h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3><p>贪心算法是算法设计中的一种方法（思想），期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优，但是并不一定是最优的解法。</p>\n<p>【练习：455 分饼干】</p>\n<pre><code class=\"javascript\">var findContentChildren = function (g, s) &#123;\n  const sortFn = function (a, b) &#123;\n    return a - b;\n  &#125;;\n  g = g.sort(sortFn);\n  s = s.sort(sortFn);\n  let i = 0;\n  s.forEach((item) =&gt; &#123;\n    if (item &gt;= g[i]) &#123;\n      i++;\n    &#125;\n  &#125;);\n  return i;\n&#125;;\n</code></pre>\n<p>【练习：122 买卖股票的最佳时机】</p>\n<pre><code class=\"javascript\">var maxProfit = function (prices) &#123;\n  let profit = 0;\n  for (let i = 1; i &lt; prices.length; i++) &#123;\n    if (prices[i] &gt; prices[i - 1]) &#123;\n      profit += prices[i] - prices[i - 1];\n    &#125;\n  &#125;\n  return profit;\n&#125;;\n</code></pre>\n<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><p>回溯算法是算法设计中的一种方法（思想），</p>\n<p>回溯算法是一种渐进式寻找并构建问题解决方式的策略。</p>\n<p>回溯算法会先从一个可能的动作开始解决问题，如果不行就回溯并选择另一个动作，直到将问题解决。</p>\n<p>【练习：46 全排列】</p>\n<p>时间复杂度：O(n!) ;空间复杂度：O(n)</p>\n<pre><code class=\"javascript\">var permute = function (nums) &#123;\n  const res = [];\n  const backtrack = (arr) =&gt; &#123;\n    if (arr.length === nums.length) &#123;\n      res.push(arr);\n      return;\n    &#125;\n    nums.forEach((item) =&gt; &#123;\n      if (arr.includes(item)) return;\n      backtrack(arr.concat(item));\n    &#125;);\n  &#125;;\n  backtrack([]);\n  return res;\n&#125;;\n</code></pre>\n<p>【练习：78 子集】（难点）</p>\n<p>时间复杂度：O(2**n) , 空间复杂度：O(n)</p>\n<pre><code class=\"javascript\">var subsets = function (nums) &#123;\n  const res = [];\n  const backtrack = (path, l, start) =&gt; &#123;\n    if (path.length === l) &#123;\n      res.push(path);\n      return;\n    &#125;\n    for (let i = start; i &lt; nums.length; i++) &#123;\n      backtrack(path.concat(nums[i]), l, i + 1);\n    &#125;\n  &#125;;\n  for (let i = 0; i &lt;= nums.length; i++) &#123;\n    backtrack([], i, 0);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<h1 id=\"代码思想录\"><a href=\"#代码思想录\" class=\"headerlink\" title=\"代码思想录\"></a>代码思想录</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHJvZ3JhbW1lcmNhcmwuY29tLzA3MDQuJUU0JUJBJThDJUU1JTg4JTg2JUU2JTlGJUE1JUU2JTg5JUJFLmh0bWwjJUU2JTgwJTlEJUU4JUI3JUFG\">代码思想录</span></p>\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>时间复杂度不是在计算执行时间因为执行时间是没有标准的，这个和我们的硬件设备和机器环境有关系。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法 的时间复杂度。</p>\n<p>找到<strong>某条基本语句与问题规模 N 之间的数学表达式</strong>，就是算出了该算法的时间复杂度。</p>\n<p>另外有些算法的时间复杂度存在最好、平均和最坏情况：</p>\n<p>最坏情况：任意输入规模的最大运行次数(上界)</p>\n<p>平均情况：任意输入规模的期望运行次数</p>\n<p>最好情况：任意输入规模的最小运行次数(下界)</p>\n<p>一般情况关注的是算法的最坏运行情况，所以以<strong>最坏情况的时间复杂度为准</strong>。</p>\n<p>使用<strong>大 O 的渐进表示法</strong>进行估算。</p>\n<p>o(1):</p>\n<pre><code class=\"typescript\">let i = 0;\ni += 1;\n</code></pre>\n<p>0(n):</p>\n<pre><code class=\"typescript\">for (let i = 0; i &lt; n; i++) &#123;\n  console.log(i);\n&#125;\n</code></pre>\n<p>o(n^2):</p>\n<p><strong>双重 for 循环</strong></p>\n<p>o(logN)：</p>\n<pre><code class=\"typescript\">let i = 1;\nwhile (i &lt; n) &#123;\n  console.log(i);\n  i *= 2;\n&#125;\n</code></pre>\n<p><img data-src=\"/images/%E7%AE%97%E6%B3%953.png\" alt=\"/images/image-20240123164938769\"></p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><p>相比而言现在算法不那么关注空间复杂度，因为现在的设备的存储空间都比较大。</p>\n<p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 ，也就是额外占取的空间的大小。在进行计算时需要注意空间是可以重复利用的，不进行累积。例如：for 循环中定义的变量 i 每一次创建时使用的都是同一块空间。</p>\n<p>【变量空间可以重复利用】</p>\n<p><img data-src=\"/images/%E7%AE%97%E6%B3%951.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【函数的调用需要建立栈】</p>\n<p><img data-src=\"/images/%E7%AE%97%E6%B3%952.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>使用<strong>大 O 的渐进表示法</strong>进行估算。</p>\n<h2 id=\"数组算法：\"><a href=\"#数组算法：\" class=\"headerlink\" title=\"数组算法：\"></a>数组算法：</h2><h4 id=\"理论\"><a href=\"#理论\" class=\"headerlink\" title=\"理论\"></a>理论</h4><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>\n<ul>\n<li><strong>数组下标都是从 0 开始的。</strong></li>\n<li><strong>数组内存空间的地址是连续的</strong></li>\n</ul>\n<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>\n<p>java 中的二位数组不是一直连续的，而是 n 条连续的地址空间组成。</p>\n<h4 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h4><p>【前提】传入的数组是有序数组，数组中无重复元素</p>\n<p>【要点】区间定义 循环不变量</p>\n<p>然后 while 循环(left&lt;right),定中间的 mid 变量为：left+((right-left) &gt;&gt; 1)，利用位运算进行除法操作。</p>\n<pre><code class=\"ts\">function search(nums: number[], target: number): number &#123;\n  let mid: number,\n    left: number = 0,\n    right: number = nums.length - 1;\n  while (left &lt;= right) &#123;\n    // 位运算 + 防止大数溢出\n    mid = left + ((right - left) &gt;&gt; 1);\n    if (nums[mid] &gt; target) &#123;\n      right = mid - 1;\n    &#125; else if (nums[mid] &lt; target) &#123;\n      left = mid + 1;\n    &#125; else &#123;\n      return mid;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n</code></pre>\n<h4 id=\"移除元素\"><a href=\"#移除元素\" class=\"headerlink\" title=\"移除元素\"></a>移除元素</h4><p>【前提】传入数组和 val,移除数组中等于 val 的全部元素，返回移除后数组长度</p>\n<p>【要点】数组的元素在内存空间是连续的，不能单独删除数组的某个元素，只能覆盖</p>\n<p>两次循环（移动数组元素）：</p>\n<pre><code class=\"ts\">function solution(arr: any[], val: any): number &#123;\n  let size: number = arr.length;\n  for (let i = 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] == val) &#123;\n      //集体向前进位\n      for (let j = i + 1; j &lt; arr.length; j++) &#123;\n        arr[j - 1] = arr[j];\n      &#125;\n      i--;\n      size--;\n    &#125;\n  &#125;\n  return size;\n&#125;\n</code></pre>\n<p><strong>快慢指针</strong>（给指定元素重新赋值）：</p>\n<pre><code class=\"ts\">function removeElement(nums: number[], val: number): number &#123;\n  let slowIndex: number = 0,\n    fastIndex: number = 0; //定义快慢指针index\n  while (fastIndex &lt; nums.length) &#123;\n    //当快指针index小于数组长度时执行循环\n    if (nums[fastIndex] !== val) &#123;\n      //如果快指针对应的元素不等于val元素\n      // 注意后置递增的运算顺序大于赋值运算，相当于确定了nums中的数值，表达式结束之后再自增加一\n      nums[slowIndex++] = nums[fastIndex]; //满指针赋值\n    &#125;\n    fastIndex++;\n  &#125;\n  return slowIndex;\n&#125;\n</code></pre>\n<p>4 将排序数组平方后再排序（注意负数平方后可能大于正数）</p>\n<p>暴力解法：</p>\n<pre><code class=\"ts\">function sortedSquares(arr: number[]): number[] &#123;\n  return arr\n    .map((item: number) =&gt; item ** 2)\n    .sort((a: number, b: number) =&gt; a - b);\n&#125;\nconsole.log(sortedSquares([2, 1, 4, 0, 3]));\n</code></pre>\n<p>双指针解法：</p>\n<pre><code class=\"ts\">// 数组本来是存在顺序的,问题在于负数平方之后变为了最大数\n// 此时考虑双指针方法，向两边靠拢\nfunction sortedSquares(arr: number[]): number[] &#123;\n  let right: number = arr.length - 1,\n    left: number = 0,\n    newArr: number[] = [];\n  while (right &gt;= left) &#123;\n    if (arr[right] ** 2 &gt;= arr[left] ** 2) &#123;\n      newArr.push(arr[right--] ** 2);\n    &#125; else &#123;\n      newArr.push(arr[left++] ** 2);\n    &#125;\n  &#125;\n  return newArr;\n&#125;\nconsole.log(sortedSquares([-9, -3, 0, 2, 3, 6]));\n</code></pre>\n<p>5 长度最小的子数组</p>\n<p>双重 for 循环遍历</p>\n<pre><code class=\"ts\">function minSubArrayLen(s: number, nums: number[]): number &#123;\n  let result = Infinity;\n  let sum = 0;\n  let subLength = 0;\n  for (let i = 0; i &lt; nums.length; i++) &#123;\n    //数组遍历一遍\n    sum = 0;\n    for (let j = i; j &lt; nums.length; j++) &#123;\n      //数组遍历一遍\n      sum += nums[j]; //累加\n      if (sum &gt;= s) &#123;\n        //一旦累加的和大于指定数字\n        subLength = j - i + 1; //数组长度\n        result = result &lt; subLength ? result : subLength; //\n        break;\n      &#125;\n    &#125;\n  &#125;\n  return result == Infinity ? 0 : result;\n&#125;\n</code></pre>\n<p><strong>滑动窗口法（双指针的一种）</strong></p>\n<p>双指针滑动判断条件，将满足条件的结果进行记录（这种方法执行的也是两次循环，但是省略了中间的部分步骤，剔除了不必要的记录结果的部分）</p>\n<pre><code class=\"ts\">function minSubArrayLen(target: number, nums: number[]): number &#123;\n  // 创建指针\n  let left: number = 0,\n    right: number = 0;\n  // 创建res变量\n  let res: number = nums.length + 1;\n  let sum: number = 0;\n  while (right &lt; nums.length) &#123;\n    //当右指针小于数组的长度时执行循环\n    sum += nums[right]; //sum和累加right对应的元素（移动右指针）\n    if (sum &gt;= target) &#123;\n      //如果累加和大于目标值（移动左指针）\n      while (sum - nums[left] &gt;= target) &#123;\n        //移动到累加和小于目标值\n        sum -= nums[left++];\n      &#125;\n      res = Math.min(res, right - left + 1); //每一次累加和大于目标值时，进行判断和统计\n    &#125;\n    right++;\n  &#125;\n  return res === nums.length + 1 ? 0 : res;\n&#125;\nconsole.log(minSubArrayLen(7, [2, 3, 1, 2, 4, 3]));\n</code></pre>\n<p>6 螺旋矩阵||</p>\n<p>【条件】给定一个正整数 n，生成一个包含 1 到 n 的平方的所有元素，按照顺时针顺序螺旋排列正方形矩阵。</p>\n<p>【要点】循环不变量原则，坚持每一条边左闭右开原则</p>\n<pre><code class=\"ts\">function generateMatrix(n: number): number[][] &#123;\n  let loopNum: number = Math.floor(n / 2); //定义循环次数\n  const resArr: number[][] = new Array(n).fill(1).map((i) =&gt; new Array(n)); //定义二元数组\n  let chunkNum: number = n - 1; //循环长度\n  let startX: number = 0; //开始x\n  let startY: number = 0; //开始y\n  let value: number = 1; //数值\n  let x: number, y: number;\n  while (loopNum--) &#123;\n    //当loopNum的值大于0时执行循环，每一个loopNum自减\n    x = startX;\n    y = startY;\n    while (x &lt; startX + chunkNum) &#123;\n      //当x小于开始x加上循环长度时 向右执行循环\n      resArr[y][x] = value; //填充\n      x++;\n      value++;\n    &#125;\n    while (y &lt; startY + chunkNum) &#123;\n      //当y小于开始Y加上循环长度时 向下执行循环\n      resArr[y][x] = value; //累加y的值到指定循环长度次\n      y++;\n      value++;\n    &#125;\n    while (x &gt; startX) &#123;\n      //当x大于开始的x时，向左执行循环\n      resArr[y][x] = value;\n      x--;\n      value++;\n    &#125;\n    while (y &gt; startY) &#123;\n      //当y大于开始的y时，向上执行循环\n      resArr[y][x] = value;\n      y--;\n      value++;\n    &#125;\n    startX++; //每一次让开始x和开始y自增，以达到向内延展的效果\n    startY++;\n    chunkNum -= 2; //每一次循环之后，一行或一列需要的长度少2\n  &#125;\n  //全部循环完毕之后进行判断：如果n是奇数，则中间会有一个空出来，填充\n  if (n % 2 === 1) &#123;\n    resArr[startX][startY] = value;\n  &#125;\n  return resArr;\n&#125;\n</code></pre>\n<h2 id=\"链表算法：\"><a href=\"#链表算法：\" class=\"headerlink\" title=\"链表算法：\"></a>链表算法：</h2><h4 id=\"理论-1\"><a href=\"#理论-1\" class=\"headerlink\" title=\"理论\"></a>理论</h4><p>链表理论基础：</p>\n<p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null（空指针的意思）。</p>\n<p>链表的入口节点称为链表的头结点也就是 head。</p>\n<p>1 单链表</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A81.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>2 双链表</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A82.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>3 循环链表</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A83.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><strong>4 链表存储方式</strong></p>\n<p><strong>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</strong></p>\n<p><strong>链表是通过指针域的指针链接在内存中各个节点。</strong></p>\n<p><strong>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</strong></p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A84.png\" alt=\"/images/image-20240123164938769\"></p>\n<p>【链表和数组的区别：】</p>\n<p><img data-src=\"/images/%E9%93%BE%E8%A1%A85.png\" alt=\"/images/image-20240123164938769\"></p>\n<p><strong>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</strong></p>\n<p><strong>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</strong></p>\n<p><strong>数组取值容易增删难，链表增删简单，取值难</strong></p>\n<p><strong>5 链表的定义：</strong></p>\n<pre><code class=\"ts\">//定义链表\nclass ListNode &#123;\n  public val: number;\n  public next: ListNode | null = null;\n  constructor(value: number, next?: ListNode | null) &#123;\n    this.val = value;\n    this.next = next || null;\n  &#125;\n&#125;\nconst head1 = new ListNode(1);\nconst head2 = new ListNode(2);\nconst head3 = new ListNode(2);\nconst head4 = new ListNode(1);\nhead1.next = head2;\nhead2.next = head3;\nhead3.next = head4;\n</code></pre>\n<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【练习：203 移除链表中对应值的元素：】</p>\n<p>（1）原链表上直接删除</p>\n<pre><code class=\"ts\">// 移除链表节点元素,传入ListNode链表，val数值\nfunction removeElements(head: ListNode | null, val: number): ListNode | null &#123;\n  //边界判断，如果当前链表头节点的值为目标值，不能直接移除头节点（设置虚拟头节点可以避免）\n  while (head !== null &amp;&amp; head.val === val) &#123;\n    head = head.next;\n  &#125;\n  if (head === null) return head; //如果传入的链表是空对象，直接返回\n  let pre: ListNode = head,\n    cur: ListNode | null = head.next; //定义前一个节点，当前节点\n  // 删除非头部节点\n  while (cur) &#123;\n    //当前节点有值时进行循环\n    if (cur.val === val) &#123;\n      //如果当前节点的值为进行判断的值，就将当前的下一项赋值给pre前一个的下一项（跳过当前节点）\n      pre.next = cur.next;\n    &#125; else &#123;\n      //否则遍历判断下一项\n      //此处不加类型断言时：编译器会认为pre类型为ListNode, pre.next类型为ListNode | null\n      pre = pre.next as ListNode;\n    &#125;\n    cur = cur.next;\n  &#125;\n  return head; //返回头节点\n&#125;\n</code></pre>\n<p>（2）创建虚拟头节点删除</p>\n<pre><code class=\"ts\">//在原链表上直接删除\nvar removeElements = function (\n  head: ListNode | null,\n  val: number\n): ListNode | null &#123;\n  //添加虚拟头节点\n  const data = new ListNode(0, head);\n  let pre = data,\n    cur = data.next;\n  while (cur) &#123;\n    if (cur.val === val) &#123;\n      pre.next = cur.next;\n    &#125; else &#123;\n      pre = cur;\n    &#125;\n    cur = cur.next;\n  &#125;\n  return data.next;\n&#125;;\nconsole.log(removeElements(head1, 2));\n</code></pre>\n<p>【练习：707 设计链表】</p>\n<pre><code class=\"ts\">class ListNode &#123;\n  public val: number;\n  public next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) &#123;\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  &#125;\n&#125;\n\nclass MyLinkedList &#123;\n  // 记录链表长度\n  private size: number;\n  private head: ListNode | null;\n  private tail: ListNode | null;\n  constructor() &#123;\n    this.size = 0;\n    this.head = null;\n    this.tail = null;\n  &#125;\n\n  // 获取链表中第 index个节点的值\n  get(index: number): number &#123;\n    // 索引无效的情况\n    if (index &lt; 0 || index &gt;= this.size) &#123;\n      return -1;\n    &#125;\n    let curNode = this.getNode(index);\n    // 这里在前置条件下，理论上不会出现 null的情况\n    return curNode.val;\n  &#125;\n\n  // 在链表的第一个元素之前添加一个值为 val的节点。插入后，新节点将成为链表的第一个节点。\n  addAtHead(val: number): void &#123;\n    let node: ListNode = new ListNode(val, this.head);\n    this.head = node;\n    if (!this.tail) &#123;\n      this.tail = node;\n    &#125;\n    this.size++;\n  &#125;\n\n  // 将值为 val 的节点追加到链表的最后一个元素。\n  addAtTail(val: number): void &#123;\n    let node: ListNode = new ListNode(val, null);\n    if (this.tail) &#123;\n      this.tail.next = node;\n    &#125; else &#123;\n      // 还没有尾节点，说明一个节点都还没有\n      this.head = node;\n    &#125;\n    this.tail = node;\n    this.size++;\n  &#125;\n\n  // 在链表中的第 index个节点之前添加值为 val的节点。\n  // 如果 index等于链表的长度，则该节点将附加到链表的末尾。如果 index大于链表长度，则不会插入节点。如果 index小于0，则在头部插入节点。\n  addAtIndex(index: number, val: number): void &#123;\n    if (index === this.size) &#123;\n      this.addAtTail(val);\n      return;\n    &#125;\n    if (index &gt; this.size) &#123;\n      return;\n    &#125;\n    // &lt;= 0 的情况都是在头部插入\n    if (index &lt;= 0) &#123;\n      this.addAtHead(val);\n      return;\n    &#125;\n    // 正常情况\n    // 获取插入位置的前一个 node\n    let curNode = this.getNode(index - 1);\n    let node: ListNode = new ListNode(val, curNode.next);\n    curNode.next = node;\n    this.size++;\n  &#125;\n\n  // 如果索引 index有效，则删除链表中的第 index个节点。\n  deleteAtIndex(index: number): void &#123;\n    if (index &lt; 0 || index &gt;= this.size) &#123;\n      return;\n    &#125;\n    // 处理头节点\n    if (index === 0) &#123;\n      this.head = this.head!.next;\n      // 如果链表中只有一个元素，删除头节点后，需要处理尾节点\n      if (index === this.size - 1) &#123;\n        this.tail = null;\n      &#125;\n      this.size--;\n      return;\n    &#125;\n    // 索引有效\n    let curNode: ListNode = this.getNode(index - 1);\n    curNode.next = curNode.next!.next;\n    // 处理尾节点\n    if (index === this.size - 1) &#123;\n      this.tail = curNode;\n    &#125;\n    this.size--;\n  &#125;\n\n  // 获取指定 Node节点\n  private getNode(index: number): ListNode &#123;\n    // 这里不存在没办法获取到节点的情况，都已经在前置方法做过判断\n    // 创建虚拟头节点\n    let curNode: ListNode = new ListNode(0, this.head);\n    for (let i = 0; i &lt;= index; i++) &#123;\n      // 理论上不会出现 null\n      curNode = curNode.next!;\n    &#125;\n    return curNode;\n  &#125;\n&#125;\n</code></pre>\n<p>【练习：206 反转链表】</p>\n<p>双指针法：</p>\n<pre><code class=\"ts\">var reverseList = function (head: ListNode | null): ListNode | null &#123;\n  let pre: ListNode | null = null;\n  let curNode: ListNode | null = head;\n  let tempNode: ListNode | null;\n  while (curNode) &#123;\n    tempNode = curNode.next;\n    [curNode.next, pre] = [pre, curNode];\n    curNode = tempNode;\n  &#125;\n  return pre;\n&#125;;\n</code></pre>\n<p>递归法（从前往后翻转）：</p>\n<pre><code class=\"ts\">function reverseList(head: ListNode | null): ListNode | null &#123;\n  function recur(\n    preNode: ListNode | null,\n    curNode: ListNode | null\n  ): ListNode | null &#123;\n    if (curNode === null) return preNode;\n    let tempNode: ListNode | null = curNode.next;\n    curNode.next = preNode;\n    preNode = curNode;\n    curNode = tempNode;\n    return recur(preNode, curNode);\n  &#125;\n  return recur(null, head);\n&#125;\n</code></pre>\n<p>【练习：24 两两交换链表中的节点】</p>\n<pre><code class=\"javascript\">var swapPairs = function (head) &#123;\n  // 首先创建一个新的节点\n  const res = new ListNode(0, head);\n  let temp = res;\n  while (temp &amp;&amp; temp.next &amp;&amp; temp.next.next) &#123;\n    const node1 = temp.next;\n    const node2 = temp.next.next;\n    temp.next = node2;\n    node1.next = node2.next;\n    node2.next = node1;\n    temp = node1;\n  &#125;\n  return res.next;\n&#125;;\n</code></pre>\n<p>【练习：19 删除链表的倒数第 N 个节点】</p>\n<p>双指针</p>\n<pre><code class=\"javascript\">var removeNthFromEnd = function (head, n) &#123;\n  let pre = new ListNode(0, head),\n    tail = head;\n  let res = pre;\n  while (n--) &#123;\n    tail = tail.next;\n  &#125;\n  while (tail) &#123;\n    tail = tail.next;\n    pre = pre.next;\n  &#125;\n  pre.next = pre.next.next;\n  return res.next;\n&#125;;\n</code></pre>\n<p>【练习：160 相交链表】</p>\n<p>时间复杂度：O(n) 或 O(m)</p>\n<pre><code class=\"javascript\">function getListLen(list) &#123;\n  let len = 0,\n    head = list;\n  while (head) &#123;\n    len++;\n    head = head.next;\n  &#125;\n  return len;\n&#125;\nfunction getIntersectionNode(head1, head2) &#123;\n  let len1 = getListLen(head1),\n    len2 = getListLen(head2),\n    shortList = head1,\n    bigList = head2;\n  if (len2 &lt; len1) &#123;\n    shortList = head2;\n    bigList = head1;\n  &#125;\n  let i = Math.abs(len1 - len2);\n  while (i-- &gt; 0) &#123;\n    bigList = bigList.next;\n  &#125;\n  while (bigList &amp;&amp; bigList !== shortList) &#123;\n    bigList = bigList.next;\n    shortList = shortList.next;\n  &#125;\n  return bigList;\n&#125;\n</code></pre>\n<p>【练习：142 环形链表】</p>\n<pre><code class=\"javascript\">var detectCycle = function (head) &#123;\n  if (!head || !head.next) return null;\n  let slow = head.next,\n    fast = head.next.next;\n  //当快慢指针都有值，并且快指针和慢指针不相等时循环\n  while (fast &amp;&amp; fast.next &amp;&amp; fast !== slow) &#123;\n    slow = slow.next;\n    fast = fast.next.next;\n  &#125;\n  //此时判断是由于遍历结束，还是两值相等（有环）\n  if (!fast || !fast.next) return null;\n  slow = head;\n  while (fast !== slow) &#123;\n    slow = slow.next;\n    fast = fast.next;\n  &#125;\n  return slow;\n&#125;;\n</code></pre>\n<h2 id=\"哈希算法：\"><a href=\"#哈希算法：\" class=\"headerlink\" title=\"哈希算法：\"></a>哈希算法：</h2><h4 id=\"理论-2\"><a href=\"#理论-2\" class=\"headerlink\" title=\"理论\"></a>理论</h4><p>1 哈希表</p>\n<p>也称散列表，数组就是一张哈希表，哈希表将元素和数组的下标相对应，这样就可以快速查询到数组中的某个元素。一般哈希表用于快速判断一个元素是否出现在集合里。如果查询数组中是否有某个元素，或者获取该元素，需要遍历整个数组（O(n)），但要是查询哈希表中是否有某个元素，只需要找数组对应下标的元素。</p>\n<p>其中关键在于将元素和数组下标对应起来，这就是哈希函数:</p>\n<p>2 哈希函数</p>\n<p>哈希函数通过算法，将元素和数组下标对应起来，例如当存储元素为 a-z 的字母时，可以巧妙使用 Unicode 值：</p>\n<pre><code class=\"javascript\">const hashArr = [];\nfunction hashFn(str) &#123;\n  const index = str.charCodeAt() - &quot;a&quot;.charCodeAt();\n  hashArr[index] = str;\n&#125;\n</code></pre>\n<p>但是，某情况下无法避免两个元素所计算的下标相同的情况（哈希碰撞）</p>\n<p>3 哈希碰撞</p>\n<p>两个不同元素，通过哈希函数所计算出来的下标相同。</p>\n<p>4 拉链法</p>\n<p>拉链法用于解决哈希碰撞，发生碰撞的时候，将碰撞处以链表形式添加，就是适当选择哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多空间。</p>\n<p>5 线性探测法</p>\n<p>线性探测法当发生哈希碰撞时，根据碰撞位置向下寻找，知道找到空位。</p>\n<h4 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【242】有效的字母异位词</p>\n<pre><code class=\"javascript\">var isAnagram = function (s, t) &#123;\n  if (s.length !== t.length) return false;\n  const arr = new Array(26).fill(0);\n  const base = &quot;a&quot;.charCodeAt();\n  for (const i of s) &#123;\n    arr[i.charCodeAt() - base]++;\n  &#125;\n  for (const i of t) &#123;\n    if (!arr[i.charCodeAt() - base]) return false;\n    arr[i.charCodeAt() - base]--;\n  &#125;\n  return true;\n&#125;;\n</code></pre>\n<p>【349】两个数组的交集</p>\n<pre><code class=\"javascript\">var intersection = function (nums1, nums2) &#123;\n  const res = [];\n  const map = new Map();\n  nums1.forEach((item) =&gt; &#123;\n    map.set(item, true);\n  &#125;);\n  nums2.forEach((item) =&gt; &#123;\n    if (map.get(item)) &#123;\n      res.push(item);\n      map.delete(item);\n    &#125;\n  &#125;);\n  return res;\n&#125;;\n</code></pre>\n<pre><code class=\"javascript\">var intersection = function (nums1, nums2) &#123;\n  return Array.from(new Set(nums1.filter((item) =&gt; nums2.includes(item))));\n&#125;;\n</code></pre>\n<p>【202】快乐数</p>\n<pre><code class=\"javascript\">var getSum = function (n) &#123;\n  let sum = 0;\n  while (n) &#123;\n    sum += (n % 10) ** 2;\n    n = Math.floor(n / 10);\n  &#125;\n  return sum;\n&#125;;\nvar isHappy = function (n) &#123;\n  let set = new Set(); // Set() 里的数是惟一的\n  // 如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数\n  while (n !== 1 &amp;&amp; !set.has(n)) &#123;\n    set.add(n);\n    n = getSum(n);\n  &#125;\n  return n === 1;\n&#125;;\n</code></pre>\n<p>【1】两数之和</p>\n<pre><code class=\"javascript\">var twoSum = function (nums, target) &#123;\n  const map = new Map();\n  for (let i = 0; i &lt; nums.length; i += 1) &#123;\n    const n = nums[i];\n    const n2 = target - n;\n    if (map.has(n2)) &#123;\n      return [map.get(n2), i];\n    &#125; else &#123;\n      map.set(n, i);\n    &#125;\n  &#125;\n&#125;;\n</code></pre>\n<p>【454】四数相加 ||</p>\n<pre><code class=\"javascript\">var fourSumCount = function (nums1, nums2, nums3, nums4) &#123;\n  const towSumMap = new Map();\n  let count = 0;\n  for (const n1 of nums1) &#123;\n    for (const n2 of nums2) &#123;\n      const sum = n1 + n2;\n      //如果map中有sum就get++，如果map中没有sum就set\n      towSumMap.set(sum, (towSumMap.get(sum) || 0) + 1);\n    &#125;\n  &#125;\n  for (const n3 of nums3) &#123;\n    for (const n4 of nums4) &#123;\n      const sum = n3 + n4;\n      count += towSumMap.get(-sum) || 0;\n    &#125;\n  &#125;\n  return count;\n&#125;;\n</code></pre>\n<p>【383】赎金信</p>\n<pre><code class=\"javascript\">var canConstruct = function (ransomNote, magazine) &#123;\n  if (magazine.length &lt; ransomNote.length) return false;\n  const arr = new Array(26).fill(0);\n  const base = &quot;a&quot;.charCodeAt();\n  for (let i of magazine) &#123;\n    arr[i.charCodeAt() - base]++;\n  &#125;\n  for (let i of ransomNote) &#123;\n    let index = i.charCodeAt() - base;\n    if (arr[index] === 0) &#123;\n      return false;\n    &#125;\n    arr[index]--;\n  &#125;\n  return true;\n&#125;;\n</code></pre>\n<p>【15】三数之和</p>\n<pre><code class=\"javascript\">var threeSum = function (nums) &#123;\n  const res = [],\n    len = nums.length;\n  //将数组排序\n  nums.sort((a, b) =&gt; a - b);\n  console.log(nums);\n  //遍历数组\n  for (let i = 0; i &lt; len; i++) &#123;\n    let l = i + 1,\n      r = len - 1,\n      iNum = nums[i];\n    //判断首元素\n    if (nums[i] &gt; 0) return res;\n    if (iNum == nums[i - 1]) continue;\n    while (l &lt; r) &#123;\n      let lNum = nums[l],\n        rNum = nums[r],\n        threeSum = iNum + lNum + rNum;\n      console.log(iNum, lNum, rNum);\n      console.log(threeSum);\n      if (threeSum &lt; 0) l++;\n      else if (threeSum &gt; 0) r--;\n      else &#123;\n        res.push([iNum, lNum, rNum]);\n        //去重\n        while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) &#123;\n          l++;\n        &#125;\n        while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) &#123;\n          r--;\n        &#125;\n        l++;\n        r--;\n      &#125;\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【18】四数之和 <strong>难点</strong></p>\n<pre><code class=\"javascript\">var fourSum = function (nums, target) &#123;\n  const len = nums.length;\n  if (len &lt; 4) return [];\n  nums.sort((a, b) =&gt; a - b);\n  const res = [];\n  for (let i = 0; i &lt; len - 3; i++) &#123;\n    //去重\n    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;\n    for (let j = i + 1; j &lt; len - 2; j++) &#123;\n      // 去重\n      if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) continue;\n      let l = j + 1,\n        r = len - 1;\n      while (l &lt; r) &#123;\n        const sum = nums[i] + nums[j] + nums[l] + nums[r];\n        if (sum &lt; target) &#123;\n          l++;\n          continue;\n        &#125;\n        if (sum &gt; target) &#123;\n          r--;\n          continue;\n        &#125;\n        res.push([nums[i], nums[j], nums[l], nums[r]]);\n        while (l &lt; r &amp;&amp; nums[l] === nums[++l]);\n        while (l &lt; r &amp;&amp; nums[r] === nums[--r]);\n      &#125;\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h4 id=\"题目-2\"><a href=\"#题目-2\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【27】移除元素</p>\n<pre><code class=\"javascript\">let removeElement = (nums, val) =&gt; &#123;\n  let k = 0;\n  for (let i of nums) &#123;\n    if (i != val) &#123;\n      nums[k++] = i;\n    &#125;\n  &#125;\n  return k;\n&#125;;\n</code></pre>\n<p>【344】反转字符串</p>\n<pre><code class=\"javascript\">var reverse = function (s) &#123;\n  let l = -1,\n    r = s.length;\n  while (++l &lt; --r) [s[l], s[r]] = [s[r], s[l]];\n  return s;\n&#125;;\n</code></pre>\n<p>【】替换数字</p>\n<pre><code class=\"javascript\">let replaceNumber = (nums) =&gt; &#123;\n  let str = &quot;&quot;;\n  for (let i of nums) &#123;\n    if (!Object.is(Number(i), NaN)) &#123;\n      console.log(i);\n      str += &quot;number&quot;;\n    &#125; else &#123;\n      str += i;\n    &#125;\n  &#125;\n  return str;\n&#125;;\n</code></pre>\n<p>【151】翻转字符串里的单词</p>\n<pre><code class=\"javascript\">/**\n * 删除前后的空格\n */\nfunction removeExtraSpaces(strArr) &#123;\n  let slowIndex = 0,\n    fastIndex = 0;\n  while (fastIndex &lt; strArr.length) &#123;\n    if (\n      strArr[fastIndex] === &quot; &quot; &amp;&amp;\n      (fastIndex === 0 || strArr[fastIndex - 1] === &quot; &quot;)\n    ) &#123;\n      fastIndex++;\n    &#125; else &#123;\n      strArr[slowIndex++] = strArr[fastIndex++];\n    &#125;\n  &#125;\n  // 移除末尾的空格\n  strArr.length = strArr[slowIndex - 1] === &quot; &quot; ? slowIndex - 1 : slowIndex;\n&#125;\n/**\n * 翻转从start到end的字符\n */\nfunction reverse(strArr, start, end) &#123;\n  let left = start;\n  let right = end;\n  while (left &lt; right) &#123;\n    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];\n    left++;\n    right;\n  &#125;\n&#125;\n/**\n * 翻转字符串\n */\nfunction reverseWords(s) &#123;\n  const strArr = Array.from(s);\n  removeExtraSpaces(strArr);\n  reverse(strArr, 0, strArr.length - 1);\n  let start = 0;\n  for (let i = 0; i &lt;= strArr.length; i++) &#123;\n    if (strArr[i] === &quot; &quot; || i === strArr.length) &#123;\n      reverse(strArr, start, i - 1);\n      start = i + i;\n    &#125;\n  &#125;\n  return strArr.join(&quot;&quot;);\n&#125;\n</code></pre>\n<p>【28】实现 strStr()</p>\n<p>自己实现：</p>\n<pre><code class=\"javascript\">var strStr = function (str1, str2) &#123;\n  if (str2.length === 0) return 0;\n  if (str2.length &gt; str1.length) return -1;\n  let l = 0,\n    r = 0,\n    len = str1.length,\n    len2;\n  while (l &lt; len) &#123;\n    if (str1[l] === str2[0]) &#123;\n      if (str2.length === 1) return l;\n      let i = 1;\n      for (; i &lt; str2.length; i++) &#123;\n        if (str1[l + i] != str2[i]) &#123;\n          break;\n        &#125;\n      &#125;\n      len2 = i - 1;\n    &#125;\n    if (len2 === str2.length - 1) &#123;\n      return l;\n    &#125;\n    l++;\n  &#125;\n  return -1;\n&#125;;\n</code></pre>\n<p>next 数组前缀表统一减一</p>\n<pre><code class=\"javascript\">var strStr = function (haystack, needle) &#123;\n  if (needle.length === 0) return 0;\n\n  const getNext = (needle) =&gt; &#123;\n    let next = [];\n    let j = -1;\n    next.push(j);\n\n    for (let i = 1; i &lt; needle.length; ++i) &#123;\n      while (j &gt;= 0 &amp;&amp; needle[i] !== needle[j + 1]) j = next[j];\n      if (needle[i] === needle[j + 1]) j++;\n      next.push(j);\n    &#125;\n\n    return next;\n  &#125;;\n\n  let next = getNext(needle);\n  let j = -1;\n  for (let i = 0; i &lt; haystack.length; ++i) &#123;\n    while (j &gt;= 0 &amp;&amp; haystack[i] !== needle[j + 1]) j = next[j];\n    if (haystack[i] === needle[j + 1]) j++;\n    if (j === needle.length - 1) return i - needle.length + 1;\n  &#125;\n\n  return -1;\n&#125;;\n</code></pre>\n<p>【459】重复的子字符串</p>\n<pre><code class=\"javascript\">var repeatedSubstringPattern = function (s) &#123;\n  let str = s + s;\n  return str.slice(1, str.length - 1).includes(s);\n&#125;;\n</code></pre>\n<p>next 数组实现</p>\n<pre><code class=\"javascript\">var repeatedSubstringPattern = function (s) &#123;\n  if (s.length === 0) return false;\n  const getNext = (s) =&gt; &#123;\n    //得到next数组\n    let next = [];\n    let j = -1;\n    next.push(j); //next数组第一个是-1\n    for (let i = 1; i &lt; s.length; ++i) &#123;\n      //遍历s的长度\n      while (j &gt;= 0 &amp;&amp; s[i] !== s[j + 1]) j = next[j];\n      if (s[i] === s[j + 1]) j++;\n      next.push(j);\n    &#125;\n    return next;\n  &#125;;\n  let next = getNext(s); //得到next数组\n  if (\n    next[next.length - 1] !== -1 &amp;&amp;\n    s.length % (s.length - (next[next.length - 1] + 1)) === 0\n  ) &#123;\n    // next数组最后一个元素不等于-1 并且 字符串的长度取余next数组最后一个元素\n    return true;\n  &#125;\n  return false;\n&#125;;\n</code></pre>\n<h2 id=\"双指针算法\"><a href=\"#双指针算法\" class=\"headerlink\" title=\"双指针算法\"></a>双指针算法</h2><h4 id=\"题目-3\"><a href=\"#题目-3\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【27】移除元素</p>\n<pre><code class=\"javascript\">var removeElement = function (nums, val) &#123;\n  let i = 0,\n    len = nums.length - 1;\n  while (i &lt;= len) &#123;\n    if (nums[i] === val) &#123;\n      nums[i] = nums[len];\n      len--;\n      i--;\n    &#125;\n    i++;\n  &#125;\n  nums.length = len + 1;\n  return len + 1;\n&#125;;\n</code></pre>\n<p>【344】反转字符串</p>\n<pre><code class=\"javascript\">var reverseString = function (s) &#123;\n  let i = 0,\n    j = s.length - 1;\n  while (i &lt;= j) &#123;\n    [s[i], s[j]] = [s[j], s[i]];\n    j--;\n    i++;\n  &#125;\n  return s;\n&#125;;\n</code></pre>\n<p>【】替换数字</p>\n<pre><code class=\"javascript\">function reverseNumber(str) &#123;\n  let i = 0,\n    res = &quot;&quot;;\n  while (i &lt; str.length) &#123;\n    if (Object.is(+str[i], NaN)) &#123;\n      console.log(str[i]);\n      res += str[i];\n    &#125; else &#123;\n      console.log(str[i]);\n      res += &quot;number&quot;;\n    &#125;\n    i++;\n  &#125;\n  return res;\n&#125;\n</code></pre>\n<p>【151】翻转字符串里的单词</p>\n<pre><code class=\"javascript\">var reverseWords = function (s) &#123;\n  return s.split(/\\s+/).reverse().join(&quot; &quot;).trim();\n&#125;;\n</code></pre>\n<p>【160】链表相交</p>\n<p>链表后长度统一：</p>\n<pre><code class=\"javascript\">function getListLen(list) &#123;\n  let len = 0,\n    head = list;\n  while (head) &#123;\n    len++;\n    head = head.next;\n  &#125;\n  return len;\n&#125;\nfunction getIntersectionNode(head1, head2) &#123;\n  let len1 = getListLen(head1),\n    len2 = getListLen(head2),\n    shortList = head1,\n    bigList = head2;\n  if (len2 &lt; len1) &#123;\n    shortList = head2;\n    bigList = head1;\n  &#125;\n  let i = Math.abs(len1 - len2);\n  while (i-- &gt; 0) &#123;\n    bigList = bigList.next;\n  &#125;\n  while (bigList &amp;&amp; bigList !== shortList) &#123;\n    bigList = bigList.next;\n    shortList = shortList.next;\n  &#125;\n  return bigList;\n&#125;\n</code></pre>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><p>队列是先进先出，栈是先进后出。</p>\n<h4 id=\"题目-4\"><a href=\"#题目-4\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【232】用栈实现队列</p>\n<pre><code class=\"javascript\">//实现链表\nclass listNode &#123;\n  constructor(val, next = null) &#123;\n    this.val = val;\n    this.next = next;\n  &#125;\n&#125;\n//实现栈\nclass Stack &#123;\n  constructor() &#123;\n    this.items = [];\n  &#125;\n&#125;\nStack.prototype.push = function (val) &#123;\n  return this.items.push(val);\n&#125;;\nStack.prototype.pop = function () &#123;\n  return this.items.pop();\n&#125;;\nStack.prototype.peek = function () &#123;\n  return this.items[this.items.length - 1];\n&#125;;\nStack.prototype.isEmpty = function () &#123;\n  return this.items.length === 0;\n&#125;;\nStack.prototype.size = function () &#123;\n  return this.items.length;\n&#125;;\n//用栈实现队列\nclass MyQueue &#123;\n  constructor() &#123;\n    this.stackIn = new Stack();\n    this.stackOut = new Stack();\n  &#125;\n&#125;\n\nMyQueue.prototype.push = function (x) &#123;\n  this.stackIn.push(x);\n&#125;;\n\nMyQueue.prototype.pop = function () &#123;\n  const size = this.stackOut.size();\n  if (size) &#123;\n    return this.stackOut.pop();\n  &#125;\n  while (this.stackIn.size()) &#123;\n    this.stackOut.push(this.stackIn.pop());\n  &#125;\n  return this.stackOut.pop();\n&#125;;\n\nMyQueue.prototype.peek = function () &#123;\n  const size = this.stackOut.size();\n  if (size) &#123;\n    return this.stackOut[this.stackOut.size() - 1];\n  &#125;\n  while (this.stackIn.size()) &#123;\n    this.stackOut.push(this.stackIn.pop());\n  &#125;\n  return this.stackOut.peek();\n&#125;;\n\nMyQueue.prototype.empty = function () &#123;\n  return !this.stackOut.size() &amp;&amp; !this.stackIn.size();\n&#125;;\n</code></pre>\n<p>【225】用队列实现栈</p>\n<pre><code class=\"javascript\">//队列模拟栈\nclass Queue &#123;\n  constructor() &#123;\n    this.items = [];\n  &#125;\n&#125;\nQueue.prototype.shift = function () &#123;\n  return this.items.shift();\n&#125;;\nQueue.prototype.push = function (val) &#123;\n  return this.items.push(val);\n&#125;;\nQueue.prototype.size = function () &#123;\n  return this.items.length;\n&#125;;\nQueue.prototype.peek = function () &#123;\n  return this.items[0];\n&#125;;\n\nclass Stack &#123;\n  constructor() &#123;\n    this.queueIn = new Queue();\n    this.queueOut = new Queue();\n  &#125;\n&#125;\nStack.prototype.push = function (val) &#123;\n  this.queueIn.push(val);\n&#125;;\nStack.prototype.pop = function () &#123;\n  if (!this.queueIn.size()) &#123;\n    [this.queueIn, this.queueOut] = [this.queueOut, this.queueIn];\n  &#125;\n  while (this.queueIn.size() &gt; 1) &#123;\n    this.queueOut.push(this.queueIn.shift());\n  &#125;\n  return this.queueIn.shift();\n&#125;;\nStack.prototype.top = function () &#123;\n  const x = this.pop();\n  this.queueIn.push(x);\n  return x;\n&#125;;\nStack.prototype.empty = function () &#123;\n  return !this.queueIn.size() &amp;&amp; !this.queueOut.size();\n&#125;;\n</code></pre>\n<p>【1047】删除字符串中的所有相邻重复项</p>\n<pre><code class=\"javascript\">const removeDuplicates = (str) =&gt; &#123;\n  //使用栈\n  const resArr = [];\n  for (let i of str) &#123;\n    if (resArr[resArr.length - 1] === i) &#123;\n      resArr.pop();\n    &#125; else &#123;\n      resArr.push(i);\n    &#125;\n  &#125;\n  return resArr.join(&quot;&quot;);\n&#125;;\n</code></pre>\n<p>【150】逆波兰表达式求值</p>\n<pre><code class=\"javascript\">/**\n * @param &#123;string[]&#125; tokens\n * @return &#123;number&#125;\n */\nvar evalRPN = function (tokens) &#123;\n  //维持一个栈\n  const stack = [];\n  for (const token of tokens) &#123;\n    if (isNaN(+token)) &#123;\n      const n2 = stack.pop();\n      const n1 = stack.pop();\n      switch (token) &#123;\n        case &quot;+&quot;:\n          stack.push(n1 + n2);\n          break;\n        case &quot;-&quot;:\n          stack.push(n1 - n2);\n          break;\n        case &quot;*&quot;:\n          stack.push(n1 * n2);\n          break;\n        case &quot;/&quot;:\n          stack.push((n1 / n2) | 0);\n          break;\n      &#125;\n    &#125; else &#123;\n      stack.push(+token);\n    &#125;\n  &#125;\n  return stack[0];\n&#125;;\n</code></pre>\n<p>【239】滑动窗口最大值（难点）</p>\n<p>使用队列：</p>\n<pre><code class=\"javascript\">var maxSlidingWindow = function (nums, k) &#123;\n  class MonoQueue &#123;\n    queue;\n    constructor() &#123;\n      this.queue = [];\n    &#125;\n    enqueue(value) &#123;\n      let back = this.queue[this.queue.length - 1];\n      while (back !== undefined &amp;&amp; back &lt; value) &#123;\n        this.queue.pop();\n        back = this.queue[this.queue.length - 1];\n      &#125;\n      this.queue.push(value);\n    &#125;\n    dequeue(value) &#123;\n      let front = this.front();\n      if (front === value) &#123;\n        this.queue.shift();\n      &#125;\n    &#125;\n    front() &#123;\n      return this.queue[0];\n    &#125;\n  &#125;\n  let helperQueue = new MonoQueue();\n  let i = 0,\n    j = 0;\n  let resArr = [];\n  while (j &lt; k) &#123;\n    helperQueue.enqueue(nums[j++]);\n  &#125;\n  resArr.push(helperQueue.front());\n  while (j &lt; nums.length) &#123;\n    helperQueue.enqueue(nums[j]);\n    helperQueue.dequeue(nums[i]);\n    resArr.push(helperQueue.front());\n    i++, j++;\n  &#125;\n  return resArr;\n&#125;;\n</code></pre>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>1、满二叉树</p>\n<p>如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且<strong>度为 0 的结点在同一层上</strong>，则这颗二叉树就为满二叉树。</p>\n<p>2、完全二叉树</p>\n<p>在完全二叉树中，除了最底层节点可能没填满之外，其余每层结点数都达到最大值，并且最下面一层的结点都集中在该层最左边的若干位置。</p>\n<p>3、二叉搜索树</p>\n<p>二叉搜索树是一个有序树（左&lt;中&lt;右的排序向下递归）：</p>\n<ul>\n<li>若左子树不空，则左子树所有结点均小于它的根节点的值</li>\n<li>若右子树不空，则右子树上所有结点的值均大于它的根节点的值</li>\n<li>它的左右子树也分别为二叉搜索树</li>\n</ul>\n<p>4、平衡二叉树（左子树右子树高度差不超过 1 的方式向下递归）</p>\n<p>平衡二叉树是一颗空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一颗平衡二叉树。</p>\n<p>5、红黑树</p>\n<p>当二叉搜索树插入序列是有序的时候会出现退化的情况，变成链表（查询速度变慢），这时使用平衡树，在插入的时候调整这棵树，让它的节点尽可能地均匀分布，变为平衡二叉搜索树。</p>\n<p>红黑树其实就是平衡树的一种，它的复杂定义和规则都是为了保证树的平衡性。红黑树是一种更为宽松的二叉平衡搜索树，相对于二叉平衡搜索树，它的平衡条件更加宽松，可以容忍一定程度的不平衡。</p>\n<p>保证树的平衡的意义：因为树的查找性能取决于树的高度，让树尽可能平衡就是为了降低树的高度。</p>\n<p>6、B 树</p>\n<p>B 树是一种<strong>多路搜索树</strong>，它的每个节点可以拥有多于两个孩子节点。M 路的 B 树最多能拥有 M 个孩子节点。路数越多，树的高度越低。不限制路数，B 树就退化成一个有序数组了。</p>\n<p><strong>B 树常用于文件系统的索引</strong>，文件系统和数据库的索引都是存在硬盘上的，如果数据量大的话，不一定能一次性加载到内存中（运行时内存）。这时就需要使用<strong>B 树多路存储</strong>的威力，可以每次加载 B 树的一个节点，然后一步步往下找。</p>\n<p>在内存中，红黑树确实比 B 树效率更高，但是当涉及到磁盘操作时，B 树就更优了。</p>\n<p>7、B+树</p>\n<p>B+树是在 B 树的基础上进行改造的，它的数据都在叶子节点，同时叶子节点之间还加了指针形成链表。</p>\n<p><strong>B+树在数据库索引中用的比较多</strong>，数据库中 Select 数据，不一定只选一条，很多时候会选多条。如果是多条的话，B 树需要做局部的中序遍历，可能要跨层访问。而 B+ 树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>\n<h4 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h4><ul>\n<li><p>用数组存储：如果父节点数组下标是 i，则它的左孩子就是 i _ 2 + 1 , 右孩子就是 i _ 2 + 2</p>\n</li>\n<li><p>用链表存储：用左右指针进行存储</p>\n<pre><code class=\"ts\">class TreeNode &#123;\n  public val: number;\n  public left: TreeNode | null;\n  public right: TreeNode | null;\n  constructor(val: number, left?: TreeNode, right?: TreeNode) &#123;\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = left === undefined ? null : right;\n  &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><p>二叉树的遍历方式有：（中间节点的顺序就是所谓的遍历方式）</p>\n<ul>\n<li>前序遍历：中 左 右</li>\n<li>中序遍历：左 中 右</li>\n<li>后序遍历： 左 右 中</li>\n</ul>\n<p><strong>遍历结果的联系：根节点的分割性</strong></p>\n<p><strong>根节点的分割性就是说：三种遍历方式得到的结果，在去掉根节点后，根节点左边就是根节点左子树对应的遍历方式，右边就是右子树对应的遍历方式（三种遍历方式都是）。</strong></p>\n<p>例如：</p>\n<p><img data-src=\"/images/Snipaste_2024-06-14_09-57-32.png\" alt=\"树\"></p>\n<ul>\n<li><p>先序遍历：A B D F C E G H I</p>\n</li>\n<li><p>中序遍历：B F D A C H G I E</p>\n</li>\n<li><p>后序遍历：F D B H I G E C A</p>\n<ul>\n<li><p>中序遍历的根节点左边是其左子树，右边是其右子树，即假如知道了根节点的位置，就可以初步构造出其左子树和右子树，利用递归的思想就能还原出整颗树。</p>\n</li>\n<li><p>而先序遍历的第一个元素就是根节点，后序遍历的最后一个元素是根节点，因此只要知道其一和中序遍历结合就能还原整棵树。</p>\n</li>\n<li><p>中序遍历引导的颗粒性适用于其他两种遍历方式。即：中序遍历以根节点为基准（index）进行切割：都有先序遍历和后序遍历相同的切割方式与之对应。</p>\n</li>\n<li><p>即：<strong>先序遍历和后序遍历移除根节点后：</strong></p>\n<ul>\n<li>中序遍历（0，index） —–&gt; 先序遍历（0，index）和 后序遍历（0，index）</li>\n<li>中序遍历（index+1） —–&gt; 先序遍历（index） 和 后序遍历（index）</li>\n<li>中序遍历结果在确定根节点后，就确定了左子树（n）和右子树（m）的节点数量（m+n）</li>\n<li>先序遍历结果去掉根节点后，前 n 个就是左子树的先序遍历结果，后 m 个就是右子树先序遍历结果</li>\n<li>后序遍历结果去掉根节点后，前 n 个就是左子树的先序遍历结果，后 m 个就是右子树先序遍历结果</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>二叉树的递归遍历：</strong></p>\n<pre><code class=\"ts\">// 前序遍历\nfunction preorderTracersal(node: TreeNode | null): number[] &#123;\n  function traverse(node: TreeNode | null, res: number[]): void &#123;\n    if (node === null) return;\n    res.push(node.val);\n    traverse(node.left, res);\n    traverse(node.right, res); //中序遍历和后序遍历除了此处顺序不同之外，其余都相同\n  &#125;\n  const res: number[] = [];\n  traverse(node, res);\n  return res;\n&#125;\n</code></pre>\n<p><strong>二叉树的迭代遍历（需要维持一个栈）：</strong></p>\n<pre><code class=\"ts\">// 前序遍历（迭代法）\nfunction preorderTraversal(root: TreeNode | null): number[] &#123;\n  if (root === null) return [];\n  let res: number[] = [];\n  let helperStack: TreeNode[] = [];\n  let curNode: TreeNode = root;\n  helperStack.push(curNode);\n  while (helperStack.length &gt; 0) &#123;\n    curNode = helperStack.pop()!;\n    res.push(curNode.val);\n    if (curNode.right !== null) helperStack.push(curNode.right);\n    if (curNode.left !== null) helperStack.push(curNode.left);\n  &#125;\n  return res;\n&#125;\n\n// 中序遍历（迭代法）\nfunction inorderTraversal(root: TreeNode | null): number[] &#123;\n  let helperStack: TreeNode[] = [];\n  let res: number[] = [];\n  if (root === null) return res;\n  let curNode: TreeNode | null = root;\n  while (curNode !== null || helperStack.length &gt; 0) &#123;\n    if (curNode !== null) &#123;\n      helperStack.push(curNode);\n      curNode = curNode.left;\n    &#125; else &#123;\n      curNode = helperStack.pop()!;\n      res.push(curNode.val);\n      curNode = curNode.right;\n    &#125;\n  &#125;\n  return res;\n&#125;\n\n// 后序遍历（迭代法）\nfunction postorderTraversal(root: TreeNode | null): number[] &#123;\n  let helperStack: TreeNode[] = [];\n  let res: number[] = [];\n  let curNode: TreeNode;\n  if (root === null) return res;\n  helperStack.push(root);\n  while (helperStack.length &gt; 0) &#123;\n    curNode = helperStack.pop()!;\n    res.push(curNode.val);\n    if (curNode.left !== null) helperStack.push(curNode.left);\n    if (curNode.right !== null) helperStack.push(curNode.right);\n  &#125;\n  return res.reverse();\n&#125;\n</code></pre>\n<p><strong>二叉树的层序遍历：</strong></p>\n<pre><code class=\"javascript\">const testTree = &#123;\n  val: 1,\n  left: &#123;\n    val: 2,\n    left: &#123; val: 3 &#125;,\n    right: &#123; val: 4 &#125;,\n  &#125;,\n  right: &#123;\n    val: 5,\n    left: &#123; val: 6 &#125;,\n    right: &#123; val: 7 &#125;,\n  &#125;,\n&#125;;\n/**\n * 二叉树层序遍历\n */\nconst levelOrder = (tree) =&gt; &#123;\n  if (!tree) return [];\n  const queue = [tree],\n    res = [];\n  let currentNode;\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      currentNode = queue.shift();\n      console.log(currentNode.val);\n      res.push(currentNode.val);\n      currentNode.left &amp;&amp; queue.push(currentNode.left);\n      currentNode.right &amp;&amp; queue.push(currentNode.right);\n    &#125;\n  &#125;\n  return res;\n&#125;;\nlevelOrder(testTree);\n</code></pre>\n<h4 id=\"题目-5\"><a href=\"#题目-5\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>【102】二叉树的层序遍历</p>\n<pre><code class=\"javascript\">var levelOrder = function (root) &#123;\n  //二叉树的层序遍历\n  let res = [],\n    queue = [];\n  queue.push(root);\n  if (root === null) &#123;\n    return res;\n  &#125;\n  while (queue.length !== 0) &#123;\n    // 记录当前层级节点数\n    let length = queue.length;\n    //存放每一层的节点\n    let curLevel = [];\n    for (let i = 0; i &lt; length; i++) &#123;\n      let node = queue.shift();\n      curLevel.push(node.val);\n      // 存放当前层下一层的节点\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    &#125;\n    //把每一层的结果放到结果数组\n    res.push(curLevel);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【107】二叉树的层序遍历 ||</p>\n<pre><code class=\"javascript\">var levelOrderBottom = function (root) &#123;\n  let queue = [root],\n    res = [];\n  if (!root) return [];\n  while (queue.length) &#123;\n    let len = queue.length;\n    let currArr = [];\n    while (len--) &#123;\n      const currNode = queue.shift();\n      currArr.push(currNode.val);\n      currNode.left &amp;&amp; queue.push(currNode.left);\n      currNode.right &amp;&amp; queue.push(currNode.right);\n    &#125;\n    res.unshift(currArr);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【199】二叉树的右视图</p>\n<pre><code class=\"javascript\">var rightSideView = function (root) &#123;\n  const res = [],\n    queue = [root];\n  while (queue.length &amp;&amp; root !== null) &#123;\n    let len = queue.length;\n    while (len--) &#123;\n      const curNode = queue.shift();\n      if (len === 0) &#123;\n        res.push(curNode.val);\n      &#125;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【637】二叉树的层平均值</p>\n<pre><code class=\"javascript\">var averageOfLevels = function (root) &#123;\n  const res = [],\n    queue = [root];\n  while (queue.length) &#123;\n    const len = queue.length;\n    let sum = 0;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      sum += curNode.val;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n    res.push(sum / len);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【429】N 叉树的层序遍历</p>\n<pre><code class=\"javascript\">var levelOrder = function (root) &#123;\n  const res = [],\n    queue = [root];\n  while (queue.length &amp;&amp; root !== null) &#123;\n    const len = queue.length;\n    const curArr = [];\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      curArr.push(curNode.val);\n      curNode.children &amp;&amp;\n        curNode.children.forEach((item) =&gt; &#123;\n          item !== null &amp;&amp; queue.push(item);\n        &#125;);\n    &#125;\n    res.push(curArr);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【515】在每个树行中找最大值</p>\n<pre><code class=\"javascript\">var largestValues = function (root) &#123;\n  const res = [],\n    queue = [root];\n  while (root !== null &amp;&amp; queue.length) &#123;\n    const len = queue.length;\n    let maxNum = -Infinity;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      maxNum = curNode.val &gt; maxNum ? curNode.val : maxNum;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n    res.push(maxNum);\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【116】填充每个节点的下一个右侧节点指针</p>\n<pre><code class=\"javascript\">var connect = function (root) &#123;\n  if (root === null) return root;\n  let queue = [root];\n  while (queue.length) &#123;\n    let n = queue.length;\n    for (let i = 0; i &lt; n; i++) &#123;\n      let node = queue.shift();\n      if (i &lt; n - 1) &#123;\n        node.next = queue[0];\n      &#125;\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    &#125;\n  &#125;\n  return root;\n&#125;;\n</code></pre>\n<p>【104】二叉树的最大深度</p>\n<pre><code class=\"javascript\">var maxDepth = function (root) &#123;\n  if (!root) return 0;\n  let depth = 0;\n  const queue = [root];\n  while (queue.length) &#123;\n    depth++;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return depth;\n&#125;;\n</code></pre>\n<p>【111】二叉树的最小深度</p>\n<pre><code class=\"javascript\">var minDepth = function (root) &#123;\n  if (!root) return 0;\n  let depth = 0;\n  const queue = [root];\n  while (queue.length) &#123;\n    depth++;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      if (curNode.left === null &amp;&amp; curNode.right === null) &#123;\n        return depth;\n      &#125;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return depth;\n&#125;;\n</code></pre>\n<p>【226】翻转二叉树</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">let traverseNode = function (root) &#123;\n  if (!root) return null;\n  const rightNode = root.right;\n  root.right = traverseNode(root.left);\n  root.left = traverseNode(rightNode);\n  return root;\n&#125;;\n</code></pre>\n<p>前序遍历：</p>\n<pre><code class=\"javascript\">var invertTree = function (root) &#123;\n  if (root === null) return root;\n  // 先定义节点交换函数,给一个节点，将左右节点交换\n  function invertNode(root) &#123;\n    if (!root) return null;\n    [root.left, root.right] = [root.right, root.left];\n  &#125;\n  // 先序遍历\n  const queue = [root];\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      invertNode(curNode);\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return root;\n&#125;;\n</code></pre>\n<p>【101】对称二叉树</p>\n<pre><code class=\"javascript\">var isSymmetric = function (root) &#123;\n  if (!root) return true;\n  const isMirror = (l, r) =&gt; &#123;\n    if (!l &amp;&amp; !r) return true;\n    if (\n      l &amp;&amp;\n      r &amp;&amp;\n      l.val === r.val &amp;&amp;\n      isMirror(l.left, r.right) &amp;&amp;\n      isMirror(l.right, r.left)\n    ) &#123;\n      return true;\n    &#125;\n    return false;\n  &#125;;\n  return isMirror(root.left, root.right);\n&#125;;\n</code></pre>\n<p>【222】完全二叉树的节点个数</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var countNodes = function (root) &#123;\n  const getNodeSum = (node) =&gt; &#123;\n    if (node === null) &#123;\n      return 0;\n    &#125;\n    return getNodeSum(node.left) + getNodeSum(node.right) + 1;\n  &#125;;\n  return getNodeSum(root);\n&#125;;\n</code></pre>\n<p>层序遍历一遍：</p>\n<pre><code class=\"javascript\">let traverseNode = function (root) &#123;\n  if (!root) return 0;\n  const queue = [root];\n  let res = 0;\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      res++;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【110】平衡二叉树</p>\n<pre><code class=\"javascript\">let getHeight = function (curNode) &#123;\n  if (!curNode) return 0;\n  const queue = [curNode];\n  let res = 0;\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const node = queue.shift();\n      res++;\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    &#125;\n  &#125;\n  return res;\n&#125;;\nlet isBalanced = function (root) &#123;\n  if (root === null) return true;\n  let queue = [root];\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      if (Math.abs(getHeight(curNode.left) - getHeight(curNode.right)) &gt; 1) &#123;\n        return false;\n      &#125;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return true;\n&#125;;\n</code></pre>\n<p>【257】二叉树的所有路径</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var binaryTreePaths = function (root) &#123;\n  let res = [];\n  const getRoad = (node, curPath) =&gt; &#123;\n    if (node.left === null &amp;&amp; node.right === null) &#123;\n      curPath += node.val;\n      res.push(curPath);\n      return;\n    &#125;\n    curPath += node.val + &quot;-&gt;&quot;;\n    node.left &amp;&amp; getRoad(node.left, curPath);\n    node.right &amp;&amp; getRoad(node.right, curPath);\n  &#125;;\n  getRoad(root, &quot;&quot;);\n  return res;\n&#125;;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var binaryTreePaths = function (root) &#123;\n  if (!root) return [];\n  const stack = [root],\n    paths = [&quot;&quot;],\n    res = []; //使用栈时：每个栈数据，对应一个路径\n  while (stack.length) &#123;\n    const node = stack.pop();\n    let path = paths.pop();\n    if (!node.left &amp;&amp; !node.right) &#123;\n      // 到叶子节点终止, 添加路径到结果中\n      res.push(path + node.val);\n      continue;\n    &#125;\n    path += node.val + &quot;-&gt;&quot;;\n    if (node.right) &#123;\n      // 右节点存在\n      stack.push(node.right);\n      paths.push(path);\n    &#125;\n    if (node.left) &#123;\n      // 左节点存在\n      stack.push(node.left);\n      paths.push(path);\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【404】左叶子之和</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var sumOfLeftLeaves = function (root) &#123;\n  const nodeSum = (node) =&gt; &#123;\n    if (!node) return 0;\n    let leftValue = nodeSum(node.left);\n    let rightValue = nodeSum(node.right);\n    let midValue = 0;\n    if (node.left &amp;&amp; !node.left.left &amp;&amp; !node.left.right) &#123;\n      midValue = node.left.val;\n    &#125;\n    return midValue + leftValue + rightValue;\n  &#125;;\n  return nodeSum(root);\n&#125;;\n</code></pre>\n<p>层序遍历：</p>\n<pre><code class=\"javascript\">var sumOfLeftLeaves = function (root) &#123;\n  if (!root) return;\n  let res = 0;\n  const queue = [root];\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      if (curNode.left &amp;&amp; !curNode.left.left &amp;&amp; !curNode.left.right) &#123;\n        res += curNode.left.val;\n      &#125;\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【513】找树左下角的值</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var findBottomLeftValue = function (root) &#123;\n  //前序遍历,找到最大深度的叶子节点即可\n  let maxPath = 0,\n    resNode = null;\n  const dfsTree = (node, curPath) =&gt; &#123;\n    if (!node.left &amp;&amp; !node.right) &#123;\n      if (curPath &gt; maxPath) &#123;\n        maxPath = curPath;\n        resNode = node.val;\n      &#125;\n    &#125;\n    node.left &amp;&amp; dfsTree(node.left, curPath + 1);\n    node.right &amp;&amp; dfsTree(node.right, curPath + 1);\n  &#125;;\n  dfsTree(root, 1);\n  return resNode;\n&#125;;\n</code></pre>\n<p>层序遍历：</p>\n<pre><code class=\"javascript\">var findBottomLeftValue = function (root) &#123;\n  //层序遍历,记录最后一行的第一个元素\n  if (!root) return;\n  const queue = [root];\n  let resNode;\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      if (i === 0) resNode = curNode.val; //栈中第一个是最左边节点\n      curNode.left &amp;&amp; queue.push(curNode.left);\n      curNode.right &amp;&amp; queue.push(curNode.right);\n    &#125;\n  &#125;\n  return resNode;\n&#125;;\n</code></pre>\n<p>【112】路径总和</p>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var hasPathSum = function (root, targetSum) &#123;\n  if (!root) return false;\n  const queue = [root],\n    sumQueue = [0];\n  while (queue.length) &#123;\n    const len = queue.length;\n    for (let i = 0; i &lt; len; i++) &#123;\n      const curNode = queue.shift();\n      const curNum = sumQueue.shift();\n      if (\n        !curNode.left &amp;&amp;\n        !curNode.right &amp;&amp;\n        curNode.val + curNum === targetSum\n      ) &#123;\n        return true;\n      &#125;\n      if (curNode.left) &#123;\n        queue.push(curNode.left);\n        sumQueue.push(curNum + curNode.val);\n      &#125;\n      if (curNode.right) &#123;\n        queue.push(curNode.right);\n        sumQueue.push(curNum + curNode.val);\n      &#125;\n    &#125;\n  &#125;\n  return false;\n&#125;;\n</code></pre>\n<p>递归：</p>\n<pre><code class=\"javascript\">var hasPathSum = function (root, targetSum) &#123;\n  if (!root) return false;\n  // 递归函数\n  const equal = (node, curSum) =&gt; &#123;\n    // 到达叶子节点时，检查当前路径和是否等于目标和\n    if (!node.left &amp;&amp; !node.right) &#123;\n      return curSum + node.val === targetSum;\n    &#125;\n    // 递归检查左右子节点\n    const left = node.left ? equal(node.left, curSum + node.val) : false;\n    const right = node.right ? equal(node.right, curSum + node.val) : false;\n    return left || right;\n  &#125;;\n  // 从根节点开始，初始路径和为 0\n  return equal(root, 0);\n&#125;;\n</code></pre>\n<p>【106】从中序与后序遍历序列构造二叉树</p>\n<p>递归法：</p>\n<pre><code class=\"javascript\">var buildTree = function (inorder, postorder) &#123;\n  //递归法\n  if (!inorder.length) return null;\n  const rootVal = postorder.pop();\n  let rootIndex = inorder.indexOf(rootVal);\n  const root = new TreeNode(rootVal);\n  root.left = buildTree(\n    inorder.slice(0, rootIndex),\n    postorder.slice(0, rootIndex)\n  );\n  root.right = buildTree(\n    inorder.slice(rootIndex + 1),\n    postorder.slice(rootIndex)\n  );\n  return root;\n&#125;;\nclass TreeNode &#123;\n  constructor(nodeVal, left = null, right = null) &#123;\n    this.val = nodeVal;\n    this.left = left;\n    this.right = right;\n  &#125;\n&#125;\n</code></pre>\n<p>【105】从前序与中序遍历序列构造二叉树</p>\n<pre><code class=\"javascript\">var buildTree = function (preorder, inorder) &#123;\n  //从前序遍历与中序遍历构造树\n  if (!preorder.length) return null;\n  const rootVal = preorder.shift(); //前序遍历第一个就是根节点\n  const index = inorder.indexOf(rootVal); //获取到根节点在前序遍历中的位置\n  const root = new TreeNode(rootVal); //创建中间节点\n  //中序遍历结果中,左边的是它的左子树,右边是它的右子树,思路是找到根节点然后分左右\n  //根节点从先序遍历中查找,先序遍历跟节点到子节点的个数是固定的,分段遍历\n  root.left = buildTree(preorder.slice(0, index), inorder.slice(0, index));\n  root.right = buildTree(preorder.slice(index), inorder.slice(index + 1));\n  return root;\n&#125;;\nclass TreeNode &#123;\n  constructor(nodeVal, left = null, right = null) &#123;\n    this.val = nodeVal;\n    this.left = left;\n    this.right = right;\n  &#125;\n&#125;\n</code></pre>\n<p>【654】最大二叉树</p>\n<pre><code class=\"javascript\">class TreeNode &#123;\n  constructor(nodeVal, left = null, right = null) &#123;\n    this.val = nodeVal;\n    this.left = left;\n    this.right = right;\n  &#125;\n&#125;\nvar constructMaximumBinaryTree = function (nums) &#123;\n  //使用递归方法进行遍历\n  if (nums.length === 0) return null;\n  const rootVal = Math.max(...nums);\n  const rootIndex = nums.indexOf(rootVal);\n  const root = new TreeNode(rootVal);\n  root.left = constructMaximumBinaryTree(nums.slice(0, rootIndex));\n  root.right = constructMaximumBinaryTree(nums.slice(rootIndex + 1));\n  return root;\n&#125;;\n</code></pre>\n<p>【617】合并二叉树</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var mergeTrees = function (root1, root2) &#123;\n  const preOrder = (root1, root2) =&gt; &#123;\n    if (!root1) return root2;\n    if (!root2) return root1;\n    root1.val = root1.val + root2.val;\n    root1.left = preOrder(root1.left, root2.left);\n    root1.right = preOrder(root1.right, root2.right);\n    return root1;\n  &#125;;\n  return preOrder(root1, root2);\n&#125;;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var mergeTrees = function (root1, root2) &#123;\n  if (root1 === null) return root2;\n  if (root2 === null) return root1;\n\n  let queue = [];\n  queue.push(root1);\n  queue.push(root2);\n  while (queue.length) &#123;\n    let node1 = queue.shift();\n    let node2 = queue.shift();\n    node1.val += node2.val;\n    if (node1.left !== null &amp;&amp; node2.left !== null) &#123;\n      queue.push(node1.left);\n      queue.push(node2.left);\n    &#125;\n    if (node1.right !== null &amp;&amp; node2.right !== null) &#123;\n      queue.push(node1.right);\n      queue.push(node2.right);\n    &#125;\n    if (node1.left === null &amp;&amp; node2.left !== null) &#123;\n      node1.left = node2.left;\n    &#125;\n    if (node1.right === null &amp;&amp; node2.right !== null) &#123;\n      node1.right = node2.right;\n    &#125;\n  &#125;\n  return root1;\n&#125;;\n</code></pre>\n<p>【700】二叉搜索树中的搜索</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var searchBST = function (root, val) &#123;\n  //递归\n  if (!root || root.val === val) return root;\n  if (root.val &gt; val) &#123;\n    return searchBST(root.left, val);\n  &#125;\n  if (root.val &lt; val) &#123;\n    return searchBST(root.right, val);\n  &#125;\n&#125;;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var searchBST = function (root, val) &#123;\n  while (root) &#123;\n    if (root.val &gt; val) &#123;\n      root = root.left;\n    &#125; else if (root.val &lt; val) &#123;\n      root = root.right;\n    &#125; else &#123;\n      return root;\n    &#125;\n  &#125;\n  return null;\n&#125;;\n</code></pre>\n<p>【98】验证二叉搜索树</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var isValidBST = function (root) &#123;\n  let pre = null;\n  const inOrder = (root) =&gt; &#123;\n    if (!root) &#123;\n      return true;\n    &#125;\n    const left = inOrder(root.left);\n    if (pre &amp;&amp; pre.val &gt;= root.val) &#123;\n      return false;\n    &#125;\n    pre = root;\n    const right = inOrder(root.right);\n    return left &amp;&amp; right;\n  &#125;;\n  return inOrder(root);\n&#125;;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var isValidBST = function (root) &#123;\n  const queue = [];\n  let cur = root;\n  let pre = null;\n  while (cur !== null || queue.length !== 0) &#123;\n    if (cur !== null) &#123;\n      queue.push(cur);\n      cur = cur.left;\n    &#125; else &#123;\n      cur = queue.pop();\n      if (pre !== null &amp;&amp; cur.val &lt;= pre.val) &#123;\n        return false;\n      &#125;\n      pre = cur;\n      cur = cur.right;\n    &#125;\n  &#125;\n  return true;\n&#125;;\n</code></pre>\n<p>【530】二叉搜索树的最小绝对差</p>\n<p>递归法：</p>\n<pre><code class=\"javascript\">var getMinimumDifference = function (root) &#123;\n  let res = Infinity;\n  let preNode = null;\n  const inOrder = (node) =&gt; &#123;\n    if (!node) return;\n    inOrder(node.left);\n    if (preNode) res = Math.min(res, node.val - preNode.val);\n    preNode = node;\n    inOrder(node.right);\n  &#125;;\n  inOrder(root);\n  return res;\n&#125;;\n</code></pre>\n<p>迭代法：</p>\n<pre><code class=\"javascript\">var getMinimumDifference = function (root) &#123;\n  const stack = [];\n  let cur = root;\n  let res = Infinity;\n  let pre = null;\n  while (cur || stack.length) &#123;\n    if (cur) &#123;\n      stack.push(cur);\n      cur = cur.left;\n    &#125; else &#123;\n      cur = stack.pop();\n      if (pre) res = Math.min(res, cur.val - pre.val);\n      pre = cur;\n      cur = cur.right;\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【501】二叉搜索树中的众数</p>\n<p>递归中序遍历：</p>\n<pre><code class=\"javascript\">var findMode = function (root) &#123;\n  let count = 0,\n    maxCount = 1;\n  let pre = root,\n    res = [];\n  const travelTree = function (cur) &#123;\n    if (cur === null) &#123;\n      return;\n    &#125;\n    travelTree(cur.left);\n    if (pre.val === cur.val) &#123;\n      count++;\n    &#125; else &#123;\n      count = 1;\n    &#125;\n    pre = cur;\n    if (count === maxCount) &#123;\n      res.push(cur.val);\n    &#125;\n    if (count &gt; maxCount) &#123;\n      res = [];\n      maxCount = count;\n      res.push(cur.val);\n    &#125;\n    travelTree(cur.right);\n  &#125;;\n  travelTree(root);\n  return res;\n&#125;;\n</code></pre>\n<p>使用 map：</p>\n<pre><code class=\"javascript\">var findMode = function (root) &#123;\n  let map = new Map();\n  const traverTree = function (root) &#123;\n    if (root === null) return;\n    traverTree(root.left);\n    map.set(root.val, map.has(root.val) ? map.get(root.val) + 1 : 1);\n    traverTree(root.right);\n  &#125;;\n  traverTree(root);\n  let maxCount = map.get(root.val),\n    res = [];\n  for (let [key, val] of map) &#123;\n    if (val === maxCount) res.push(key);\n    if (val &gt; maxCount) &#123;\n      res = [];\n      maxCount = val;\n      res.push(key);\n    &#125;\n  &#125;\n  return res;\n&#125;;\n</code></pre>\n<p>【236】 二叉树的最近公共祖先</p>\n<pre><code class=\"javascript\">var lowestCommonAncestor = function (root, p, q) &#123;\n  // 使用递归的方法\n  // 需要从下到上，所以使用后序遍历\n  // 1. 确定递归的函数\n  const travelTree = function (root, p, q) &#123;\n    // 2. 确定递归终止条件\n    if (root === null || root === p || root === q) &#123;\n      return root;\n    &#125;\n    // 3. 确定递归单层逻辑\n    let left = travelTree(root.left, p, q);\n    let right = travelTree(root.right, p, q);\n    if (left !== null &amp;&amp; right !== null) &#123;\n      return root;\n    &#125;\n    if (left === null) &#123;\n      return right;\n    &#125;\n    return left;\n  &#125;;\n  return travelTree(root, p, q);\n&#125;;\n</code></pre>\n<p>【235】二叉搜索树的最近公共祖先</p>\n<pre><code class=\"javascript\">var lowestCommonAncestor = function (root, p, q) &#123;\n  // 使用递归的方法\n  // 1. 使用给定的递归函数lowestCommonAncestor\n  // 2. 确定递归终止条件\n  if (root === null) &#123;\n    return root;\n  &#125;\n  if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;\n    // 向左子树查询\n    return (root.left = lowestCommonAncestor(root.left, p, q));\n  &#125;\n  if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;\n    // 向右子树查询\n    return (root.right = lowestCommonAncestor(root.right, p, q));\n  &#125;\n  return root;\n&#125;;\n</code></pre>\n<p>【701】二叉搜索树中的插入操作</p>\n<pre><code class=\"javascript\">function insertIntoBST(root, num) &#123;\n  if (root === null) &#123;\n    return new TreeNode(num);\n  &#125;\n  if (num &lt; root.val) root.left = insertIntoBST(root.left, num);\n  else if (num &gt; root.val) root.right = insertIntoBST(root.right, num);\n  return root;\n&#125;\n</code></pre>\n<p>【450】删除二叉搜索树中的节点</p>\n<pre><code class=\"javascript\">function deleteNode(root, num) &#123;\n  if (!root) return null;\n  if (num &lt; root.val) &#123;\n    root.left = deleteNode(root.left, num);\n    return root;\n  &#125; else if (num &gt; root.val) &#123;\n    root.right = deleteNode(root.right, num);\n    return root;\n  &#125; else &#123;\n    if (!root.left &amp;&amp; !root.right) &#123;\n      return null;\n    &#125; else if (root.right &amp;&amp; !root.left) &#123;\n      return root.right;\n    &#125; else if (root.left &amp;&amp; !root.right) &#123;\n      return root.left;\n    &#125;\n    const rightMinNode = getMinNode(root.right);\n    root.val = rightMinNode.val;\n    root.right = deleteNode(root.right, rightMinNode.val);\n    return root;\n  &#125;\n&#125;\nfunction getMinNode(root) &#123;\n  while (root.left) &#123;\n    root = root.left;\n  &#125;\n  return root;\n&#125;\n</code></pre>\n<p>【669】修剪二叉搜索树</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">var trimBST = function (root, low, high) &#123;\n  if (root === null) &#123;\n    return null;\n  &#125;\n  if (root.val &lt; low) &#123;\n    let right = trimBST(root.right, low, high);\n    return right;\n  &#125;\n  if (root.val &gt; high) &#123;\n    let left = trimBST(root.left, low, high);\n    return left;\n  &#125;\n  root.left = trimBST(root.left, low, high);\n  root.right = trimBST(root.right, low, high);\n  return root;\n&#125;;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">function trimBST(root, low, high) &#123;\n  //修剪二叉搜索树\n  if (root === null) &#123;\n    return null;\n  &#125;\n  // 如果root不在范围之内\n  while (root !== null &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;\n    // 如果root小于low\n    if (root.val &lt; low) &#123;\n      root = root.right;\n    &#125; else &#123;\n      root = root.left;\n    &#125;\n  &#125;\n  //  知道找到在root范围内的节点\n  let cur = root;\n  while (cur !== null) &#123;\n    // 当左节点小于low时，进行判断\n    while (cur.left &amp;&amp; cur.left.val &lt; low) &#123;\n      cur.left = cur.left.right;\n    &#125;\n    cur = cur.left;\n  &#125;\n  cur = root;\n  while (cur !== null) &#123;\n    while (cur.right &amp;&amp; cur.right.val &gt; high) &#123;\n      cur.right = cur.right.left;\n    &#125;\n    cur = cur.right;\n  &#125;\n  return root;\n&#125;\n</code></pre>\n<p>【108】将有序数组转换为二叉搜索树</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">function sortedArrayToBST(arr) &#123;\n  const buildTree = (arr, left, right) =&gt; &#123;\n    if (left &gt; right) return null;\n    const mid = (left + right) &gt;&gt; 1;\n    const root = new TreeNode(arr[mid]);\n    root.left = buildTree(arr, left, mid - 1);\n    root.right = buildTree(arr, mid + 1, right);\n    return root;\n  &#125;;\n  return buildTree(arr, 0, arr.length - 1);\n&#125;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var sortedArrayToBST = function (nums) &#123;\n  if (nums.length === 0) &#123;\n    return null;\n  &#125;\n  let root = new TreeNode(0); //初始根节点\n  let nodeQue = [root]; //放遍历的节点,并初始化\n  let leftQue = [0]; //放左区间的下标,初始化\n  let rightQue = [nums.length - 1]; // 放右区间的下标\n\n  while (nodeQue.length) &#123;\n    let curNode = nodeQue.pop();\n    let left = leftQue.pop();\n    let right = rightQue.pop();\n    let mid = left + Math.floor((right - left) / 2);\n\n    curNode.val = nums[mid]; //将下标为mid的元素给中间节点\n\n    //         处理左区间\n    if (left &lt;= mid - 1) &#123;\n      curNode.left = new TreeNode(0);\n      nodeQue.push(curNode.left);\n      leftQue.push(left);\n      rightQue.push(mid - 1);\n    &#125;\n\n    //         处理右区间\n    if (right &gt;= mid + 1) &#123;\n      curNode.right = new TreeNode(0);\n      nodeQue.push(curNode.right);\n      leftQue.push(mid + 1);\n      rightQue.push(right);\n    &#125;\n  &#125;\n  return root;\n&#125;;\n</code></pre>\n<p>【538】把二叉搜索树转换为累加树</p>\n<p>递归：</p>\n<pre><code class=\"javascript\">function convertBST(root) &#123;\n  let pre = 0;\n  const ReverseInOrder = (cur) =&gt; &#123;\n    if (cur) &#123;\n      ReverseInOrder(cur.right);\n      cur.val += pre;\n      pre = cur.val;\n      ReverseInOrder(cur.left);\n    &#125;\n  &#125;;\n  ReverseInOrder(root);\n  return root;\n&#125;\n</code></pre>\n<p>迭代：</p>\n<pre><code class=\"javascript\">var convertBST = function (root) &#123;\n  let pre = 0;\n  let cur = root;\n  let stack = [];\n  while (cur !== null || stack.length !== 0) &#123;\n    while (cur !== null) &#123;\n      stack.push(cur);\n      cur = cur.right;\n    &#125;\n    cur = stack.pop();\n    cur.val += pre;\n    pre = cur.val;\n    cur = cur.left;\n  &#125;\n  return root;\n&#125;;\n</code></pre>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2><h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li><p>回溯法也叫回溯搜索法，是一种搜索的方式。</p>\n</li>\n<li><p>回溯是递归的副产品，只要有递归就会有回溯（一般递归逻辑的下面就是回溯的逻辑部分）</p>\n</li>\n<li><p>回溯的本质是穷举，效率并不高</p>\n</li>\n<li><p>回溯方法主要用于解决：</p>\n<ul>\n<li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li>\n<li>切割问题：一个字符串按一定规则有几种切割方式</li>\n<li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li>\n<li>排列问题：N 个数按一定规则全排列，有几种排列方式</li>\n<li>棋盘问题：N 皇后，解数独等等</li>\n</ul>\n</li>\n<li><p>回溯算法基本模板</p>\n<pre><code class=\"javascript\">function ()&#123;\n    if(终止条件)&#123;\n        收集结果\n        return;\n    &#125;\n    for(集合元素)&#123;\n        处理节点\n        递归函数\n        回溯操作\n    &#125;\n&#125;\n</code></pre>\n<p>【77】组合</p>\n<pre><code class=\"javascript\">var combine = function (n, k) &#123;\n  let result = [],\n    path = [];\n  combineHelper(n, k, 1);\n  function combineHelper(n, k, startIndex) &#123;\n    //1到n选取k个，一共有多少种组合方式\n    if (path.length === k) &#123;\n      result.push([...path]);\n      return;\n    &#125;\n    for (let i = startIndex; i &lt;= n - (k - path.length) + 1; i++) &#123;\n      path.push(i);\n      combineHelper(n, k, i + 1);\n      path.pop();\n    &#125;\n  &#125;\n  return result;\n&#125;;\n</code></pre>\n<p>【216】组合总和 |||</p>\n<pre><code class=\"javascript\">var letterCombinations = function (digits) &#123;\n  //按下字符，返回两个字符所对应的全部字符串\n  const map = [\n    [],\n    [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],\n    [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;],\n    [&quot;g&quot;, &quot;h&quot;, &quot;i&quot;],\n    [&quot;j&quot;, &quot;k&quot;, &quot;l&quot;],\n    [&quot;m&quot;, &quot;n&quot;, &quot;o&quot;],\n    [&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;],\n    [&quot;t&quot;, &quot;u&quot;, &quot;v&quot;],\n    [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;],\n  ];\n  const len = digits.length;\n  if (!len) return [];\n  if (len === 1) return map[digits - 1];\n  let res = [],\n    path = [];\n  backTracking(digits, len, 0);\n  return res;\n  function backTracking(digits, len, startIndex) &#123;\n    //设置递归终点\n    if (path.length === len) &#123;\n      res.push(path.join(&quot;&quot;));\n      return;\n    &#125;\n    for (let item of map[digits[startIndex] - 1]) &#123;\n      path.push(item);\n      backTracking(digits, len, startIndex + 1);\n      path.pop();\n    &#125;\n  &#125;\n&#125;;\n</code></pre>\n<p>【39】组合总和</p>\n<pre><code class=\"javascript\">var combinationSum = function (arr, target) &#123;\n  // 在数组中找出，和为target的全部情况\n  let res = [],\n    path = [],\n    sum = 0;\n  backTracing(arr, 0);\n  return res;\n  function backTracing(arr, startIndex) &#123;\n    if (sum &gt; target) return;\n    if (sum === target) &#123;\n      res.push([...path]);\n      return;\n    &#125;\n    for (let i = startIndex; i &lt; arr.length; i++) &#123;\n      path.push(arr[i]);\n      sum += arr[i];\n      backTracing(arr, i);\n      path.pop();\n      sum -= arr[i];\n    &#125;\n  &#125;\n&#125;;\n</code></pre>\n<p>【40】组合总和</p>\n<pre><code class=\"javascript\">\n</code></pre>\n</li>\n</ul>\n","categories":["算法"],"tags":["算法","数据结构"]},{"title":"设计模式与设计原则","url":"/2024/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/","content":"<p>注：本教程总结自《设计模式之争》和《大话设计模式》，对设计模式感兴趣的同学强烈推荐这两本书。</p>\n<h1 id=\"23-种设计模式\"><a href=\"#23-种设计模式\" class=\"headerlink\" title=\"23 种设计模式\"></a>23 种设计模式</h1><h2 id=\"创建型\"><a href=\"#创建型\" class=\"headerlink\" title=\"创建型\"></a>创建型</h2><ul>\n<li><p>单例模式</p>\n</li>\n<li><p>原型模式</p>\n</li>\n<li><p>工厂模式</p>\n</li>\n<li><p>抽象工厂模式</p>\n</li>\n<li><p>建造者模式</p>\n</li>\n</ul>\n<h2 id=\"结构型\"><a href=\"#结构型\" class=\"headerlink\" title=\"结构型\"></a>结构型</h2><ul>\n<li><p>适配器模式</p>\n</li>\n<li><p>装饰器模式</p>\n</li>\n<li><p>代理模式</p>\n</li>\n<li><p>外观模式</p>\n</li>\n<li><p>桥接模式</p>\n</li>\n<li><p>组合模式</p>\n</li>\n<li><p>享元模式</p>\n</li>\n</ul>\n<h2 id=\"行为型\"><a href=\"#行为型\" class=\"headerlink\" title=\"行为型\"></a>行为型</h2><ul>\n<li><p>观察者模式</p>\n</li>\n<li><p>迭代器模式</p>\n</li>\n<li><p>策略模式</p>\n</li>\n<li><p>模板方法模式</p>\n</li>\n<li><p>职责链模式</p>\n</li>\n<li><p>命令模式</p>\n</li>\n<li><p>备忘录模式</p>\n</li>\n<li><p>状态模式</p>\n</li>\n<li><p>访问者模式</p>\n</li>\n<li><p>中介者模式</p>\n</li>\n<li><p>解释器模式</p>\n</li>\n</ul>\n<h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>\n<pre><code class=\"javascript\">class Product &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n  init() &#123;\n    console.log(&quot;init&quot;);\n  &#125;\n  fun() &#123;\n    console.log(&quot;fun&quot;);\n  &#125;\n&#125;\nclass Factory &#123;\n  create(name) &#123;\n    return new Product(name);\n  &#125;\n&#125;\n// use\nlet factory = new Factory();\nlet p = factory.create(&quot;p1&quot;);\np.init();\np.fun();\n</code></pre>\n<ul>\n<li>适用场景</li>\n</ul>\n<p>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择<br>将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；<br>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>创建对象的过程可能很复杂，但我们只需要关心创建结果。<br>构造函数和创建者分离, 符合“开闭原则”<br>一个调用者想创建一个对象，只要知道其名称就可以了。<br>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度<br>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</p>\n<ul>\n<li>什么时候不用<br>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。<br>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。<br>例子</li>\n</ul>\n<p>曾经我们熟悉的 JQuery 的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的 jQuery 对象</p>\n<pre><code class=\"javascript\">class jQuery &#123;\n  constructor(selector) &#123;\n    super(selector);\n  &#125;\n  add() &#123;&#125;\n  // 此处省略若干 API\n&#125;\nwindow.$ = function (selector) &#123;\n  return new jQuery(selector);\n&#125;;\n</code></pre>\n<ul>\n<li>vue 的异步组件</li>\n</ul>\n<p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>\n<pre><code class=\"javascript\">Vue.component(&quot;async-example&quot;, function (resolve, reject) &#123;\n  setTimeout(function () &#123;\n    // 向 `resolve` 回调传递组件定义\n    resolve(&#123;\n      template: &quot;&lt;div&gt;I am async!&lt;/div&gt;&quot;,\n    &#125;);\n  &#125;, 1000);\n&#125;);\n</code></pre>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>一个类只有一个实例，并提供一个访问它的全局访问点。</p>\n<pre><code class=\"javascript\">class LoginForm &#123;\n  constructor() &#123;\n    this.state = &quot;hide&quot;;\n  &#125;\n  show() &#123;\n    if (this.state === &quot;show&quot;) &#123;\n      alert(&quot;已经显示&quot;);\n      return;\n    &#125;\n    this.state = &quot;show&quot;;\n    console.log(&quot;登录框显示成功&quot;);\n  &#125;\n  hide() &#123;\n    if (this.state === &quot;hide&quot;) &#123;\n      alert(&quot;已经隐藏&quot;);\n      return;\n    &#125;\n    this.state = &quot;hide&quot;;\n    console.log(&quot;登录框隐藏成功&quot;);\n  &#125;\n&#125;\nLoginForm.getInstance = (function () &#123;\n  let instance;\n  return function () &#123;\n    if (!instance) &#123;\n      instance = new LoginForm();\n    &#125;\n    return instance;\n  &#125;;\n&#125;)();\nlet obj1 = LoginForm.getInstance();\nobj1.show();\n\nlet obj2 = LoginForm.getInstance();\nobj2.hide();\nconsole.log(obj1 === obj2);\n</code></pre>\n<ul>\n<li>优点</li>\n</ul>\n<p>划分命名空间，减少全局变量<br>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护<br>且只会实例化一次。简化了代码的调试和维护</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</p>\n<ul>\n<li>场景例子</li>\n</ul>\n<p>定义命名空间和实现分支型方法<br>登录框<br>vuex 和 redux 中的 store</p>\n<h1 id=\"适配器模式0\"><a href=\"#适配器模式0\" class=\"headerlink\" title=\"适配器模式0\"></a>适配器模式0</h1><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p>\n<pre><code class=\"javascript\">class Plug &#123;\n  getName() &#123;\n    return &quot;iphone 充电头&quot;;\n  &#125;\n&#125;\nclass Target &#123;\n  constructor() &#123;\n    this.plug = new Plug();\n  &#125;\n  getName() &#123;\n    return this.plug.getName() + &quot; 适配器 Type-c 充电头&quot;;\n  &#125;\n&#125;\nlet target = new Target();\ntarget.getName(); // iphone 充电头 适配器转 Type-c 充电头\n</code></pre>\n<ul>\n<li>优点</li>\n</ul>\n<p>可以让任何两个没有关联的类一起运行。<br>提高了类的复用。<br>适配对象，适配库，适配数据</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)<br>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</p>\n<ul>\n<li>场景</li>\n</ul>\n<p>整合第三方 SDK<br>封装旧接口</p>\n<p>自己封装的 ajax， 使用方式如下</p>\n<pre><code class=\"javascript\">ajax(&#123;\n  url: &quot;/getData&quot;,\n  type: &quot;Post&quot;,\n  dataType: &quot;json&quot;,\n  data: &#123;\n    test: 111,\n  &#125;,\n&#125;).done(function () &#123;&#125;);\n// 因为历史原因，代码中全都是：\n// $.ajax(&#123;....&#125;)\n\n// 做一层适配器\nvar $ = &#123;\n  ajax: function (options) &#123;\n    return ajax(options);\n  &#125;,\n&#125;;\n</code></pre>\n<p>vue 的 computed</p>\n<pre><code>&lt;template&gt;\n  &lt;div id=&quot;example&quot;&gt;\n    &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;\n    &lt;!-- Hello --&gt;\n    &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;\n    &lt;!-- olleH --&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nexport default &#123;\n  name: &quot;demo&quot;,\n  data() &#123;\n    return &#123;\n      message: &quot;Hello&quot;,\n    &#125;;\n  &#125;,\n  computed: &#123;\n    reversedMessage: function () &#123;\n      return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;);\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\nexport default &#123;\n  name: &quot;demo&quot;,\n  data() &#123;\n    return &#123;\n      message: &quot;Hello&quot;,\n    &#125;;\n  &#125;,\n  computed: &#123;\n    reversedMessage: function () &#123;\n      return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;);\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>原有 data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式<br>不同点<br>适配器与代理模式相似</p>\n<p>适配器模式： 提供一个不同的接口（如不同版本的插头）<br>代理模式： 提供一模一样的接口</p>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><p>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案<br>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p>\n<pre><code class=\"javascript\">class Cellphone &#123;\n  create() &#123;\n    console.log(&quot;生成一个手机&quot;);\n  &#125;\n&#125;\nclass Decorator &#123;\n  constructor(cellphone) &#123;\n    this.cellphone = cellphone;\n  &#125;\n  create() &#123;\n    this.cellphone.create();\n    this.createShell(cellphone);\n  &#125;\n  createShell() &#123;\n    console.log(&quot;生成手机壳&quot;);\n  &#125;\n&#125;\n// 测试代码\nlet cellphone = new Cellphone();\ncellphone.create();\n\nconsole.log(&quot;------------&quot;);\nlet dec = new Decorator(cellphone);\ndec.create();\n</code></pre>\n<ul>\n<li>场景例子</li>\n</ul>\n<p>比如现在有 4 种型号的自行车，我们为每种自行车都定义了一个单<br>独的类。现在要给每种自行车都装上前灯、尾<br>灯和铃铛这 3 种配件。如果使用继承的方式来给<br>每种自行车创建子类，则需要 4×3 &#x3D; 12 个子类。<br>但是如果把前灯、尾灯、铃铛这些对象动态组<br>合到自行车上面，则只需要额外增加 3 个类<br>ES7 Decorator 阮一峰<br>core-decorators</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。<br>方便动态的扩展功能，且提供了比继承更多的灵活性。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>多层装饰比较复杂。<br>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><blockquote>\n<p>代理模式和中介者模式的区别在于：代理模式往往是一对一的，但中介模式往往是一对多。<br>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>\n</blockquote>\n<p>假设当 A 在心情好的时候收到花，小明表白成功的几率有<br>60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。<br>小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花<br>被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。<br>但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选<br>择 A 心情好的时候把花转交给 A，代码如下：</p>\n<pre><code class=\"javascript\">let Flower = function () &#123;&#125;;\nlet xiaoming = &#123;\n  sendFlower: function (target) &#123;\n    let flower = new Flower();\n    target.receiveFlower(flower);\n  &#125;,\n&#125;;\nlet B = &#123;\n  receiveFlower: function (flower) &#123;\n    A.listenGoodMood(function () &#123;\n      A.receiveFlower(flower);\n    &#125;);\n  &#125;,\n&#125;;\nlet A = &#123;\n  receiveFlower: function (flower) &#123;\n    console.log(&quot;收到花&quot; + flower);\n  &#125;,\n  listenGoodMood: function (fn) &#123;\n    setTimeout(function () &#123;\n      fn();\n    &#125;, 1000);\n  &#125;,\n&#125;;\nxiaoming.sendFlower(B);\n</code></pre>\n<ul>\n<li>场景</li>\n</ul>\n<p>HTML 元 素事件代理</p>\n<pre><code>&lt;template&gt;\n  &lt;ul id=&quot;ul&quot;&gt;\n    &lt;li&gt;1&lt;/li&gt;\n    &lt;li&gt;2&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n&lt;script&gt;\nlet ul = document.querySelector(&quot;#ul&quot;);\nul.addEventListener(&quot;click&quot;, (event) =&gt; &#123;\n  console.log(event.target);\n&#125;);\n&lt;/script&gt;\n</code></pre>\n<p>ES6 的 proxy 阮一峰 Proxy<br>jQuery.proxy()方法</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用<br>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</p>\n<ul>\n<li><p>缺点<br>处理请求速度可能有差别，非直接访问存在开销</p>\n</li>\n<li><p>不同点<br>装饰者模式实现上和代理模式类似</p>\n</li>\n</ul>\n<p>装饰者模式： 扩展功能，原有功能不变且可直接使用<br>代理模式： 显示原有功能，但是经过限制之后的</p>\n<h1 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h1><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用<br>兼容浏览器事件绑定</p>\n<pre><code class=\"javascript\">let addMyEvent = function (el, ev, fn) &#123;\n  if (el.addEventListener) &#123;\n    el.addEventListener(ev, fn, false);\n  &#125; else if (el.attachEvent) &#123;\n    el.attachEvent(&quot;on&quot; + ev, fn);\n  &#125; else &#123;\n    el[&quot;on&quot; + ev] = fn;\n  &#125;\n&#125;;\n\n// 封装接口\nlet myEvent = &#123;\n  // ...\n  stop: (e) =&gt; &#123;\n    e.stopPropagation();\n    e.preventDefault();\n  &#125;,\n&#125;;\n</code></pre>\n<p>场景</p>\n<p>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade<br>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。<br>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作。</p>\n<p>参考： 大话设计模式</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>减少系统相互依赖。<br>提高灵活性。<br>提高了安全性</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>\n<p>观察者模式<br>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p>\n<h1 id=\"发布-amp-订阅\"><a href=\"#发布-amp-订阅\" class=\"headerlink\" title=\"发布 &amp; 订阅\"></a>发布 &amp; 订阅</h1><ul>\n<li>一对多</li>\n</ul>\n<pre><code class=\"javascript\">// 主题 保存状态，状态变化之后触发所有观察者对象\nclass Subject &#123;\n  constructor() &#123;\n    this.state = 0;\n    this.observers = [];\n  &#125;\n  getState() &#123;\n    return this.state;\n  &#125;\n  setState(state) &#123;\n    this.state = state;\n    this.notifyAllObservers();\n  &#125;\n  notifyAllObservers() &#123;\n    this.observers.forEach((observer) =&gt; &#123;\n      observer.update();\n    &#125;);\n  &#125;\n  attach(observer) &#123;\n    this.observers.push(observer);\n  &#125;\n&#125;\n// 观察者\nclass Observer &#123;\n  constructor(name, subject) &#123;\n    this.name = name;\n    this.subject = subject;\n    this.subject.attach(this);\n  &#125;\n  update() &#123;\n    console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`);\n  &#125;\n&#125;\n// 测试\nlet s = new Subject();\nlet o1 = new Observer(&quot;o1&quot;, s);\nlet o2 = new Observer(&quot;02&quot;, s);\n\ns.setState(12);\n</code></pre>\n<ul>\n<li>场景</li>\n</ul>\n<p>DOM 事件</p>\n<pre><code class=\"javascript\">document.body.addEventListener(&quot;click&quot;, function () &#123;\n  console.log(&quot;hello world!&quot;);\n&#125;);\ndocument.body.click();\n</code></pre>\n<p>vue 响应式</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>支持简单的广播通信，自动通知所有已经订阅过的对象<br>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用<br>增加了灵活性<br>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>\n<ul>\n<li>缺点<br>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</li>\n</ul>\n<h1 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h1><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p>\n<pre><code class=\"javascript\">// 状态 （弱光、强光、关灯）\nclass State &#123;\n  constructor(state) &#123;\n    this.state = state;\n  &#125;\n  handle(context) &#123;\n    console.log(`this is $&#123;this.state&#125; light`);\n    context.setState(this);\n  &#125;\n&#125;\nclass Context &#123;\n  constructor() &#123;\n    this.state = null;\n  &#125;\n  getState() &#123;\n    return this.state;\n  &#125;\n  setState(state) &#123;\n    this.state = state;\n  &#125;\n&#125;\n// test\nlet context = new Context();\nlet weak = new State(&quot;weak&quot;);\nlet strong = new State(&quot;strong&quot;);\nlet off = new State(&quot;off&quot;);\n// 弱光\nweak.handle(context);\nconsole.log(context.getState());\n// 强光\nstrong.handle(context);\nconsole.log(context.getState());\n// 关闭\noff.handle(context);\nconsole.log(context.getState());\n</code></pre>\n<p>场景</p>\n<p>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为<br>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</p>\n<ul>\n<li>优点</li>\n</ul>\n<p>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便<br>状态与状态间，行为与行为间彼此独立互不干扰<br>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>会在系统中定义许多状态类<br>逻辑分散</p>\n<h1 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h1><p>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>\n<pre><code class=\"javascript\">class Iterator &#123;\n  constructor(conatiner) &#123;\n    this.list = conatiner.list;\n    this.index = 0;\n  &#125;\n  next() &#123;\n    if (this.hasNext()) &#123;\n      return this.list[this.index++];\n    &#125;\n    return null;\n  &#125;\n  hasNext() &#123;\n    if (this.index &gt;= this.list.length) &#123;\n      return false;\n    &#125;\n    return true;\n  &#125;\n&#125;\nclass Container &#123;\n  constructor(list) &#123;\n    this.list = list;\n  &#125;\n  getIterator() &#123;\n    return new Iterator(this);\n  &#125;\n&#125;\n// 测试代码\nlet container = new Container([1, 2, 3, 4, 5]);\nlet iterator = container.getIterator();\nwhile (iterator.hasNext()) &#123;\n  console.log(iterator.next());\n&#125;\n</code></pre>\n<ul>\n<li>场景例子</li>\n</ul>\n<p>Array.prototype.forEach<br>jQuery 中的$.each()<br>ES6 Iterator</p>\n<ul>\n<li>特点</li>\n</ul>\n<p>访问一个聚合对象的内容而无需暴露它的内部表示。<br>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</p>\n<ul>\n<li>总结<br>对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式</li>\n</ul>\n<h1 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h1><p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>\n<pre><code class=\"javascript\">class Color &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n&#125;\nclass Shape &#123;\n  constructor(name, color) &#123;\n    this.name = name;\n    this.color = color;\n  &#125;\n  draw() &#123;\n    console.log(`$&#123;this.color.name&#125; $&#123;this.name&#125;`);\n  &#125;\n&#125;\n\n//测试\nlet red = new Color(&quot;red&quot;);\nlet yellow = new Color(&quot;yellow&quot;);\nlet circle = new Shape(&quot;circle&quot;, red);\ncircle.draw();\nlet triangle = new Shape(&quot;triangle&quot;, yellow);\ntriangle.draw();\n</code></pre>\n<ul>\n<li>优点</li>\n</ul>\n<p>有助于独立地管理各组成部分， 把抽象化与实现化解耦<br>提高可扩充性</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</p>\n<h1 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h1><p>将对象组合成树形结构，以表示“整体-部分”的层次结构。<br>通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。</p>\n<pre><code class=\"javascript\">class TrainOrder &#123;\n  create() &#123;\n    console.log(&quot;创建火车票订单&quot;);\n  &#125;\n&#125;\nclass HotelOrder &#123;\n  create() &#123;\n    console.log(&quot;创建酒店订单&quot;);\n  &#125;\n&#125;\nclass TotalOrder &#123;\n  constructor() &#123;\n    this.orderList = [];\n  &#125;\n  addOrder(order) &#123;\n    this.orderList.push(order);\n    return this;\n  &#125;\n  create() &#123;\n    this.orderList.forEach((item) =&gt; &#123;\n      item.create();\n    &#125;);\n    return this;\n  &#125;\n&#125;\n// 可以在购票网站买车票同时也订房间\nlet train = new TrainOrder();\nlet hotel = new HotelOrder();\nlet total = new TotalOrder();\ntotal.addOrder(train).addOrder(hotel).create();\n</code></pre>\n<ul>\n<li>场景</li>\n</ul>\n<p>表示对象-整体层次结构<br>希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）</p>\n<ul>\n<li>缺点<br>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</li>\n</ul>\n<h1 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h1><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>\n<pre><code class=\"javascript\">class Person &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n  getName() &#123;\n    return this.name;\n  &#125;\n&#125;\nclass Student extends Person &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n  sayHello() &#123;\n    console.log(`Hello， My name is $&#123;this.name&#125;`);\n  &#125;\n&#125;\nlet student = new Student(&quot;xiaoming&quot;);\nstudent.sayHello();\n</code></pre>\n<p>原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。</p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换</p>\n<pre><code class=\"html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;策略模式-校验表单&lt;/title&gt;\n    &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;form id=&quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt;\n      用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; /&gt; 密码：&lt;input\n        type=&quot;text&quot;\n        name=&quot;password&quot;\n      /&gt;\n      手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;\n      &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n      // 策略对象\n      const strategies = &#123;\n        isNoEmpty: function (value, errorMsg) &#123;\n          if (value === &quot;&quot;) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        isNoSpace: function (value, errorMsg) &#123;\n          if (value.trim() === &quot;&quot;) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        minLength: function (value, length, errorMsg) &#123;\n          if (value.trim().length &lt; length) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        maxLength: function (value, length, errorMsg) &#123;\n          if (value.length &gt; length) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n        isMobile: function (value, errorMsg) &#123;\n          if (\n            !/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$/.test(\n              value\n            )\n          ) &#123;\n            return errorMsg;\n          &#125;\n        &#125;,\n      &#125;;\n      // 验证类\n      class Validator &#123;\n        constructor() &#123;\n          this.cache = [];\n        &#125;\n        add(dom, rules) &#123;\n          for (let i = 0, rule; (rule = rules[i++]); ) &#123;\n            let strategyAry = rule.strategy.split(&quot;:&quot;);\n            let errorMsg = rule.errorMsg;\n            this.cache.push(() =&gt; &#123;\n              let strategy = strategyAry.shift();\n              strategyAry.unshift(dom.value);\n              strategyAry.push(errorMsg);\n              return strategies[strategy].apply(dom, strategyAry);\n            &#125;);\n          &#125;\n        &#125;\n        start() &#123;\n          for (let i = 0, validatorFunc; (validatorFunc = this.cache[i++]); ) &#123;\n            let errorMsg = validatorFunc();\n            if (errorMsg) &#123;\n              return errorMsg;\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n      // 调用代码\n      let registerForm = document.getElementById(&quot;registerForm&quot;);\n      let validataFunc = function () &#123;\n        let validator = new Validator();\n        validator.add(registerForm.userName, [\n          &#123;\n            strategy: &quot;isNoEmpty&quot;,\n            errorMsg: &quot;用户名不可为空&quot;,\n          &#125;,\n          &#123;\n            strategy: &quot;isNoSpace&quot;,\n            errorMsg: &quot;不允许以空白字符命名&quot;,\n          &#125;,\n          &#123;\n            strategy: &quot;minLength:2&quot;,\n            errorMsg: &quot;用户名长度不能小于2位&quot;,\n          &#125;,\n        ]);\n        validator.add(registerForm.password, [\n          &#123;\n            strategy: &quot;minLength:6&quot;,\n            errorMsg: &quot;密码长度不能小于6位&quot;,\n          &#125;,\n        ]);\n        validator.add(registerForm.phoneNumber, [\n          &#123;\n            strategy: &quot;isMobile&quot;,\n            errorMsg: &quot;请输入正确的手机号码格式&quot;,\n          &#125;,\n        ]);\n        return validator.start();\n      &#125;;\n\n      registerForm.onsubmit = function () &#123;\n        let errorMsg = validataFunc();\n        if (errorMsg) &#123;\n          alert(errorMsg);\n          return false;\n        &#125;\n      &#125;;\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li>场景例子<br>如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>一个系统需要动态地在几种算法中选择一种。<br>表单验证</li>\n<li>优点<br>利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句<br>提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，理解，易于扩展<br>利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的代替方案</li>\n<li>缺点<br>会在程序中增加许多策略类或者策略对象<br>要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy</li>\n</ul>\n<h1 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h1><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式</p>\n<pre><code class=\"javascript\">let examCarNum = 0 // 驾考车总数\n// /_ 驾考车对象 _/\nclass ExamCar &#123;\nconstructor(carType) &#123;\nexamCarNum++\nthis.carId = examCarNum\nthis.carType = carType ? &#39;手动档&#39; : &#39;自动档&#39;\nthis.usingState = false // 是否正在使用\n&#125;\n/* 在本车上考试 */\nexamine(candidateId) &#123;\n    return new Promise((resolve =&gt; &#123;\n        this.usingState = true\n        console.log(`考生- $&#123; candidateId &#125; 开始在$&#123; this.carType &#125;驾考车- $&#123; this.carId &#125; 上考试`)\n        setTimeout(() =&gt; &#123;\n            this.usingState = false\n            console.log(`%c考生- $&#123; candidateId &#125; 在$&#123; this.carType &#125;驾考车- $&#123; this.carId &#125; 上考试完毕`, &#39;color:#f40&#39;)\n            resolve()                       // 0~2秒后考试完毕\n        &#125;, Math.random() * 2000)\n    &#125;))\n&#125;&#125;\n// /_ 手动档汽车对象池 _/\nManualExamCarPool = &#123;\n\\_pool: [], // 驾考车对象池\n\\_candidateQueue: [], // 考生队列\n/* 注册考生 ID 列表 */\nregistCandidates(candidateList) &#123;\n  candidateList.forEach(candidateId =&gt; this.registCandidate(candidateId))\n&#125;,\n/* 注册手动档考生 */\nregistCandidate(candidateId) &#123;\n  const examCar = this.getManualExamCar()    // 找一个未被占用的手动档驾考车\n  if (examCar) &#123;\n      examCar.examine(candidateId)           // 开始考试，考完了让队列中的下一个考生开始考试\n        .then(() =&gt; &#123;\n            const nextCandidateId = this._candidateQueue.length &amp;&amp; this._candidateQueue.shift()\n            nextCandidateId &amp;&amp; this.registCandidate(nextCandidateId)\n        &#125;)\n  &#125; else this._candidateQueue.push(candidateId)\n&#125;,\n/* 注册手动档车 */\ninitManualExamCar(manualExamCarNum) &#123;\n  for (let i = 1; i &lt;= manualExamCarNum; i++) &#123;\n      this._pool.push(new ExamCar(true))\n  &#125;\n&#125;,\n/* 获取状态为未被占用的手动档车 */\ngetManualExamCar() &#123;\n  return this._pool.find(car =&gt; !car.usingState)\n&#125;\nManualExamCarPool.initManualExamCar(3) // 一共有 3 个驾考车\nManualExamCarPool.registCandidates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) // 10 个考生来考试\n&#125;\n</code></pre>\n<ul>\n<li>场景例子<br>文件上传需要创建多个文件实例的时候<br>如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式</li>\n<li>优点<br>大大减少对象的创建，降低系统的内存，使效率提高。</li>\n<li>缺点</li>\n</ul>\n<p>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，<br>不应该随着内部状态的变化而变化，否则会造成系统的混乱</p>\n<h1 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h1><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>\n<pre><code class=\"javascript\">class Beverage &#123;\n  constructor(&#123; brewDrink, addCondiment &#125;) &#123;\n    this.brewDrink = brewDrink;\n    this.addCondiment = addCondiment;\n  &#125;\n  // /_ 烧开水，共用方法 _/\n  boilWater() &#123;\n    console.log(&quot;水已经煮沸=== 共用&quot;);\n  &#125;\n  // /_ 倒杯子里，共用方法 _/\n  pourCup() &#123;\n    console.log(&quot;倒进杯子里===共用&quot;);\n  &#125;\n  // /_ 模板方法 _/\n  init() &#123;\n    this.boilWater();\n    this.brewDrink();\n    this.pourCup();\n    this.addCondiment();\n  &#125;\n&#125;\n/_ 咖啡 _/;\nconst coffee = new Beverage(&#123;\n  // /_ 冲泡咖啡，覆盖抽象方法 _/\n  brewDrink: function () &#123;\n    console.log(&quot;冲泡咖啡&quot;);\n  &#125;,\n  // /_ 加调味品，覆盖抽象方法 _/\n  addCondiment: function () &#123;\n    console.log(&quot;加点奶和糖&quot;);\n  &#125;,\n&#125;);\ncoffee.init();\n</code></pre>\n<ul>\n<li>场景例子<br>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现<br>子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复</li>\n<li>优点<br>提取了公共代码部分，易于维护</li>\n<li>缺点<br>增加了系统复杂度，主要是增加了的抽象类和类间联系</li>\n</ul>\n<h1 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>\n<pre><code class=\"javascript\">// 请假审批，需要组长审批、经理审批、总监审批\nclass Action &#123;\n  constructor(name) &#123;\n    this.name = name;\n    this.nextAction = null;\n  &#125;\n  setNextAction(action) &#123;\n    this.nextAction = action;\n  &#125;\n  handle() &#123;\n    console.log(`$&#123;this.name&#125; 审批`);\n    if (this.nextAction != null) &#123;\n      this.nextAction.handle();\n    &#125;\n  &#125;\n&#125;\nlet a1 = new Action(&quot;组长&quot;);\nlet a2 = new Action(&quot;经理&quot;);\nlet a3 = new Action(&quot;总监&quot;);\na1.setNextAction(a2);\na2.setNextAction(a3);\na1.handle();\n</code></pre>\n<ul>\n<li>场景例子<br>JS 中的事件冒泡<br>作用域链<br>原型链</li>\n<li>优点<br>降低耦合度。它将请求的发送者和接收者解耦。<br>简化了对象。使得对象不需要知道链的结构<br>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任<br>增加新的请求处理类很方便。</li>\n<li>缺点<br>不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。<br>使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。</li>\n</ul>\n<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><blockquote>\n<p>简单理解为一个类,光传递内部数据而不执行过程,类似于控制反转<br>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p>\n</blockquote>\n<pre><code class=\"javascript\">// 接收者类\nclass Receiver &#123;\n  execute() &#123;\n    console.log(&quot;接收者执行请求&quot;);\n  &#125;\n&#125;\n// 命令者\nclass Command &#123;\n  constructor(receiver) &#123;\n    this.receiver = receiver;\n  &#125;\n  execute() &#123;\n    console.log(&quot;命令&quot;);\n    this.receiver.execute();\n  &#125;\n&#125;\n// 触发者\nclass Invoker &#123;\n  constructor(command) &#123;\n    this.command = command;\n  &#125;\n  invoke() &#123;\n    console.log(&quot;开始&quot;);\n    this.command.execute();\n  &#125;\n&#125;\n// 仓库\nconst warehouse = new Receiver();\n// 订单\nconst order = new Command(warehouse);\n// 客户\nconst client = new Invoker(order);\nclient.invoke();\n</code></pre>\n<ul>\n<li>优点<br>对命令进行封装，使命令易于扩展和修改<br>命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行</li>\n<li>缺点<br>使用命令模式可能会导致某些系统有过多的具体命令类。</li>\n</ul>\n<h1 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h1><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>\n<pre><code class=\"javascript\">//备忘类\nclass Memento &#123;\n  constructor(content) &#123;\n    this.content = content;\n  &#125;\n  getContent() &#123;\n    return this.content;\n  &#125;\n&#125;\n// 备忘列表\nclass CareTaker &#123;\n  constructor() &#123;\n    this.list = [];\n  &#125;\n  add(memento) &#123;\n    this.list.push(memento);\n  &#125;\n  get(index) &#123;\n    return this.list[index];\n  &#125;\n&#125;\n// 编辑器\nclass Editor &#123;\n  constructor() &#123;\n    this.content = null;\n  &#125;\n  setContent(content) &#123;\n    this.content = content;\n  &#125;\n  getContent() &#123;\n    return this.content;\n  &#125;\n  saveContentToMemento() &#123;\n    return new Memento(this.content);\n  &#125;\n  getContentFromMemento(memento) &#123;\n    this.content = memento.getContent();\n  &#125;\n&#125;\n//测试代码\nlet editor = new Editor();\nlet careTaker = new CareTaker();\neditor.setContent(&quot;111&quot;);\neditor.setContent(&quot;222&quot;);\ncareTaker.add(editor.saveContentToMemento());\neditor.setContent(&quot;333&quot;);\ncareTaker.add(editor.saveContentToMemento());\neditor.setContent(&quot;444&quot;);\nconsole.log(editor.getContent()); //444\neditor.getContentFromMemento(careTaker.get(1));\nconsole.log(editor.getContent()); //333\neditor.getContentFromMemento(careTaker.get(0));\nconsole.log(editor.getContent()); //222\n</code></pre>\n<ul>\n<li>场景例子<br>分页控件<br>撤销组件</li>\n<li>优点<br>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>\n<li>缺点<br>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>\n</ul>\n<h1 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h1><blockquote>\n<p>代理模式和中介者模式的区别在于：代理模式往往是一对一的，但中介模式往往是一对多。<br>解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者<br>模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）</p>\n</blockquote>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.number = 0;\n  &#125;\n  setNumber(num, m) &#123;\n    this.number = num;\n    if (m) &#123;\n      m.setB();\n    &#125;\n  &#125;\n&#125;\nclass B &#123;\n  constructor() &#123;\n    this.number = 0;\n  &#125;\n  setNumber(num, m) &#123;\n    this.number = num;\n    if (m) &#123;\n      m.setA();\n    &#125;\n  &#125;\n&#125;\nclass Mediator &#123;\n  constructor(a, b) &#123;\n    this.a = a;\n    this.b = b;\n  &#125;\n  setA() &#123;\n    let number = this.b.number;\n    this.a.setNumber(number / 10);\n  &#125;\n  setB() &#123;\n    let number = this.a.number;\n    this.b.setNumber(number / 10);\n  &#125;\n&#125;\nlet a = new A();\nlet b = new B();\nlet m = new Mediator(a, b);\na.setNumber(10, m);\nconsole.log(a.number, b.number);\nb.setNumber(10, m);\nconsole.log(a.number, b.number);\n</code></pre>\n<ul>\n<li>场景例子<br>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象<br>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>\n<li>优点<br>使各对象之间耦合松散，而且可以独立地改变它们之间的交互<br>中介者和对象一对多的关系取代了对象之间的网状多对多的关系<br>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码</li>\n<li>缺点<br>系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</li>\n</ul>\n<h1 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h1><p>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>\n<pre><code class=\"javascript\">class Context &#123;\n  constructor() &#123;\n    this._list = []; // 存放 终结符表达式\n    this._sum = 0; // 存放 非终结符表达式(运算结果)\n  &#125;\n  get sum() &#123;\n    return this._sum;\n  &#125;\n  set sum(newValue) &#123;\n    this._sum = newValue;\n  &#125;\n  add(expression) &#123;\n    this._list.push(expression);\n  &#125;\n  get list() &#123;\n    return [...this._list];\n  &#125;\n&#125;\nclass PlusExpression &#123;\n  interpret(context) &#123;\n    if (!(context instanceof Context)) &#123;\n      throw new Error(&quot;TypeError&quot;);\n    &#125;\n    context.sum = ++context.sum;\n  &#125;\n&#125;\nclass MinusExpression &#123;\n  interpret(context) &#123;\n    if (!(context instanceof Context)) &#123;\n      throw new Error(&quot;TypeError&quot;);\n    &#125;\n    context.sum = --context.sum;\n  &#125;\n&#125;\n/** 以下是测试代码 **/\nconst context = new Context();\n// 依次添加: 加法 | 加法 | 减法 表达式\ncontext.add(new PlusExpression());\ncontext.add(new PlusExpression());\ncontext.add(new MinusExpression());\n// 依次执行: 加法 | 加法 | 减法 表达式\ncontext.list.forEach((expression) =&gt; expression.interpret(context));\nconsole.log(context.sum);\n</code></pre>\n<ul>\n<li>优点<br>易于改变和扩展文法。<br>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>\n<li>缺点<br>执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度慢<br>对于复杂的文法比较难维护</li>\n</ul>\n<h1 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h1><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>\n<pre><code class=\"javascript\">// 访问者\nclass Visitor &#123;\n  constructor() &#123;&#125;\n  visitConcreteElement(ConcreteElement) &#123;\n    ConcreteElement.operation();\n  &#125;\n&#125;\n// 元素类\nclass ConcreteElement &#123;\n  constructor() &#123;&#125;\n  operation() &#123;\n    console.log(&quot;ConcreteElement.operation invoked&quot;);\n  &#125;\n  accept(visitor) &#123;\n    visitor.visitConcreteElement(this);\n  &#125;\n&#125;\n// client\nlet visitor = new Visitor();\nlet element = new ConcreteElement();\nelement.accept(visitor);\n</code></pre>\n<ul>\n<li>场景例子<br>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作<br>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>\n<li>优点<br>符合单一职责原则<br>优秀的扩展性<br>灵活性</li>\n<li>缺点<br>具体元素对访问者公布细节，违反了迪米特原则<br>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br>具体元素变更比较困难</li>\n</ul>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h4 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h4><blockquote>\n<p>开放封闭原则的核心是：对扩展开放，对修改封闭。</p>\n</blockquote>\n<ul>\n<li>对扩展开放意味着：软件实体（如类、模块、函数等）应该易于扩展，即：不修改现有代码的基础上添加新的功能</li>\n<li>对修改封闭意味着：软件实体应该避免修改，尤其是已经经过测试并被证明是稳定的代码</li>\n</ul>\n<h4 id=\"单一功能原则\"><a href=\"#单一功能原则\" class=\"headerlink\" title=\"单一功能原则\"></a>单一功能原则</h4><blockquote>\n<p>单一功能原则的核心是：一个类应该只有一个引起他变化的原因，它强调的是类的职责应该清晰明确，一个类只负责一项任务或功能，这样做的目的是为了降低类的复杂性，增加代码的可维护性和可复用性。</p>\n</blockquote>\n<h4 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h4><blockquote>\n<p>里氏替换原则是实现开放封闭原则的方式之一，里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>\n</blockquote>\n<h4 id=\"最少知识原则\"><a href=\"#最少知识原则\" class=\"headerlink\" title=\"最少知识原则\"></a>最少知识原则</h4><blockquote>\n<p>最少知识原则又称迪米特法则，意思是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br>最少知识原则降低了类的耦合性，提高了模块的独立性，从而提升了模块的可复用率和系统的扩展性。但是过度使用则会使系统产生大量的中介类，从而增加系统的复杂性。</p>\n</blockquote>\n<h4 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h4><blockquote>\n<p>类的复用分为两种：继承复用和合成复用</p>\n</blockquote>\n<ul>\n<li>继承复用的优点：简单清晰，易于实现</li>\n<li>继承复用的缺点：破坏了类的封装性（继承会将父类的实现细节暴露给子类，因此这种复用又称为白箱复用）、子类与父类的耦合度高，父类的实现改变会导致子类的实现改变。</li>\n<li>合成复用的优点：维持了类的封装性（对象内部细节对外部是不可见的，因此又称为黑盒复用）、新类和旧类之间耦合度低、复用的灵活性高</li>\n<li>合成复用的缺点：实现复杂、代码量多<blockquote>\n<p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"面向接口\"><a href=\"#面向接口\" class=\"headerlink\" title=\"面向接口\"></a>面向接口</h2><h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><blockquote>\n<p>依赖倒置原则：程序要依赖于抽象接口，而不要依赖于具体的实现，也就是说高层模块不应该依赖于底层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖抽象。<br>依赖倒置原则的核心是：通过面向接口的编程来降低类之间的耦合性。<br><code>依赖倒置</code>是面向接口领域的软件设计原则，<code>依赖反转</code>是遵守依赖倒置原则而提出的一种设计模式，而<code>依赖注入</code>是为了实现依赖反转的一种手段和方式。</p>\n</blockquote>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><blockquote>\n<p>接口隔离原则要求将臃肿庞大的接口进行拆分，拆分为更小的更具体的接口，小的接口之间相互隔离。<br>接口隔离原则的核心是：提高内聚，减少对外交互，使接口用最少的方法完成最多的事情。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中：</p>\n<ul>\n<li>开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；</li>\n<li>里氏替换原则告诉我们不要破坏继承体系；</li>\n<li>依赖倒置原则告诉我们要面向接口编程；</li>\n<li>单一职责原则告诉我们实现类要职责单一；</li>\n<li>接口隔离原则告诉我们在设计接口的时候要精简单一；</li>\n<li>最少知识原则告诉我们要降低耦合度；</li>\n<li>合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</li>\n</ul>\n","categories":["设计模式与设计原则"],"tags":["设计模式与设计原则"]},{"title":"面试题","url":"/2023/08/29/%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><p><img data-src=\"/images/image-20240615100110302.png\" alt=\"image-20240615100110302\"></p>\n<p><img data-src=\"/images/image-20240615100348230.png\" alt=\"image-20240615100348230\"></p>\n<p><img data-src=\"/images/image-20240615103856678.png\" alt=\"image-20240615103856678\"></p>\n<h1 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h1><p><img data-src=\"/images/image-20240615104315494.png\" alt=\"image-20240615104315494\"></p>\n<p><img data-src=\"/images/image-20240615144630951.png\" alt=\"image-20240615144630951\"></p>\n<p><img data-src=\"/images/image-20240615144850506.png\" alt=\"image-20240615144850506\"></p>\n<h1 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h1><p><img data-src=\"/images/image-20240615145615464.png\" alt=\"image-20240615145615464\"></p>\n<p><img data-src=\"/images/image-20240615145720791.png\" alt=\"image-20240615145720791\"></p>\n<h1 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h1><p><img data-src=\"/images/image-20240615154852705.png\" alt=\"image-20240615154852705\"></p>\n<p>​</p>\n<p><img data-src=\"/images/image-20240615155246599.png\" alt=\"image-20240615155246599\"></p>\n<h1 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h1><p><img data-src=\"/images/image-20240615155930056.png\" alt=\"image-20240615155930056\"></p>\n<p><img data-src=\"/images/image-20240615160004896.png\" alt=\"image-20240615160004896\"></p>\n<p><img data-src=\"/images/image-20240615161115653.png\" alt=\"image-20240615161115653\"></p>\n<p><img data-src=\"/images/image-20240615161945008.png\" alt=\"image-20240615161945008\"></p>\n<h1 id=\"restful\"><a href=\"#restful\" class=\"headerlink\" title=\"restful\"></a>restful</h1><p><img data-src=\"/images/image-20240615162039503.png\" alt=\"image-20240615162039503\"></p>\n<p><img data-src=\"/images/image-20240615162814863.png\" alt=\"image-20240615162814863\"></p>\n<p><img data-src=\"/images/image-20240615163452260.png\" alt=\"image-20240615163452260\"></p>\n<p><img data-src=\"/images/image-20240615163708988.png\" alt=\"image-20240615163708988\"></p>\n<p><img data-src=\"/images/image-20240615164606824.png\" alt=\"image-20240615164606824\"></p>\n<p><img data-src=\"/images/image-20240615164703711.png\" alt=\"image-20240615164703711\"></p>\n<p><img data-src=\"/images/image-20240615165454563.png\" alt=\"image-20240615165454563\"></p>\n<p><img data-src=\"/images/image-20240615165036538.png\" alt=\"image-20240615165036538\"></p>\n<p><img data-src=\"/images/image-20240615165358744.png\" alt=\"image-20240615165358744\"></p>\n<p><img data-src=\"/images/image-20240615165253528.png\" alt=\"image-20240615165253528\"></p>\n<h1 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h1><p><img data-src=\"/images/image-20240615174235183.png\" alt=\"image-20240615174235183\"></p>\n<p><img data-src=\"/images/image-20240615174757319.png\" alt=\"image-20240615174757319\"></p>\n<p><img data-src=\"/images/image-20240615174819942.png\" alt=\"image-20240615174819942\"></p>\n<p><img data-src=\"/images/image-20240615175041938.png\" alt=\"image-20240615175041938\"></p>\n<p><img data-src=\"/images/image-20240615175155718.png\" alt=\"image-20240615175155718\"></p>\n<p><img data-src=\"/images/image-20240615175309361.png\" alt=\"image-20240615175309361\"></p>\n<p><img data-src=\"/images/image-20240615181223986.png\" alt=\"image-20240615181223986\"></p>\n<p><img data-src=\"/images/image-20240615182042111.png\" alt=\"image-20240615182042111\"></p>\n<p><img data-src=\"/images/image-20240615182506393.png\" alt=\"image-20240615182506393\"></p>\n<p><img data-src=\"/images/image-20240615182658126.png\" alt=\"image-20240615182658126\"></p>\n<p><img data-src=\"/images/image-20240615182946625.png\" alt=\"image-20240615182946625\"></p>\n<p><img data-src=\"/images/image-20240615183118177.png\" alt=\"image-20240615183118177\"></p>\n<p><img data-src=\"/images/image-20240615184908403.png\" alt=\"image-20240615184908403\"></p>\n<p><img data-src=\"/images/image-20240615190633946.png\" alt=\"image-20240615190633946\"></p>\n<p><img data-src=\"/images/image-20240615195704070.png\" alt=\"image-20240615195704070\"></p>\n<p><img data-src=\"/images/image-20240615201443518.png\" alt=\"image-20240615201443518\"></p>\n<h1 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h1><p><img data-src=\"/images/image-20240615235053481.png\" alt=\"image-20240615235053481\"></p>\n<h1 id=\"vue2\"><a href=\"#vue2\" class=\"headerlink\" title=\"vue2\"></a>vue2</h1><p><img data-src=\"/images/image-20240620212614138.png\" alt=\"image-20240620212614138\"></p>\n<p>v-show 和 v-if：</p>\n<ul>\n<li><p>v-show</p>\n<ul>\n<li><p>v-show 的原理是使用 display:none 进行隐藏，会引发重绘而不会回流。</p>\n</li>\n<li><p>v-show 适用于需要频繁切换 DOM 元素的场景中；</p>\n</li>\n</ul>\n</li>\n<li><p>v-if</p>\n<ul>\n<li>v-if 原理是 DOM 元素是否添加，会引发回流与重绘</li>\n<li>v-if 适用于不常切换 DOM 元素的条件判断中</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"/images/image-20240620213800567.png\" alt=\"image-20240620213800567\"></p>\n<p>v-for 和 v-if 同时使用</p>\n<ul>\n<li>在 vue2 中，v-for 和 v-if 同时使用会严重造成性能的浪费，这是因为 vue2 中 v-for 的优先级高于 vue3</li>\n<li>但是在 vue3 中，v-if 的优先级高于 v-for，因此一起使用也无可厚非</li>\n</ul>\n<p><img data-src=\"/images/image-20240620214812889.png\" alt=\"image-20240620214812889\"></p>\n<p><img data-src=\"/images/image-20240620215109900.png\" alt=\"image-20240620215109900\"></p>\n<p><img data-src=\"/images/image-20240620215153287.png\" alt=\"image-20240620215153287\"></p>\n<p><img data-src=\"/images/image-20240620215803063.png\" alt=\"image-20240620215803063\"></p>\n<p><img data-src=\"/images/image-20240620224000511.png\" alt=\"image-20240620224000511\"></p>\n<p>生命周期（父子子父）：</p>\n<ul>\n<li>父组件 created 之后—-子组件 created</li>\n<li>子组件 mounted 到父组件之后—-父组件 mounted</li>\n<li>父组件 before update—-子组件 before update</li>\n<li>子组件 updated—-父组件 updated</li>\n</ul>\n<p><img data-src=\"/images/image-20240622104018967.png\" alt=\"image-20240622104018967\"></p>\n<p><img data-src=\"/images/image-20240622105007968.png\" alt=\"image-20240622105007968\"></p>\n<p><img data-src=\"/images/image-20240622120259017.png\" alt=\"image-20240622120259017\"></p>\n<p>vue 虚拟 dom 基于 snabbdom 来实现的。</p>\n<ul>\n<li>h 函数，生成 vnode</li>\n<li></li>\n</ul>\n<p>v-for 中：key 的作用（diff 算法的降级处理）：</p>\n<ul>\n<li><p>在进行 diff 比对时，树的 diff 算法的时间复杂度是 O（n ** 3）</p>\n<ul>\n<li>遍历 tree1、遍历 tree2 然后 排序，这样在进行 diff 比对时，性能消耗就会很大，因此需要对 diff 算法进行降级处理。</li>\n</ul>\n</li>\n<li><p>vnode 在进行 diff 算法时，需要比较两个节点是否相同，如果比较两个节点全部的属性，则时间复杂度就很高，因此采用 key+tag 的形式进行判断是否是相同节点，以降低 diff 算法的时间复杂度。</p>\n</li>\n<li><p>除了 diff 算法中起到作用之外，key 还有其他作用：</p>\n<ul>\n<li>transition-group 中确保过渡效果准确应用。</li>\n<li>组件 vnode 中也有 key，它可以确保组件的状态在重新渲染时得以保留。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"/images/image-20240622234014692.png\" alt=\"image-20240622234014692\"></p>\n<h1 id=\"vue3\"><a href=\"#vue3\" class=\"headerlink\" title=\"vue3\"></a>vue3</h1><p><img data-src=\"/images/image-20240624191248157.png\" alt=\"image-20240624191248157\"></p>\n<ul>\n<li>Proxy 代理整个对象，而不需要循环遍历属性进行代理，提升了速度</li>\n<li>patchFlag 标记：用于 diff 算法中，将节点进行标记使得 diff 算法可以跳过固定的静态节点的比对<ul>\n<li>其中有一个技巧就是使用位运算进行累计各种类型。通过按位与判断是否包含某种类型。</li>\n</ul>\n</li>\n<li>hoistStatic（静态节点提升）：对于静态节点，将其提升到父级作用域缓存起来，用于节点复用，并且不用每次重新生成静态节点。<ul>\n<li>多个相邻的静态节点进行合并。</li>\n</ul>\n</li>\n<li>cacheHandler 缓存事件处理函数，将事件处理函数提升到父级作用域进行缓存，以提高性能。</li>\n<li>SSR 优化：静态节点直接输出（html 格式标签），绕过了 vdom，动态节点还是动态渲染。</li>\n<li>tree shaking：根据模板的内容动态的 import 所需要的内容，没有用到就不会进行 import。<ul>\n<li>vue3 中按需导入会大大减小最终构建产物的体积，tree-shaking 会自动检测模板中用到的组件并导入，但是并不是所有的库和框架都支持 tree-shaking，需要三方适配或提供按需导入的方式。</li>\n</ul>\n</li>\n</ul>\n<p>vite 为什么快：</p>\n<ul>\n<li>开发环境使用 ES6 Module，模块使用时才会去打包</li>\n<li>使用 esbuild 工具进行预构建等，提升速度<ul>\n<li>esbuild 是基于 go 语言开发，可以多线程打包，并将代码直接编译为机器码。</li>\n</ul>\n</li>\n<li>生产环境使用 rollup，并且生产环境不能使用 ES6 Module，所以不会快很多。</li>\n</ul>\n<p>Composition API 和 React Hooks 对比</p>\n<ul>\n<li>前者 setup 只会被调用一次，而后者 hooks 会被多次调用（必要时进行缓存，并且 hooks 需要保证调用顺序一致，不能在分支中使用 hooks）。</li>\n</ul>\n<p>Vue3 中使用 JSX</p>\n<ul>\n<li>JSX 语法被 React 使用之后越来越壮大。（现在已发展壮大）</li>\n<li>使用.jsx 后缀格式文件和 defineComponent 定义组件，需要 babel 中的 jsx-loader 进行支持。</li>\n</ul>\n<p>JSX 和 template 语法的区别</p>\n<ul>\n<li>JSX 的本质就是 js 代码，可以使用 js 的任何能力（组件大小写敏感）</li>\n<li>template 只能嵌入简单的 js 表达式，其他需要指令去完成（组件大小写不敏感）</li>\n<li>JSX 成为 ES 规范，template 仅仅是 Vue 的模板规范</li>\n<li>都会被编译为 js 代码（render 函数）</li>\n</ul>\n<p>Vue3 setup 语法糖</p>\n<ul>\n<li>this 为 undefined</li>\n</ul>\n<h1 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h1><p>事件</p>\n<ul>\n<li>react 自身实现了一套自己的事件机制，包括事件注册、事件合成、事件冒泡和事件派发等。虽然和原生是两码事，但是也是基于浏览器的事件机制下完成的。</li>\n<li>react 所有事件并没有绑定到具体的 dom 节点上而是绑定在了 document 上，然后由统一的事件处理程序处理，同时也是基于浏览器的冒泡机制，所有节点事件都会在 document 上触发。</li>\n<li>事件被存储在 React.createElement 的 props 中，接着被保存在 fiber 对象的 memoizedProps 和 pendingProps 上。</li>\n<li>例如给 input 绑定 onChange 事件，最后被统一绑定在了 document 上，onChange 被处理成很多事件监听器，例如：blur，change，input，keydown，keyup 等。</li>\n<li>意义：减少内存消耗，提升性能，不需要注册很多事件，一种事件类型只会在 document 上注册一次，对开发者友好。</li>\n</ul>\n<p>性能优化</p>\n<ul>\n<li><p>shouldComponentUpdate</p>\n<ul>\n<li>React 默认（SCU 默认返回 true）：父组件有更新时，子组件也无条件跟着更新</li>\n<li>shouldComponentUpdate 一般进行判断下一张快照的 state 和当前快照的 state 有没有发生变化，从而判断是否需要进行更新。所以需要结合不可变值。（当更改当前快照的状态并且设置 state 时，会导致判断不按照相应地逻辑去走，这也是为什么 react 不直接内置 shouldComponentUpdate 的原因）</li>\n</ul>\n</li>\n<li><p>PureComponent 和 React.memo</p>\n<ul>\n<li><p>PureComponent 纯组件，用于避免不必要的渲染，从而提高效率，类组件中建议使用 PureComponent。</p>\n</li>\n<li><p>PureComponent 中，shouldComponentUpdate 实现了浅比较</p>\n</li>\n<li><p>memo 是函数组件中的 PureComponent</p>\n</li>\n<li><p>浅比较已使用大部分情况（尽量不要做深度比较）</p>\n</li>\n</ul>\n</li>\n<li><p>不可变值 immutable.js</p>\n</li>\n</ul>\n<p>公共逻辑抽离</p>\n<ul>\n<li>高阶组件 HOC<ul>\n<li>传入一个组件，返回一个组件（使用了传入的组件）</li>\n<li>通过…props 进行透传</li>\n</ul>\n</li>\n<li>Render Props<ul>\n<li>类组件接收一个 render 函数（render 函数返回需要显示的组件），类组件内部执行 this.props.render 函数，将 this.state 传入进去。</li>\n</ul>\n</li>\n</ul>\n<p>redux</p>\n<ul>\n<li>单向数据流<ul>\n<li>dispatch（action）</li>\n<li>reducer –&gt; newState</li>\n<li>subscribe 触发通知</li>\n</ul>\n</li>\n</ul>\n<p>react-redux</p>\n<ul>\n<li>引入 react-redux 中的 Provider 组件</li>\n<li>使用 redux 中的 createStore 创建 store（传入 reducer）</li>\n<li>在跟组件外嵌套一层 Provider 组件，绑定 sotre 属性为 sotre</li>\n</ul>\n<p>redux 中间件</p>\n<ul>\n<li>redux-thunk</li>\n<li>redux-promise</li>\n<li>redux-saga</li>\n</ul>\n<p>react-router</p>\n<ul>\n<li><p>路由模式</p>\n<ul>\n<li>hash 模式</li>\n<li>H5 history 模式（服务端配置支持）</li>\n</ul>\n</li>\n<li><p>使用</p>\n<ul>\n<li>从 react-router-dom 中导入 HashRouter 或者 BrowserRouter、Switch 和 Route 组件</li>\n<li>创建 RouterComponent 组件，外层 BrowserRouter 包裹 Switch 组件，里面嵌套 Route 组件</li>\n<li>Route 组件 path 属性定义路径，component 属性显示组件（或者嵌套显示的内部组件）</li>\n</ul>\n</li>\n<li><p>懒加载</p>\n<ul>\n<li>使用 react 的 lazy 组件，lazy 组件包裹一个函数，函数返回 import 动态导入的组件。</li>\n<li>使用 Suspense 组件，传递 fallback 属性显示加载时内容。</li>\n</ul>\n</li>\n</ul>\n<p>react 原理</p>\n<p>函数式编程</p>\n<ul>\n<li>纯函数</li>\n<li>不可变值</li>\n</ul>\n<p>状态码</p>\n<ul>\n<li>100:客户端继续请求</li>\n<li>101:服务器根据客户端得请求切换协议</li>\n<li>200:请求成功</li>\n<li>202:已接受但未处理完成</li>\n<li>204:无内容</li>\n<li>301:永久重定向</li>\n<li>302:临时重定向</li>\n<li>304:未修改</li>\n<li>400 bad:请求语法错误</li>\n<li>401 unauthorized:要求用户身份认证</li>\n<li>403 forbidden:拒绝此请求</li>\n<li>500 server Error:服务器错误</li>\n<li>502 bad gateway:网关或代理服务器错误</li>\n<li>504 gateway time-out:网关或代理服务器超时</li>\n</ul>\n<h1 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h1><ul>\n<li>为什么vue2中只能有一个根节点但是vue3中可以有多个？<blockquote>\n<p>vue2中vdom需要有一个单根节点作为入口，这样才能向下遍历，但vue3引入了Fragement节点，当顶层节点包含多个入口节点时会自动创建Fragement节点将这些节点包裹，转化为render函数时，会自动跳过Fragement节点转而遍历子节点。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><p><img data-src=\"/images/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"/images/image-20240123164938769\"></p>\n<pre><code class=\"javascript\">const date = new Date();\nconst a = &#123;name:1&#125;\nconsole.log(date.constructor.name);\nconsole.log(Date.prototype);\nconsole.log(date.__proto__);\nconsole.log(Date.prototype===date.__proto__);\nconsole.log(Date.prototype.constructor===Date);\nconsole.log(date.constructor.prototype.constructor===date.__proto__.constructor);\nconsole.log(date.constructor.prototype.constructor===Date.prototype.constructor);\nconsole.log(date.__proto__.constructor===date.constructor);\nconsole.log(Date.prototype.constructor===date.constructor);\nconsole.log(Date.prototype.constructor===Date);\nconsole.log(Date.prototype.__proto__===Object.prototype);\nconsole.log(Date.prototype.__proto__===a.__proto__);\n//Function相关\nconsole.log(Function.prototype===Function.__proto__);\nconsole.log(Function.constructor === Function);\nconst fn = function()&#123;&#125;;\nconsole.log(Function.__proto__===fn.__proto__);\n</code></pre>\n<h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a><em>JavaScript</em></h1><h3 id=\"1-根据下面-ES6-构造函数的书写方式，要求写出-ES5-的\"><a href=\"#1-根据下面-ES6-构造函数的书写方式，要求写出-ES5-的\" class=\"headerlink\" title=\"1. 根据下面 ES6 构造函数的书写方式，要求写出 ES5 的\"></a>1. 根据下面 <em>ES6</em> 构造函数的书写方式，要求写出 <em>ES5</em> 的</h3><pre><code class=\"javascript\">class Example &#123; \n  constructor(name) &#123; \n    this.name = name;\n  &#125;\n  init() &#123; \n    const fun = () =&gt; &#123; console.log(this.name) &#125;\n    fun(); \n  &#125; \n&#125;\nconst e = new Example(&#39;Hello&#39;);\ne.init();\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function Example(name) &#123;\n      &#39;use strict&#39;;\n      if (!new.target) &#123;\n           throw new TypeError(&#39;Class constructor cannot be invoked without new&#39;);\n      &#125;\n      this.name = name;\n&#125;\n\nObject.defineProperty(Example.prototype, &#39;init&#39;, &#123;\n      enumerable: false,\n      value: function () &#123;\n           &#39;use strict&#39;;\n           if (new.target) &#123;\n               throw new TypeError(&#39;init is not a constructor&#39;);\n           &#125;\n           var fun = function () &#123;\n               console.log(this.name);\n           &#125;\n           fun.call(this);\n      &#125;\n&#125;)\n</code></pre>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>此题的关键在于是否清楚 <em>ES6</em> 的 <em>class</em> 和普通构造函数的区别，记住它们有以下区别，就不会有遗漏：</p>\n<ol>\n<li><p><em>ES6</em> 中的 <em>class</em> 必须通过 <em>new</em> 来调用，不能当做普通函数调用，否则报错</p>\n<p> 因此，在答案中，加入了 <em>new.target</em> 来判断调用方式</p>\n</li>\n<li><p><em>ES6</em> 的 <em>class</em> 中的所有代码均处于严格模式之下</p>\n</li>\n</ol>\n<p>   因此，在答案中，无论是构造函数本身，还是原型方法，都使用了严格模式</p>\n<ol start=\"3\">\n<li><p><em>ES6</em> 中的原型方法是不可被枚举的</p>\n<p> 因此，在答案中，定义原型方法使用了属性描述符，让其不可枚举</p>\n</li>\n<li><p>原型上的方法不允许通过 <em>new</em> 来调用</p>\n<p>因此，在答案中，原型方法中加入了 <em>new.target</em> 来判断调用方式</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"2-数组去重有哪些方法？（美团-19-年）\"><a href=\"#2-数组去重有哪些方法？（美团-19-年）\" class=\"headerlink\" title=\"2. 数组去重有哪些方法？（美团 19 年）\"></a>2. 数组去重有哪些方法？（美团 <em>19</em> 年）</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">// 数字或字符串数组去重，效率高\nfunction unique(arr) &#123;\n      var result = &#123;&#125;; // 利用对象属性名的唯一性来保证不重复\n      for (var i = 0; i &lt; arr.length; i++) &#123;\n           if (!result[arr[i]]) &#123;\n               result[arr[i]] = true;\n           &#125;\n      &#125;\n      return Object.keys(result); // 获取对象所有属性名的数组\n&#125;\n\n// 任意数组去重，适配范围广，效率低\nfunction unique(arr) &#123;\n      var result = []; // 结果数组\n      for (var i = 0; i &lt; arr.length; i++) &#123;\n           if (!result.includes(arr[i])) &#123;\n               result.push(arr[i]);\n           &#125;\n      &#125;\n      return result;\n&#125;\n\n// 利用ES6的Set去重，适配范围广，效率一般，书写简单\nfunction unique(arr) &#123;\n      return [...new Set(arr)]\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"3-描述下列代码的执行结果\"><a href=\"#3-描述下列代码的执行结果\" class=\"headerlink\" title=\"3. 描述下列代码的执行结果\"></a>3. 描述下列代码的执行结果</h3><pre><code class=\"javascript\">foo(typeof a);\nfunction foo(p) &#123;\n    console.log(this);\n    console.log(p);\n    console.log(typeof b);\n    let b = 0;\n&#125;\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>报错，报错的位置在 <code>console.log(typeof b);</code></p>\n<p>报错原因：<em>ReferenceError: Cannot access ‘b’ before initialization</em></p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>这道题考查的是 <em>ES6</em> 新增的声明变量关键字 <em>let</em> 以及暂时性死区的知识。<em>let</em> 和以前的 <em>var</em> 关键字不一样，无法在 <em>let</em> 声明变量之前访问到该变量，所以在 <em>typeof b</em> 的地方就会报错。</p>\n</blockquote>\n<h3 id=\"4-描述下列代码的执行结果\"><a href=\"#4-描述下列代码的执行结果\" class=\"headerlink\" title=\"4. 描述下列代码的执行结果\"></a>4. 描述下列代码的执行结果</h3><pre><code class=\"javascript\">class Foo &#123;\n    constructor(arr) &#123; \n        this.arr = arr; \n    &#125;\n    bar(n) &#123;\n        return this.arr.slice(0, n);\n    &#125;\n&#125;\nvar f = new Foo([0, 1, 2, 3]);\nconsole.log(f.bar(1));\nconsole.log(f.bar(2).splice(1, 1));\nconsole.log(f.arr);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>[ 0 ]<br>[ 1 ]<br>[ 0, 1, 2, 3 ]</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>主要考察的是数组相关的知识。 <em>f</em> 对象上面有一个属性 <em>arr</em>，<em>arr</em> 的值在初始化的时候会被初始化为 *[0, 1, 2, 3]*，之后就完全是考察数组以及数组方法的使用了。</p>\n</blockquote>\n<h3 id=\"5-描述下列代码的执行结果\"><a href=\"#5-描述下列代码的执行结果\" class=\"headerlink\" title=\"5. 描述下列代码的执行结果\"></a>5. 描述下列代码的执行结果</h3><pre><code class=\"javascript\">01 function f(count) &#123;\n02    console.log(`foo$&#123;count&#125;`);\n03    setTimeout(() =&gt; &#123; console.log(`bar$&#123;count&#125;`); &#125;);\n04 &#125;\n05 f(1);\n06 f(2);\n07 setTimeout(() =&gt; &#123; f(3); &#125;);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>foo1<br>foo2<br>bar1<br>bar2<br>foo3<br>bar3</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>这个完全是考察的异步的知识。调用 <em>f(1)</em> 的时候，会执行同步代码，打印出 <em>foo1</em>，然后 <em>03</em> 行的 <em>setTimeout</em> 被放入到异步执行队列，接下来调用 <em>f(2)</em> 的时候，打印出 <em>foo2</em>，后面 <em>03</em> 行的 <em>setTimeout</em> 又被放入到异步执行队列。然后执行 <em>07</em> 行的语句，被放入到异步执行队列。至此，所有同步代码就都执行完毕了。</p>\n<p>接下来开始执行异步代码，那么大家时间没写，就都是相同的，所以谁先被放入到异步队列，谁就先执行，所以先打印出 <em>bar1</em>、然后是 <em>bar2</em>，接下来执行之前 <em>07</em> 行放入到异步队列里面的 <em>setTimeout</em>，先执行 <em>f</em> 函数里面的同步代码，打印出 <em>foo3</em>，然后是最后一个异步，打印出 <em>bar3</em></p>\n</blockquote>\n<h3 id=\"6-描述下列代码的执行结果\"><a href=\"#6-描述下列代码的执行结果\" class=\"headerlink\" title=\"6. 描述下列代码的执行结果\"></a>6. 描述下列代码的执行结果</h3><pre><code class=\"javascript\">var a = 2;\nvar b = 5;\nconsole.log(a === 2 || 1 &amp;&amp; b === 3 || 4);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p><em>true</em></p>\n<p>考察的是逻辑运算符。在 || 里面，只要有一个为真，后面的直接短路，都不用去计算。所以 <em>a &#x3D;&#x3D;&#x3D; 2</em> 得到 <em>true</em> 之后直接短路了，返回 <em>true</em>。</p>\n</blockquote>\n<h3 id=\"7-描述下列代码的执行结果\"><a href=\"#7-描述下列代码的执行结果\" class=\"headerlink\" title=\"7. 描述下列代码的执行结果\"></a>7. 描述下列代码的执行结果</h3><pre><code class=\"javascript\">export class ButtonWrapper &#123;\n    constructor(domBtnEl, hash) &#123;\n        this.domBtnEl = domBtnEl;\n        this.hash = hash;\n        this.bindEvent();\n    &#125;\n    bindEvent() &#123;\n        this.domBtnEl.addEventListener(&#39;click&#39;, this.clickEvent, false);\n    &#125;\n    detachEvent() &#123;\n        this.domBtnEl.removeEventListener(&#39;click&#39;, this.clickEvent);\n    &#125;\n    clickEvent() &#123;\n        console.log(`The hash of the button is: $&#123;this.hash&#125;`);\n    &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>上面的代码导出了一个 <em>ButtonWrapper</em> 类，该类在被实例化的时候，实例化对象上面有两个属性，分别是 <em>domBtnEl</em> 和 <em>hash</em>，<em>domBtnEl</em> 是一个 <em>DOM</em> 节点，之后为这个 <em>domBtnEl</em> 绑定了点击事件，点击后打印出 <em>The hash of the button is: hash</em> 那句话。<em>detachEvent</em> 是移除点击事件，当调用实例化对象的 <em>detachEvent</em> 方法时，点击事件就会被移除。</p>\n</blockquote>\n<h3 id=\"8-箭头函数有哪些特点\"><a href=\"#8-箭头函数有哪些特点\" class=\"headerlink\" title=\"8. 箭头函数有哪些特点\"></a>8. 箭头函数有哪些特点</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li>更简洁的语法，例如<ul>\n<li>只有一个形参就不需要用括号括起来</li>\n<li>如果函数体只有一行，就不需要放到一个块中</li>\n<li>如果 <em>return</em> 语句是函数体内唯一的语句，就不需要 <em>return</em> 关键字</li>\n</ul>\n</li>\n<li>箭头函数没有自己的 <em>this</em>，<em>arguments</em>，<em>super</em></li>\n<li>箭头函数 <em>this</em> 只会从自己的作用域链的上一层继承 <em>this</em>。</li>\n</ol>\n</blockquote>\n<h3 id=\"9-说一说类的继承\"><a href=\"#9-说一说类的继承\" class=\"headerlink\" title=\"9. 说一说类的继承\"></a>9. 说一说类的继承</h3><blockquote>\n<p>参考答案：</p>\n<p>继承是面向对象编程中的三大特性之一。</p>\n<p><em>JavaScript</em> 中的继承经过不断的发展，从最初的对象冒充慢慢发展到了今天的圣杯模式继承。</p>\n<p>其中最需要掌握的就是<strong>伪经典继承</strong>和<strong>圣杯模式</strong>的继承。</p>\n<p>很长一段时间，JS 继承使用的都是<strong>组合继承</strong>。这种继承也被称之为伪经典继承，该继承方式综合了原型链和盗用构造函数的方式，将两者的优点集中了起来。</p>\n<p>组合继承弥补了之前原型链和盗用构造函数这两种方式各自的不足，是 <em>JavaScript</em> 中使用最多的继承方式。</p>\n<p>组合继承最大的问题就是效率问题。最主要就是父类的构造函数始终会被调用两次：一次是在创建子类原型时调用，另一次是在子类构造函数中调用。</p>\n<p>本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>\n<p>圣杯模式的继承解决了这一问题，其基本思路就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。</p>\n</blockquote>\n<blockquote>\n<p>解析：该题主要考察就是对 <em>js</em> 中的继承是否了解，以及常见的继承的形式有哪些。最常用的继承就是<strong>组合继承</strong>（伪经典继承）和圣杯模式继承。下面附上 <em>js</em> 中这两种继承模式的详细解析。</p>\n<p>下面是一个组合继承的例子：</p>\n<pre><code class=\"javascript\">// 基类\nvar Person = function (name, age) &#123;\n    this.name = name;\n    this.age = age;\n&#125;\nPerson.prototype.test = &quot;this is a test&quot;;\nPerson.prototype.testFunc = function () &#123;\n    console.log(&#39;this is a testFunc&#39;);\n&#125;\n\n// 子类\nvar Student = function (name, age, gender, score) &#123;\n    Person.apply(this, [name, age]); // 盗用构造函数\n    this.gender = gender;\n    this.score = score;\n&#125;\nStudent.prototype = new Person(); // 改变 Student 构造函数的原型对象\nStudent.prototype.testStuFunc = function () &#123;\n    console.log(&#39;this is a testStuFunc&#39;);\n&#125;\n\n// 测试\nvar zhangsan = new Student(&quot;张三&quot;, 18, &quot;男&quot;, 100);\nconsole.log(zhangsan.name); // 张三\nconsole.log(zhangsan.age); // 18\nconsole.log(zhangsan.gender); // 男\nconsole.log(zhangsan.score); // 100\nconsole.log(zhangsan.test); // this is a test\nzhangsan.testFunc(); // this is a testFunc\nzhangsan.testStuFunc(); // this is a testStuFunc\n</code></pre>\n<p>在上面的例子中，我们使用了组合继承的方式来实现继承，可以看到无论是基类上面的属性和方法，还是子类自己的属性和方法，都得到了很好的实现。</p>\n<p>但是在组合继承中存在效率问题，比如在上面的代码中，我们其实调用了两次 <em>Person</em>，产生了两组 <em>name</em> 和 <em>age</em> 属性，一组在原型上，一组在实例上。</p>\n<p>也就是说，我们在执行 <em>Student.prototype &#x3D; new Person( )</em> 的时候，我们是想要 <em>Person</em> 原型上面的方法，属性是不需要的，因为属性之后可以通过 <em>Person.apply(this, [name, age])</em> 拿到，但是当你 <em>new Person( )</em> 的时候，会实例化一个 <em>Person</em> 对象出来，这个对象上面，属性和方法都有。</p>\n<p>圣杯模式的继承解决了这一问题，其基本思路就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。</p>\n<p>下面是一个圣杯模式的示例：</p>\n<pre><code class=\"javascript\">// target 是子类，origin 是基类\n// target ---&gt; Student, origin ---&gt; Person\nfunction inherit(target, origin) &#123;\n    function F() &#123; &#125;; // 没有任何多余的属性\n\n    // origin.prototype === Person.prototype, origin.prototype.constructor === Person 构造函数\n    F.prototype = origin.prototype;\n\n    // 假设 new F() 出来的对象叫小 f\n    // 那么这个 f 的原型对象 === F.prototype === Person.prototype\n    // 那么 f.constructor === Person.prototype.constructor === Person 的构造函数\n    target.prototype = new F();\n\n    // 而 f 这个对象又是 target 对象的原型对象\n    // 这意味着 target.prototype.constructor === f.constructor\n    // 所以 target 的 constructor 会指向 Person 构造函数\n\n    // 我们要让子类的 constructor 重新指向自己\n    // 若不修改则会发现 constructor 指向的是父类的构造函数\n    target.prototype.constructor = target;\n&#125;\n\n\n// 基类\nvar Person = function (name, age) &#123;\n    this.name = name;\n    this.age = age;\n&#125;\nPerson.prototype.test = &quot;this is a test&quot;;\nPerson.prototype.testFunc = function () &#123;\n    console.log(&#39;this is a testFunc&#39;);\n&#125;\n\n\n// 子类\nvar Student = function (name, age, gender, score) &#123;\n    Person.apply(this, [name, age]);\n    this.gender = gender;\n    this.score = score;\n&#125;\ninherit(Student, Person); // 使用圣杯模式实现继承\n// 在子类上面添加方法\nStudent.prototype.testStuFunc = function () &#123;\n    console.log(&#39;this is a testStuFunc&#39;);\n&#125;\n\n// 测试\nvar zhangsan = new Student(&quot;张三&quot;, 18, &quot;男&quot;, 100);\n\nconsole.log(zhangsan.name); // 张三\nconsole.log(zhangsan.age); // 18\nconsole.log(zhangsan.gender); // 男\nconsole.log(zhangsan.score); // 100\nconsole.log(zhangsan.test); // this is a test\nzhangsan.testFunc(); // this is a testFunc\nzhangsan.testStuFunc(); // this is a testStuFunc\n</code></pre>\n<p>在上面的代码中，我们在 <em>inherit</em> 方法中创建了一个中间层，之后让 <em>F</em> 的原型和父类的原型指向同一地址，再让子类的原型指向这个 <em>F</em> 的实例化对象来实现了继承。</p>\n<p>这样我们的继承，属性就不会像之前那样实例对象上一份，原型对象上一份，拥有两份。圣杯模式继承是目前 <em>js</em> 继承的最优解。</p>\n<p>最后我再画个图帮助大家理解，如下图：</p>\n<p>组合模式（伪经典模式）下的继承示意图：</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-08-022111.png\" alt=\"image-20210808102111003\" style=\"zoom:50%;\" />\n\n<p>圣杯模式下的继承示意图：</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-08-021304.png\" alt=\"image-20210808101303180\" style=\"zoom:50%;\" />\n\n\n</blockquote>\n<h3 id=\"10-new-操作符都做了哪些事？\"><a href=\"#10-new-操作符都做了哪些事？\" class=\"headerlink\" title=\"10. new 操作符都做了哪些事？\"></a>10. <em>new</em> 操作符都做了哪些事？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>new</em> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>\n<p><em>new</em> 关键字会进行如下的操作：<br>步骤 <em>1</em>：创建一个空的简单 <em>JavaScript</em> 对象，即 { } ;<br>步骤 <em>2</em>：链接该对象到另一个对象（即设置该对象的原型对象）；<br>步骤 <em>3</em>：将步骤 <em>1</em> 新创建的对象作为 <em>this</em> 的上下文；<br>步骤 <em>4</em>：如果该函数没有返回对象，则返回 <em>this</em>。</p>\n</blockquote>\n<h3 id=\"11-call、apply、bind-的区别-？\"><a href=\"#11-call、apply、bind-的区别-？\" class=\"headerlink\" title=\"11. call、apply、bind 的区别 ？\"></a>11. <em>call、apply、bind</em> 的区别 ？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>call</em> 和 <em>apply</em> 的功能相同，区别在于传参的方式不一样:</p>\n<ul>\n<li><em>fn.call(obj, arg1, arg2, …)</em> 调用一个函数, 具有一个指定的 <em>this</em> 值和分别地提供的参数(参数的列表)。</li>\n<li><em>fn.apply(obj, [argsArray])</em> 调用一个函数，具有一个指定的 <em>this</em> 值，以及作为一个数组（或类数组对象）提供的参数。</li>\n</ul>\n<p><em>bind</em> 和 <em>call&#x2F;apply</em> 有一个很重要的区别，一个函数被 <em>call&#x2F;apply</em> 的时候，会直接调用，但是 <em>bind</em> 会创建一个新函数。当这个新函数被调用时，<em>bind( )</em> 的第一个参数将作为它运行时的 <em>this</em>，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>\n</blockquote>\n<h3 id=\"12-事件循环机制（宏任务、微任务）\"><a href=\"#12-事件循环机制（宏任务、微任务）\" class=\"headerlink\" title=\"12. 事件循环机制（宏任务、微任务）\"></a>12. 事件循环机制（宏任务、微任务）</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>js</em> 中任务会分为同步任务和异步任务。</p>\n<p>如果是同步任务，则会在主线程（也就是 <em>js</em> 引擎线程）上进行执行，形成一个执行栈。但是一旦遇到异步任务，则会将这些异步任务交给异步模块去处理，然后主线程继续执行后面的同步代码。</p>\n<p>当异步任务有了运行结果以后，就会在任务队列里面放置一个事件，这个任务队列由事件触发线程来进行管理。</p>\n<p>一旦执行栈中所有的同步任务执行完毕，就代表着当前的主线程（<em>js</em> 引擎线程）空闲了，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。</p>\n<p>在 <em>js</em> 中，任务队列中的任务又可以被分为 <em>2</em> 种类型：宏任务（<em>macrotask</em>）与微任务（<em>microtask</em>），两者的区别在于是否在UI渲染前执行（node.js中区别在于：是否在扫描输入输出回调栈前扫描）。</p>\n<p>宏任务可以理解为每次执行栈所执行的代码就是一个宏任务，包括每次从事件队列中获取一个事件回调并放到执行栈中所执行的任务。</p>\n<p>微任务可以理解为当前宏任务执行结束后立即执行的任务。</p>\n</blockquote>\n<h3 id=\"13-你了解-node-中的事件循环机制吗？node11-版本以后有什么改变\"><a href=\"#13-你了解-node-中的事件循环机制吗？node11-版本以后有什么改变\" class=\"headerlink\" title=\"13. 你了解 node 中的事件循环机制吗？node11 版本以后有什么改变\"></a>13. 你了解 <em>node</em> 中的事件循环机制吗？<em>node11</em> 版本以后有什么改变</h3><blockquote>\n<p>参考答案：</p>\n<p><em>Node.js</em> 在主线程里维护了一个<strong>事件队列，</strong>当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时（没有请求接入时），就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 <em>I&#x2F;O</em> 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 <em>I&#x2F;O</em> 任务，就从<strong>线程池</strong>中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p>\n<p>当线程中的 <em>I&#x2F;O</em> 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 <strong>事件循环</strong> (<em>Event Loop</em>)。</p>\n<p>无论是 <em>Linux</em> 平台还是 <em>Windows</em> 平台，<em>Node.js</em> 内部都是通过<strong>线程池</strong>来完成异步 <em>I&#x2F;O</em> 操作的，而 <em>LIBUV</em> 针对不同平台的差异性实现了统一调用。因此，<strong><em>Node.js</em> 的单线程仅仅是指 <em>JavaScript</em> 运行在单线程中，而并非 <em>Node.js</em> 是单线程。</strong></p>\n<p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p>\n<ul>\n<li>nextTick和Promise等微任务不在事件循环的扫描队列中，而是在事件循环的各个阶段之间执行，在调用栈中的同步代码执行完毕后执行（先执行nextTick队列）。</li>\n<li><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</li>\n<li><em>I&#x2F;O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I&#x2F;O</em> 回调</li>\n<li><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</li>\n<li><em>poll</em> 阶段：获取新的 <em>I&#x2F;O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</li>\n<li><em>check</em> 阶段：执行 <em>setImmediate( )</em> 的回调</li>\n<li><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</li>\n</ul>\n<p>事件循环的执行顺序为：</p>\n<p>外部输入数据 –-&gt; 轮询阶段（ <em>poll</em> ）-–&gt; 检查阶段（ <em>check</em> ）-–&gt; 关闭事件回调阶段（ <em>close callback</em> ）–-&gt; 定时器检测阶段（ <em>timer</em> ）–-&gt; <em>I&#x2F;O</em> 事件回调阶段（ <em>I&#x2F;O callbacks</em> ）-–&gt;闲置阶段（ <em>idle、prepare</em> ）–-&gt;轮询阶段（按照该顺序反复运行）…</p>\n<p>浏览器和 <em>Node.js</em> 环境下，微任务任务队列的执行时机不同</p>\n<ul>\n<li><em>Node.js</em> 端，微任务在事件循环的各个阶段之间执行</li>\n<li>浏览器端，微任务在事件循环的宏任务执行完之后执行</li>\n</ul>\n<p><em>Node.js v11.0.0</em> 版本于 <em>2018</em> 年 <em>10</em> 月，主要有以下变化：</p>\n<ol>\n<li><em>V8</em> 引擎更新至版本 <em>7.0</em></li>\n<li><em>http、https</em> 和 <em>tls</em> 模块默认使用 <em>WHESWG URL</em> 解析器。</li>\n<li>隐藏子进程的控制台窗口默认改为了 <em>true</em>。</li>\n<li><em>FreeBSD 10</em>不再支持。</li>\n<li>增加了多线程 <em>Worker Threads</em></li>\n</ol>\n</blockquote>\n<h3 id=\"14-什么是函数柯里化？\"><a href=\"#14-什么是函数柯里化？\" class=\"headerlink\" title=\"14. 什么是函数柯里化？\"></a>14. 什么是函数柯里化？</h3><blockquote>\n<p>参考答案：</p>\n<p>柯里化（<em>currying</em>）又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p>\n<p>举个例子，就是把原本：</p>\n<p><em>function(arg1,arg2)</em> 变成 <em>function(arg1)(arg2)</em><br><em>function(arg1,arg2,arg3)</em> 变成 <em>function(arg1)(arg2)(arg3)</em><br><em>function(arg1,arg2,arg3,arg4)</em> 变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p>\n<p>总而言之，就是将：</p>\n<p><em>function(arg1,arg2,…,argn)</em> 变成 <em>function(arg1)(arg2)…(argn)</em></p>\n</blockquote>\n<h3 id=\"15-promise-all-方法的使用场景？数组中必须每一项都是-promise-对象吗？不是-promise-对象会如何处理-？\"><a href=\"#15-promise-all-方法的使用场景？数组中必须每一项都是-promise-对象吗？不是-promise-对象会如何处理-？\" class=\"headerlink\" title=\"15. promise.all 方法的使用场景？数组中必须每一项都是 promise 对象吗？不是 promise 对象会如何处理 ？\"></a>15. <em>promise.all</em> 方法的使用场景？数组中必须每一项都是 <em>promise</em> 对象吗？不是 <em>promise</em> 对象会如何处理 ？</h3><blockquote>\n<p>参考答案：</p>\n<p><em><strong>promise.all(promiseArray)</strong></em> 方法是 <em>promise</em> 对象上的静态方法，该方法的作用是将多个 <em>promise</em> 对象实例包装，生成并返回一个新的 <em>promise</em> 实例。</p>\n<p>此方法在集合多个 <em>promise</em> 的返回结果时很有用。</p>\n<p>返回值将会按照参数内的 <em>promise</em> 顺序排列，而不是由调用 <em>promise</em> 的完成顺序决定。</p>\n<p><strong><em>promise.all</em> 的特点</strong></p>\n<p>接收一个<em>Promise</em>实例的数组或具有<em>Iterator</em>接口的对象</p>\n<p>如果元素不是<em>Promise</em>对象，则使用<em>Promise.resolve</em>转成<em>Promise</em>对象</p>\n<p>如果全部成功，状态变为<em>resolved</em>，返回值将组成一个数组传给回调</p>\n<p>只有有一个失败，状态就变为 <em>rejected</em>，返回值将直接传递给回调  *all( )*的返回值，也是新的 <em>promise</em> 对象</p>\n</blockquote>\n<h3 id=\"16-this-的指向哪几种-？\"><a href=\"#16-this-的指向哪几种-？\" class=\"headerlink\" title=\"16. this 的指向哪几种 ？\"></a>16. <em>this</em> 的指向哪几种 ？</h3><blockquote>\n<p>参考答案：</p>\n<p>总结起来，<em>this</em> 的指向规律有如下几条：</p>\n<ul>\n<li>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 <em>this</em> 会被绑定到 <em>undefined</em> 上，在非严格模式下则会被绑定到全局对象 <em>window&#x2F;global</em> 上。</li>\n<li>一般使用 <em>new</em> 方法调用构造函数时，构造函数内的 <em>this</em> 会被绑定到新创建的对象上。</li>\n<li>一般通过 <em>call&#x2F;apply&#x2F;bind</em> 方法显式调用函数时，函数体内的 <em>this</em> 会被绑定到指定参数的对象上。</li>\n<li>一般通过上下文对象调用函数时，函数体内的 <em>this</em> 会被绑定到该对象上。</li>\n<li>在箭头函数中，<em>this</em> 的指向是由外层（函数或全局）作用域来决定的。</li>\n</ul>\n</blockquote>\n<h3 id=\"17-JS-中继承实现的几种方式\"><a href=\"#17-JS-中继承实现的几种方式\" class=\"headerlink\" title=\"17. JS 中继承实现的几种方式\"></a>17. <em>JS</em> 中继承实现的几种方式</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JS</em> 的继承随着语言的发展，从最早的对象冒充到现在的圣杯模式，涌现出了很多不同的继承方式。每一种新的继承方式都是对前一种继承方式不足的一种补充。</p>\n<ol>\n<li>原型链继承</li>\n</ol>\n<ul>\n<li>重点：让新实例的原型等于父类的实例。</li>\n<li>特点：实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</li>\n<li>缺点：<ul>\n<li>1、新实例无法向父类构造函数传参。</li>\n<li>2、继承单一。</li>\n<li>3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>借用构造函数继承</li>\n</ol>\n<ul>\n<li>重点：用 <em>call( )</em> 和 <em>apply( )</em> 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</li>\n<li>特点：<br>　　　- 1、只继承了父类构造函数的属性，没有继承父类原型的属性。<ul>\n<li>2、解决了原型链继承缺点1、2、3。</li>\n<li>3、可以继承多个构造函数属性（call多个）。</li>\n<li>4、在子实例中可向父实例传参。</li>\n</ul>\n</li>\n<li>缺点：<br>　　　- 1、只能继承父类构造函数的属性。<ul>\n<li>2、无法实现构造函数的复用。（每次用每次都要重新调用）</li>\n<li>3、每个新实例都有父类构造函数的副本，臃肿。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>组合模式（又被称之为伪经典模式）</li>\n</ol>\n<ul>\n<li>重点：结合了两种模式的优点，传参和复用</li>\n<li>特点：<br>　　　- 1、可以继承父类原型上的属性，可以传参，可复用。<br>  　　　- 2、每个新实例引入的构造函数属性是私有的。</li>\n<li>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</li>\n</ul>\n<ol start=\"4\">\n<li>寄生组合式继承（圣杯模式）</li>\n</ol>\n<ul>\n<li>重点：修复了组合继承的问题</li>\n</ul>\n</blockquote>\n<h3 id=\"18-什么是事件监听\"><a href=\"#18-什么是事件监听\" class=\"headerlink\" title=\"18. 什么是事件监听\"></a>18. 什么是事件监听</h3><blockquote>\n<p>参考答案：</p>\n<p>首先需要区别清楚事件监听和事件监听器。</p>\n<p>在绑定事件的时候，我们需要对应的书写一个事件处理程序，来应对事件发生时的具体行为。</p>\n<p>这个事件处理程序我们也称之为事件监听器。</p>\n<p>当事件绑定好后，程序就会对事件进行监听，当用户触发事件时，就会执行对应的事件处理程序。</p>\n<p>关于事件监听，<em>W3C</em> 规范中定义了 <em>3</em> 个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。</p>\n<ul>\n<li><p><strong>捕获</strong>阶段：在事件对象到达事件目标之前，事件对象必须从 <em>window</em> 经过目标的祖先节点传播到事件目标。 这个阶段被我们称之为捕获阶段。在这个阶段注册的事件监听器在事件到达其目标前必须先处理事件。</p>\n</li>\n<li><p><strong>目标</strong> 阶段：事件对象到达其事件目标。 这个阶段被我们称为目标阶段。一旦事件对象到达事件目标，该阶段的事件监听器就要对它进行处理。如果一个事件对象类型被标志为不能冒泡。那么对应的事件对象在到达此阶段时就会终止传播。</p>\n</li>\n<li><p><strong>冒泡</strong> 阶段：事件对象以一个与捕获阶段相反的方向从事件目标传播经过其祖先节点传播到 <em>window</em>。这个阶段被称之为冒泡阶段。在此阶段注册的事件监听器会对相应的冒泡事件进行处理。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"19-什么是-js-的闭包？有什么作用？\"><a href=\"#19-什么是-js-的闭包？有什么作用？\" class=\"headerlink\" title=\"19. 什么是 js 的闭包？有什么作用？\"></a>19. 什么是 <em>js</em> 的闭包？有什么作用？</h3><blockquote>\n<p>参考答案：</p>\n<p>一个函数和对其周围状态（<em>lexical environment</em>，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<em>closure</em>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 <em>JavaScript</em> 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>\n<p>闭包的用处：</p>\n<ol>\n<li>匿名自执行函数</li>\n<li>结果缓存</li>\n<li>封装</li>\n<li>实现类和继承</li>\n</ol>\n</blockquote>\n<h3 id=\"20-事件委托以及冒泡原理\"><a href=\"#20-事件委托以及冒泡原理\" class=\"headerlink\" title=\"20. 事件委托以及冒泡原理\"></a>20. 事件委托以及冒泡原理</h3><blockquote>\n<p>参考答案：</p>\n<p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p>\n<p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p>\n<p>对事件处理程序过多问题的解决方案就是事件委托。</p>\n<p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>\n<p>事件冒泡（<em>event bubbling</em>），是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。.ll</p>\n</blockquote>\n<h3 id=\"21-let-const-var-的区别？什么是块级作用域？如何用？\"><a href=\"#21-let-const-var-的区别？什么是块级作用域？如何用？\" class=\"headerlink\" title=\"21. let const var 的区别？什么是块级作用域？如何用？\"></a>21. <em>let const var</em> 的区别？什么是块级作用域？如何用？</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</li>\n<li><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</li>\n<li><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</li>\n</ol>\n<p>最初在 <em>JS</em> 中作用域有：全局作用域、函数作用域。没有块作用域的概念。</p>\n<p><em>ES6</em> 中新增了块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p>\n<p>在以前没有块作用域的时候，在 if 或者 for 循环中声明的变量会泄露成全局变量，其次就是 { } 中的内层变量可能会覆盖外层变量。块级作用域的出现解决了这些问题。</p>\n</blockquote>\n<h3 id=\"22-ES5-的方法实现块级作用域（立即执行函数）-ES6-呢？\"><a href=\"#22-ES5-的方法实现块级作用域（立即执行函数）-ES6-呢？\" class=\"headerlink\" title=\"22. ES5 的方法实现块级作用域（立即执行函数） ES6 呢？\"></a>22. <em>ES5</em> 的方法实现块级作用域（立即执行函数） <em>ES6</em> 呢？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>ES6</em> 原生支持块级作用域。块作用域由 { } 包括，<em>if</em> 语句和 <em>for</em> 语句里面的 { } 也属于块作用域。</p>\n<p>使用 <em>let</em> 声明的变量或者使用 <em>const</em> 声明的常量，只能在块作用域里访问，不能跨块访问。</p>\n</blockquote>\n<h3 id=\"23-ES6-箭头函数的特性\"><a href=\"#23-ES6-箭头函数的特性\" class=\"headerlink\" title=\"23. ES6 箭头函数的特性\"></a>23. <em>ES6</em> 箭头函数的特性</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li>更简洁的语法，例如<ul>\n<li>只有一个形参就不需要用括号括起来</li>\n<li>如果函数体只有一行，就不需要放到一个块中</li>\n<li>如果 <em>return</em> 语句是函数体内唯一的语句，就不需要 <em>return</em> 关键字</li>\n</ul>\n</li>\n<li>箭头函数没有自己的 <em>this</em>，<em>arguments</em>，<em>super</em></li>\n<li>箭头函数 <em>this</em> 只会从自己的作用域链的上一层继承 <em>this</em>。</li>\n</ol>\n</blockquote>\n<h3 id=\"24-箭头函数与普通函数的区别-？\"><a href=\"#24-箭头函数与普通函数的区别-？\" class=\"headerlink\" title=\"24. 箭头函数与普通函数的区别 ？\"></a>24. 箭头函数与普通函数的区别 ？</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li><p>外形不同。箭头函数使用箭头定义，普通函数中没有</p>\n</li>\n<li><p>普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。</p>\n</li>\n<li><p>**箭头函数不能用于构造函数，不能使用 <em>new</em>，**普通函数可以用于构造函数，以此创建对象实例。</p>\n</li>\n<li><p><strong>箭头函数中 <em>this</em> 的指向不同，</strong>在普通函数中，<em>this</em> 总是指向调用它的对象，如果用作构造函数，<em>this</em> 指向创建的对象实例。<br>箭头函数本身不创建 <em>this</em>，也可以说箭头函数本身没有 <em>this</em>，但是它在声明时可以捕获其所在上下文的 <em>this</em> 供自己使用。</p>\n</li>\n<li><p>每一个普通函数调用后都具有一个 <em>arguments</em> 对象，用来存储实际传递的参数。</p>\n<p>但是箭头函数并没有此对象。<strong>取而代之用rest参数来解决</strong>。</p>\n</li>\n<li><p>箭头函数不能用于 <em>Generator</em> 函数，不能使用 <em>yeild</em> 关键字。</p>\n</li>\n<li><p>箭头函数不具有 <em>prototype</em> 原型对象。而普通函数具有 <em>prototype</em> 原型对象。</p>\n</li>\n<li><p>箭头函数不具有 <em>super</em>。</p>\n</li>\n<li><p>箭头函数不具有 <em>new.target</em>。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"25-JS-的基本数据类型有哪些？基本数据类型和引用数据类型的区别\"><a href=\"#25-JS-的基本数据类型有哪些？基本数据类型和引用数据类型的区别\" class=\"headerlink\" title=\"25. JS 的基本数据类型有哪些？基本数据类型和引用数据类型的区别\"></a>25. <em>JS</em> 的基本数据类型有哪些？基本数据类型和引用数据类型的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p>\n<p>基本数据类型，一共有 <em>8</em> 种：</p>\n<pre><code class=\"text\">string，symbol，number，boolean，undefined，null，bigInt\n</code></pre>\n<p>其中 <em>symbol</em>、<em>bigInt</em> 类型是在 <em>ES6</em> 及后续版本里面新添加的基本数据类型。</p>\n<p>引用数据类型，就只有 <em>1</em> 种：</p>\n<pre><code class=\"javascript\">object\n</code></pre>\n<p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p>\n<p>两者的区别在于：</p>\n<p><strong>原始值是表示 <em>JavaScript</em> 中可用的数据或信息的最底层形式或最简单形式。</strong>简单类型的值被称为原始值，是因为它们是<strong>不可细化</strong>的。</p>\n<p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p>\n<p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p>\n<p>最后总结一下两者的区别：</p>\n<ol>\n<li><p>访问方式</p>\n<ul>\n<li>原始值：访问到的是值</li>\n<li>引用值：访问到的是引用地址</li>\n</ul>\n</li>\n<li><p>比较方式</p>\n<ul>\n<li>原始值：比较的是值</li>\n<li>引用值：比较的是地址</li>\n</ul>\n</li>\n<li><p>动态属性</p>\n<ul>\n<li>原始值：无法添加动态属性</li>\n<li>引用值：可以添加动态属性</li>\n</ul>\n</li>\n<li><p>变量赋值</p>\n<ul>\n<li>原始值：赋值的是值</li>\n<li>引用值：赋值的是地址</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"26-NaN-是什么的缩写\"><a href=\"#26-NaN-是什么的缩写\" class=\"headerlink\" title=\"26. NaN 是什么的缩写\"></a>26. <em>NaN</em> 是什么的缩写</h3><blockquote>\n<p>参考答案：</p>\n<p><em>NaN</em> 的全称为 <em>Not a Number</em>，表示非数，或者说不是一个数。虽然 NaN 表示非数，但是它却属于 <em>number</em> 类型。</p>\n<p><em>NaN</em> 有两个特点：</p>\n<ol>\n<li>任何涉及 <em>NaN</em> 的操作都会返回 <em>NaN</em></li>\n<li><em>NaN</em> 和任何值都不相等，包括它自己本身</li>\n</ol>\n</blockquote>\n<h3 id=\"27-JS-的作用域类型\"><a href=\"#27-JS-的作用域类型\" class=\"headerlink\" title=\"27. JS 的作用域类型\"></a>27. <em>JS</em> 的作用域类型</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>JavaScript</em> 里面，作用域一共有 4 种：全局作用域，局部作用域、函数作用域以及 <em>eval</em> 作用域。</p>\n<p><strong>全局作用域：</strong>这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。</p>\n<p><strong>局部作用域：</strong>当使用 <em>let</em> 或者 <em>const</em> 声明变量时，这些变量在一对花括号中存在局部作用域，只能够在花括号内部进行访问使用。</p>\n<p><strong>函数作用域：</strong>当进入到一个函数的时候，就会产生一个函数作用域。函数作用域里面所声明的变量只在函数中提供访问使用。</p>\n<p><strong><em>eval</em> 作用域：</strong>当调用 <em>eval( )</em> 函数的时候，就会产生一个 <em>eval</em> 作用域。</p>\n</blockquote>\n<h3 id=\"28-undefined-x3D-x3D-null-返回的结果是什么？undefined-与-null-的区别在哪？\"><a href=\"#28-undefined-x3D-x3D-null-返回的结果是什么？undefined-与-null-的区别在哪？\" class=\"headerlink\" title=\"28. undefined&#x3D;&#x3D;null 返回的结果是什么？undefined 与 null 的区别在哪？\"></a>28. <em>undefined&#x3D;&#x3D;null</em> 返回的结果是什么？<em>undefined</em> 与 <em>null</em> 的区别在哪？</h3><blockquote>\n<p>参考答案：</p>\n<p>返回 <em>true</em>。</p>\n<p>这两个值都表示“无”的意思。</p>\n<p>通常情况下， 当我们试图访问某个不存在的或者没有赋值的变量时，就会得到一个 <em>undefined</em> 值。<em>Javascript</em> 会自动将声明是没有进行初始化的变量设为 <em>undifined</em>。</p>\n<p>而 <em>null</em> 值表示空，<em>null</em> 不能通过 <em>Javascript</em> 来自动赋值，也就是说必须要我们自己手动来给某个变量赋值为 <em>null</em>。</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>那么为什么 <em>JavaScript</em> 要设置两个表示”无”的值呢？这其实是历史原因。</p>\n<p><em>1995</em> 年 <em>JavaScript</em> 诞生时，最初像 <em>Java</em> 一样，只设置了 <em>null</em> 作为表示”无”的值。根据 <em>C</em> 语言的传统，<em>null</em> 被设计成可以自动转为<em>0</em>。</p>\n<p>但是，<em>JavaScript</em> 的设计者，觉得这样做还不够，主要有以下两个原因。</p>\n<ol>\n<li><em>null</em> 像在 <em>Java</em> 里一样，被当成一个对象。但是，<em>JavaScript</em> 的数据类型分成原始类型（<em>primitive</em>）和合成类型（<em>complex</em>）两大类，作者觉得表示”无”的值最好不是对象。</li>\n<li><em>JavaScript</em> 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。作者觉得，如果 <em>null</em> 自动转为 <em>0</em>，很不容易发现错误。</li>\n</ol>\n<p>因此，作者又设计了一个 <em>undefined</em>。</p>\n<p><strong>这里注意：先有 <em>null</em> 后有 <em>undefined</em> 出来，<em>undefined</em> 是为了填补之前的坑。</strong></p>\n<p><em>JavaScript</em> 的最初版本是这样区分的：</p>\n<p><em>null</em> 是一个表示”无”的对象（空对象指针），转为数值时为 <em>0</em>；</p>\n<p>典型用法是：</p>\n<ul>\n<li><p>作为函数的参数，表示该函数的参数不是对象。</p>\n</li>\n<li><p>作为对象原型链的终点。</p>\n</li>\n</ul>\n<p><em>undefined</em> 是一个表示”无”的原始值，转为数值时为 <em>NaN</em>。</p>\n<p>典型用法是：</p>\n<ul>\n<li>变量被声明了，但没有赋值时，就等于 <em>undefined</em>。 </li>\n<li>调用函数时，应该提供的参数没有提供，该参数等于 <em>undefined</em>。</li>\n<li>对象没有赋值的属性，该属性的值为 <em>undefined</em>。</li>\n<li>函数没有返回值时，默认返回 <em>undefined</em>。</li>\n</ul>\n</blockquote>\n<h3 id=\"29-写一个函数判断变量类型\"><a href=\"#29-写一个函数判断变量类型\" class=\"headerlink\" title=\"29. 写一个函数判断变量类型\"></a>29. 写一个函数判断变量类型</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function getType(data)&#123;\n    let type = typeof data;\n    if(type !== &quot;object&quot;)&#123;\n        return type\n    &#125;\n    return Object.prototype.toString.call(data).replace(/^\\[object (\\S+)\\]$/,&#39;$1&#39;)\n&#125;\nfunction Person()&#123;&#125;\nconsole.log(getType(1)); // number\nconsole.log(getType(true)); // boolean\nconsole.log(getType([1,2,3])); // Array\nconsole.log(getType(/abc/)); // RegExp\nconsole.log(getType(new Date)); // Date\nconsole.log(getType(new Person)); // Object\nconsole.log(getType(&#123;&#125;)); // Object\n</code></pre>\n</blockquote>\n<h3 id=\"30-js-的异步处理函数\"><a href=\"#30-js-的异步处理函数\" class=\"headerlink\" title=\"30. js 的异步处理函数\"></a>30. <em>js</em> 的异步处理函数</h3><blockquote>\n<p>参考答案：</p>\n<p>在最早期的时候，<em>JavaScript</em> 中要实现异步操作，使用的就是 <em>Callback</em> 回调函数。</p>\n<p>但是回调函数会产生回调地狱（<em>Callback Hell</em>）</p>\n<p>之后 ES6 推出了 <em>Promise</em> 解决方案来解决回调地狱的问题。不过，虽然 <em>Promise</em> 作为 <em>ES6</em> 中提供的一种新的异步编程解决方案，但是它也有问题。比如，代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大。</p>\n<p>之后，就出现了基于 <em>Generator</em> 的异步解决方案。不过，这种方式需要编写外部的执行器，而执行器的代码写起来一点也不简单。当然也可以使用一些插件，比如 <em>co</em> 模块来简化执行器的编写。</p>\n<p><em>ES7</em> 提出的 <em>async</em> 函数，终于让 <em>JavaScript</em> 对于异步操作有了终极解决方案。</p>\n<p>实际上，<em>async</em> 只是生成器的一种语法糖而已，简化了外部执行器的代码，同时利用 <em>await</em> 替代 <em>yield</em>，<em>async</em> 替代生成器的<code>*</code>号。</p>\n</blockquote>\n<h3 id=\"31-defer-与-async-的区别\"><a href=\"#31-defer-与-async-的区别\" class=\"headerlink\" title=\"31. defer 与 async 的区别\"></a>31. <em>defer</em> 与 <em>async</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>按照惯例，所有 <em>script</em> 元素都应该放在页面的 <em>head</em> 元素中。这种做法的目的就是把<strong>所有外部文件（<em>CSS</em> 文件和 <em>JavaScript</em> 文件）的引用都放在相同的地方</strong>。可是，在文档的 <em>head</em> 元素中包含所有 <em>JavaScript</em> 文件，意味着必须等到全部 <em>JavaScript</em> 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 <em>body</em> 标签时才开始呈现内容）。</p>\n<p>对于那些需要很多 <em>JavaScript</em> 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。为了避免这个问题，现在 <strong><em>Web</em> 应用程序一般都全部 <em>JavaScript</em> 引用放在 <em>body</em> 元素中页面的内容后面</strong>。这样一来，在解析包含的 <em>JavaScript</em> 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p>\n<p>有了 <em>defer</em> 和 <em>async</em> 后，这种局面得到了改善。</p>\n<p><strong><em>defer</em> （延迟脚本）</strong></p>\n<p>延迟脚本：<em>defer</em> 属性只适用于外部脚本文件。</p>\n<p>如果给 <em>script</em> 标签定义了<em>defer</em> 属性，这个属性的作用是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，如果 <em>script</em> 元素中设置了 <em>defer</em> 属性，相当于告诉浏览器立即下载，但延迟执行。</p>\n<p><strong><em>async</em>（异步脚本）</strong></p>\n<p>异步脚本：<em>async</em> 属性也只适用于外部脚本文件，并告诉浏览器立即下载文件。</p>\n<p><strong>但与 <em>defer</em> 不同的是：标记为 <em>async</em> 的脚本并不保证按照指定它们的先后顺序执行。</strong></p>\n<p>所以总结起来，两者之间最大的差异就是在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的。</p>\n<p><em>defer</em> 是立即下载但延迟执行，加载后续文档元素的过程将和脚本的加载并行进行（异步），但是脚本的执行要在所有元素解析完成之后，<em>DOMContentLoaded</em> 事件触发之前完成。<em>async</em> 是立即下载并执行，加载和渲染后续文档元素的过程将和 <em>js</em> 脚本的加载与执行并行进行（异步）。</p>\n</blockquote>\n<h3 id=\"32-浏览器事件循环和任务队列\"><a href=\"#32-浏览器事件循环和任务队列\" class=\"headerlink\" title=\"32. 浏览器事件循环和任务队列\"></a>32. 浏览器事件循环和任务队列</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JavaScript</em> 的异步机制由事件循环和任务队列构成。</p>\n<p><em>JavaScript</em> 本身是单线程语言，所谓异步依赖于浏览器或者操作系统等完成。<em>JavaScript</em> 主线程拥有一个执行栈以及一个任务队列，主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。</p>\n<p>遇到异步操作（例如：<em>setTimeout、Ajax</em>）时，异步操作会由浏览器(<em>OS</em>)执行，浏览器会在这些任务完成后，将事先定义的回调函数推入主线程的任务队列(<em>task queue</em>)中,当主线程的执行栈清空之后会读取任务队列中的回调函数,当任务队列被读取完毕之后,主线程接着执行,从而进入一个无限的循环，这就是事件循环。</p>\n</blockquote>\n<h3 id=\"33-原型与原型链-（美团-19年）\"><a href=\"#33-原型与原型链-（美团-19年）\" class=\"headerlink\" title=\"33. 原型与原型链 （美团 19年）\"></a>33. 原型与原型链 （美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li>每个对象都有一个 <code>__proto__ </code> 属性，该属性指向自己的原型对象</li>\n<li>每个构造函数都有一个 <code>prototype </code> 属性，该属性指向实例对象的原型对象</li>\n<li>原型对象里的 <code>constructor</code> 指向构造函数本身</li>\n</ul>\n<p>如下图：</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-12-081402.png\" alt=\"image-20210812161401493\" style=\"zoom: 45%;\" />\n\n<p>每个对象都有自己的原型对象，而原型对象本身，也有自己的原型对象，从而形成了一条原型链条。</p>\n<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>\n</blockquote>\n<h3 id=\"34-作用域与作用域链-（美团-19年）\"><a href=\"#34-作用域与作用域链-（美团-19年）\" class=\"headerlink\" title=\"34. 作用域与作用域链 （美团 19年）\"></a>34. 作用域与作用域链 （美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。<em>ES6</em> 之前 <em>JavaScript</em> 没有块级作用域，只有全局作用域和函数作用域。<em>ES6</em> 的到来，为我们提供了块级作用域。</p>\n<p>作用域链指的是作用域与作用域之间形成的链条。当我们查找一个当前作用域没有定义的变量（自由变量）的时候，就会向上一级作用域寻找，如果上一级也没有，就再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p>\n</blockquote>\n<h3 id=\"35-闭包及应用场景以及闭包缺点-（美团-19年）\"><a href=\"#35-闭包及应用场景以及闭包缺点-（美团-19年）\" class=\"headerlink\" title=\"35. 闭包及应用场景以及闭包缺点 （美团 19年）\"></a>35. 闭包及应用场景以及闭包缺点 （美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<p>闭包的应用场景：</p>\n<ol>\n<li>匿名自执行函数</li>\n<li>结果缓存</li>\n<li>封装</li>\n<li>实现类和继承</li>\n</ol>\n<p>闭包的缺点：</p>\n<p>因为闭包的作用域链会引用包含它的函数的活动对象，导致这些活动对象不会被销毁，因此会占用更多的内存。</p>\n</blockquote>\n<h3 id=\"36-继承方式-（美团-19年）\"><a href=\"#36-继承方式-（美团-19年）\" class=\"headerlink\" title=\"36. 继承方式 （美团 19年）\"></a>36. 继承方式 （美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<p>参阅前面第 <em>9</em> 题以及第 <em>18</em> 题答案。</p>\n</blockquote>\n<h3 id=\"37-原始值与引用值-（美团-19年）\"><a href=\"#37-原始值与引用值-（美团-19年）\" class=\"headerlink\" title=\"37. 原始值与引用值 （美团 19年）\"></a>37. 原始值与引用值 （美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>原始值是表示 <em>JavaScript</em> 中可用的数据或信息的最底层形式或最简单形式。</strong>简单类型的值被称为原始值，是因为它们是<strong>不可细化</strong>的。</p>\n<p>也就是说，数字是数字，字符是字符，布尔值是 <em>true</em> 或 <em>false</em>，<em>null</em> 和 <em>undefined</em> 就是 <em>null</em> 和 <em>undefined</em>。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以<strong>原始值的数据是存储于内存中的栈区里面的。</strong></p>\n<p>在 <em>JavaScript</em> 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。<strong>引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以引用值的数据都是存储于堆区里面。</strong></p>\n<p>最后总结一下两者的区别：</p>\n<ol>\n<li><p>访问方式</p>\n<ul>\n<li>原始值：访问到的是值</li>\n<li>引用值：访问到的是引用地址</li>\n</ul>\n</li>\n<li><p>比较方式</p>\n<ul>\n<li>原始值：比较的是值</li>\n<li>引用值：比较的是地址</li>\n</ul>\n</li>\n<li><p>动态属性</p>\n<ul>\n<li>原始值：无法添加动态属性</li>\n<li>引用值：可以添加动态属性</li>\n</ul>\n</li>\n<li><p>变量赋值</p>\n<ul>\n<li>原始值：赋值的是值</li>\n<li>引用值：赋值的是地址</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"38-描述下列代码的执行结果\"><a href=\"#38-描述下列代码的执行结果\" class=\"headerlink\" title=\"38. 描述下列代码的执行结果\"></a>38. 描述下列代码的执行结果</h3><pre><code class=\"javascript\">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;\n    console.log(3);\n    let p = new Promise((resolve, reject) =&gt; &#123;\n        console.log(7);\n        setTimeout(() =&gt; &#123;\n            console.log(1);\n        &#125;, 0);\n        setTimeout(() =&gt; &#123;\n            console.log(2);\n            resolve(3);\n        &#125;, 0)\n        resolve(4);\n    &#125;);\n    resolve(2);\n    p.then((arg) =&gt; &#123;\n        console.log(arg, 5); // 1 bb\n    &#125;);\n    setTimeout(() =&gt; &#123;\n        console.log(6);\n    &#125;, 0);\n&#125;))\nfirst().then((arg) =&gt; &#123;\n    console.log(arg, 7); // 2 aa\n    setTimeout(() =&gt; &#123;\n        console.log(8);\n    &#125;, 0);\n&#125;);\nsetTimeout(() =&gt; &#123;\n    console.log(9);\n&#125;, 0);\nconsole.log(10);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>3<br>7<br>10<br>4 5<br>2 7<br>1<br>2<br>6<br>9<br>8</p>\n</blockquote>\n<h3 id=\"39-如何判断数组或对象（美团-19年）\"><a href=\"#39-如何判断数组或对象（美团-19年）\" class=\"headerlink\" title=\"39. 如何判断数组或对象（美团 19年）\"></a>39. 如何判断数组或对象（美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li>通过 <em>instanceof</em> 进行判断</li>\n</ol>\n<pre><code class=\"javascript\">var arr = [1,2,3,1];\nconsole.log(arr instanceof Array) // true\n</code></pre>\n<ol start=\"2\">\n<li>通过对象的 <em>constructor</em> 属性</li>\n</ol>\n<pre><code class=\"javascript\">var arr = [1,2,3,1];\nconsole.log(arr.constructor === Array) // true\n</code></pre>\n<ol start=\"3\">\n<li><em>Object.prototype.toString.call(arr)</em></li>\n</ol>\n<pre><code class=\"javascript\">console.log(Object.prototype.toString.call(&#123;name: &quot;jerry&quot;&#125;));//[object Object]\nconsole.log(Object.prototype.toString.call([]));//[object Array]\n</code></pre>\n<ol start=\"4\">\n<li>可以通过 <em>ES6</em> 新提供的方法 <em>Array.isArray( )</em></li>\n</ol>\n<pre><code class=\"javascript\">Array.isArray([]) //true\n</code></pre>\n</blockquote>\n<h3 id=\"40-对象深拷贝与浅拷贝，单独问了-Object-assign（美团-19年）\"><a href=\"#40-对象深拷贝与浅拷贝，单独问了-Object-assign（美团-19年）\" class=\"headerlink\" title=\"40. 对象深拷贝与浅拷贝，单独问了 Object.assign（美团 19年）\"></a>40. 对象深拷贝与浅拷贝，单独问了 <em>Object.assign</em>（美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p>\n<p>  浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>\n</li>\n<li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p>\n</li>\n</ul>\n<p><em>Object.assign</em> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <em>Object.assign</em> 方法进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>\n</blockquote>\n<h3 id=\"42-说说-instanceof-原理，并回答下面的题目（美团-19年）\"><a href=\"#42-说说-instanceof-原理，并回答下面的题目（美团-19年）\" class=\"headerlink\" title=\"42. 说说 instanceof 原理，并回答下面的题目（美团 19年）\"></a>42. 说说 <em>instanceof</em> 原理，并回答下面的题目（美团 19年）</h3><pre><code class=\"javascript\">function A()&#123;&#125;\nfunction B()&#123;&#125;\nA.prototype = new B(); \nlet a = new A(); \nconsole.log(a instanceof B) // true of false ?\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>答案为 <em>true</em>。</p>\n<p><em>instanceof</em> 原理：</p>\n<p><em>instanceof</em>  用于检测一个对象是否为某个构造函数的实例。</p>\n<p>例如：<em>A instanceof B</em><br><em>instanceof</em> 用于检测对象 <em>A</em> 是不是 <em>B</em> 的实例，而检测是基于原型链进行查找的，也就是说 <em>B</em> 的 <em>prototype</em> 有没有在对象 <em>A</em> 的_<em><em>proto</em></em>_ 原型链上，如果有就返回 <em>true</em>，否则返回 <em>false</em></p>\n</blockquote>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"43-内存泄漏（美团-19-年）\"><a href=\"#43-内存泄漏（美团-19-年）\" class=\"headerlink\" title=\"43. 内存泄漏（美团 19 年）\"></a>43. 内存泄漏（美团 19 年）</h3><blockquote>\n<p>参考答案：</p>\n<p>内存泄漏（<em>Memory Leak</em>）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>\n<p><em>Javascript</em> 是一种高级语言，它不像 <em>C</em> 语言那样要手动申请内存，然后手动释放，<em>Javascript</em> 在声明变量的时候自动会分配内存，普通的类型比如 <em>number</em>，一般放在栈内存里，对象放在堆内存里，声明一个变量，就分配一些内存，然后定时进行垃圾回收。垃圾回收的任务由 <em>JavaScript</em> 引擎中的垃圾回收器来完成，它监视所有对象，并删除那些不可访问的对象。</p>\n<p>基本的垃圾回收算法称为<strong>“标记-清除”</strong>，定期执行以下“垃圾回收”步骤:</p>\n<ul>\n<li>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</li>\n<li>然后它访问并“标记”所有来自它们的引用。</li>\n<li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li>\n<li>以此类推，直到有未访问的引用(可以从根访问)为止。</li>\n<li>除标记的对象外，所有对象都被删除。</li>\n</ul>\n</blockquote>\n<h3 id=\"44-ES6-新增哪些东西？让你自己说（美团-19-年）\"><a href=\"#44-ES6-新增哪些东西？让你自己说（美团-19-年）\" class=\"headerlink\" title=\"44. ES6 新增哪些东西？让你自己说（美团 19 年）\"></a>44. <em>ES6</em> 新增哪些东西？让你自己说（美团 19 年）</h3><blockquote>\n<p>参考答案：</p>\n<p><em>ES6</em> 新增内容众多，这里列举出一些关键的以及平时常用的新增内容：</p>\n<ol>\n<li>箭头函数</li>\n<li>字符串模板</li>\n<li>支持模块化（<em>import、export</em>）</li>\n<li>类（<em>class、constructor、extends</em>）</li>\n<li><em>let、const</em> 关键字</li>\n<li>新增一些数组、字符串等内置构造函数方法，例如 <em>Array.from</em>、<em>Array.of</em> 、<em>Math.sign</em>、<em>Math.trunc</em> 等</li>\n<li>新增一些语法，例如扩展操作符、解构、函数默认参数等</li>\n<li>新增一种基本数据类型 <em>Symbol</em></li>\n<li>新增元编程相关，例如 <em>proxy</em>、<em>Reflect</em></li>\n<li><em>Set</em> 和 <em>Map</em> 数据结构</li>\n<li><em>Promise</em></li>\n<li><em>Generator</em> 生成器</li>\n</ol>\n</blockquote>\n<h3 id=\"45-weakmap、weakset（美团-19-年）\"><a href=\"#45-weakmap、weakset（美团-19-年）\" class=\"headerlink\" title=\"45. weakmap、weakset（美团 19 年）\"></a>45. <em>weakmap、weakset</em>（美团 <em>19</em> 年）</h3><blockquote>\n<p>参考答案：</p>\n<p><em>WeakSet</em> 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在 <em>WeakSet</em> 的集合中是唯一的</p>\n<p>它和 <em>Set</em> 对象的区别有两点:</p>\n<ul>\n<li>与 <em>Set</em> 相比，<em>WeakSet</em> 只能是<strong>对象的集合</strong>，而不能是任何类型的任意值。</li>\n<li><em>WeakSet</em> 持弱引用：集合中对象的引用为弱引用。 如果没有其他的对 <em>WeakSet</em> 中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <em>WeakSet</em> 中没有存储当前对象的列表。 正因为这样，<em>WeakSet</em> 是不可枚举的。</li>\n</ul>\n<p><em>WeakMap</em> 对象也是键值对的集合。它的<strong>键必须是对象类型</strong>，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被 <em>GC</em> 回收掉。<em>WeakMap</em> 提供的接口与 <em>Map</em> 相同。</p>\n<p>与 <em>Map</em> 对象不同的是，<em>WeakMap</em> 的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。</p>\n</blockquote>\n<h3 id=\"46-为什么-ES6-会新增-Promise（美团-19年）\"><a href=\"#46-为什么-ES6-会新增-Promise（美团-19年）\" class=\"headerlink\" title=\"46. 为什么 ES6 会新增 Promise（美团 19年）\"></a>46. 为什么 <em>ES6</em> 会新增 <em>Promise</em>（美团 19年）</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>ES6</em> 以前，解决异步的方法是回调函数。但是回调函数有一个最大的问题就是回调地狱（<em>callback hell</em>），当我们的回调函数嵌套的层数过多时，就会导致代码横向发展。</p>\n<p><em>Promise</em> 的出现就是为了解决回调地狱的问题。</p>\n</blockquote>\n<h3 id=\"47-ES5-实现继承？（虾皮）\"><a href=\"#47-ES5-实现继承？（虾皮）\" class=\"headerlink\" title=\"47. ES5 实现继承？（虾皮）\"></a>47. <em>ES5</em> 实现继承？（虾皮）</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li>借用构造函数实现继承</li>\n</ol>\n<pre><code class=\"javascript\">function Parent1()&#123;\n    this.name = &quot;parent1&quot;\n&#125;\nfunction Child1()&#123;\n    Parent1.call(this);\n    this.type = &quot;child1&quot;;\n&#125;\n</code></pre>\n<p>缺点：<em>Child1</em> 无法继承 <em>Parent1</em> 的原型对象，并没有真正的实现继承 (部分继承)。</p>\n<ol start=\"2\">\n<li>借用原型链实现继承</li>\n</ol>\n<pre><code class=\"javascript\">function Parent2()&#123;\n    this.name = &quot;parent2&quot;;\n    this.play = [1,2,3];\n&#125;\nfunction Child2()&#123;\n    this.type = &quot;child2&quot;;\n&#125;\nChild2.prototype = new Parent2();\n</code></pre>\n<p>缺点：原型对象的属性是共享的。</p>\n<ol start=\"3\">\n<li>组合式继承</li>\n</ol>\n<pre><code class=\"javascript\">function Parent3()&#123;\n    this.name = &quot;parent3&quot;;\n    this.play = [1,2,3];\n&#125;\nfunction Child3()&#123;\n    Parent3.call(this);\n    this.type = &quot;child3&quot;;\n&#125;\nChild3.prototype = Object.create(Parent3.prototype);\nChild3.prototype.constructor = Child3;\n</code></pre>\n</blockquote>\n<h3 id=\"48-科里化？（搜狗）\"><a href=\"#48-科里化？（搜狗）\" class=\"headerlink\" title=\"48. 科里化？（搜狗）\"></a>48. 科里化？（搜狗）</h3><blockquote>\n<p>参考答案：</p>\n<p>柯里化，英语全称 <em>Currying</em>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n<p>举个例子，就是把原本：</p>\n<p><em>function(arg1,arg2)</em> 变成 <em>function(arg1)(arg2)</em><br><em>function(arg1,arg2,arg3)</em> 变成 <em>function(arg1)(arg2)(arg3)</em><br><em>function(arg1,arg2,arg3,arg4)</em> 变成 <em>function(arg1)(arg2)(arg3)(arg4)</em></p>\n<p>总而言之，就是将：</p>\n<p><em>function(arg1,arg2,…,argn)</em> 变成 <em>function(arg1)(arg2)…(argn)</em></p>\n</blockquote>\n<h3 id=\"49-防抖和节流？（虾皮）\"><a href=\"#49-防抖和节流？（虾皮）\" class=\"headerlink\" title=\"49. 防抖和节流？（虾皮）\"></a>49. 防抖和节流？（虾皮）</h3><blockquote>\n<p>参考答案：</p>\n<p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p>\n<p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p>\n<p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次… 。节流如字面意思，会稀释函数的执行频率。</p>\n</blockquote>\n<h3 id=\"50-闭包？（好未来—探讨了-40-分钟）\"><a href=\"#50-闭包？（好未来—探讨了-40-分钟）\" class=\"headerlink\" title=\"50. 闭包？（好未来—探讨了 40 分钟）\"></a>50. 闭包？（好未来—探讨了 <em>40</em> 分钟）</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>20</em> 题以及第 <em>36</em> 题答案。</p>\n</blockquote>\n<h3 id=\"51-原型和原型链？（字节）\"><a href=\"#51-原型和原型链？（字节）\" class=\"headerlink\" title=\"51. 原型和原型链？（字节）\"></a>51. 原型和原型链？（字节）</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>34</em> 题答案。</p>\n</blockquote>\n<h3 id=\"52-排序算法—（时间复杂度、空间复杂度）\"><a href=\"#52-排序算法—（时间复杂度、空间复杂度）\" class=\"headerlink\" title=\"52. 排序算法—（时间复杂度、空间复杂度）\"></a>52. 排序算法—（时间复杂度、空间复杂度）</h3><blockquote>\n<p>参考答案：</p>\n<p>算法（<em>Algorithm</em>）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p>\n<p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p>\n<ul>\n<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>\n<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li>\n</ul>\n<p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p>\n<p>排序也称排序算法(<em>Sort Algorithm</em>)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。</p>\n<p>排序的分类分为<strong>内部排序</strong>和<strong>外部排序法</strong>。</p>\n<ul>\n<li>内部排序：指将需要处理的所有数据都加载到**内部存储器(内存)**中进行排序。</li>\n<li>外部排序：<strong>数据量过大</strong>，无法全部加载到内存中，需要借助**外部存储(文件等)**进行排序。</li>\n</ul>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-13-054747.png\" alt=\"image-20210813134746501\" style=\"zoom:50%;\" />\n</blockquote>\n<h3 id=\"53-浏览器事件循环和-node-事件循环（搜狗）\"><a href=\"#53-浏览器事件循环和-node-事件循环（搜狗）\" class=\"headerlink\" title=\"53. 浏览器事件循环和 node 事件循环（搜狗）\"></a>53. 浏览器事件循环和 <em>node</em> 事件循环（搜狗）</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li>浏览器中的 <em>Event Loop</em></li>\n</ol>\n<p>事件循环中的异步队列有两种：<em>macro</em>（宏任务）队列和 <em>micro</em>（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p>\n<ul>\n<li>常见的 <em>macro-task</em> 比如：<em>setTimeout、setInterval、 setImmediate、script</em>（整体代码）、 <em>I&#x2F;O</em> 操作、<em>UI</em> 渲染等。</li>\n<li>常见的 <em>micro-task</em> 比如: <em>process.nextTick、new Promise( ).then</em>(回调)、<em>MutationObserver</em>(<em>html5</em> 新特性) 等。</li>\n</ul>\n<p>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p>\n<ol start=\"2\">\n<li><em>Node</em> 中的事件循环</li>\n</ol>\n<p><em>Node</em> 中的 <em>Event Loop</em> 和浏览器中的是完全不相同的东西。<em>Node.js</em> 采用 <em>V8</em> 作为 <em>js</em> 的解析引擎，而 <em>I&#x2F;O</em> 处理方面使用了自己设计的 <em>libuv</em>，<em>libuv</em> 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 <em>API</em>，事件循环机制也是它里面的实现。</p>\n<p><em>Node.JS</em> 的事件循环分为 <em>6</em> 个阶段：</p>\n<ul>\n<li><em>timers</em> 阶段：这个阶段执行 <em>timer</em>（ <em>setTimeout、setInterval</em> ）的回调</li>\n<li><em>I&#x2F;O callbacks</em> 阶段：处理一些上一轮循环中的少数未执行的 <em>I&#x2F;O</em> 回调</li>\n<li><em>idle、prepare</em> 阶段：仅 <em>Node.js</em> 内部使用</li>\n<li><em>poll</em> 阶段：获取新的 <em>I&#x2F;O</em> 事件, 适当的条件下 <em>Node.js</em> 将阻塞在这里</li>\n<li><em>check</em> 阶段：执行 <em>setImmediate( )</em> 的回调</li>\n<li><em>close callbacks</em> 阶段：执行 <em>socket</em> 的 <em>close</em> 事件回调</li>\n</ul>\n<p><em>Node.js</em> 的运行机制如下:</p>\n<ul>\n<li><em>V8</em> 引擎解析 <em>JavaScript</em> 脚本。</li>\n<li>解析后的代码，调用 <em>Node API</em>。</li>\n<li><em>libuv</em> 库负责 <em>Node API</em> 的执行。它将不同的任务分配给不同的线程，形成一个 <em>Event Loop</em>（事件循环），以异步的方式将任务的执行结果返回给 <em>V8</em> 引擎。</li>\n<li><em>V8</em> 引擎再将结果返回给用户。</li>\n</ul>\n</blockquote>\n<h3 id=\"54-闭包的好处\"><a href=\"#54-闭包的好处\" class=\"headerlink\" title=\"54. 闭包的好处\"></a>54. 闭包的好处</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>20</em> 题以及第 <em>36</em> 题答案。</p>\n</blockquote>\n<h3 id=\"55-let、const、var-的区别\"><a href=\"#55-let、const、var-的区别\" class=\"headerlink\" title=\"55. let、const、var 的区别\"></a>55. <em>let、const、var</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li><em>var</em> 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，有变量提升。</li>\n<li><em>let</em> 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。</li>\n<li><em>const</em> 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明。</li>\n</ol>\n</blockquote>\n<h3 id=\"56-闭包、作用域（可以扩充到作用域链）\"><a href=\"#56-闭包、作用域（可以扩充到作用域链）\" class=\"headerlink\" title=\"56. 闭包、作用域（可以扩充到作用域链）\"></a>56. 闭包、作用域（可以扩充到作用域链）</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>什么是作业域?</strong></p>\n<p>ES5 中只存在两种作用域：全局作用域和函数作用域。在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量(变量名或者函数名)查找。</p>\n<p><strong>什么是作用域链?</strong></p>\n<p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p>\n<p><strong>闭包产生的本质</strong></p>\n<p>当前环境中存在指向父级作用域的引用</p>\n<p><strong>什么是闭包</strong></p>\n<p>闭包是一种特殊的对象，它由两部分组成：执行上下文(代号 A)，以及在该执行上下文中创建的函数 (代号 B)，当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包。</p>\n<p><strong>一般如何产生闭包</strong></p>\n<ul>\n<li>返回函数</li>\n<li>函数当做参数传递</li>\n</ul>\n<p><strong>闭包的应用场景</strong></p>\n<ul>\n<li>柯里化 bind</li>\n<li>模块</li>\n</ul>\n</blockquote>\n<h3 id=\"57-Promise\"><a href=\"#57-Promise\" class=\"headerlink\" title=\"57. Promise\"></a>57. <em>Promise</em></h3><blockquote>\n<p>参考答案：</p>\n<p><em>Promise</em> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，<em>ES6</em>将其写进了语言标准，统一了用法，并原生提供了<em>Promise</em>对象。</p>\n<p><strong>特点</strong></p>\n<ol>\n<li><p>对象的状态不受外界影响 （<em>3</em> 种状态）</p>\n<ul>\n<li><p><em>Pending</em> 状态（进行中）</p>\n</li>\n<li><p><em>Fulfilled</em> 状态（已成功）</p>\n</li>\n<li><p><em>Rejected</em> 状态（已失败）</p>\n</li>\n</ul>\n</li>\n<li><p>一旦状态改变就不会再变 （两种状态改变：成功或失败）</p>\n<ul>\n<li><em>Pending</em> -&gt; <em>Fulfilled</em></li>\n<li><em>Pending</em> -&gt; <em>Rejected</em></li>\n</ul>\n</li>\n</ol>\n<p><strong>用法</strong></p>\n<pre><code class=\"javascript\">var promise = new Promise(function(resolve, reject)&#123;\n    // ... some code\n    \n    if (/* 异步操作成功 */) &#123;\n        resolve(value);\n    &#125; else &#123;\n        reject(error);\n    &#125;\n&#125;)\n</code></pre>\n</blockquote>\n<h3 id=\"58-实现一个函数-对一个url进行请求-失败就再次请求-超过最大次数就走失败回调-任何一次成功都走成功回调\"><a href=\"#58-实现一个函数-对一个url进行请求-失败就再次请求-超过最大次数就走失败回调-任何一次成功都走成功回调\" class=\"headerlink\" title=\"58. 实现一个函数,对一个url进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调\"></a>58. 实现一个函数,对一个url进行请求,失败就再次请求,超过最大次数就走失败回调,任何一次成功都走成功回调</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">/**\n    @params url: 请求接口地址;\n    @params body: 设置的请求体;\n    @params succ: 请求成功后的回调\n    @params error: 请求失败后的回调\n    @params maxCount: 设置请求的数量\n*/\nfunction request(url, body, succ, error, maxCount = 5) &#123;\n    return fetch(url, body)\n        .then(res =&gt; succ(res))\n        .catch(err =&gt; &#123;\n            if (maxCount &lt;= 0) return error(&#39;请求超时&#39;);\n            return request(url, body, succ, error, --maxCount);\n        &#125;);\n&#125;\n\n// 调用请求函数\nrequest(&#39;https://java.some.com/pc/reqCount&#39;, &#123; method: &#39;GET&#39;, headers: &#123;&#125; &#125;,\n    (res) =&gt; &#123;\n        console.log(res.data);\n    &#125;,\n    (err) =&gt; &#123;\n        console.log(err);\n    &#125;)\n</code></pre>\n</blockquote>\n<h3 id=\"59-冒泡排序\"><a href=\"#59-冒泡排序\" class=\"headerlink\" title=\"59. 冒泡排序\"></a>59. 冒泡排序</h3><blockquote>\n<p>参考答案：</p>\n<p>冒泡排序的核心思想是：</p>\n<ol>\n<li>比较相邻的两个元素，如果前一个比后一个大或者小（取决于排序的顺序是小到大还是大到小），则交换位置。</li>\n<li>比较完第一轮的时候，最后一个元素是最大或最小的元素。</li>\n<li>这时候最后一个元素已经是最大或最小的了，所以下一次冒泡的时候最后一个元素不需要参与比较。</li>\n</ol>\n<p>示例代码：</p>\n<pre><code class=\"javascript\">function bSort(arr) &#123;\n    var len = arr.length;\n    // 外层 for 循环控制冒泡的次数\n    for (var i = 0; i &lt; len - 1; i++) &#123;\n        for (var j = 0; j &lt; len - 1 - i; j++) &#123;\n            // 内层 for 循环控制每一次冒泡需要比较的次数\n            // 因为之后每一次冒泡的两两比较次数会越来越少，所以 -i\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            &#125;\n        &#125;\n    &#125;\n    return arr;\n&#125;\n\n//举个数组\nmyArr = [20, -1, 27, -7, 35];\n//使用函数\nconsole.log(bSort(myArr)); // [ -7, -1, 20, 27, 35 ]\n</code></pre>\n</blockquote>\n<h3 id=\"60-数组降维\"><a href=\"#60-数组降维\" class=\"headerlink\" title=\"60. 数组降维\"></a>60. 数组降维</h3><blockquote>\n<p>参考答案：</p>\n<p>数组降维就是将一个嵌套多层的数组进行降维操作，也就是对数组进行扁平化。在 <em>ES5</em> 时代我们需要自己手写方法或者借助函数库来完成，但是现在可以使用 <em>ES6</em> 新提供的数组方法 <em>flat</em> 来完成数组降维操作。</p>\n</blockquote>\n<blockquote>\n<p>解析：使用 <em>flat</em> 方法会接收一个参数，这个参数是数值类型，是要处理扁平化数组的深度，生成后的新数组是独立存在的，不会对原数组产生影响。</p>\n<p><em>flat</em> 方法的语法如下：</p>\n<pre><code class=\"javascript\">var newArray = arr.flat([depth])\n</code></pre>\n<p>其中 <em>depth</em> 指定要提取嵌套数组结构的深度，默认值为 <em>1</em>。</p>\n<p>示例如下：</p>\n<pre><code class=\"javascript\">var arr = [1, 2, [3, 4, [5, 6]]];\nconsole.log(arr.flat());      // [1, 2, 3, 4, [5, 6]]\nconsole.log(arr.flat(2));     // [1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>上面的代码定义了一个层嵌套的数组，默认情况下只会拍平一层数组，也就是把原来的三维数组降低到了二维数组。在传入的参数为 <em>2</em> 时，则会降低两维，成为一个一维数组。</p>\n<p>使用 <em>Infinity</em>，可展开任意深度的嵌套数组，示例如下：</p>\n<pre><code class=\"javascript\">var arr = [1, 2, [3, 4, [5, 6, [7, 8]]]];\nconsole.log(arr.flat(Infinity));  // [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre>\n<p>在数组中有空项的时候，使用 <em>flat</em> 方法会将中的空项进行移除。</p>\n<pre><code class=\"javascript\">var arr = [1, 2, , 4, 5];\nconsole.log(arr.flat()); // [1, 2, 4, 5]\n</code></pre>\n<p>上面的代码中，数组中第三项是空值，在使用 <em>flat</em> 后会对空项进行移除。</p>\n</blockquote>\n<h3 id=\"61-call-apply-bind\"><a href=\"#61-call-apply-bind\" class=\"headerlink\" title=\"61. call apply bind\"></a>61. <em>call apply bind</em></h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>11</em> 题答案。</p>\n</blockquote>\n<h3 id=\"62-promise-代码题\"><a href=\"#62-promise-代码题\" class=\"headerlink\" title=\"62. promise 代码题\"></a>62. promise 代码题</h3><pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; &#123;\n    reject(1);\n    console.log(2);\n    resolve(3);\n    console.log(4);\n&#125;).then((res) =&gt; &#123; console.log(res) &#125;)\n    .catch(res =&gt; &#123; console.log(&#39;reject1&#39;) &#125;)\ntry &#123;\n    new Promise((resolve, reject) =&gt; &#123;\n        throw &#39;error&#39;\n    &#125;).then((res) =&gt; &#123; console.log(res) &#125;)\n        .catch(res =&gt; &#123; console.log(&#39;reject2&#39;) &#125;)\n&#125; catch (err) &#123;\n    console.log(err)\n&#125;\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>2<br>4<br>reject1<br>reject2</p>\n<p>直播课或者录播课进行解析。</p>\n</blockquote>\n<h3 id=\"63-proxy-是实现代理，可以改变-js-底层的实现方式-然后说了一下和-Object-defineProperty-的区别\"><a href=\"#63-proxy-是实现代理，可以改变-js-底层的实现方式-然后说了一下和-Object-defineProperty-的区别\" class=\"headerlink\" title=\"63. proxy 是实现代理，可以改变 js 底层的实现方式, 然后说了一下和 Object.defineProperty 的区别\"></a>63. <em>proxy</em> 是实现代理，可以改变 <em>js</em> 底层的实现方式, 然后说了一下和 <em>Object.defineProperty</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>两者的区别总结如下：</p>\n<ul>\n<li>代理原理：Object.defineProperty的原理是通过将数据属性转变为存取器属性的方式实现的属性读写代理。而Proxy则是因为这个内置的Proxy对象内部有一套监听机制，在传入handler对象作为参数构造代理对象后，一旦代理对象的某个操作触发，就会进入handler中对应注册的处理函数，此时我们就可以有选择的使用Reflect将操作转发被代理对象上。</li>\n<li>代理局限性：Object.defineProperty始终还是局限于属性层面的读写代理，对于对象层面以及属性的其它操作代理它都无法实现。鉴于此，由于数组对象push、pop等方法的存在，它对于数组元素的读写代理实现的并不完全。而使用Proxy则可以很方便的监视数组操作。</li>\n<li>自我代理：Object.defineProperty方式可以代理到自身（代理之后使用对象本身即可），也可以代理到别的对象身上（代理之后需要使用代理对象）。Proxy方式只能代理到Proxy实例对象上。这一点在其它说法中是Proxy对象不需要侵入对象就可以实现代理，实际上Object.defineProperty方式也可以不侵入。</li>\n</ul>\n</blockquote>\n<h3 id=\"64-使用-ES5-与-ES6-分别实现继承\"><a href=\"#64-使用-ES5-与-ES6-分别实现继承\" class=\"headerlink\" title=\"64. 使用 ES5 与 ES6 分别实现继承\"></a>64. 使用 <em>ES5</em> 与 <em>ES6</em> 分别实现继承</h3><blockquote>\n<p>参考答案：</p>\n<p>如果是使用 <em>ES5</em> 来实现继承，那么现在的最优解是使用圣杯模式。圣杯模式的核心思想就是不通过调用父类构造函数来给子类原型赋值，而是取得父类原型的一个副本，然后将返回的新对象赋值给子类原型。具体代码可以参阅前面第 <em>9</em> 题的解析。</p>\n<p><em>ES6</em> 新增了 <em>extends</em> 关键字，直接使用该关键字就能够实现继承。</p>\n</blockquote>\n<h3 id=\"65-深拷贝\"><a href=\"#65-深拷贝\" class=\"headerlink\" title=\"65. 深拷贝\"></a>65. 深拷贝</h3><blockquote>\n<p>参考答案：</p>\n<p>有深拷贝就有浅拷贝。</p>\n<p>浅拷贝就是只拷贝对象的引用，而不深层次的拷贝对象的值，多个对象指向堆内存中的同一对象，任何一个修改都会使得所有对象的值修改，因为它们共用一条数据。</p>\n<p>深拷贝不是单纯的拷贝一份引用数据类型的引用地址，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突。</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>「深拷贝」就是在拷贝数据的时候，将数据的所有<strong>引用结构</strong>都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p>\n<p>分析下怎么做「深拷贝」：</p>\n<ol>\n<li>首先假设深拷贝这个方法已经完成，为 deepClone</li>\n<li>要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复</li>\n</ol>\n<pre><code>function deepClone(o1, o2) &#123;\n    for (let k in o2) &#123;\n        if (typeof o2[k] === &#39;object&#39;) &#123;\n            o1[k] = &#123;&#125;;\n            deepClone(o1[k], o2[k]);\n        &#125; else &#123;\n            o1[k] = o2[k];\n        &#125;\n    &#125;\n&#125;\n// 测试用例\nlet obj = &#123;\n    a: 1,\n    b: [1, 2, 3],\n    c: &#123;&#125;\n&#125;;\nlet emptyObj = Object.create(null);\ndeepClone(emptyObj, obj);\nconsole.log(emptyObj.a == obj.a);\nconsole.log(emptyObj.b == obj.b);\n</code></pre>\n<p>递归容易造成爆栈，尾部调用可以解决递归的这个问题，<em>Chrome</em> 的 <em>V8</em> 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过 <em>for</em> 或者 <em>while</em> 来代替递归。</p>\n</blockquote>\n<h3 id=\"66-async-与-await-的作用\"><a href=\"#66-async-与-await-的作用\" class=\"headerlink\" title=\"66. async 与 await 的作用\"></a>66. <em>async</em> 与 <em>await</em> 的作用</h3><blockquote>\n<p>参考答案：</p>\n<p><em>async</em> 是一个修饰符，<em>async</em> 定义的函数会默认的返回一个 <em>Promise</em> 对象 <em>resolve</em> 的值，因此对 <em>async</em> 函数可以直接进行 <em>then</em> 操作，返回的值即为 <em>then</em> 方法的传入函数。</p>\n<p><em>await</em> 关键字只能放在 <em>async</em> 函数内部， <em>await</em> 关键字的作用就是获取 <em>Promise</em> 中返回的内容， 获取的是 <em>Promise</em> 函数中 <em>resolve</em> 或者 <em>reject</em> 的值。</p>\n</blockquote>\n<h3 id=\"67-数据的基础类型（原始类型）有哪些\"><a href=\"#67-数据的基础类型（原始类型）有哪些\" class=\"headerlink\" title=\"67. 数据的基础类型（原始类型）有哪些\"></a>67. 数据的基础类型（原始类型）有哪些</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JavaScript</em> 中的基础数据类型，一共有 <em>7</em> 种：</p>\n<p><em>string，symbol，number，boolean，undefined，null</em>，<em>bigInt</em></p>\n</blockquote>\n<h3 id=\"68-typeof-null-返回结果\"><a href=\"#68-typeof-null-返回结果\" class=\"headerlink\" title=\"68. typeof null 返回结果\"></a>68. <em>typeof null</em> 返回结果</h3><blockquote>\n<p>参考答案：</p>\n<p>返回 <em>object</em></p>\n</blockquote>\n<blockquote>\n<p>解析：至于为什么会返回 <em>object</em>，这实际上是来源于 <em>JavaScript</em> 从第一个版本开始时的一个 <em>bug</em>，并且这个 <em>bug</em> 无法被修复。修复会破坏现有的代码。</p>\n<p>原理这是这样的，不同的对象在底层都表现为二进制，在 <em>JavaScript</em> 中二进制前三位都为 <em>0</em> 的话会被判断为 <em>object</em> 类型，<em>null</em> 的二进制全部为 <em>0</em>，自然前三位也是 <em>0</em>，所以执行 <em>typeof</em> 值会返回 <em>object</em>。</p>\n</blockquote>\n<h3 id=\"69-对变量进行类型判断的方式有哪些\"><a href=\"#69-对变量进行类型判断的方式有哪些\" class=\"headerlink\" title=\"69. 对变量进行类型判断的方式有哪些\"></a>69. 对变量进行类型判断的方式有哪些</h3><blockquote>\n<p>参考答案：</p>\n<p>常用的方法有 <em>4</em> 种：</p>\n<ol>\n<li><em>typeof</em></li>\n</ol>\n<p><em>typeof</em> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 <em>7</em> 种：<em>number、boolean、symbol、string、object、undefined、function</em> 等。</p>\n<ol start=\"2\">\n<li><em>instanceof</em></li>\n</ol>\n<p><em>instanceof</em> 是用来判断 <em>A</em> 是否为 <em>B</em> 的实例，表达式为：<em>A instanceof B</em>，如果 <em>A</em> 是 <em>B</em> 的实例，则返回 <em>true</em>,否则返回 <em>false</em>。 在这里需要特别注意的是：<em>instanceof</em> 检测的是原型。</p>\n<ol start=\"3\">\n<li><em>constructor</em></li>\n</ol>\n<p>当一个函数 <em>F</em> 被定义时，<em>JS</em> 引擎会为 <em>F</em> 添加 <em>prototype</em> 原型，然后再在 <em>prototype</em> 上添加一个 <em>constructor</em> 属性，并让其指向 <em>F</em> 的引用。</p>\n<ol start=\"4\">\n<li><em>toString</em></li>\n</ol>\n<p><em>toString( )</em> 是 <em>Object</em> 的原型方法，调用该方法，默认返回当前对象的 <em>[[Class]]</em> 。这是一个内部属性，其格式为 <em>[object Xxx]</em> ，其中 <em>Xxx</em> 就是对象的类型。</p>\n<p>对于 <em>Object</em> 对象，直接调用 <em>toString( )</em> 就能返回 <em>[object Object]</em> 。而对于其他对象，则需要通过 <em>call &#x2F; apply</em> 来调用才能返回正确的类型信息。例如：</p>\n<pre><code class=\"javascript\">Object.prototype.toString.call(&#39;&#39;) ;  // [object String]\nObject.prototype.toString.call(1) ;   // [object Number]\nObject.prototype.toString.call(true) ;// [object Boolean]\nObject.prototype.toString.call(Symbol());//[object Symbol]\nObject.prototype.toString.call(undefined) ;// [object Undefined]\nObject.prototype.toString.call(null) ;// [object Null]\n</code></pre>\n</blockquote>\n<h3 id=\"70-typeof-与-instanceof-的区别？-instanceof-是如何实现？\"><a href=\"#70-typeof-与-instanceof-的区别？-instanceof-是如何实现？\" class=\"headerlink\" title=\"70. typeof 与 instanceof 的区别？ instanceof 是如何实现？\"></a>70. <em>typeof</em> 与 <em>instanceof</em> 的区别？ <em>instanceof</em> 是如何实现？</h3><blockquote>\n<p>参考答案：</p>\n<ol>\n<li><em>typeof</em></li>\n</ol>\n<p><em>typeof</em> 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 <em>7</em> 种：<em>number、boolean、symbol、string、object、undefined、function</em> 等。</p>\n<ol start=\"2\">\n<li><em>instanceof</em></li>\n</ol>\n<p><em>instanceof</em> 是用来判断 <em>A</em> 是否为 <em>B</em> 的实例，表达式为：<em>A instanceof B</em>，如果 <em>A</em> 是 <em>B</em> 的实例，则返回 <em>true</em>,否则返回 <em>false</em>。 在这里需要特别注意的是：<em>instanceof</em> 检测的是原型。</p>\n<p>用一段伪代码来模拟其内部执行过程：</p>\n<pre><code class=\"javascript\">instanceof (A,B) = &#123;\n    varL = A.__proto__;\n    varR = B.prototype;\n    if(L === R) &#123;\n        // A的内部属性 __proto__ 指向 B 的原型对象\n        return true;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<p>从上述过程可以看出，当 <em>A</em> 的 _<em><em>proto</em></em>_ 指向 <em>B</em> 的 <em>prototype</em> 时，就认为 <em>A</em> 就是 <em>B</em> 的实例。</p>\n<p>需要注意的是，<em>instanceof</em> 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p>\n<p>例如：*[ ] instanceof Object* 返回的也会是 <em>true</em>。</p>\n</blockquote>\n<h3 id=\"71-引用类型有哪些，有什么特点\"><a href=\"#71-引用类型有哪些，有什么特点\" class=\"headerlink\" title=\"71. 引用类型有哪些，有什么特点\"></a>71. 引用类型有哪些，有什么特点</h3><blockquote>\n<p>参考答案：</p>\n<p>JS 中七种内置类型（<em>null，undefined，boolean，number，string，symbol，object</em>）又分为两大类型</p>\n<p>两大类型：</p>\n<ul>\n<li>基本类型： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code></li>\n<li>引用类型Object： <code>Array</code> ，<code>Function</code>， <code>Date</code>， <code>RegExp</code>等</li>\n</ul>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-13-073833.png\" alt=\"image-20210813153833385\" style=\"zoom:50%;\" />\n\n<p>基本类型和引用类型的主要区别有以下几点：</p>\n<p><strong>存放位置：</strong></p>\n<ul>\n<li>基本数据类型：基本类型值在内存中占据固定大小，直接存储在<strong>栈内存</strong>中的数据</li>\n<li>引用数据类型：引用类型在栈中存储了指针，这个指针指向堆内存中的地址，真实的数据存放在<strong>堆内存</strong>里。</li>\n</ul>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-13-074040.png\" alt=\"image-20210813154040287\" style=\"zoom:50%;\" />\n\n<p><strong>值的可变性：</strong></p>\n<ul>\n<li><p>基本数据类型： 值不可变，<em>javascript</em> 中的原始值（<em>undefined、null</em>、布尔值、数字和字符串）是不可更改的</p>\n</li>\n<li><p>引用数据类型：引用类型是可以直接改变其值的</p>\n</li>\n</ul>\n<p><strong>比较：</strong></p>\n<ul>\n<li><p>基本数据类型： 基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的</p>\n</li>\n<li><p>引用数据类型： 引用数据类型的比较是引用的比较，看其的引用是否指向同一个对象</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"72-如何得到一个变量的类型—指函数封装实现\"><a href=\"#72-如何得到一个变量的类型—指函数封装实现\" class=\"headerlink\" title=\"72. 如何得到一个变量的类型—指函数封装实现\"></a>72. 如何得到一个变量的类型—指函数封装实现</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>30</em> 题答案。</p>\n</blockquote>\n<h3 id=\"73-什么是作用域、闭包\"><a href=\"#73-什么是作用域、闭包\" class=\"headerlink\" title=\"73. 什么是作用域、闭包\"></a>73. 什么是作用域、闭包</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>56</em> 题。</p>\n</blockquote>\n<h3 id=\"74-闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？\"><a href=\"#74-闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？\" class=\"headerlink\" title=\"74. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？\"></a>74. 闭包的缺点是什么？闭包的应用场景有哪些？怎么销毁闭包？</h3><blockquote>\n<p>参考答案：</p>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以<strong>闭包使用过多，会占用较多的内存，这也是一个副作用，内存泄漏。</strong></p>\n<p>如果要销毁一个闭包，可以 把被引用的变量设置为<em>null</em>，即手动清除变量，这样下次 <em>js</em> 垃圾回收机制回收时，就会把设为 <em>null</em> 的量给回收了。</p>\n<p>闭包的应用场景：</p>\n<ol>\n<li>匿名自执行函数</li>\n<li>结果缓存</li>\n<li>封装</li>\n<li>实现类和继承</li>\n</ol>\n</blockquote>\n<h3 id=\"75-JS的垃圾回收站机制\"><a href=\"#75-JS的垃圾回收站机制\" class=\"headerlink\" title=\"75. JS的垃圾回收站机制\"></a>75. <em>JS</em>的垃圾回收站机制</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JS</em> 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</p>\n<p><em>JS</em> 常见的垃圾回收方式：标记清除、引用计数方式。</p>\n<p>1、标记清除方式：</p>\n<ul>\n<li><p>工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</p>\n</li>\n<li><p>工作流程：</p>\n</li>\n<li><p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；</p>\n</li>\n<li><p>去掉环境中的变量以及被环境中的变量引用的变量的标记；</p>\n</li>\n<li><p>被加上标记的会被视为准备删除的变量；</p>\n</li>\n<li><p>垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。</p>\n</li>\n</ul>\n<p>2、引用计数方式：</p>\n<ul>\n<li><p>工作原理：跟踪记录每个值被引用的次数。</p>\n</li>\n<li><p>工作流程：</p>\n</li>\n<li><p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 <em>1</em>；</p>\n</li>\n<li><p>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1；</p>\n</li>\n<li><p>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 <em>1</em>；</p>\n</li>\n<li><p>当引用次数变成 <em>0</em> 时，说明没办法访问这个值了；</p>\n</li>\n<li><p>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"76-什么是作用域链、原型链\"><a href=\"#76-什么是作用域链、原型链\" class=\"headerlink\" title=\"76. 什么是作用域链、原型链\"></a>76. 什么是作用域链、原型链</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>什么是作用域链?</strong></p>\n<p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p>\n<p><strong>什么原型链?</strong></p>\n<p>每个对象都可以有一个原型__<em>proto</em>__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。</p>\n</blockquote>\n<h3 id=\"77-new-一个构造函数发生了什么\"><a href=\"#77-new-一个构造函数发生了什么\" class=\"headerlink\" title=\"77. new 一个构造函数发生了什么\"></a>77. <em>new</em> 一个构造函数发生了什么</h3><blockquote>\n<p>参考答案：</p>\n<p><em>new</em> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>\n<p><em>new</em> 关键字会进行如下的操作：<br>步骤 <em>1</em>：创建一个空的简单 <em>JavaScript</em> 对象，即 { } ;<br>步骤 <em>2</em>：链接该对象到另一个对象（即设置该对象的原型对象）；<br>步骤 <em>3</em>：将步骤 <em>1</em> 新创建的对象作为 <em>this</em> 的上下文；<br>步骤 <em>4</em>：如果该函数没有返回对象，则返回 <em>this</em>。</p>\n</blockquote>\n<h3 id=\"78-对一个构造函数实例化后-它的原型链指向什么\"><a href=\"#78-对一个构造函数实例化后-它的原型链指向什么\" class=\"headerlink\" title=\"78. 对一个构造函数实例化后. 它的原型链指向什么\"></a>78. 对一个构造函数实例化后. 它的原型链指向什么</h3><blockquote>\n<p>参考答案：</p>\n<p>指向该构造函数实例化出来对象的原型对象。</p>\n<p>对于构造函数来讲，可以通过 <em>prototype</em> 访问到该对象。</p>\n<p>对于实例对象来讲，可以通过隐式属性 _<em><em>proto</em></em>_ 来访问到。</p>\n</blockquote>\n<h3 id=\"79-什么是变量提升\"><a href=\"#79-什么是变量提升\" class=\"headerlink\" title=\"79. 什么是变量提升\"></a>79. 什么是变量提升</h3><blockquote>\n<p>参考答案：</p>\n<p>当 <em>JavaScript</em> 编译所有代码时，所有使用 <em>var</em> 的变量声明都被提升到它们的函数&#x2F;局部作用域的顶部(如果在函数内部声明的话)，或者提升到它们的全局作用域的顶部(如果在函数外部声明的话)，而不管实际的声明是在哪里进行的。这就是我们所说的“提升”。</p>\n<p>请记住，这种“提升”实际上并不发生在你的代码中，而只是一种比喻，与 <em>JavaScript</em> 编译器如何读取你的代码有关。记住当我们想到“提升”的时候，我们可以想象任何被提升的东西都会被移动到顶部，但是实际上你的代码并不会被修改。</p>\n<p>函数声明也会被提升，但是被提升到了最顶端，所以将位于所有变量声明之上。</p>\n<p>在编译阶段变量和函数声明会被放入内存中，但是你在代码中编写它们的位置会保持不变。</p>\n</blockquote>\n<h3 id=\"80-x3D-x3D-和-x3D-x3D-x3D-的区别是什么\"><a href=\"#80-x3D-x3D-和-x3D-x3D-x3D-的区别是什么\" class=\"headerlink\" title=\"80. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别是什么\"></a>80. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别是什么</h3><blockquote>\n<p>参考答案：</p>\n<p>简单来说： &#x3D;&#x3D; 代表相同， &#x3D;&#x3D;&#x3D; 代表严格相同（数据类型和值都相等）。</p>\n<p>当进行双等号比较时候，先检查两个操作数数据类型，如果相同，则进行&#x3D;&#x3D;&#x3D;比较，如果不同，则愿意为你进行一次类型转换，转换成相同类型后再进行比较，而 &#x3D;&#x3D;&#x3D; 比较时，如果类型不同，直接就是false。</p>\n<p>从这个过程来看，大家也能发现，某些情况下我们使用 &#x3D;&#x3D;&#x3D; 进行比较效率要高些，因此，没有歧义的情况下，不会影响结果的情况下，在 <em>JS</em> 中首选 &#x3D;&#x3D;&#x3D; 进行逻辑比较。</p>\n</blockquote>\n<h3 id=\"81-Object-is-方法比较的是什么\"><a href=\"#81-Object-is-方法比较的是什么\" class=\"headerlink\" title=\"81. Object.is 方法比较的是什么\"></a>81. <em>Object.is</em> 方法比较的是什么</h3><blockquote>\n<p>参考答案：</p>\n<p><em>Object.is</em> 方法是 <em>ES6</em> 新增的用来比较两个值是否严格相等的方法，与 &#x3D;&#x3D;&#x3D; (严格相等)的行为基本一致。不过有两处不同：</p>\n<ul>\n<li>+0 不等于 -0。</li>\n<li><em>NaN</em> 等于自身。</li>\n</ul>\n<p>所以可以将<em>Object.is</em> 方法看作是加强版的严格相等。</p>\n</blockquote>\n<h3 id=\"82-基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？\"><a href=\"#82-基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？\" class=\"headerlink\" title=\"82. 基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？\"></a>82. 基础数据类型和引用数据类型，哪个是保存在栈内存中？哪个是在堆内存中？</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>ECMAScript</em> 规范中，共定义了 <em>7</em> 种数据类型，分为 <strong>基本类型</strong> 和 <strong>引用类型</strong> 两大类，如下所示：</p>\n<ul>\n<li><p><strong>基本类型</strong>：<em>String、Number、Boolean、Symbol、Undefined、Null</em> </p>\n</li>\n<li><p><strong>引用类型</strong>：<em>Object</em></p>\n</li>\n</ul>\n<p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p>\n<p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(<em>heap</em>)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 <em>Object</em> 外，还包括 <em>Function 、Array、RegExp、Date</em> 等等。</p>\n</blockquote>\n<h3 id=\"83-箭头函数解决了什么问题？\"><a href=\"#83-箭头函数解决了什么问题？\" class=\"headerlink\" title=\"83. 箭头函数解决了什么问题？\"></a>83. 箭头函数解决了什么问题？</h3><blockquote>\n<p>参考答案：</p>\n<p>箭头函数主要解决了 <em>this</em> 的指向问题。</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>在 <em>ES5</em> 时代，一旦对象的方法里面又存在函数，则 <em>this</em> 的指向往往会让开发人员抓狂。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">//错误案例，this 指向会指向 Windows 或者 undefined\nvar obj = &#123;\n    age: 18,\n    getAge: function () &#123;\n        var a = this.age; // 18\n        var fn = function () &#123;\n            return new Date().getFullYear() - this.age; // this 指向 window 或 undefined\n        &#125;;\n        return fn();\n    &#125;\n&#125;;\nconsole.log(obj.getAge()); // NaN\n</code></pre>\n<p>然而，箭头函数没有 <em>this</em>，箭头函数的 <em>this</em> 是继承父执行上下文里面的 <em>this</em></p>\n<pre><code class=\"javascript\">var obj = &#123;\n    age: 18,\n    getAge: function () &#123;\n        var a = this.age; // 18\n        var fn = () =&gt; new Date().getFullYear() - this.age; // this 指向 obj 对象\n        return fn();\n    &#125;\n&#125;;\n\nconsole.log(obj.getAge()); // 2003\n</code></pre>\n</blockquote>\n<h3 id=\"84-new-一个箭头函数后，它的-this-指向什么？\"><a href=\"#84-new-一个箭头函数后，它的-this-指向什么？\" class=\"headerlink\" title=\"84. new 一个箭头函数后，它的 this 指向什么？\"></a>84. <em>new</em> 一个箭头函数后，它的 <em>this</em> 指向什么？</h3><blockquote>\n<p>参考答案：</p>\n<p>我不知道这道题是出题人写错了还是故意为之。</p>\n<p>箭头函数无法用来充当构造函数，所以是无法 <em>new</em> 一个箭头函数的。</p>\n<p>当然，也有可能是面试官故意挖的一个坑，等着你往里面跳。</p>\n</blockquote>\n<h3 id=\"85-promise-的其他方法有用过吗？如-all、race。请说下这两者的区别\"><a href=\"#85-promise-的其他方法有用过吗？如-all、race。请说下这两者的区别\" class=\"headerlink\" title=\"85. promise 的其他方法有用过吗？如 all、race。请说下这两者的区别\"></a>85. <em>promise</em> 的其他方法有用过吗？如 <em>all、race</em>。请说下这两者的区别</h3><blockquote>\n<p>参考答案：</p>\n<p><em>promise.all</em> 方法参数是一个 <em>promise</em> 的数组,只有当所有的 <em>promise</em> 都完成并返回成功，才会调用 <em>resolve</em>，当有一个失败，都会进<em>catch</em>，被捕获错误，<em>promise.all</em> 调用成功返回的结果是每个 <em>promise</em> 单独调用成功之后返回的结果组成的数组,如果调用失败的话，返回的则是第一个 <em>reject</em> 的结果</p>\n<p><em>promise.race</em> 也会调用所有的 <em>promise</em>，返回的结果则是所有 <em>promise</em> 中最先返回的结果，不关心是成功还是失败。</p>\n</blockquote>\n<h3 id=\"86-class-是如何实现的\"><a href=\"#86-class-是如何实现的\" class=\"headerlink\" title=\"86. class 是如何实现的\"></a>86. <em>class</em> 是如何实现的</h3><blockquote>\n<p>参考答案：</p>\n<p><em>class</em> 是 <em>ES6</em> 新推出的关键字，它是一个语法糖，本质上就是基于这个原型实现的。只不过在以前 <em>ES5</em> 原型实现的基础上，添加了一些 <em>_classCallCheck、_defineProperties、_createClass</em>等方法来做出了一些特殊的处理。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">class Hello &#123;\n   constructor(x) &#123;\n       this.x = x;\n   &#125;\n   greet() &#123;\n       console.log(&quot;Hello, &quot; + this.x)\n   &#125;\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">&quot;use strict&quot;;\n\nfunction _classCallCheck(instance, Constructor) &#123;\n     if (!(instance instanceof Constructor)) &#123;\n         throw new TypeError(&quot;Cannot call a class as a function&quot;);\n     &#125;\n&#125;\n\nfunction _defineProperties(target, props) &#123;\n     for (var i = 0; i &lt; props.length; i++) &#123;\n         var descriptor = props[i];\n         descriptor.enumerable = descriptor.enumerable || false;\n         descriptor.configurable = true;\n         if (&quot;value&quot; in descriptor)\n             descriptor.writable = true;\n         Object.defineProperty(target, descriptor.key, descriptor);\n     &#125;\n&#125;\n\nfunction _createClass(Constructor, protoProps, staticProps) &#123;\n     console.log(&quot;Constructor::&quot;,Constructor);\n     console.log(&quot;protoProps::&quot;,protoProps);\n     console.log(&quot;staticProps::&quot;,staticProps);\n     if (protoProps)\n         _defineProperties(Constructor.prototype, protoProps);\n     if (staticProps)\n         _defineProperties(Constructor, staticProps);\n     return Constructor;\n&#125;\n\nvar Hello = /*#__PURE__*/function () &#123;\n   function Hello(x) &#123;\n       _classCallCheck(this, Hello);\n\n       this.x = x;\n   &#125;\n\n   _createClass(Hello, [&#123;\n       key: &quot;greet&quot;,\n       value: function greet() &#123;\n         console.log(&quot;Hello, &quot; + this.x);\n       &#125;\n     &#125;]);\n\n     return Hello;\n&#125;();\n</code></pre>\n</blockquote>\n<h3 id=\"87-let、const、var-的区别\"><a href=\"#87-let、const、var-的区别\" class=\"headerlink\" title=\"87. let、const、var 的区别\"></a>87. <em>let、const、var</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>22</em> 题答案。</p>\n</blockquote>\n<h3 id=\"88-ES6-中模块化导入和导出与-common-js-有什么区别\"><a href=\"#88-ES6-中模块化导入和导出与-common-js-有什么区别\" class=\"headerlink\" title=\"88. ES6 中模块化导入和导出与 common.js 有什么区别\"></a>88. <em>ES6</em> 中模块化导入和导出与 <em>common.js</em> 有什么区别</h3><blockquote>\n<p>参考答案：</p>\n<p>CommonJs模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化不会影响到这个值.</p>\n<pre><code>// common.js\nvar count = 1;\n\nvar printCount = () =&gt;&#123; \n  return ++count;\n&#125;\n\nmodule.exports = &#123;\n    printCount: printCount,\n    count: count\n&#125;;\n// index.js\nlet v = require(&#39;./common&#39;);\nconsole.log(v.count); // 1\nconsole.log(v.printCount()); // 2\nconsole.log(v.count); // 1\n</code></pre>\n<p>你可以看到明明common.js里面改变了count，但是输出的结果还是原来的。这是因为count是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动的值。将common.js里面的module.exports 改写成</p>\n<pre><code>module.exports = &#123;\n    printCount: printCount,\n    get count()&#123;\n        return count\n    &#125;\n&#125;;\n</code></pre>\n<p>这样子的输出结果是 1，2，2</p>\n<p>而在ES6当中，写法是这样的，是利用export 和import导入的</p>\n<pre><code>// es6.js\nexport let count = 1;\nexport function printCount() &#123;\n    ++count;\n&#125;\n// main1.js\nimport  &#123; count, printCount &#125; from &#39;./es6&#39;;\nconsole.log(count)\nconsole.log(printCount());\nconsole.log(count)\n</code></pre>\n<p>ES6 模块是动态引用，并且不会缓存，模块里面的变量绑定其所有的模块，而是动态地去加载值，并且不能重新赋值，</p>\n<p>ES6 输入的模块变量，只是一个“符号连接符”，所以这个变量是只读的，对它进行重新赋值会报错。如果是引用类型，变量指向的地址是只读的，但是可以为其添加属性或成员。</p>\n<p>另外还想说一个 <em>export default</em></p>\n<pre><code>let count = 1;\nfunction printCount() &#123;\n    ++count;\n&#125; \nexport default &#123; count, printCount&#125;\n// main3.js\nimport res form &#39;./main3.js&#39;\nconsole.log(res.count)\n</code></pre>\n<p>export与export default的区别及联系：</p>\n<ol>\n<li><p>export与export default均可用于导出常量、函数、文件、模块等</p>\n</li>\n<li><p>你可以在其它文件或模块中通过 import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用 </p>\n</li>\n<li><p>在一个文件或模块中，export、import可以有多个，export default仅有一个</p>\n</li>\n<li><p>通过export方式导出，在导入时要加{ }，export default则不需要。</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"89-说一下普通函数和箭头函数的区别\"><a href=\"#89-说一下普通函数和箭头函数的区别\" class=\"headerlink\" title=\"89. 说一下普通函数和箭头函数的区别\"></a>89. 说一下普通函数和箭头函数的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>8、25、83</em> 题答案。</p>\n</blockquote>\n<h3 id=\"90-说一下-promise-和-async-和-await-什么关系\"><a href=\"#90-说一下-promise-和-async-和-await-什么关系\" class=\"headerlink\" title=\"90. 说一下 promise 和 async 和 await 什么关系\"></a>90. 说一下 <em>promise</em> 和 <em>async</em> 和 <em>await</em> 什么关系</h3><blockquote>\n<p>参考答案：</p>\n<p><em>await</em> 表达式会造成异步函数停止执行并且等待<em>promise</em>的解决，当值被<em>resolved</em>，异步函数会恢复执行以及返回<em>resolved</em>值。如果该值不是一个<em>promise</em>，它将会被转换成一个<em>resolved</em>后的<em>promise</em>。如果<em>promise</em>被<em>rejected</em>，<em>await</em> 表达式会抛出异常值。</p>\n</blockquote>\n<h3 id=\"91-说一下你学习过的有关-ES6-的知识点\"><a href=\"#91-说一下你学习过的有关-ES6-的知识点\" class=\"headerlink\" title=\"91. 说一下你学习过的有关 ES6 的知识点\"></a>91. 说一下你学习过的有关 <em>ES6</em> 的知识点</h3><blockquote>\n<p>参考答案：</p>\n<p>这种题目是开放题，可以简单列举一下 <em>ES6</em> 的新增知识点。（ <em>ES6</em> 的新增知识点参阅前面第 <em>44</em> 题）</p>\n<p>然后说一下自己平时开发中用得比较多的是哪些即可。</p>\n<p>一般面试官会针对你所说的内容进行二次提问。例如：你回答平时开发中箭头函数用得比较多，那么面试官极大可能针对箭头函数展开二次提问，询问你箭头函数有哪些特性？箭头函数 <em>this</em> 特点之类的问题。</p>\n</blockquote>\n<h3 id=\"92-了解过-js-中-arguments-吗？接收的是实参还是形参？\"><a href=\"#92-了解过-js-中-arguments-吗？接收的是实参还是形参？\" class=\"headerlink\" title=\"92. 了解过 js 中 arguments 吗？接收的是实参还是形参？\"></a>92. 了解过 <em>js</em> 中 <em>arguments</em> 吗？接收的是实参还是形参？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JS</em> 中的 <em>arguments</em> 是一个伪数组对象。这个伪数组对象将包含调用函数时传递的所有的实参。</p>\n<p>与之相对的，<em>JS</em> 中的函数还有一个 <em>length</em> 属性，返回的是函数形参的个数。</p>\n</blockquote>\n<h3 id=\"93-ES6-相比于-ES5-有什么变化\"><a href=\"#93-ES6-相比于-ES5-有什么变化\" class=\"headerlink\" title=\"93. ES6 相比于 ES5 有什么变化\"></a>93. <em>ES6</em> 相比于 <em>ES5</em> 有什么变化</h3><blockquote>\n<p>参考答案：</p>\n<p><em>ES6</em> 相比 <em>ES5</em> 新增了很多新特性，这里可以自己简述几个。</p>\n<p>具体的新增特性可以参阅前面第 <em>44</em> 题。</p>\n</blockquote>\n<h3 id=\"94-强制类型转换方法有哪些？\"><a href=\"#94-强制类型转换方法有哪些？\" class=\"headerlink\" title=\"94. 强制类型转换方法有哪些？\"></a>94. 强制类型转换方法有哪些？</h3><blockquote>\n<p>参考答案：</p>\n<p>JavaScript 中的数据类型转换，主要有三种方式：</p>\n<ol>\n<li>转换函数</li>\n</ol>\n<p><em>js</em> 提供了诸如 <em>parseInt</em> 和 <em>parseFloat</em> 这些转换函数，通过这些转换函数可以进行数据类型的转换 。</p>\n<ol start=\"2\">\n<li>强制类型转换</li>\n</ol>\n<p>还可使用强制类型转换（<em>type casting</em>）处理转换值的类型。</p>\n<p>例如：</p>\n<ul>\n<li><em>Boolean</em>(<em>value</em>) 把给定的值转换成 <em>Boolean</em> 型；</li>\n<li><em>Number</em>(<em>value</em>)——把给定的值转换成数字（可以是整数或浮点数）；</li>\n<li><em>String</em>(<em>value</em>)——把给定的值转换成字符串。</li>\n</ul>\n<ol start=\"3\">\n<li>利用 <em>js</em> 变量弱类型转换。</li>\n</ol>\n<p>例如：</p>\n<ul>\n<li><p>转换字符串：直接和一个空字符串拼接，例如：<code>a = &quot;&quot; + 数据</code></p>\n</li>\n<li><p>转换布尔：!!数据类型，例如：<code>!!&quot;Hello&quot;</code></p>\n</li>\n<li><p>转换数值：数据*1 或 &#x2F;1，例如：<code>&quot;Hello * 1&quot;</code></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"95-纯函数\"><a href=\"#95-纯函数\" class=\"headerlink\" title=\"95. 纯函数\"></a>95. 纯函数</h3><blockquote>\n<p>参考答案：</p>\n<p>一个函数，如果符合以下两个特点，那么它就可以称之为<strong>纯函数</strong>：</p>\n<ol>\n<li>对于相同的输入，永远得到相同的输出</li>\n<li>没有任何可观察到的副作用</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>针对上面的两个特点，我们一个一个来看。</p>\n<ul>\n<li>相同输入得到相同输出</li>\n</ul>\n<p>我们先来看一个不纯的反面典型：</p>\n<pre><code>let greeting = &#39;Hello&#39;\n\nfunction greet (name) &#123;\n  return greeting + &#39; &#39; + name\n&#125;\n\nconsole.log(greet(&#39;World&#39;)) // Hello World\n</code></pre>\n<p>上面的代码中，<em>greet(‘World’)</em> 是不是永远返回 <em>Hello World</em> ? 显然不是，假如我们修改 <em>greeting</em> 的值，就会影响 <em>greet</em> 函数的输出。即函数 <em>greet</em> 其实是 <strong>依赖外部状态</strong> 的。</p>\n<p>那我们做以下修改：</p>\n<pre><code>function greet (greeting, name) &#123;\n  return greeting + &#39; &#39; + name\n&#125;\n\nconsole.log(greet(&#39;Hi&#39;, &#39;Savo&#39;)) // Hi Savo\n</code></pre>\n<p>将 <em>greeting</em> 参数也传入，这样对于任何输入参数，都有与之对应的唯一的输出参数了，该函数就符合了第一个特点。</p>\n<ul>\n<li>没有副作用</li>\n</ul>\n<p>副作用的意思是，这个函数的运行，<strong>不会修改外部的状态</strong>。</p>\n<p>下面再看反面典型：</p>\n<pre><code>const user = &#123;\n  username: &#39;savokiss&#39;\n&#125;\n\nlet isValid = false\n\nfunction validate (user) &#123;\n  if (user.username.length &gt; 4) &#123;\n    isValid = true\n  &#125;\n&#125;\n</code></pre>\n<p>可见，执行函数的时候会修改到 <em>isValid</em> 的值（注意：如果你的函数没有任何返回值，那么它很可能就具有副作用！）</p>\n<p>那么我们如何移除这个副作用呢？其实不需要修改外部的 <em>isValid</em> 变量，我们只需要在函数中将验证的结果 <em>return</em> 出来：</p>\n<pre><code>const user = &#123;\n  username: &#39;savokiss&#39;\n&#125;\n\nfunction validate (user) &#123;\n  return user.username.length &gt; 4;\n&#125;\n\nconst isValid = validate(user)\n</code></pre>\n<p>这样 <em>validate</em> 函数就不会修改任何外部的状态了~</p>\n</blockquote>\n<h3 id=\"96-JS-模块化\"><a href=\"#96-JS-模块化\" class=\"headerlink\" title=\"96. JS 模块化\"></a>96. <em>JS</em> 模块化</h3><blockquote>\n<p>参考答案：</p>\n<p>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</p>\n<p>模块化的整个发展历史如下：</p>\n<p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p>\n<pre><code class=\"javascript\">(function()&#123;\n return &#123;\ndata:[]\n &#125;\n&#125;)()\n</code></pre>\n<p><strong>AMD</strong>： 使用requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p>\n<pre><code class=\"javascript\">define(&#39;./index.js&#39;,function(code)&#123;\n// code 就是index.js 返回的内容\n&#125;)\n</code></pre>\n<p><strong>CMD</strong>： 使用seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p>\n<pre><code class=\"javascript\">define(function(require, exports, module) &#123;  \n var indexCode = require(&#39;./index.js&#39;);\n&#125;);\n</code></pre>\n<p><strong>CommonJS</strong>： nodejs 中自带的模块化。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n</code></pre>\n<p><strong>UMD</strong>：兼容AMD，CommonJS 模块化语法。</p>\n<p>**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。</p>\n<p><strong>ES Modules</strong>： ES6 引入的模块化，支持import 来引入另一个 js 。</p>\n<pre><code class=\"javascript\">import a from &#39;a&#39;;\n</code></pre>\n</blockquote>\n<h3 id=\"97-看过-jquery-源码吗？\"><a href=\"#97-看过-jquery-源码吗？\" class=\"headerlink\" title=\"97. 看过 jquery 源码吗？\"></a>97. 看过 <em>jquery</em> 源码吗？</h3><blockquote>\n<p>参考答案：</p>\n<p>开放题，但是需要注意的是，如果看过 <em>jquery</em> 源码，不要简单的回答一个“看过”就完了，应该继续乘胜追击，告诉面试官例如哪个哪个部分是怎么怎么实现的，并针对这部分的源码实现，可以发表一些自己的看法和感想。</p>\n</blockquote>\n<h3 id=\"98-说一下-js-中的-this\"><a href=\"#98-说一下-js-中的-this\" class=\"headerlink\" title=\"98. 说一下 js 中的 this\"></a>98. 说一下 <em>js</em> 中的 <em>this</em></h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>17</em> 题答案。</p>\n</blockquote>\n<h3 id=\"99-apply-call-bind-区别，手写\"><a href=\"#99-apply-call-bind-区别，手写\" class=\"headerlink\" title=\"99. apply call bind 区别，手写\"></a>99. <em>apply call bind</em> 区别，手写</h3><blockquote>\n<p>参考答案：</p>\n<p>apply call bind 区别 ？</p>\n<p><em>call</em> 和 <em>apply</em> 的功能相同，区别在于传参的方式不一样:</p>\n<ul>\n<li><em>fn.call(obj, arg1, arg2, …)</em> 调用一个函数, 具有一个指定的 <em>this</em> 值和分别地提供的参数(参数的列表)。</li>\n<li><em>fn.apply(obj, [argsArray])</em> 调用一个函数，具有一个指定的 <em>this</em> 值，以及作为一个数组（或类数组对象）提供的参数。</li>\n</ul>\n<p><em>bind</em> 和 <em>call&#x2F;apply</em> 有一个很重要的区别，一个函数被 <em>call&#x2F;apply</em> 的时候，会直接调用，但是 <em>bind</em> 会创建一个新函数。当这个新函数被调用时，<em>bind( )</em> 的第一个参数将作为它运行时的 <em>this</em>，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>\n<p>实现 <em>call</em> 方法：</p>\n<pre><code class=\"javascript\">Function.prototype.call2 = function (context) &#123;\n   //没传参数或者为 null 是默认是 window\n   var context = context || (typeof window !== &#39;undefined&#39; ? window : global)\n   // 首先要获取调用 call 的函数，用 this 可以获取\n   context.fn = this\n   var args = []\n   for (var i = 1; i &lt; arguments.length; i++) &#123;\n       args.push(&#39;arguments[&#39; + i + &#39;]&#39;)\n   &#125;\n   eval(&#39;context.fn(&#39; + args + &#39;)&#39;)\n   delete context.fn\n&#125;\n\n// 测试\nvar value = 3\nvar foo = &#123;\n   value: 2\n&#125;\n\nfunction bar(name, age) &#123;\n   console.log(this.value)\n   console.log(name)\n   console.log(age)\n&#125;\nbar.call2(null)\n// 浏览器环境： 3 undefinde undefinde   \n// Node环境：undefinde undefinde undefinde\n\nbar.call2(foo, &#39;cc&#39;, 18) // 2  cc 18\n</code></pre>\n<p>实现 <em>apply</em> 方法：</p>\n<pre><code class=\"javascript\">Function.prototype.apply2 = function (context, arr) &#123;\n   var context = context || (typeof window !== &#39;undefined&#39; ? window : global)\n   context.fn = this;\n\n   var result;\n   if (!arr) &#123;\n       result = context.fn();\n   &#125;\n   else &#123;\n       var args = [];\n       for (var i = 0, len = arr.length; i &lt; len; i++) &#123;\n           args.push(&#39;arr[&#39; + i + &#39;]&#39;);\n       &#125;\n       result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)\n   &#125;\n\n   delete context.fn\n   return result;\n&#125;\n\n// 测试：\n\nvar value = 3\nvar foo = &#123;\n   value: 2\n&#125;\n\nfunction bar(name, age) &#123;\n   console.log(this.value)\n   console.log(name)\n   console.log(age)\n&#125;\nbar.apply2(null)\n// 浏览器环境： 3 undefinde undefinde   \n// Node环境：undefinde undefinde undefinde\n\nbar.apply2(foo, [&#39;cc&#39;, 18]) // 2  cc 18\n</code></pre>\n<p>实现 <em>bind</em> 方法：</p>\n<pre><code class=\"javascript\">Function.prototype.bind2 = function (oThis) &#123;\n   if (typeof this !== &quot;function&quot;) &#123;\n       // closest thing possible to the ECMAScript 5 internal IsCallable function\n       throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);\n   &#125;\n   var aArgs = Array.prototype.slice.call(arguments, 1),\n       fToBind = this,\n       fNOP = function () &#123; &#125;,\n       fBound = function () &#123;\n           return fToBind.apply(this instanceof fNOP &amp;&amp; oThis\n               ? this\n               : oThis || window,\n               aArgs.concat(Array.prototype.slice.call(arguments)));\n       &#125;;\n\n   fNOP.prototype = this.prototype;\n   fBound.prototype = new fNOP();\n\n   return fBound;\n&#125;\n\n// 测试\nvar test = &#123;\n   name: &quot;jack&quot;\n&#125;\nvar demo = &#123;\n   name: &quot;rose&quot;,\n   getName: function () &#123; return this.name; &#125;\n&#125;\n\nconsole.log(demo.getName()); // 输出 rose  这里的 this 指向 demo\n\n// 运用 bind 方法更改 this 指向\nvar another2 = demo.getName.bind2(test);\nconsole.log(another2()); // 输出 jack  这里 this 指向了 test 对象了\n</code></pre>\n</blockquote>\n<h3 id=\"100-手写-reduce-flat\"><a href=\"#100-手写-reduce-flat\" class=\"headerlink\" title=\"100. 手写 reduce flat\"></a>100. 手写 <em>reduce flat</em></h3><blockquote>\n<p>参考答案：</p>\n<p><em>reduce</em> 实现：</p>\n<pre><code class=\"javascript\">Array.prototype.my_reduce = function (callback, initialValue) &#123;\n    if (!Array.isArray(this) || !this.length || typeof callback !== &#39;function&#39;) &#123;\n        return []\n    &#125; else &#123;\n        // 判断是否有初始值\n        let hasInitialValue = initialValue !== undefined;\n        let value = hasInitialValue ? initialValue : tihs[0];\n        for (let index = hasInitialValue ? 0 : 1; index &lt; this.length; index++) &#123;\n            const element = this[index];\n            value = callback(value, element, index, this)\n        &#125;\n        return value\n    &#125;\n&#125;\n\nlet arr = [1, 2, 3, 4, 5]\nlet res = arr.my_reduce((pre, cur, i, arr) =&gt; &#123;\n    console.log(pre, cur, i, arr)\n    return pre + cur\n&#125;, 10)\nconsole.log(res)//25\n</code></pre>\n<p><em>flat</em> 实现：</p>\n<pre><code class=\"javascript\">let arr = [1, [2, 3, [4, 5, [12, 3, &quot;zs&quot;], 7, [8, 9, [10, 11, [1, 2, [3, 4]]]]]]];\n\n//万能的类型检测方法\nconst checkType = (arr) =&gt; &#123;\n    return Object.prototype.toString.call(arr).slice(8, -1);\n&#125;\n//自定义flat方法，注意：不可以使用箭头函数，使用后内部的this会指向window\nArray.prototype.myFlat = function (num) &#123;\n    //判断第一层数组的类型\n    let type = checkType(this);\n    //创建一个新数组，用于保存拆分后的数组\n    let result = [];\n    //若当前对象非数组则返回undefined\n    if (!Object.is(type, &quot;Array&quot;)) &#123;\n        return;\n    &#125;\n    //遍历所有子元素并判断类型，若为数组则继续递归，若不为数组则直接加入新数组\n    this.forEach((item) =&gt; &#123;\n        let cellType = checkType(item);\n        if (Object.is(cellType, &quot;Array&quot;)) &#123;\n            //形参num，表示当前需要拆分多少层数组，传入Infinity则将多维直接降为一维\n            num--;\n            if (num &lt; 0) &#123;\n                let newArr = result.push(item);\n                return newArr;\n            &#125;\n            //使用三点运算符解构，递归函数返回的数组，并加入新数组\n            result.push(...item.myFlat(num));\n        &#125; else &#123;\n            result.push(item);\n        &#125;\n    &#125;)\n    return result;\n&#125;\nconsole.time();\n\nconsole.log(arr.flat(Infinity)); //[1, 2, 3, 4, 5, 12, 3, &quot;zs&quot;, 7, 8, 9, 10, 11, 1, 2, 3, 4];\n\nconsole.log(arr.myFlat(Infinity)); //[1, 2, 3, 4, 5, 12, 3, &quot;zs&quot;, 7, 8, 9, 10, 11, 1, 2, 3, 4];\n//自定义方法和自带的flat返回结果一致!!!!\nconsole.timeEnd();\n</code></pre>\n</blockquote>\n<h3 id=\"101-x3D-x3D-隐试转换的原理？是怎么转换的\"><a href=\"#101-x3D-x3D-隐试转换的原理？是怎么转换的\" class=\"headerlink\" title=\"101. &#x3D;&#x3D; 隐试转换的原理？是怎么转换的\"></a>101. &#x3D;&#x3D; 隐试转换的原理？是怎么转换的</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>两个与类型转换有关的函数：valueOf()和toString()</strong></p>\n<ul>\n<li>valueOf()的语义是，返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。</li>\n<li>toString()的语义是，返回这个对象的字符串表示。用一个字符串来描述这个对象的内容。</li>\n</ul>\n<p>valueOf()和toString()是定义在Object.prototype上的方法，也就是说，所有的对象都会继承到这两个方法。但是在Object.prototype上定义的这两个方法往往不能满足我们的需求（Object.prototype.valueOf()仅仅返回对象本身），因此js的许多内置对象都重写了这两个函数，以实现更适合自身的功能需要（比如说，String.prototype.valueOf就覆盖了在Object.prototype中定义的valueOf）。当我们自定义对象的时候，最好也重写这个方法。重写这个方法时要遵循上面所说的语义。</p>\n<p><strong>js内部用于实现类型转换的4个函数</strong></p>\n<p>这4个方法实际上是ECMAScript定义的4个抽象的操作，它们在js内部使用，进行类型转换。js的使用者不能直接调用这些函数。</p>\n<ul>\n<li>ToPrimitive ( input [ , PreferredType ] )</li>\n<li>ToBoolean ( argument )</li>\n<li>ToNumber ( argument )</li>\n<li>ToString ( argument )</li>\n</ul>\n<p>需要区分这里的 ToString() 和上文谈到的 toString()，一个是 js 引擎内部使用的函数，另一个是定义在对象上的函数。</p>\n<p>（1）ToPrimitive ( input [ , PreferredType ] )</p>\n<p>将 input 转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number 或 String。<strong>如果PreferredType参数是Number</strong>，ToPrimitive这样执行：</p>\n<ol>\n<li>如果input本身就是原始类型，直接返回input。</li>\n<li>调用**input.valueOf()**，如果结果是原始类型，则返回这个结果。</li>\n<li>调用**input.toString()**，如果结果是原始类型，则返回这个结果。</li>\n<li>抛出TypeError异常。</li>\n</ol>\n<p><strong>以下是PreferredType不为Number时的执行顺序。</strong></p>\n<ul>\n<li>如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。</li>\n<li>如果PreferredType参数没有传入<ul>\n<li>如果input是内置的Date类型，PreferredType 视为String</li>\n<li>否则PreferredType 视为 Number</li>\n</ul>\n</li>\n</ul>\n<p><strong>可以看出，ToPrimitive依赖于valueOf和toString的实现。</strong></p>\n<p>（2）ToBoolean ( argument )</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-19-084743.png\" alt=\"image-20210819164742154\" style=\"zoom:50%;\" />\n\n<p>只需要记忆 <em>0, null, undefined, NaN, “”</em> 返回 <em>false</em> 就可以了，其他一律返回 <em>true</em>。</p>\n<p>（3）ToNumber ( argument )</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-19-084928.png\" alt=\"image-20210819164927980\" style=\"zoom:50%;\" />\n\n<p>ToNumber的转化并不总是成功，有时会转化成NaN，有时则直接抛出异常。</p>\n<p>（4）ToString ( argument )</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-19-085006.png\" alt=\"image-20210819165004906\" style=\"zoom:50%;\" />\n\n<p>当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。</p>\n</blockquote>\n<h3 id=\"102-‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么-（字节）\"><a href=\"#102-‘1’-‘2’-‘3’-map-parseInt-结果是什么，为什么-（字节）\" class=\"headerlink\" title=\"102. [‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么 （字节）\"></a>102. [‘1’, ‘2’, ‘3’].map(parseInt) 结果是什么，为什么 （字节）</h3><blockquote>\n<p>参考答案：</p>\n<p>[1, NaN, NaN]</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>一、为什么会是这个结果？</p>\n<ol>\n<li><em>map</em> 函数</li>\n</ol>\n<p>将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 <em>[‘1’,’2’,’3’].map(parseInt)</em> 就是将字符串 <em>1，2，3</em> 作为元素；<em>0，1，2</em> 作为下标分别调用 <em>parseInt</em> 函数。即分别求出 <em>parseInt(‘1’,0), parseInt(‘2’,1), parseInt(‘3’,2)</em> 的结果。</p>\n<ol start=\"2\">\n<li><em>parseInt</em> 函数（重点）</li>\n</ol>\n<p>概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) &#x2F;&#x2F;结果为2</p>\n<p>特点：接收两个参数 <em>parseInt(string,radix)</em></p>\n<p><em>string</em>：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 ‘2’、’2w’、’2!’</p>\n<p><em>radix</em>：解析字符串的基数，基数规则如下：</p>\n<p>  1）   区间范围介于 <em>2~36</em> 之间；</p>\n<p>  2 ）  当参数为 <em>0</em>，<em>parseInt( )</em> 会根据十进制来解析；</p>\n<p>  3 ）  如果忽略该参数，默认的基数规则：</p>\n<p>​\t\t如果 <em>string</em> 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt(“0xf”)   &#x2F;&#x2F; 15<br>​\t\t如果 <em>string</em> 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt(“08”)   &#x2F;&#x2F; 8<br>​\t\t如果 <em>string</em> 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt(“88.99f”)   &#x2F;&#x2F; 88<br>​\t\t只有字符串中的第一个数字会被返回。parseInt(“10.33”)   &#x2F;&#x2F; 返回10；<br>​\t\t开头和结尾的空格是允许的。parseInt(“ 69 10 “)   &#x2F;&#x2F; 返回69<br>​\t\t如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt(“f”)  &#x2F;&#x2F; 返回 NaN  而 parseInt(“f”，16)  &#x2F;&#x2F; 返回15</p>\n<p>二、<em>parseInt</em> 方法解析的运算过程</p>\n<p>parseInt(‘101.55’,10); &#x2F;&#x2F; 以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。</p>\n<p>parseInt(‘101’,2);  &#x2F;&#x2F; 以二进制解析，运算过程：1<em>2的2次方+0</em>2的1次方+1*2的0次方&#x3D;4+0+1&#x3D;5，结果为 5。</p>\n<p>parseInt(‘101’,8);  &#x2F;&#x2F; 以八进制解析，运算过程：1<em>8的2次方+0</em>8的1次方+1*8的0次方&#x3D;64+0+1&#x3D;65，结果为 65。</p>\n<p>parseInt(‘101’,16);  &#x2F;&#x2F; 以十六进制解析，运算过程：1<em>16的2次方+0</em>16的1次方+1*16的0次方&#x3D;256+0+1&#x3D;257，结果为 257。</p>\n<p>三、再来分析一下结果</p>\n<p><em>[‘1’,’2’,’3’].map(parseInt)</em> 即</p>\n<p>parseInt(‘1’,0); radix 为 0，parseInt( ) 会根据十进制来解析，所以结果为 <em>1</em>；</p>\n<p>parseInt(‘2’,1); radix 为 1，超出区间范围，所以结果为 <em>NaN</em>；</p>\n<p>parseInt(‘3’,2); radix 为 2，用2进制来解析，应以 <em>0</em> 和 <em>1</em> 开头，所以结果为 <em>NaN</em>。</p>\n</blockquote>\n<h3 id=\"103-防抖，节流是什么，如何实现-（字节）\"><a href=\"#103-防抖，节流是什么，如何实现-（字节）\" class=\"headerlink\" title=\"103. 防抖，节流是什么，如何实现 （字节）\"></a>103. 防抖，节流是什么，如何实现 （字节）</h3><blockquote>\n<p>参考答案：</p>\n<p>我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，<em>onmousemove、resize、onscroll</em> 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。</p>\n<p>函数防抖(<em>debounce</em>)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。</p>\n<p>具体实现：</p>\n<pre><code class=\"javascript\">/**\n * 函数防抖\n * @param &#123;function&#125; func 一段时间后，要调用的函数\n * @param &#123;number&#125; wait 等待的时间，单位毫秒\n */\nfunction debounce(func, wait)&#123;\n    // 设置变量，记录 setTimeout 得到的 id\n    let timerId = null;\n    return function(...args)&#123;\n        if(timerId)&#123;\n            // 如果有值，说明目前正在等待中，清除它\n            clearTimeout(timerId);\n        &#125;\n        // 重新开始计时\n        timerId = setTimeout(() =&gt; &#123;\n            func(...args);\n        &#125;, wait);\n    &#125;\n&#125;\n</code></pre>\n<p>函数节流(<em>throttle</em>)，指连续触发事件但是在 <em>n</em> 秒中只执行一次函数。即 <em>2n</em> 秒内执行 <em>2</em> 次… 。节流如字面意思，会稀释函数的执行频率。</p>\n<p>具体实现：</p>\n<pre><code class=\"javascript\">function throttle(func, wait) &#123;\n    let context, args;\n    let previous = 0;\n    return function () &#123;\n        let now = +new Date();\n        context = this;\n        args = arguments;\n        if (now - previous &gt; wait) &#123;\n            func.apply(context, args);\n            previous = now;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"104-介绍下-Set、Map、WeakSet-和-WeakMap-的区别（字节）\"><a href=\"#104-介绍下-Set、Map、WeakSet-和-WeakMap-的区别（字节）\" class=\"headerlink\" title=\"104. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别（字节）\"></a>104. 介绍下 <em>Set、Map、WeakSet</em> 和 <em>WeakMap</em> 的区别（字节）</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>Set</strong></p>\n<ul>\n<li><p>成员唯一、无序且不重复</p>\n</li>\n<li><p>键值与键名是一致的（或者说只有键值，没有键名）</p>\n</li>\n<li><p>可以遍历，方法有 <em>add, delete,has</em></p>\n</li>\n</ul>\n<p><strong>WeakSet</strong></p>\n<ul>\n<li><p>成员都是对象</p>\n</li>\n<li><p>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 <em>DOM</em> 节点，不容易造成内存泄漏</p>\n</li>\n<li><p>不能遍历，方法有 <em>add, delete,has</em></p>\n</li>\n</ul>\n<p><strong>Map</strong></p>\n<ul>\n<li><p>本质上是健值对的集合，类似集合</p>\n</li>\n<li><p>可以遍历，方法很多，可以跟各种数据格式转换</p>\n</li>\n</ul>\n<p><strong>WeakMap</strong></p>\n<ul>\n<li><p>只接受对象作为健名（<em>null</em> 除外），不接受其他类型的值作为健名</p>\n</li>\n<li><p>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾机制回收，此时键名是无效的</p>\n</li>\n<li><p>不能遍历，方法有 <em>get、set、has、delete</em></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"105-setTimeout、Promise、Async-x2F-Await-的区别（字节）\"><a href=\"#105-setTimeout、Promise、Async-x2F-Await-的区别（字节）\" class=\"headerlink\" title=\"105. setTimeout、Promise、Async&#x2F;Await 的区别（字节）\"></a>105. <em>setTimeout、Promise、Async&#x2F;Await</em> 的区别（字节）</h3><blockquote>\n<p>参考答案：</p>\n<p>事件循环中分为宏任务队列和微任务队列。</p>\n<p>其中 <em>setTimeout</em> 的回调函数放到宏任务队列里，等到执行栈清空以后执行；</p>\n<p><em>promise.then</em> 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；</p>\n<p><em>async</em> 函数表示函数里面可能会有异步方法，<em>await</em> 后面跟一个表达式，<em>async</em> 方法执行时，遇到 <em>await</em> 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</p>\n</blockquote>\n<h3 id=\"106-Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？（字节）\"><a href=\"#106-Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？（字节）\" class=\"headerlink\" title=\"106. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？（字节）\"></a>106. <em>Promise</em> 构造函数是同步执行还是异步执行，那么 <em>then</em> 方法呢？（字节）</h3><blockquote>\n<p>参考答案：</p>\n<p><em>promise</em> 构造函数是同步执行的，<em>then</em> 方法是异步执行，<em>then</em> 方法中的内容加入微任务中。</p>\n</blockquote>\n<h3 id=\"107-情人节福利题，如何实现一个-new-（字节）\"><a href=\"#107-情人节福利题，如何实现一个-new-（字节）\" class=\"headerlink\" title=\"107. 情人节福利题，如何实现一个 new （字节）\"></a>107. 情人节福利题，如何实现一个 <em>new</em> （字节）</h3><blockquote>\n<p>参考答案：<br>首先我们需要明白 <em>new</em> 的原理。关于 <em>new</em> 的原理，主要分为以下几步：</p>\n<ul>\n<li><p>创建一个空对象 。</p>\n</li>\n<li><p>由 <em>this</em> 变量引用该对象 。</p>\n</li>\n<li><p>该对象继承该函数的原型(更改原型链的指向) 。</p>\n</li>\n<li><p>把属性和方法加入到 <em>this</em> 引用的对象中。</p>\n</li>\n<li><p>新创建的对象由 <em>this</em> 引用 ，最后隐式地返回 <em>this</em></p>\n</li>\n</ul>\n<p>明白了这个原理后，我们就可以尝试来实现一个 <em>new</em> 方法，参考示例如下：</p>\n<pre><code class=\"javascript\">// 构造器函数\nlet Parent = function (name, age) &#123;\n    this.name = name;\n    this.age = age;\n&#125;;\nParent.prototype.sayName = function () &#123;\n    console.log(this.name);\n&#125;;\n//自己定义的new方法\nlet newMethod = function (Parent, ...rest) &#123;\n    // 1.以构造器的prototype属性为原型，创建新对象；\n    let child = Object.create(Parent.prototype);\n    // 2.将this和调用参数传给构造器执行\n    let result = Parent.apply(child, rest);\n    // 3.如果构造器没有手动返回对象，则返回第一步的对象\n    return typeof result === &#39;object&#39; ? result : child;\n&#125;;\n//创建实例，将构造函数Parent与形参作为参数传入\nconst child = newMethod(Parent, &#39;echo&#39;, 26);\nchild.sayName() //&#39;echo&#39;;\n//最后检验，与使用new的效果相同\nconsole.log(child instanceof Parent)//true\nconsole.log(child.hasOwnProperty(&#39;name&#39;))//true\nconsole.log(child.hasOwnProperty(&#39;age&#39;))//true\nconsole.log(child.hasOwnProperty(&#39;sayName&#39;))//false\n</code></pre>\n</blockquote>\n<h3 id=\"108-实现一个-sleep-函数（字节）\"><a href=\"#108-实现一个-sleep-函数（字节）\" class=\"headerlink\" title=\"108. 实现一个 sleep 函数（字节）\"></a>108. 实现一个 <em>sleep</em> 函数（字节）</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function sleep(delay) &#123;\n    var start = (new Date()).getTime();\n    while ((new Date()).getTime() - start &lt; delay) &#123;\n        continue;\n    &#125;\n&#125;\n\nfunction test() &#123;\n    console.log(&#39;111&#39;);\n    sleep(2000);\n    console.log(&#39;222&#39;);\n&#125;\n\ntest()\n</code></pre>\n<p>这种实现方式是利用一个伪死循环阻塞主线程。因为 <em>JS</em> 是单线程的。所以通过这种方式可以实现真正意义上的 <em>sleep</em>。</p>\n</blockquote>\n<h3 id=\"109-使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果-（字节）\"><a href=\"#109-使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果-（字节）\" class=\"headerlink\" title=\"109. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 （字节）\"></a>109. 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 （字节）</h3><blockquote>\n<p>参考答案：</p>\n<p><em>sort</em> 方法默认按照 <em>ASCII</em> 码来排序，如果要按照数字大小来排序，需要传入一个回调函数，如下：</p>\n<pre><code class=\"javascript\">[3, 15, 8, 29, 102, 22].sort((a,b) =&gt; &#123;return a - b&#125;);\n</code></pre>\n</blockquote>\n<h3 id=\"110-实现-5-add-3-sub-2-百度\"><a href=\"#110-实现-5-add-3-sub-2-百度\" class=\"headerlink\" title=\"110. 实现 5.add(3).sub(2) (百度)\"></a>110. 实现 5.add(3).sub(2) (百度)</h3><blockquote>\n<p>参考答案：</p>\n<p>这里想要实现的是链式操作，那么我们可以考虑在 <em>Number</em> 类型的原型上添加 <em>add</em> 和 <em>sub</em> 方法，这两个方法返回新的数</p>\n<p>示例如下：</p>\n<pre><code class=\"javascript\">Number.prototype.add = function (number) &#123;\n    if (typeof number !== &#39;number&#39;) &#123;\n        throw new Error(&#39;请输入数字～&#39;);\n    &#125;\n    return this.valueOf() + number;\n&#125;;\nNumber.prototype.minus = function (number) &#123;\n    if (typeof number !== &#39;number&#39;) &#123;\n        throw new Error(&#39;请输入数字～&#39;);\n    &#125;\n    return this.valueOf() - number;\n&#125;;\nconsole.log((5).add(3).minus(2)); // 6\n</code></pre>\n</blockquote>\n<h3 id=\"111-给定两个数组，求交集\"><a href=\"#111-给定两个数组，求交集\" class=\"headerlink\" title=\"111. 给定两个数组，求交集\"></a>111. 给定两个数组，求交集</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">function intersect(nums1, nums2) &#123;\n    let i = j = 0,\n        len1 = nums1.length,\n        len2 = nums2.length,\n        newArr = [];\n    if (len1 === 0 || len2 === 0) &#123;\n        return newArr;\n    &#125;\n    nums1.sort(function (a, b) &#123;\n        return a - b;\n    &#125;);\n    nums2.sort(function (a, b) &#123;\n        return a - b;\n    &#125;);\n    while (i &lt; len1 || j &lt; len2) &#123;\n        if (nums1[i] &gt; nums2[j]) &#123;\n            j++;\n        &#125; else if (nums1[i] &lt; nums2[j]) &#123;\n            i++;\n        &#125; else &#123;\n            if (nums1[i] === nums2[j]) &#123;\n                newArr.push(nums1[i]);\n            &#125;\n            if (i &lt; len1 - 1) &#123;\n                i++;\n            &#125; else &#123;\n                break;\n            &#125;\n            if (j &lt; len2 - 1) &#123;\n                j++;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return newArr;\n&#125;;\n// 测试\nconsole.log(intersect([3, 5, 8, 1], [2, 3]));\n</code></pre>\n</blockquote>\n<h3 id=\"112-为什么普通-for-循环的性能远远高于-forEach-的性能，请解释其中的原因。\"><a href=\"#112-为什么普通-for-循环的性能远远高于-forEach-的性能，请解释其中的原因。\" class=\"headerlink\" title=\"112. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。\"></a>112. 为什么普通 <em>for</em> 循环的性能远远高于 <em>forEach</em> 的性能，请解释其中的原因。</h3><blockquote>\n<p>参考答案：</p>\n<p><em>for</em> 循环按顺序遍历，<em>forEach</em> 使用 <em>iterator</em> 迭代器遍历</p>\n<p>下面是一段性能测试的代码：</p>\n<pre><code class=\"javascript\">let arrs = new Array(100000);\nconsole.time(&#39;for&#39;);\nfor (let i = 0; i &lt; arrs.length; i++) &#123;\n&#125;;\nconsole.timeEnd(&#39;for&#39;);\nconsole.time(&#39;forEach&#39;);\narrs.forEach((arr) =&gt; &#123;\n&#125;);\nconsole.timeEnd(&#39;forEach&#39;);\n\nfor: 2.263ms\nforEach: 0.254ms\n</code></pre>\n<p>在10万这个级别下，<code>forEach</code>的性能是<code>for</code>的十倍</p>\n<pre><code class=\"javascript\">for: 2.263ms\nforEach: 0.254ms\n</code></pre>\n<p>在100万这个量级下，<code>forEach</code>的性能是和<code>for</code>的一致</p>\n<pre><code class=\"javascript\">for: 2.844ms\nforEach: 2.652ms\n</code></pre>\n<p>在1000万级以上的量级上 ，<code>forEach</code>的性能远远低于<code>for</code>的性能</p>\n<pre><code class=\"javascript\">for: 8.422ms\nforEach: 30.328m\n</code></pre>\n<p>我们从语法上面来观察：</p>\n<pre><code class=\"javascript\">arr.forEach(callback(currentValue [, index [, array]])[, thisArg])\n</code></pre>\n<p>可以看到 <em>forEach</em> 是有回调的，它会按升序为数组中含有效值的每一项执行一次 <em>callback</em>，且除了抛出异常以外，也没有办法中止或者跳出 <em>forEach</em> 循环。那这样的话执行就会额外的调用栈和函数内的上下文。</p>\n<p>而 <em>for</em> 循环则是底层写法，不会产生额外的消耗。</p>\n<p>在实际业务中没有很大的数组时，<em>for</em> 和 <em>forEach</em> 的性能差距其实很小，<em>forEach</em> 甚至会优于 <em>for</em> 的时间，且更加简洁，可读性也更高，一般也会优先使用 <em>forEach</em> 方法来进行数组的循环处理。</p>\n</blockquote>\n<h3 id=\"113-实现一个字符串匹配算法，从长度为-n-的字符串-S-中，查找是否存在字符串-T，T-的长度是-m，若存在返回所在位置。\"><a href=\"#113-实现一个字符串匹配算法，从长度为-n-的字符串-S-中，查找是否存在字符串-T，T-的长度是-m，若存在返回所在位置。\" class=\"headerlink\" title=\"113. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。\"></a>113. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">// 完全不用 API\nvar getIndexOf = function (s, t) &#123;\n    let n = s.length;\n    let m = t.length;\n    if (!n || !m || n &lt; m) return -1;\n    for (let i = 0; i &lt; n; i++) &#123;\n        let j = 0;\n        let k = i;\n        if (s[k] === t[j]) &#123;\n            k++; j++;\n            while (k &lt; n &amp;&amp; j &lt; m) &#123;\n                if (s[k] !== t[j]) break;\n                else &#123;\n                    k++; j++;\n                &#125;\n            &#125;\n            if (j === m) return i;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n\n// 测试\nconsole.log(getIndexOf(&quot;Hello World&quot;, &quot;rl&quot;))\n</code></pre>\n</blockquote>\n<h3 id=\"114-使用-JavaScript-Proxy-实现简单的数据绑定\"><a href=\"#114-使用-JavaScript-Proxy-实现简单的数据绑定\" class=\"headerlink\" title=\"114. 使用 JavaScript Proxy 实现简单的数据绑定\"></a>114. 使用 <em>JavaScript Proxy</em> 实现简单的数据绑定</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">&lt;body&gt;\n  hello,world\n  &lt;input type=&quot;text&quot; id=&quot;model&quot;&gt;\n  &lt;p id=&quot;word&quot;&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  const model = document.getElementById(&quot;model&quot;)\n  const word = document.getElementById(&quot;word&quot;)\n  var obj= &#123;&#125;;\n\n  const newObj = new Proxy(obj, &#123;\n      get: function(target, key, receiver) &#123;\n        console.log(`getting $&#123;key&#125;!`);\n        return Reflect.get(target, key, receiver);\n      &#125;,\n      set: function(target, key, value, receiver) &#123;\n        console.log(&#39;setting&#39;,target, key, value, receiver);\n        if (key === &quot;text&quot;) &#123;\n          model.value = value;\n          word.innerHTML = value;\n        &#125;\n        return Reflect.set(target, key, value, receiver);\n      &#125;\n    &#125;);\n\n  model.addEventListener(&quot;keyup&quot;,function(e)&#123;\n    newObj.text = e.target.value\n  &#125;)\n&lt;/script&gt;\n</code></pre>\n</blockquote>\n<h3 id=\"115-数组里面有-10-万个数据，取第一个元素和第-10-万个元素的时间相差多少（字节）\"><a href=\"#115-数组里面有-10-万个数据，取第一个元素和第-10-万个元素的时间相差多少（字节）\" class=\"headerlink\" title=\"115. 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少（字节）\"></a>115. 数组里面有 <em>10</em> 万个数据，取第一个元素和第 <em>10</em> 万个元素的时间相差多少（字节）</h3><blockquote>\n<p>参考答案：</p>\n<p>消耗时间几乎一致，差异可以忽略不计</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<ul>\n<li>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)</li>\n<li><em>JavaScript</em> 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 <em>key</em>）来使用。所以无论是取第 <em>1</em> 个还是取第 <em>10</em> 万个元素，都是用 <em>key</em> 精确查找哈希表的过程，其消耗时间大致相同。</li>\n</ul>\n</blockquote>\n<h3 id=\"116-打印出-1-10000-以内的对称数\"><a href=\"#116-打印出-1-10000-以内的对称数\" class=\"headerlink\" title=\"116. 打印出 1~10000 以内的对称数\"></a>116. 打印出 <em>1~10000</em> 以内的对称数</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function isSymmetryNum(start, end) &#123;\n    for (var i = start; i &lt; end + 1; i++) &#123;\n        var iInversionNumber = +(i.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));\n\n        if (iInversionNumber === i &amp;&amp; i &gt; 10) &#123;\n            console.log(i);\n        &#125;\n\n    &#125;\n&#125;\nisSymmetryNum(1, 10000);\n</code></pre>\n</blockquote>\n<h3 id=\"117-简述同步和异步的区别\"><a href=\"#117-简述同步和异步的区别\" class=\"headerlink\" title=\"117. 简述同步和异步的区别\"></a>117. 简述同步和异步的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>同步意味着每一个操作必须等待前一个操作完成后才能执行。<br> 异步意味着操作不需要等待其他操作完成后才开始执行。<br> 在 <em>JavaScript</em> 中，由于单线程的特性导致所有代码都是同步的。但是，有些异步操作（例如：<code>XMLHttpRequest</code> 或 <code>setTimeout</code>）并不是由主线程进行处理的，他们由本机代码（浏览器 API）所控制，并不属于程序的一部分。但程序中被执行的回调部分依旧是同步的。</p>\n<p>加分回答：</p>\n<ul>\n<li><em>JavaScript</em> 中的同步任务是指在主线程上排队执行的任务，只有前一个任务执行完成后才能执行后一个任务；异步任务是指进入任务队列（<em>task queue</em>）而非主线程的任务，只有当任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程中进行执行。</li>\n<li><em>JavaScript</em> 的并发模型是基于 “<em>event loop</em>”。</li>\n<li>像 <code>alert</code> 这样的方法回阻塞主线程，以致用户关闭他后才能继续进行后续的操作。</li>\n<li><em>JavaScript</em> 主要用于和用户互动及操作 DOM，多线程的情况和异步操作带来的复杂性相比决定了他单线程的特性。</li>\n<li><em>Web Worker</em> 虽然允许 <em>JavaScript</em> 创建多个线程，但子线程完全受主线程控制，且不能操作 <em>DOM</em>。因此他还是保持了单线程的特性。</li>\n</ul>\n</blockquote>\n<h3 id=\"118-怎么添加、移除、复制、创建、和查找节点\"><a href=\"#118-怎么添加、移除、复制、创建、和查找节点\" class=\"headerlink\" title=\"118. 怎么添加、移除、复制、创建、和查找节点\"></a>118. 怎么添加、移除、复制、创建、和查找节点</h3><blockquote>\n<p>参考答案：</p>\n<p>1）创建新节点</p>\n<p><em>createDocumentFragment</em>( )  &#x2F;&#x2F; 创建一个<em>DOM</em> 片段</p>\n<p><em>createElement</em>( )  &#x2F;&#x2F; 创建一个具体的元素</p>\n<p><em>createTextNode</em>( ) &#x2F;&#x2F; 创建一个文本节点</p>\n<p>（2）添加、移除、替换、插入</p>\n<p><em>appendChild</em>( )</p>\n<p><em>removeChild</em>( )</p>\n<p><em>replaceChild</em>( )</p>\n<p><em>insertBefore</em>( ) &#x2F;&#x2F; 在已有的子节点前插入一个新的子节点</p>\n<p>（3）查找</p>\n<p><em>getElementsByTagName</em>( )  &#x2F;&#x2F;通过标签名称</p>\n<p><em>getElementsByName</em>( ) &#x2F;&#x2F; 通过元素的 <em>Name</em> 属性的值</p>\n<p><em>getElementById</em>( ) &#x2F;&#x2F; 通过元素 <em>Id</em>，唯一性</p>\n<p><em>querySelector</em>( ) &#x2F;&#x2F; 用于接收一个 <em>CSS</em> 选择符，返回与该模式匹配的第一个元素</p>\n<p><em>querySelectorAll</em>( ) &#x2F;&#x2F; 用于选择匹配到的所有元素</p>\n</blockquote>\n<h3 id=\"119-实现一个函数-clone-可以对-Javascript-中的五种主要数据类型（Number、string、-Object、Array、Boolean）进行复制\"><a href=\"#119-实现一个函数-clone-可以对-Javascript-中的五种主要数据类型（Number、string、-Object、Array、Boolean）进行复制\" class=\"headerlink\" title=\"119. 实现一个函数 clone 可以对 Javascript 中的五种主要数据类型（Number、string、 Object、Array、Boolean）进行复制\"></a>119. 实现一个函数 <em>clone</em> 可以对 <em>Javascript</em> 中的五种主要数据类型（<em>Number、string、 Object、Array、Boolean</em>）进行复制</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">/**\n* 对象克隆\n* 支持基本数据类型及对象\n* 递归方法\n*/\nfunction clone(obj) &#123;\n    var o;\n    switch (typeof obj) &#123;\n        case &quot;undefined&quot;:\n            break;\n        case &quot;string&quot;:\n            o = obj + &quot;&quot;;\n            break;\n        case &quot;number&quot;:\n            o = obj - 0;\n            break;\n        case &quot;boolean&quot;:\n            o = obj;\n            break;\n        case &quot;object&quot;: // object 分为两种情况 对象（Object）或数组（Array）\n            if (obj === null) &#123;\n                o = null;\n            &#125; else &#123;\n                if (Object.prototype.toString.call(obj).slice(8, -1) === &quot;Array&quot;) &#123;\n                    o = [];\n                    for (var i = 0; i &lt; obj.length; i++) &#123;\n                        o.push(clone(obj[i]));\n                    &#125;\n                &#125; else &#123;\n                    o = &#123;&#125;;\n                    for (var k in obj) &#123;\n                        o[k] = clone(obj[k]);\n                    &#125;\n                &#125;\n            &#125;\n            break;\n        default:\n            o = obj;\n            break;\n    &#125;\n    return o;\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"120-如何消除一个数组里面重复的元素\"><a href=\"#120-如何消除一个数组里面重复的元素\" class=\"headerlink\" title=\"120. 如何消除一个数组里面重复的元素\"></a>120. 如何消除一个数组里面重复的元素</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>2</em> 题。</p>\n</blockquote>\n<h3 id=\"121-写一个返回闭包的函数\"><a href=\"#121-写一个返回闭包的函数\" class=\"headerlink\" title=\"121. 写一个返回闭包的函数\"></a>121. 写一个返回闭包的函数</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function foo() &#123;\n    var i = 0;\n    return function () &#123;\n        console.log(i++);\n    &#125;\n&#125;\nvar f1 = foo();\nf1(); // 0\nf1(); // 1\nf1(); // 2\n</code></pre>\n</blockquote>\n<h3 id=\"122-使用递归完成-1-到-100-的累加\"><a href=\"#122-使用递归完成-1-到-100-的累加\" class=\"headerlink\" title=\"122. 使用递归完成 1 到 100 的累加\"></a>122. 使用递归完成 1 到 100 的累加</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function add(x, y)&#123;\n    if(x === y)&#123;\n        return x;\n    &#125; else &#123;\n        return y + add(x, y-1);\n    &#125;\n&#125;\n\nconsole.log(add(1, 100))\n</code></pre>\n</blockquote>\n<h3 id=\"123-Javascript-有哪几种数据类型\"><a href=\"#123-Javascript-有哪几种数据类型\" class=\"headerlink\" title=\"123. Javascript 有哪几种数据类型\"></a>123. <em>Javascript</em> 有哪几种数据类型</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>26</em> 题。</p>\n</blockquote>\n<h3 id=\"124-如何判断数据类型\"><a href=\"#124-如何判断数据类型\" class=\"headerlink\" title=\"124. 如何判断数据类型\"></a>124. 如何判断数据类型</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>69</em> 题。</p>\n</blockquote>\n<h3 id=\"125-console-log-1-’2’-和-console-log-1-‘2’-的打印结果\"><a href=\"#125-console-log-1-’2’-和-console-log-1-‘2’-的打印结果\" class=\"headerlink\" title=\"125. console.log(1+’2’)和 console.log(1-‘2’)的打印结果\"></a>125. console.log(1+’2’)和 console.log(1-‘2’)的打印结果</h3><blockquote>\n<p>参考答案：</p>\n<p>第一个打印出 ‘12’，是一个 <em>string</em> 类型的值。</p>\n<p>第二个打印出 -1，是一个 <em>number</em> 类型的值</p>\n</blockquote>\n<h3 id=\"126-JS-的事件委托是什么，原理是什么\"><a href=\"#126-JS-的事件委托是什么，原理是什么\" class=\"headerlink\" title=\"126. JS 的事件委托是什么，原理是什么\"></a>126. <em>JS</em> 的事件委托是什么，原理是什么</h3><blockquote>\n<p>参考答案：</p>\n<p>事件委托，又被称之为事件代理。在 <em>JavaScript</em> 中，添加到页面上的事件处理程序数量将直接关系到页面整体的运行性能。导致这一问题的原因是多方面的。</p>\n<p>首先，每个函数都是对象，都会占用内存。内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 <em>DOM</em> 访问次数，会延迟整个页面的交互就绪时间。</p>\n<p>对事件处理程序过多问题的解决方案就是事件委托。</p>\n<p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，<em>click</em> 事件会一直冒泡到 <em>document</em> 层次。也就是说，我们可以为整个页面指定一个 <em>onclick</em> 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>\n</blockquote>\n<h3 id=\"127-如何改变函数内部的-this-指针的指向\"><a href=\"#127-如何改变函数内部的-this-指针的指向\" class=\"headerlink\" title=\"127. 如何改变函数内部的 this 指针的指向\"></a>127. 如何改变函数内部的 <em>this</em> 指针的指向</h3><blockquote>\n<p>参考答案：</p>\n<p>可以通过 <em>call、apply、bind</em> 方法来改变 <em>this</em> 的指向，关于 <em>call、apply、bind</em> 方法的具体使用，请参阅前面 <em>102</em> 题</p>\n</blockquote>\n<h3 id=\"128-JS-延迟加载的方式有哪些？\"><a href=\"#128-JS-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"128. JS 延迟加载的方式有哪些？\"></a>128. <em>JS</em> 延迟加载的方式有哪些？</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li><em>defer</em> 属性</li>\n<li><em>async</em> 属性</li>\n<li>使用 <em>jQuery</em> 的 <em>getScript</em>( ) 方法</li>\n<li>使用 <em>setTimeout</em> 延迟方法</li>\n<li>把 <em>JS</em> 外部引入的文件放到页面底部，来让 <em>JS</em> 最后引入</li>\n</ul>\n</blockquote>\n<h3 id=\"129-说说严格模式的限制\"><a href=\"#129-说说严格模式的限制\" class=\"headerlink\" title=\"129. 说说严格模式的限制\"></a>129. 说说严格模式的限制</h3><blockquote>\n<p>参考答案：</p>\n<p>什么是严格模式？</p>\n<p>严格模式对 <em>JavaScript</em> 的语法和行为都做了一些更改，消除了语言中一些不合理、不确定、不安全之处；提供高效严谨的差错机制，保证代码安全运行；禁用在未来版本中可能使用的语法，为新版本做好铺垫。在脚本文件第一行或函数内第一行中引入”use strict”这条指令，就能触发严格模式，这是一条没有副作用的指令，老版的浏览器会将其作为一行字符串直接忽略。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">&quot;use strict&quot;;//脚本第一行\nfunction add(a,b)&#123;\n    &quot;use strict&quot;;//函数内第一行\n    return a+b;\n&#125;\n</code></pre>\n<p>进入严格模式后的限制</p>\n<ul>\n<li>变量必须声明后再赋值</li>\n<li>不能有重复的参数名，函数的参数也不能有同名属性</li>\n<li>不能使用<em>with</em>语句</li>\n<li>不能对只读属性赋值</li>\n<li>不能使用前缀  <em>0</em>表示八进制数</li>\n<li>不能删除不可删除的属性</li>\n<li><em>eval</em> 不会在它的外层作用域引入变量。</li>\n<li><em>eval</em>和<em>arguments</em>不能被重新赋值</li>\n<li><em>arguments</em> 不会自动反应函数的变化</li>\n<li>不能使用 <em>arguments.callee</em></li>\n<li>不能使用 <em>arguments.caller</em></li>\n<li>禁止 <em>this</em> 指向全局对象</li>\n<li>不能使用 <em>fn.caller</em> 和 <em>fn.arguments</em> 获取函数调用的堆栈</li>\n<li>增加了保留字</li>\n</ul>\n</blockquote>\n<h3 id=\"130-attribute-和-property-的区别是什么？\"><a href=\"#130-attribute-和-property-的区别是什么？\" class=\"headerlink\" title=\"130. attribute 和 property 的区别是什么？\"></a>130. <em>attribute</em> 和 <em>property</em> 的区别是什么？</h3><blockquote>\n<p>参考答案：</p>\n<p>property 和 attribute 非常容易混淆，两个单词的中文翻译也都非常相近（property：属性，attribute：特性），但实际上，二者是不同的东西，属于不同的范畴。</p>\n<ul>\n<li>property是DOM中的属性，是JavaScript里的对象；</li>\n<li>attribute是HTML标签上的特性，它的值只能够是字符串；</li>\n</ul>\n<p>简单理解，Attribute就是dom节点自带的属性，例如html中常用的id、class、title、align等。</p>\n<p>而Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。</p>\n</blockquote>\n<h3 id=\"131-ES6-能写-class-么，为什么会出现-class-这种东西\"><a href=\"#131-ES6-能写-class-么，为什么会出现-class-这种东西\" class=\"headerlink\" title=\"131. ES6 能写 class 么，为什么会出现 class 这种东西?\"></a>131. <em>ES6</em> 能写 <em>class</em> 么，为什么会出现 <em>class</em> 这种东西?</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>ES6</em> 中，可以书写 <em>class</em>。因为在 <em>ES6</em> 规范中，引入了 <em>class</em> 的概念。使得 <em>JS</em> 开发者终于告别了直接使用原型对象模仿面向对象中的类和类继承时代。</p>\n<p>但是 <em>JS</em> 中并没有一个真正的 <em>class</em> 原始类型， <em>class</em> 仅仅只是对原型对象运用语法糖。</p>\n<p>之所以出现 <em>class</em> 关键字，是为了使 <em>JS</em> 更像面向对象，所以 <em>ES6</em> 才引入 <em>class</em> 的概念。</p>\n</blockquote>\n<h3 id=\"132-常见兼容性问题\"><a href=\"#132-常见兼容性问题\" class=\"headerlink\" title=\"132. 常见兼容性问题\"></a>132. 常见兼容性问题</h3><blockquote>\n<p>参考答案：</p>\n<p>常见的兼容性问题很多，这里列举一些：</p>\n<ol>\n<li>关于获取行外样式 <em>currentStyle</em> 和 <em>getComputedStyle</em> 出现的兼容问题</li>\n</ol>\n<p>我们都知道 <em>JS</em> 通过 <em>style</em> 不可以获取行外样式，如果我们需要获取行外样式就会使用这两种</p>\n<ul>\n<li><p>IE 下：<em>currentStyle</em></p>\n</li>\n<li><p>chrome、FF 下：<em>getComputedStyle</em> 第二个参数的作用是获取伪类元素的属性值</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>关于“索引”获取字符串每一项出现的兼容性的问题</li>\n</ol>\n<p>对于字符串也有类似于数组这样通过下标索引获取每一项的值</p>\n<pre><code class=\"javascript\">var str = &#39;abcd&#39;;\nconsole.log(str[2]);\n</code></pre>\n<p>但是低版本的浏览器 <em>IE6、7</em> 不兼容</p>\n<ol start=\"3\">\n<li>关于使用 <em>firstChild、lastChild</em> 等，获取第一个&#x2F;最后一个元素节点是产生的问题</li>\n</ol>\n<ul>\n<li>IE6-8下： <em>firstChild,lastChild,nextSibling,previousSibling</em> 获取第一个元素节点</li>\n<li>高版本浏览器IE9+、FF、Chrome：获取的空白文本节点</li>\n</ul>\n<ol start=\"4\">\n<li>关于使用 <em>event</em> 对象，出现兼容性问题</li>\n</ol>\n<p>在 <em>IE8</em> 及之前的版本浏览器中，<em>event</em> 事件对象是作为 <em>window</em> 对象的一个属性。</p>\n<p>所以兼容的写法如下：</p>\n<pre><code class=\"javascript\">function(event)&#123;\n    event = event || window.event;\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>关于事件绑定的兼容性问题</li>\n</ol>\n<ul>\n<li><p><em>IE8</em> 以下用: attachEvent(‘事件名’,fn);</p>\n</li>\n<li><p><em>FF、Chrome、IE9-10</em> 用: attachEventLister(‘事件名’,fn,false);</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li>关于获取滚动条距离而出现的问题</li>\n</ol>\n<p>当我们获取滚动条滚动距离时:</p>\n<ul>\n<li><p><em>IE、Chrome: document.body.scrollTop</em></p>\n</li>\n<li><p><em>FF: document.documentElement.scrollTop</em></p>\n</li>\n</ul>\n<p>兼容处理:</p>\n<p><em>var scrollTop &#x3D; document.documentElement.scrollTop||document.body.scrollTop</em></p>\n</blockquote>\n<h3 id=\"133-函数防抖节流的原理\"><a href=\"#133-函数防抖节流的原理\" class=\"headerlink\" title=\"133. 函数防抖节流的原理\"></a>133. 函数防抖节流的原理</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>49、106</em> 题。</p>\n</blockquote>\n<h3 id=\"134-原始类型有哪几种？null-是对象吗？\"><a href=\"#134-原始类型有哪几种？null-是对象吗？\" class=\"headerlink\" title=\"134. 原始类型有哪几种？null 是对象吗？\"></a>134. 原始类型有哪几种？<em>null</em> 是对象吗？</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>JavaScript</em> 中，数据类型整体上来讲可以分为两大类：<strong>基本类型</strong>和<strong>引用数据类型</strong></p>\n<p>基本数据类型，一共有 <em>7</em> 种：</p>\n<pre><code class=\"text\">string，symbol，number，boolean，undefined，null，bigInt\n</code></pre>\n<p>其中 <em>symbol</em> 类型是在 <em>ES6</em> 里面新添加的基本数据类型。</p>\n<p>引用数据类型，就只有 <em>1</em> 种：</p>\n<pre><code class=\"javascript\">object\n</code></pre>\n<p>基本数据类型的值又被称之为原始值或简单值，而引用数据类型的值又被称之为复杂值或引用值。</p>\n<p>关于原始类型和引用类型的区别，可以参阅第 <em>26</em> 题。</p>\n<p><em>null</em> 表示空，但是当我们使用 <em>typeof</em> 来进行数据类型检测的时候，得到的值是 <em>object</em>。</p>\n<p>具体原因可以参阅前面第 <em>68</em> 题。</p>\n</blockquote>\n<h3 id=\"135-为什么-console-log-0-2-0-1-x3D-x3D-0-3-x2F-x2F-false\"><a href=\"#135-为什么-console-log-0-2-0-1-x3D-x3D-0-3-x2F-x2F-false\" class=\"headerlink\" title=\"135. 为什么 console.log(0.2+0.1&#x3D;&#x3D;0.3)  &#x2F;&#x2F; false\"></a>135. 为什么 <em>console.log(0.2+0.1&#x3D;&#x3D;0.3)  &#x2F;&#x2F; false</em></h3><blockquote>\n<p>参考答案：</p>\n<p>因为浮点数的计算存在 <em>round-off</em>  问题，也就是浮点数不能够进行精确的计算。并且：</p>\n<ul>\n<li>不仅 <em>JavaScript</em>，所有遵循 <em>IEEE 754</em> 规范的语言都是如此；</li>\n<li>在 <em>JavaScript</em> 中，所有的 <em>Number</em> 都是以 <em>64-bit</em> 的双精度浮点数存储的；</li>\n<li>双精度的浮点数在这 <em>64</em> 位上划分为 <em>3</em> 段，而这 <em>3</em> 段也就确定了一个浮点数的值，<em>64bit</em> 的划分是“<em>1-11-52</em>”的模式，具体来说：<ul>\n<li>就是 <em>1</em> 位最高位（最左边那一位）表示符号位，<em>0</em> 表示正，<em>1</em> 表示负；</li>\n<li><em>11</em> 位表示指数部分；</li>\n<li><em>52</em> 位表示尾数部分，也就是有效域部分</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"136-说一下-JS-中类型转换的规则？\"><a href=\"#136-说一下-JS-中类型转换的规则？\" class=\"headerlink\" title=\"136. 说一下 JS 中类型转换的规则？\"></a>136. 说一下 <em>JS</em> 中类型转换的规则？</h3><blockquote>\n<p>参考答案：</p>\n<p>类型转换可以分为两种，<strong>隐性转换</strong>和<strong>显性转换</strong>。</p>\n<p><strong>1. 隐性转换</strong></p>\n<p>当不同数据类型之间进行相互运算，或者当对非布尔类型的数据求布尔值的时候，会发生隐性转换。</p>\n<p>预期为数字的时候：算术运算的时候，我们的结果和运算的数都是数字，数据会转换为数字来进行计算。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>转换前</th>\n<th>转换后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>number</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>string</td>\n<td>“1”</td>\n<td>1</td>\n</tr>\n<tr>\n<td>string</td>\n<td>“abc”</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>string</td>\n<td>“”</td>\n<td>0</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>true</td>\n<td>1</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>false</td>\n<td>0</td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>null</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>预期为字符串的时候：如果有一个操作数为字符串时，使用<code>+</code>符号做相加运算时，会自动转换为字符串。</p>\n<p>预期为布尔的时候：前面在介绍布尔类型时所提到的 9 个值会转为 false，其余转为 true</p>\n<p><strong>2. 显性转换</strong></p>\n<p>所谓显性转换，就是只程序员强制将一种类型转换为另外一种类型。显性转换往往会使用到一些转换方法。常见的转换方法如下：</p>\n<ul>\n<li><p>转换为数值类型：<code>Number()</code>，<code>parseInt()</code>，<code>parseFloat()</code></p>\n</li>\n<li><p>转换为布尔类型：<code>Boolean()</code></p>\n</li>\n<li><p>转换为字符串类型：<code>toString()</code>，<code>String()</code></p>\n</li>\n</ul>\n<p>当然，除了使用上面的转换方法，我们也可以通过一些快捷方式来进行数据类型的显性转换，如下：</p>\n<ul>\n<li><p>转换字符串：直接和一个空字符串拼接，例如：<code>a = &quot;&quot; + 数据</code></p>\n</li>\n<li><p>转换布尔：!!数据类型，例如：<code>!!&quot;Hello&quot;</code></p>\n</li>\n<li><p>转换数值：数据*1 或 &#x2F;1，例如：<code>&quot;Hello * 1&quot;</code></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"137-深拷贝和浅拷贝的区别？如何实现\"><a href=\"#137-深拷贝和浅拷贝的区别？如何实现\" class=\"headerlink\" title=\"137. 深拷贝和浅拷贝的区别？如何实现\"></a>137. 深拷贝和浅拷贝的区别？如何实现</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li><p><strong>浅拷贝</strong>：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）</p>\n<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>\n</li>\n<li><p><strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。</p>\n</li>\n</ul>\n<p><strong>浅拷贝方法</strong></p>\n<ol>\n<li>直接赋值</li>\n<li><em>Object.assign</em> 方法：可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。当拷贝的 <em>object</em> 只有一层的时候，是深拷贝，但是当拷贝的对象属性值又是一个引用时，换句话说有多层时，就是一个浅拷贝。</li>\n<li><em>ES6</em> 扩展运算符，当 <em>object</em> 只有一层的时候，也是深拷贝。有多层时是浅拷贝。</li>\n<li><em>Array.prototype.concat</em> 方法</li>\n<li><em>Array.prototype.slice</em> 方法</li>\n<li><em>jQuery</em> 中的 <em>$.extend</em>：在 <em>jQuery</em> 中，*$.extend(deep,target,object1,objectN)* 方法可以进行深浅拷贝。<em>deep</em> 如过设为 <em>true</em> 为深拷贝，默认是 <em>false</em> 浅拷贝。</li>\n</ol>\n<p><strong>深拷贝方法</strong></p>\n<ol>\n<li>*$.extend(deep,target,object1,objectN)*，将 <em>deep</em> 设置为 <em>true</em></li>\n<li>*JSON.parse(JSON.stringify)*：用 <em>JSON.stringify</em> 将对象转成 <em>JSON</em> 字符串，再用 <em>JSON.parse</em> 方法把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</li>\n<li>手写递归</li>\n</ol>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">function deepCopy(oldObj, newobj) &#123;\n    for (var key in oldObj) &#123;\n        var item = oldObj[key];\n        // 判断是否是对象\n        if (item instanceof Object) &#123;\n            if (item instanceof Function) &#123;\n                newobj[key] = oldObj[key];\n            &#125; else &#123;\n                newobj[key] = &#123;&#125;;  //定义一个空的对象来接收拷贝的内容\n                deepCopy(item, newobj[key]); //递归调用\n            &#125;\n\n            // 判断是否是数组\n        &#125; else if (item instanceof Array) &#123;\n            newobj[key] = [];  //定义一个空的数组来接收拷贝的内容\n            deepCopy(item, newobj[key]); //递归调用\n        &#125; else &#123;\n            newobj[key] = oldObj[key];\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"138-如何判断-this？箭头函数的-this-是什么\"><a href=\"#138-如何判断-this？箭头函数的-this-是什么\" class=\"headerlink\" title=\"138. 如何判断 this？箭头函数的 this 是什么\"></a>138. 如何判断 <em>this</em>？箭头函数的 <em>this</em> 是什么</h3><blockquote>\n<p>参考答案：</p>\n<p>有关如何判断 <em>this</em>，可以参阅前面 17 题。</p>\n<p>有关箭头函数的 <em>this</em> 指向，可以参阅前面 <em>24、25</em> 题</p>\n</blockquote>\n<h3 id=\"139-call、apply-以及-bind-函数内部实现是怎么样的\"><a href=\"#139-call、apply-以及-bind-函数内部实现是怎么样的\" class=\"headerlink\" title=\"139. call、apply 以及 bind 函数内部实现是怎么样的\"></a>139. <em>call、apply</em> 以及 <em>bind</em> 函数内部实现是怎么样的</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面 <em>102</em> 题。</p>\n</blockquote>\n<h3 id=\"140-为什么会出现-setTimeout-倒计时误差？如何减少\"><a href=\"#140-为什么会出现-setTimeout-倒计时误差？如何减少\" class=\"headerlink\" title=\"140. 为什么会出现 setTimeout 倒计时误差？如何减少\"></a>140. 为什么会出现 <em>setTimeout</em> 倒计时误差？如何减少</h3><blockquote>\n<p>参考答案：</p>\n<p>定时器是属于宏任务(<em>macrotask</em>) 。如果当前执行栈所花费的时间大于定时器时间，那么定时器的回调在宏任务(<em>macrotask</em>) 里，来不及去调用，所有这个时间会有误差。</p>\n</blockquote>\n<h3 id=\"141-谈谈你对-JS-执行上下文栈和作用域链的理解\"><a href=\"#141-谈谈你对-JS-执行上下文栈和作用域链的理解\" class=\"headerlink\" title=\"141. 谈谈你对 JS 执行上下文栈和作用域链的理解\"></a>141. 谈谈你对 <em>JS</em> 执行上下文栈和作用域链的理解</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>什么是执行上下文？</strong></p>\n<p>简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p>\n<p><strong>执行上下文的类型</strong></p>\n<p>JavaScript 中有三种执行上下文类型。</p>\n<ul>\n<li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li>\n<li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li>\n<li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文。</li>\n</ul>\n<p><strong>调用栈</strong></p>\n<p>调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）</p>\n<ul>\n<li>当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。</li>\n<li>任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。</li>\n<li>当函数运行结束后，解释器将它从堆栈中取出，并在主代码列表中继续执行代码。</li>\n<li>如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。</li>\n</ul>\n<p><strong>作用域链</strong></p>\n<p>当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。</p>\n</blockquote>\n<h3 id=\"142-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？\"><a href=\"#142-new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？\" class=\"headerlink\" title=\"142. new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？\"></a>142. <em>new</em> 的原理是什么？通过 <em>new</em> 的方式创建对象和通过字面量创建有什么区别？</h3><blockquote>\n<p>参考答案：</p>\n<p>关于 <em>new</em> 的原理，主要分为以下几步：</p>\n<ul>\n<li><p>创建一个空对象 。</p>\n</li>\n<li><p>由 <em>this</em> 变量引用该对象 。</p>\n</li>\n<li><p>该对象继承该函数的原型(更改原型链的指向) 。</p>\n</li>\n<li><p>把属性和方法加入到 <em>this</em> 引用的对象中。</p>\n</li>\n<li><p>新创建的对象由 <em>this</em> 引用 ，最后隐式地返回 <em>this</em>，过程如下：</p>\n</li>\n</ul>\n<pre><code class=\"javascript\">var obj = &#123;&#125;;\nobj.__proto__ = Base.prototype;\nBase.call(obj);\n</code></pre>\n<p>通过 <em>new</em> 的方式创建对象和通过字面量创建的对象，区别在于 <em>new</em> 出来的对象的原型对象为<code>构造函数.prototype</code>，而字面量对象的原型对象为 <code>Object.prototype</code></p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">function Computer() &#123;&#125;\nvar c = new Computer();\nvar d = &#123;&#125;;\nconsole.log(c.__proto__ === Computer.prototype); // true\nconsole.log(d.__proto__ === Object.prototype); // true\n</code></pre>\n</blockquote>\n<h3 id=\"143-prototype-和-proto-区别是什么？\"><a href=\"#143-prototype-和-proto-区别是什么？\" class=\"headerlink\" title=\"143. prototype 和 _proto_ 区别是什么？\"></a>143. <em>prototype</em> 和 _<em><em>proto</em></em>_ 区别是什么？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>prototype</em> 是构造函数上面的一个属性，指向实例化出来对象的原型对象。</p>\n<p>_<em><em>proto</em></em>_ 是对象上面的一个隐式属性，指向自己的原型对象。</p>\n</blockquote>\n<h3 id=\"144-使用-ES5-实现一个继承？\"><a href=\"#144-使用-ES5-实现一个继承？\" class=\"headerlink\" title=\"144. 使用 ES5 实现一个继承？\"></a>144. 使用 ES5 实现一个继承？</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅第 <em>47</em> 题。</p>\n</blockquote>\n<h3 id=\"145-取数组的最大值（ES5、ES6）\"><a href=\"#145-取数组的最大值（ES5、ES6）\" class=\"headerlink\" title=\"145. 取数组的最大值（ES5、ES6）\"></a>145. 取数组的最大值（<em>ES5、ES6</em>）</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">var arr = [3, 5, 8, 1];\n// ES5 方式\nconsole.log(Math.max.apply(null, arr)); // 8\n// ES6 方式\nconsole.log(Math.max(...arr)); // 8\n</code></pre>\n</blockquote>\n<h3 id=\"146-ES6-新的特性有哪些？\"><a href=\"#146-ES6-新的特性有哪些？\" class=\"headerlink\" title=\"146. ES6 新的特性有哪些？\"></a>146. <em>ES6</em> 新的特性有哪些？</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>44</em> 题。</p>\n</blockquote>\n<h3 id=\"147-Promise-有几种状态-Promise-有什么优缺点\"><a href=\"#147-Promise-有几种状态-Promise-有什么优缺点\" class=\"headerlink\" title=\"147. Promise 有几种状态, Promise 有什么优缺点 ?\"></a>147. <em>Promise</em> 有几种状态, <em>Promise</em> 有什么优缺点 ?</h3><blockquote>\n<p>参考答案：</p>\n<p><em>Promise</em> 有三种状态：</p>\n<p><em>pending、fulfilled、rejected</em>(未决定，履行，拒绝)，同一时间只能存在一种状态，且状态一旦改变就不能再变。<em>Promise</em> 是一个构造函数，<em>promise</em> 对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时分别发出相应回调。</p>\n<ul>\n<li>初始化状态：<em>pending</em></li>\n<li>当调用 <em>resolve</em>(成功) 状态：<em>pengding&#x3D;&gt;fulfilled</em></li>\n<li>当调用 <em>reject</em>(失败) 状态：<em>pending&#x3D;&gt;rejected</em></li>\n</ul>\n<p><em>Promise</em> 的优点是解决了回调地狱，缺点是代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大。所以后面出现了 <em>async&#x2F;await</em> 的异步解决方案。</p>\n</blockquote>\n<h3 id=\"148-Promise-构造函数是同步还是异步执行，then-呢-Promise-如何实现-then-处理\"><a href=\"#148-Promise-构造函数是同步还是异步执行，then-呢-Promise-如何实现-then-处理\" class=\"headerlink\" title=\"148. Promise 构造函数是同步还是异步执行，then 呢 ? Promise 如何实现 then 处理 ?\"></a>148. <em>Promise</em> 构造函数是同步还是异步执行，<em>then</em> 呢 ? <em>Promise</em> 如何实现 <em>then</em> 处理 ?</h3><blockquote>\n<p>参考答案：</p>\n<p><em>promise</em> 构造函数是同步执行的，<em>then</em> 方法是异步执行，<em>then</em> 方法中的内容加入微任务中。</p>\n<p>接下来我们来看 <em>promise</em> 如何实现 <em>then</em> 的处理。</p>\n<p>我们知道 <em>then</em> 是用来处理 <em>resolve</em> 和 <em>reject</em> 函数的回调。那么首先我们来定义 <em>then</em> 方法。</p>\n<h5 id=\"1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。\"><a href=\"#1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。\" class=\"headerlink\" title=\"1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。\"></a>1、then方法需要两个参数，其中onFulfilled代表resolve成功的回调，onRejected代表reject失败的回调。</h5><pre><code class=\"javascript\">then(onFulfilled,onRejected)&#123;&#125;\n</code></pre>\n<h5 id=\"2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected\"><a href=\"#2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected\" class=\"headerlink\" title=\"2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected\"></a>2、我们知道promise的状态是不可逆的，在状态发生改变后，即不可再次更改，只有状态为FULFILLED才会调用onFulfilled，状态为REJECTED调用onRejected</h5><pre><code class=\"javascript\">then(onFulfilled, onRejected)&#123;\n    if (this.status == Promise.FULFILLED) &#123;\n        onFulfilled(this.value)\n    &#125;\n    if (this.status == Promise.REJECTED) &#123;\n        onRejected(this.value)\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值\"><a href=\"#3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值\" class=\"headerlink\" title=\"3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值\"></a>3、then方法的每个方法都不是必须的，所以我们要处理当没有传递参数时，应该设置默认值</h5><pre><code class=\"javascript\">then(onFulfilled,onRejected)&#123;\n    if(typeof onFulfilled !==&#39;function&#39;)&#123;\n        onFulfilled = value =&gt; value;\n    &#125;\n    if(typeof onRejected  !==&#39;function&#39;)&#123;\n        onRejected = value =&gt; value;\n    &#125;\n    if(this.status == Promise.FULFILLED)&#123;\n         onFulfilled(this.value)\n    &#125;\n    if(this.status == Promise.REJECTED)&#123;\n        onRejected(this.value)\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误\"><a href=\"#4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误\" class=\"headerlink\" title=\"4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误\"></a>4、在执行then方法时，我们要考虑到传递的函数发生异常的情况，如果函数发生异常，我们应该让它进行错误异常处理，统一交给onRejected来处理错误</h5><pre><code class=\"javascript\">then(onFulfilled,onRejected)&#123;\n    if(typeof onFulfilled !==&#39;function&#39;)&#123;\n        onFulfilled = value =&gt; value;\n    &#125;   \n    if(typeof onRejected  !==&#39;function&#39;)&#123;\n        onRejected = value =&gt; value;\n    &#125;\n    if(this.status == Promise.FULFILLED)&#123;\n        try&#123;onFulfilled(this.value)&#125;catch(error)&#123; onRejected(error) &#125;\n    &#125;\n    if(this.status == Promise.REJECTED)&#123;\n        try&#123;onRejected(this.value)&#125;catch(error)&#123; onRejected(error) &#125;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。\"><a href=\"#5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。\" class=\"headerlink\" title=\"5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。\"></a>5、但是现在我们自己封装的promise有个小问题，我们知道原生的promise中then方法都是异步执行，在一个同步任务执行之后再调用，而我们的现在的情况则是同步调用，因此我们要使用setTimeout来将onFulfilled和onRejected来做异步宏任务执行。</h5><pre><code class=\"javascript\">if(this.status=Promise.FULFILLED)&#123;\n    setTimeout(()=&gt;&#123;\n        try&#123;onFulfilled(this.value)&#125;catch(error)&#123;onRejected(error)&#125;\n    &#125;)\n&#125;\nif(this.status=Promise.REJECTED)&#123;\n    setTimeout(()=&gt;&#123;\n        try&#123;onRejected(this.value)&#125;catch(error)&#123;onRejected(error)&#125;\n    &#125;)\n&#125;\n</code></pre>\n<h5 id=\"现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。\"><a href=\"#现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。\" class=\"headerlink\" title=\"现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。\"></a>现在then方法中，可以处理status为FULFILLED和REJECTED的情况，但是不能处理为pedding的情况，接下来进行几处修改。</h5><h5 id=\"6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用\"><a href=\"#6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用\" class=\"headerlink\" title=\"6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用\"></a>6、在构造函数中，添加callbacks来保存pending状态时处理函数，当状态改变时循环调用</h5><pre><code class=\"javascript\">constructor(executor) &#123;\n    ...\n  this.callbacks = [];\n  ...\n&#125;    \n</code></pre>\n<h5 id=\"7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。\"><a href=\"#7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。\" class=\"headerlink\" title=\"7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。\"></a>7、在then方法中，当status等于pending的情况时，将待执行函数存放到callbacks数组中。</h5><pre><code class=\"javascript\">then(onFulfilled,onRejected)&#123;\n    ...\n    if(this.status==Promise.PENDING)&#123;\n        this.callbacks.push(&#123;\n            onFulfilled:value=&gt;&#123;\n                try &#123;\n                  onFulfilled(value);\n                &#125; catch (error) &#123;\n                  onRejected(error);\n                &#125;\n            &#125;\n            onRejected: value =&gt; &#123;\n            try &#123;\n              onRejected(value);\n            &#125; catch (error) &#123;\n              onRejected(error);\n            &#125;\n          &#125;\n        &#125;)\n    &#125;\n    ...\n&#125;\n</code></pre>\n<h5 id=\"8、当执行resolve和reject时，在堆callacks数组中的函数进行执行\"><a href=\"#8、当执行resolve和reject时，在堆callacks数组中的函数进行执行\" class=\"headerlink\" title=\"8、当执行resolve和reject时，在堆callacks数组中的函数进行执行\"></a>8、当执行resolve和reject时，在堆callacks数组中的函数进行执行</h5><pre><code class=\"javascript\">resolve(vale)&#123;\n    if(this.status==Promise.PENDING)&#123;\n        this.status = Promise.FULFILLED;\n        this.value = value;\n        this.callbacks.map(callback =&gt; &#123;\n          callback.onFulfilled(value);\n        &#125;);\n    &#125;\n&#125;\nreject(value)&#123;\n    if(this.status==Promise.PENDING)&#123;\n        this.status = Promise.REJECTED;\n        this.value = value;\n        this.callbacks.map(callback =&gt; &#123;\n          callback.onRejected(value);\n        &#125;);\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务\"><a href=\"#9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务\" class=\"headerlink\" title=\"9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务\"></a>9、then方法中，关于处理pending状态时，异步处理的方法：只需要将resolve与reject执行通过setTimeout定义为异步任务</h5><pre><code class=\"javascript\">resolve(value) &#123;\n  if (this.status == Promise.PENDING) &#123;\n       this.status = Promise.FULFILLED;\n    this.value = value;\n    setTimeout(() =&gt; &#123;\n      this.callbacks.map(callback =&gt; &#123;\n        callback.onFulfilled(value);\n      &#125;);\n    &#125;);\n  &#125;\n&#125;\nreject(value) &#123;\n  if (this.status == Promise.PENDING) &#123;\n      this.status = Promise.REJECTED;\n    this.value = value;\n    setTimeout(() =&gt; &#123;\n      this.callbacks.map(callback =&gt; &#123;\n        callback.onRejected(value);\n      &#125;);\n    &#125;);\n  &#125;\n&#125;\n</code></pre>\n<p>到此，promise的then方法的基本实现就结束了。</p>\n</blockquote>\n<h3 id=\"149-Promise-和-setTimeout-的区别\"><a href=\"#149-Promise-和-setTimeout-的区别\" class=\"headerlink\" title=\"149. Promise 和 setTimeout 的区别 ?\"></a>149. <em>Promise</em> 和 <em>setTimeout</em> 的区别 ?</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JavaScript</em> 将异步任务分为 <em>MacroTask</em>（宏任务） 和 <em>MicroTask</em>（微任务），那么它们区别何在呢？</p>\n<ol>\n<li>依次执行同步代码直至执行完毕；</li>\n<li>检查MacroTask 队列，若有触发的异步任务，则取第一个并调用其事件处理函数，然后跳至第三步，若没有需处理的异步任务，则直接跳至第三步；</li>\n<li>检查MicroTask队列，然后执行所有已触发的异步任务，依次执行事件处理函数，直至执行完毕，然后跳至第二步，若没有需处理的异步任务中，则直接返回第二步，依次执行后续步骤；</li>\n<li>最后返回第二步，继续检查MacroTask队列，依次执行后续步骤；</li>\n<li>如此往复，若所有异步任务处理完成，则结束；</li>\n</ol>\n<p><em>Promise</em> 是一个微任务，主线程是一个宏任务，微任务队列会在宏任务后面执行</p>\n<p><em>setTimeout</em> 返回的函数是一个新的宏任务，被放入到宏任务队列</p>\n<p>所以 <em>Promise</em> 会先于新的宏任务执行</p>\n</blockquote>\n<h3 id=\"150-如何实现-Promise-all\"><a href=\"#150-如何实现-Promise-all\" class=\"headerlink\" title=\"150. 如何实现 Promise.all ?\"></a>150. 如何实现 <em>Promise.all</em> ?</h3><blockquote>\n<p>参考答案：</p>\n<p><code>Promise.all</code> 接收一个 <code>promise</code> 对象的数组作为参数，当这个数组里的所有 <code>promise</code> 对象全部变为<code>resolve</code>或 有 <code>reject</code> 状态出现的时候，它才会去调用 <code>.then</code> 方法,它们是并发执行的。</p>\n<p>总结 <code>promise.all</code> 的特点</p>\n<p>1、接收一个 <code>Promise</code> 实例的数组或具有 <code>Iterator</code> 接口的对象，</p>\n<p>2、如果元素不是 <code>Promise</code> 对象，则使用 <code>Promise.resolve</code> 转成 <code>Promise</code> 对象</p>\n<p>3、如果全部成功，状态变为 <code>resolved</code>，返回值将组成一个数组传给回调</p>\n<p>4、只要有一个失败，状态就变为 <code>rejected</code>，返回值将直接传递给回调<br><code>all()</code> 的返回值也是新的 <code>Promise</code> 对象</p>\n<p>实现 <code>Promise.all</code> 方法</p>\n<pre><code class=\"javascript\">function promiseAll(promises) &#123;\n    return new Promise(function (resolve, reject) &#123;\n        if (!isArray(promises)) &#123;\n            return reject(new TypeError(&#39;arguments must be an array&#39;));\n        &#125;\n        var resolvedCounter = 0;\n        var promiseNum = promises.length;\n        var resolvedValues = new Array(promiseNum);\n        for (var i = 0; i &lt; promiseNum; i++) &#123;\n            (function (i) &#123;\n                Promise.resolve(promises[i]).then(function (value) &#123;\n                    resolvedCounter++\n                    resolvedValues[i] = value\n                    if (resolvedCounter == promiseNum) &#123;\n                        return resolve(resolvedValues)\n                    &#125;\n                &#125;, function (reason) &#123;\n                    return reject(reason)\n                &#125;)\n            &#125;)(i)\n        &#125;\n    &#125;)\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"151-如何实现-Promise-finally\"><a href=\"#151-如何实现-Promise-finally\" class=\"headerlink\" title=\"151. 如何实现 Promise.finally ?\"></a>151. 如何实现 <em>Promise.finally</em> ?</h3><blockquote>\n<p>参考答案：</p>\n<p><em>finally</em> 方法是 <em>ES2018</em> 的新特性</p>\n<p><em>finally</em> 方法用于指定不管 <em>Promise</em> 对象最后状态如何，都会执行的操作，执行 <em>then</em> 和 <em>catch</em>  后，都会执行 <em>finally</em> 指定的回调函数。</p>\n<p>方法一：借助 <em>promise.prototype.finally</em> 包</p>\n<pre><code class=\"javascript\">npm install promise-prototype-finally\n</code></pre>\n<pre><code class=\"javascript\">const promiseFinally = require(&#39;promise.prototype.finally&#39;);\n \n// 向 Promise.prototype 增加 finally()\npromiseFinally.shim();\n \n// 之后就可以按照上面的使用方法使用了\n</code></pre>\n<p>方法二：实现 <em>Promise.finally</em></p>\n<pre><code class=\"javascript\">Promise.prototype.finally = function (callback) &#123;\n  let P = this.constructor;\n  return this.then(\n    value  =&gt; P.resolve(callback()).then(() =&gt; value),\n    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)\n  );\n&#125;;\n</code></pre>\n</blockquote>\n<h3 id=\"152-如何判断-img-加载完成\"><a href=\"#152-如何判断-img-加载完成\" class=\"headerlink\" title=\"152. 如何判断 img 加载完成\"></a>152. 如何判断 <em>img</em> 加载完成</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li>为 <em>img DOM</em> 节点绑定 <em>load</em> 事件</li>\n<li><em>readystatechange</em> 事件：<em>readyState</em> 为 <em>complete</em> 和 <em>loaded</em> 则表明图片已经加载完毕。测试 <em>IE6-IE10</em> 支持该事件，其它浏览器不支持。</li>\n<li><em>img</em> 的 <em>complete</em> 属性：轮询不断监测 <em>img</em> 的 <em>complete</em> 属性，如果为 <em>true</em> 则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持。</li>\n</ul>\n</blockquote>\n<h3 id=\"153-如何阻止冒泡？\"><a href=\"#153-如何阻止冒泡？\" class=\"headerlink\" title=\"153. 如何阻止冒泡？\"></a>153. 如何阻止冒泡？</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">// 方法一：IE9+，其他主流浏览器\nevent.stopPropagation()\n// 方法二：火狐未实现\nevent.cancelBubble = true;\n// 方法三：不建议滥用，jq 中可以同时阻止冒泡和默认事件\nreturn false;\n</code></pre>\n</blockquote>\n<h3 id=\"154-如何阻止默认事件？\"><a href=\"#154-如何阻止默认事件？\" class=\"headerlink\" title=\"154. 如何阻止默认事件？\"></a>154. 如何阻止默认事件？</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">// 方法一：全支持\nevent.preventDefault();\n// 方法二：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。\nevent.returnValue=false;\n// 方法三：不建议滥用，jq 中可以同时阻止冒泡和默认事件\nreturn false;\n</code></pre>\n</blockquote>\n<h3 id=\"155-如何用原生-js-给一个按钮绑定两个-onclick-事件？\"><a href=\"#155-如何用原生-js-给一个按钮绑定两个-onclick-事件？\" class=\"headerlink\" title=\"155. 如何用原生 js 给一个按钮绑定两个 onclick 事件？\"></a>155. 如何用原生 <em>js</em> 给一个按钮绑定两个 <em>onclick</em> 事件？</h3><blockquote>\n<p>参考答案：</p>\n<p>使用 <em>addEventListener</em> 方法来绑定事件，就可以绑定多个同种类型的事件。</p>\n</blockquote>\n<h3 id=\"156-拖拽会用到哪些事件\"><a href=\"#156-拖拽会用到哪些事件\" class=\"headerlink\" title=\"156. 拖拽会用到哪些事件\"></a>156. 拖拽会用到哪些事件</h3><blockquote>\n<p>参考答案：</p>\n<p>在以前，书写一个拖拽需要用到 <em>mousedown、mousemove、mouseup</em> 这 <em>3</em> 个事件。</p>\n<p><em>HTML5</em> 推出后，新推出了一组拖拽相关的 <em>API</em>，涉及到的事件有 <em>dragstart、dragover、drop</em> 这 <em>3</em> 个事件。</p>\n</blockquote>\n<h3 id=\"157-document-write-和-innerHTML-的区别\"><a href=\"#157-document-write-和-innerHTML-的区别\" class=\"headerlink\" title=\"157. document.write 和 innerHTML 的区别\"></a>157. <em>document.write</em> 和 <em>innerHTML</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p><em>document.write</em> 是直接写入到页面的内容流，如果在写之前没有调用 <em>document.open</em>,  浏览器会自动调用 <em>open</em>。每次写完关闭之后重新调用该函数，会导致页面全部重绘。 </p>\n<p><em>innerHTML</em> 则是 <em>DOM</em> 页面元素的一个属性，代表该元素的 <em>html</em> 内容。你可以精确到某一个具体的元素来进行更改。如果想修改 <em>document</em> 的内容，则需要修改 <em>document.documentElement.innerElement</em>。 </p>\n<p><em>innerHTML</em> 很多情况下都优于 <em>document.write</em>，其原因在于不会导致页面全部重绘。</p>\n</blockquote>\n<h3 id=\"158-jQuery-的事件委托方法-bind-、live、delegate、one、on-之间有什么区别？\"><a href=\"#158-jQuery-的事件委托方法-bind-、live、delegate、one、on-之间有什么区别？\" class=\"headerlink\" title=\"158. jQuery 的事件委托方法 bind 、live、delegate、one、on 之间有什么区别？\"></a>158. <em>jQuery</em> 的事件委托方法 <em>bind 、live、delegate、one、on</em> 之间有什么区别？</h3><blockquote>\n<p>参考答案：</p>\n<p>这几个方法都可以实现事件处理。其中 <em>on</em> 集成了事件处理的所有功能，也是目前推荐使用的方法。</p>\n<p><em>one</em> 是指添加的是一次性事件，意味着只要触发一次该事件，相应的处理方法执行后就自动被删除。</p>\n<p><em>bind</em> 是较早版本的绑定事件的方法，现在已被 <em>on</em> 替代。</p>\n<p><em>live</em> 和 <em>delegate</em> 主要用来做事件委托。<em>live</em> 的版本较早，现在已被废弃。<em>delegate</em> 目前仍然可用，不过也可用 <em>on</em> 来替代它。</p>\n</blockquote>\n<h3 id=\"159-document-ready-方法和-window-onload-有什么区别？\"><a href=\"#159-document-ready-方法和-window-onload-有什么区别？\" class=\"headerlink\" title=\"159. $(document).ready 方法和 window.onload 有什么区别？\"></a>159. <em>$(document).ready</em> 方法和 <em>window.onload</em> 有什么区别？</h3><blockquote>\n<p>参考答案：</p>\n<p>主要有两点区别：</p>\n<ol>\n<li>执行时机</li>\n</ol>\n<p><em>window.onload</em> 方法是在网页中的所有的元素（包括元素的所有关联文件）都完全加载到浏览器之后才执行。而通过 <em>jQuery</em> 中的<code>$(document).ready</code>方法注册的事件处理程序，只要在 <em>DOM</em> 完全就绪时，就可以调用了，比如一张图片只要<code>&lt;img&gt;</code>标签完成，不用等这个图片加载完成，就可以设置图片的宽高的属性或样式等。</p>\n<p>其实从二者的英文字母可以大概理解上面的话，<em>onload</em> 即加载完成，<em>ready</em> 即 <em>DOM</em> 准备就绪。</p>\n<ol start=\"2\">\n<li>注册事件</li>\n</ol>\n<p>　</p>\n<p><code>$(document).ready</code>方法可以多次使用而注册不同的事件处理程序，而 <em>window.onload</em> 一次只能保存对一个函数的引用，多次绑定函数只会覆盖前面的函数。</p>\n</blockquote>\n<h3 id=\"160-jquery-中-get-提交和-post-提交有区别吗？\"><a href=\"#160-jquery-中-get-提交和-post-提交有区别吗？\" class=\"headerlink\" title=\"160. jquery 中$.get()提交和$.post()提交有区别吗？\"></a>160. jquery 中$.get()提交和$.post()提交有区别吗？</h3><blockquote>\n<p>参考答案：</p>\n<p>相同点：都是异步请求的方式来获取服务端的数据</p>\n<p>不同点：</p>\n<ul>\n<li>请求方式不同：<code>$.get()</code> 方法使用 <em>GET</em> 方法来进行异步请求的。<code>$.post()</code> 方法使用 <em>POST</em> 方法来进行异步请求的。</li>\n<li>参数传递方式不同： <em>GET</em> 请求会将参数跟在 <em>URL</em> 后进行传递，而 <em>POST</em> 请求则是作为 <em>HTTP</em> 消息的实体内容发送给 <em>Web</em> 服务器 的，这种传递是对用户不可见的。</li>\n<li>数据传输大小不同： <em>GET</em> 方式传输的数据大小不能超过 <em>2KB</em> 而 <em>POST</em> 要大的多</li>\n<li>安全问题： <em>GET</em> 方式请求的数据会被浏览器缓存起来，因此有安全问题。</li>\n</ul>\n</blockquote>\n<h3 id=\"161-await-async-如何实现-（阿里）\"><a href=\"#161-await-async-如何实现-（阿里）\" class=\"headerlink\" title=\"161. await async 如何实现 （阿里）\"></a>161. <em>await async</em> 如何实现 （阿里）</h3><blockquote>\n<p>参考答案：</p>\n<p>async 函数只是 promise 的语法糖，它的底层实际使用的是 generator，而 generator 又是基于 promise 的。实际上，在 babel 编译 async 函数的时候，也会转化成 generatora 函数，并使用自动执行器来执行它。</p>\n<p>实现代码示例：</p>\n<pre><code class=\"javascript\">function asyncToGenerator(generatorFunc) &#123;\n    return function() &#123;\n      const gen = generatorFunc.apply(this, arguments)\n      return new Promise((resolve, reject) =&gt; &#123;\n        function step(key, arg) &#123;\n          let generatorResult\n          try &#123;\n            generatorResult = gen[key](arg)\n          &#125; catch (error) &#123;\n            return reject(error)\n          &#125;\n          const &#123; value, done &#125; = generatorResult\n          if (done) &#123;\n            return resolve(value)\n          &#125; else &#123;\n            return Promise.resolve(value).then(val =&gt; step(&#39;next&#39;, val), err =&gt; step(&#39;throw&#39;, err))\n          &#125;\n        &#125;\n        step(&quot;next&quot;)\n      &#125;)\n    &#125;\n&#125;\n</code></pre>\n<p>关于代码的解析，可以参阅：<em><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hnYW5nemFpL2FydGljbGUvZGV0YWlscy8xMDY1MzYzMjU=\">https://blog.csdn.net/xgangzai/article/details/106536325</span></em></p>\n</blockquote>\n<h3 id=\"162-clientWidth-offsetWidth-scrollWidth-的区别\"><a href=\"#162-clientWidth-offsetWidth-scrollWidth-的区别\" class=\"headerlink\" title=\"162. clientWidth,offsetWidth,scrollWidth 的区别\"></a>162. <em>clientWidth,offsetWidth,scrollWidth</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p><em>clientWidth</em> &#x3D; <em>width</em>+左右 <em>padding</em></p>\n<p><em>offsetWidth</em> &#x3D; <em>width</em> + 左右 <em>padding</em> + 左右 <em>boder</em></p>\n<p><em>scrollWidth</em>：获取指定标签内容层的真实宽度(可视区域宽度+被隐藏区域宽度)。</p>\n</blockquote>\n<h3 id=\"163-产生一个不重复的随机数组\"><a href=\"#163-产生一个不重复的随机数组\" class=\"headerlink\" title=\"163. 产生一个不重复的随机数组\"></a>163. 产生一个不重复的随机数组</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">// 生成随机数\nfunction randomNumBoth(Min, Max) &#123;\n    var Range = Max - Min;\n    var Rand = Math.random();\n    var num = Min + Math.round(Rand * Range); //四舍五入\n    return num;\n&#125;\n// 生成数组\nfunction randomArr(len, min, max) &#123;\n    if ((max - min) &lt; len) &#123; //可生成数的范围小于数组长度\n        return null;\n    &#125;\n    var hash = [];\n\n    while (hash.length &lt; len) &#123;\n        var num = randomNumBoth(min, max);\n\n        if (hash.indexOf(num) == -1) &#123;\n            hash.push(num);\n        &#125;\n    &#125;\n    return hash;\n&#125;\n// 测试\nconsole.log(randomArr(10, 1, 100));\n</code></pre>\n<p>在上面的代码中，我们封装了一个 <em>randomArr</em> 方法来生成这个不重复的随机数组，该方法接收三个参数，<em>len、min</em> 和 <em>max</em>，分别表示数组的长度、最小值和最大值。<em>randomNumBoth</em> 方法用来生成随机数。</p>\n</blockquote>\n<h3 id=\"164-continue-和-break-的区别\"><a href=\"#164-continue-和-break-的区别\" class=\"headerlink\" title=\"164. continue 和 break 的区别\"></a>164. <em>continue</em> 和 <em>break</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li><em>break</em>：用于永久终止循环。即不执行本次循环中 <em>break</em> 后面的语句，直接跳出循环。</li>\n<li><em>continue</em>：用于终止本次循环。即本次循环中 <em>continue</em> 后面的代码不执行，进行下一次循环的入口判断。</li>\n</ul>\n</blockquote>\n<h3 id=\"165-如何在-jquery-上扩展插件，以及内部原理（腾讯）\"><a href=\"#165-如何在-jquery-上扩展插件，以及内部原理（腾讯）\" class=\"headerlink\" title=\"165. 如何在 jquery 上扩展插件，以及内部原理（腾讯）\"></a>165. 如何在 <em>jquery</em> 上扩展插件，以及内部原理（腾讯）</h3><blockquote>\n<p>参考答案：</p>\n<p>通过 <em>$.extend(object);</em> 为整个 <em>jQuery</em> 类添加新的方法。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">$.extend(&#123;\n       sayHello: function(name) &#123;\n         console.log(&#39;Hello,&#39; + (name ? name : &#39;World&#39;) + &#39;!&#39;);\n     &#125;,\n     showAge()&#123;\n         console.log(18);\n     &#125;\n&#125;)\n\n// 外部使用\n$.sayHello(); // Hello,World!  无参调用\n$.sayHello(&#39;zhangsan&#39;); // Hello,zhangsan! 带参调用  \n</code></pre>\n<p>通过 <em>$.fn.extend(object);</em> 给 <em>jQuery</em> 对象添加方法。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">$.fn.extend(&#123;\n    swiper: function (options) &#123;\n        var obj = new Swiper(options, this); // 实例化 Swiper 对象\n        obj.init(); // 调用对象的 init 方法\n    &#125;\n&#125;)\n\n// 外部使用\n$(&#39;#id&#39;).swiper();\n</code></pre>\n<p><strong><em>extend</em> 方法内部原理</strong></p>\n<pre><code class=\"javascript\">jQuery.extend( target [, object1 ] [, objectN ] )\n</code></pre>\n<p>对后一个参数进行循环，然后把后面参数上所有的字段都给了第一个字段，若第一个参数里有相同的字段，则进行覆盖操作，否则就添加一个新的字段。</p>\n<p>解析如下：</p>\n<pre><code class=\"javascript\">// 为与源码的下标对应上，我们把第一个参数称为第0个参数，依次类推\njQuery.extend = jQuery.fn.extend = function() &#123;\n    var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || &#123;&#125;, // 默认第0个参数为目标参数\n        i = 1,    // i表示从第几个参数凯斯想目标参数进行合并，默认从第1个参数开始向第0个参数进行合并\n        length = arguments.length,\n        deep = false;  // 默认为浅度拷贝\n\n    // 判断第0个参数的类型，若第0个参数是boolean类型，则获取其为true还是false\n    // 同时将第1个参数作为目标参数，i从当前目标参数的下一个\n    // Handle a deep copy situation\n    if ( typeof target === &quot;boolean&quot; ) &#123;\n        deep = target;\n\n        // Skip the boolean and the target\n        target = arguments[ i ] || &#123;&#125;;\n        i++;\n    &#125;\n\n    //  判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值 \n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) &#123;\n        target = &#123;&#125;;\n    &#125;\n\n    // 若目标参数后面没有参数了，如$.extend(&#123;_name:&#39;wenzi&#39;&#125;), $.extend(true, &#123;_name:&#39;wenzi&#39;&#125;)\n    // 则目标参数即为jQuery本身，而target表示的参数不再为目标参数\n    // Extend jQuery itself if only one argument is passed\n    if ( i === length ) &#123;\n        target = this;\n        i--;\n    &#125;\n\n    // 从第i个参数开始\n    for ( ; i &lt; length; i++ ) &#123;\n        // 获取第i个参数，且该参数不为null，\n        // 比如$.extend(target, &#123;&#125;, null);中的第2个参数null是不参与合并的\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) &#123;\n\n            // 使用for~in获取该参数中所有的字段\n            // Extend the base object\n            for ( name in options ) &#123;\n                src = target[ name ];   // 目标参数中name字段的值\n                copy = options[ name ]; // 当前参数中name字段的值\n\n                // 若参数中字段的值就是目标参数，停止赋值，进行下一个字段的赋值\n                // 这是为了防止无限的循环嵌套，我们把这个称为，在下面进行比较详细的讲解\n                // Prevent never-ending loop\n                if ( target === copy ) &#123;\n                    continue;\n                &#125;\n\n                // 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深度赋值\n                // Recurse if we&#39;re merging plain objects or arrays\n                if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123;\n                    // 若当前参数中name字段的值为Array类型\n                    // 判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化\n                    if ( copyIsArray ) &#123;\n                        copyIsArray = false;\n                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];\n\n                    &#125; else &#123;\n                        // 若原对象存在，则直接进行使用，而不是创建\n                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;\n                    &#125;\n\n                    // 递归处理，此处为2.2\n                    // Never move original objects, clone them                      \n                    target[ name ] = jQuery.extend( deep, clone, copy );\n\n                // deep为false，则表示浅度拷贝，直接进行赋值\n                // 若copy是简单的类型且存在值，则直接进行赋值\n                // Don&#39;t bring in undefined values\n                &#125; else if ( copy !== undefined ) &#123;\n                    // 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性\n                    target[ name ] = copy;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    // 返回修改后的目标参数\n    // Return the modified object\n    return target;\n&#125;; \n</code></pre>\n</blockquote>\n<h3 id=\"166-async-x2F-await-如何捕获错误\"><a href=\"#166-async-x2F-await-如何捕获错误\" class=\"headerlink\" title=\"166. async&#x2F;await 如何捕获错误\"></a>166. <em>async&#x2F;await</em> 如何捕获错误</h3><blockquote>\n<p>参考答案：</p>\n<p>可以使用 <em>try…catch</em> 来进行错误的捕获</p>\n<p>示例代码：</p>\n<pre><code class=\"javascript\">async function test() &#123;\n    try &#123;\n        const res = await test1()\n    &#125; catch (err) &#123;\n        console.log(err)\n    &#125;\n    console.log(&quot;test&quot;)\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"167-Proxy-对比-Object-defineProperty-的优势\"><a href=\"#167-Proxy-对比-Object-defineProperty-的优势\" class=\"headerlink\" title=\"167. Proxy 对比 Object.defineProperty 的优势\"></a>167. <em>Proxy</em> 对比 <em>Object.defineProperty</em> 的优势</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>Proxy 的优势如下:</strong></p>\n<ul>\n<li><em>Object.defineProperty</em> 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，而 <em>Proxy</em> 可以直接监听对象而非属性；</li>\n<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，而 <em>Proxy</em> 可以直接监听数组的变化；</li>\n<li><em>Proxy</em> 有多达 <em>13</em> 种拦截方法；</li>\n<li><em>Proxy</em> 作为新标准将受到浏览器厂商重点持续的性能优化；</li>\n</ul>\n</blockquote>\n<h3 id=\"168-原型链，可以改变原型链的规则吗\"><a href=\"#168-原型链，可以改变原型链的规则吗\" class=\"headerlink\" title=\"168. 原型链，可以改变原型链的规则吗?\"></a>168. 原型链，可以改变原型链的规则吗?</h3><blockquote>\n<p>参考答案：</p>\n<p>每个对象都可以有一个原型__<em>proto</em>__，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找。这个操作被委托在整个原型链上，这个就是我们说的原型链。</p>\n<p>我们可以通过手动赋值的方式来改变原型链所对应的原型对象。</p>\n</blockquote>\n<h3 id=\"169-讲一讲继承的所有方式都有什么？手写一个寄生组合式继承\"><a href=\"#169-讲一讲继承的所有方式都有什么？手写一个寄生组合式继承\" class=\"headerlink\" title=\"169. 讲一讲继承的所有方式都有什么？手写一个寄生组合式继承\"></a>169. 讲一讲继承的所有方式都有什么？手写一个寄生组合式继承</h3><blockquote>\n<p>参考答案：</p>\n<p>可以参阅前面第 <em>9、18、47</em> 题答案。</p>\n<p>其中圣杯模式就是寄生组合式继承。</p>\n</blockquote>\n<h3 id=\"170-JS-基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）\"><a href=\"#170-JS-基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）\" class=\"headerlink\" title=\"170.  JS 基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）\"></a>170.  <em>JS</em> 基本数据类型有哪些？栈和堆有什么区别，为什么要这样存储。（快手）</h3><blockquote>\n<p>参考答案：</p>\n<p>关于 <em>JS</em> 基本数据类型有哪些这个问题，可以参阅前面 <em>26</em> 题。</p>\n<p>栈和堆的区别在于堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放。</p>\n<p>在 <em>js</em> 中，基本数据都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>\n<p><em>js</em> 中其他类型的数据被称为引用类型的数据（如对象、数组、函数等），它们是通过拷贝和 <em>new</em> 出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>\n</blockquote>\n<h3 id=\"171-setTimeout-x3D-gt-0-什么时候执行\"><a href=\"#171-setTimeout-x3D-gt-0-什么时候执行\" class=\"headerlink\" title=\"171.  setTimeout(() &#x3D;&gt; {}, 0)  什么时候执行\"></a>171.  <em>setTimeout(() &#x3D;&gt; {}, 0)</em>  什么时候执行</h3><blockquote>\n<p>参考答案：</p>\n<p>因为 <em>setTimeout</em> 是异步代码，所以即使后面的时间为 <em>0</em>，也要等到同步代码执行完毕后才会执行。</p>\n</blockquote>\n<h3 id=\"172-js-有函数重载吗（网易）\"><a href=\"#172-js-有函数重载吗（网易）\" class=\"headerlink\" title=\"172. js 有函数重载吗（网易）\"></a>172. <em>js</em> 有函数重载吗（网易）</h3><blockquote>\n<p>参考答案：</p>\n<p>所谓函数重载，是方法名称进行重用的一种技术形式，其主要特点是“方法名相同，参数的类型或个数不相同”，在调用时会根据传递的参数类型和个数的不同来执行不同的方法体。</p>\n<p>在 <em>JS</em> 中，可以通过在函数内容判断形参的类型或个数来执行不同的代码块，从而达到模拟函数重载的效果。</p>\n</blockquote>\n<h3 id=\"173-给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回-true-相反则返回的-flase\"><a href=\"#173-给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回-true-相反则返回的-flase\" class=\"headerlink\" title=\"173. 给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回  true  相反则返回的 flase\"></a>173. 给你一个数组，计算每个数出现的次数，如果每个数组返回的数都是独一无二的就返回  <em>true</em>  相反则返回的 <em>flase</em></h3><blockquote>\n<p>参考答案：</p>\n<p>输入：arr &#x3D; [1,2,2,1,1,3]</p>\n<p>输出：true</p>\n<p>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</p>\n<p>代码示例：</p>\n<pre><code class=\"javascript\">function uniqueOccurrences(arr) &#123;\n    let uniqueArr = [...new Set(arr)]\n    let countArr = []\n    for (let i = 0; i &lt; uniqueArr.length; i++) &#123;\n        countArr.push(arr.filter(item =&gt; item == uniqueArr[i]).length)\n    &#125;\n    return countArr.length == new Set(countArr).size\n&#125;;\n\n// 测试\nconsole.log(uniqueOccurrences([1, 2, 2, 1, 1, 3])); // true\nconsole.log(uniqueOccurrences([1, 2, 2, 1, 1, 3, 2])); // false\n</code></pre>\n</blockquote>\n<h3 id=\"174-封装一个能够统计重复的字符的函数，例如-aaabbbdddddfff-转化为-3a3b5d3f\"><a href=\"#174-封装一个能够统计重复的字符的函数，例如-aaabbbdddddfff-转化为-3a3b5d3f\" class=\"headerlink\" title=\"174. 封装一个能够统计重复的字符的函数，例如  aaabbbdddddfff  转化为 3a3b5d3f\"></a>174. 封装一个能够统计重复的字符的函数，例如  <em>aaabbbdddddfff</em>  转化为 <em>3a3b5d3f</em></h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">function compression(str) &#123;\n    if (str.length == 0) &#123;\n        return 0;\n    &#125;\n    var len = str.length;\n    var str2 = &quot;&quot;;\n    var i = 0;\n    var num = 1;\n    while (i &lt; len) &#123;\n        if (str.charAt(i) == str.charAt(i + 1)) &#123;\n            num++;\n        &#125; else &#123;\n            str2 += num;\n            str2 += str.charAt(i);\n            num = 1;\n        &#125;\n        i++;\n    &#125;\n    return str2;\n&#125;\n// 测试：\nconsole.log(compression(&#39;aaabbbdddddfff&#39;)); // 3a3b5d3f\n</code></pre>\n</blockquote>\n<h3 id=\"175-写出代码的执行结果，并解释为什么？\"><a href=\"#175-写出代码的执行结果，并解释为什么？\" class=\"headerlink\" title=\"175. 写出代码的执行结果，并解释为什么？\"></a>175. 写出代码的执行结果，并解释为什么？</h3><pre><code class=\"javascript\">function a() &#123;\n    console.log(1);\n&#125;\n(function() &#123;\n    if (false) &#123;\n        function a() &#123;\n            console.log(2);\n        &#125;\n    &#125;\n    console.log(typeof a); \n    a(); \n&#125;)()\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>会报错，<em>a is not a function</em>。</p>\n<p>因为立即执行函数里面有函数 <em>a</em>，<em>a</em> 会被提升到该函数作用域的最顶端，但是由于判断条件是 <em>false</em>，所以不会进入到条件语句里面， <em>a</em> 也就没有值。所以 <em>typeof</em> 打印出来是 <em>undefined</em>。而后面在尝试调用方法，自然就会报错。</p>\n</blockquote>\n<h3 id=\"176-写出代码的执行结果，并解释为什么？\"><a href=\"#176-写出代码的执行结果，并解释为什么？\" class=\"headerlink\" title=\"176. 写出代码的执行结果，并解释为什么？\"></a>176. 写出代码的执行结果，并解释为什么？</h3><pre><code class=\"javascript\">alert(a);\na();\nvar a = 3;\nfunction a() &#123;\n  alert(10);\n&#125;;\nalert(a);\na = 6;\na(); \n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>首先打印 function a() {alert(10);};</p>\n<p>然后打印 10</p>\n<p>最后打印 3</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>首先 a 变量会被提升到该全局作用域的最顶端，然后值为对应的函数，所以第一次打印出来的是函数。</p>\n<p>接下来调用这个 a 函数，所以打印出 10</p>\n<p>最后给这个 a 赋值为 3，然后又 alert，所以打印出 3。</p>\n<p>之后 a 的值还会发生改变，但是由于没有 alert，说明不会再打印出其他值了。</p>\n</blockquote>\n<h3 id=\"177-写出下面程序的打印顺序，并简要说明原因\"><a href=\"#177-写出下面程序的打印顺序，并简要说明原因\" class=\"headerlink\" title=\"177. 写出下面程序的打印顺序，并简要说明原因\"></a>177. 写出下面程序的打印顺序，并简要说明原因</h3><pre><code class=\"javascript\">setTimeout(function () &#123;\n    console.log(&quot;set1&quot;);\n    new Promise(function (resolve) &#123;\n        resolve();\n    &#125;).then(function () &#123;\n        new Promise(function (resolve) &#123;\n            resolve();\n        &#125;).then(function () &#123;\n            console.log(&quot;then4&quot;);\n        &#125;)\n        console.log(&#39;then2&#39;);\n    &#125;)\n&#125;);\nnew Promise(function (resolve) &#123;\n    console.log(&#39;pr1&#39;);\n    resolve();\n&#125;).then(function () &#123;\n    console.log(&#39;then1&#39;);\n&#125;);\n\nsetTimeout(function () &#123;\n    console.log(&quot;set2&quot;);\n&#125;);\nconsole.log(2);\n\nnew Promise(function (resolve) &#123;\n    resolve();\n&#125;).then(function () &#123;\n    console.log(&#39;then3&#39;);\n&#125;)\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>打印结果为：</p>\n<p>pr1<br>2<br>then1<br>then3<br>set1<br>then2<br>then4<br>set2</p>\n</blockquote>\n<h3 id=\"178-javascript-中什么是伪数组？如何将伪数组转换为标准数组\"><a href=\"#178-javascript-中什么是伪数组？如何将伪数组转换为标准数组\" class=\"headerlink\" title=\"178. javascript 中什么是伪数组？如何将伪数组转换为标准数组\"></a>178. <em>javascript</em> 中什么是伪数组？如何将伪数组转换为标准数组</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>JavaScript</em> 中，<em>arguments</em> 就是一个伪数组对象。关于 <em>arguments</em> 具体可以参阅后面 <em>250</em> 题。</p>\n<p>可以使用 <em>ES6</em> 的扩展运算符来将伪数组转换为标准数组</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">var arr = [...arguments];\n</code></pre>\n</blockquote>\n<h3 id=\"179-array-和-object-的区别\"><a href=\"#179-array-和-object-的区别\" class=\"headerlink\" title=\"179. array 和 object 的区别\"></a>179. <em>array</em> 和 <em>object</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>数组表示有序数据的集合，对象表示无序数据的集合。如果数据顺序很重要的话，就用数组，否则就用对象。</p>\n</blockquote>\n<h3 id=\"180-jquery-事件委托\"><a href=\"#180-jquery-事件委托\" class=\"headerlink\" title=\"180. jquery 事件委托\"></a>180. <em>jquery</em> 事件委托</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>jquery</em> 中使用 <em>on</em> 来绑定事件的时候，传入第二个参数即可。例如：</p>\n<pre><code class=\"javascript\">$(&quot;ul&quot;).on(&quot;click&quot;,&quot;li&quot;,function () &#123;\n  alert(1);\n&#125;)\n</code></pre>\n</blockquote>\n<h3 id=\"181-JS-基本数据类型\"><a href=\"#181-JS-基本数据类型\" class=\"headerlink\" title=\"181. JS 基本数据类型\"></a>181. <em>JS</em> 基本数据类型</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>26</em> 题</p>\n</blockquote>\n<h3 id=\"182-请实现一个模块-math，支持链式调用math-add-2-4-minus-3-times-2\"><a href=\"#182-请实现一个模块-math，支持链式调用math-add-2-4-minus-3-times-2\" class=\"headerlink\" title=\"182. 请实现一个模块 math，支持链式调用math.add(2,4).minus(3).times(2);\"></a>182. 请实现一个模块 <em>math</em>，支持链式调用<code>math.add(2,4).minus(3).times(2);</code></h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码：</p>\n<pre><code class=\"javascript\">class Math &#123;\n    constructor(value) &#123;\n        let hasInitValue = true;\n        if (value === undefined) &#123;\n            value = NaN;\n            hasInitValue = false;\n        &#125;\n        Object.defineProperties(this, &#123;\n            value: &#123;\n                enumerable: true,\n                value: value,\n            &#125;,\n            hasInitValue: &#123;\n                enumerable: false,\n                value: hasInitValue,\n            &#125;,\n        &#125;);\n    &#125;\n\n    add(...args) &#123;\n        const init = this.hasInitValue ? this.value : args.shift();\n        const value = args.reduce((pv, cv) =&gt; pv + cv, init);\n        return new Math(value);\n    &#125;\n\n    minus(...args) &#123;\n        const init = this.hasInitValue ? this.value : args.shift();\n        const value = args.reduce((pv, cv) =&gt; pv - cv, init);\n        return new Math(value);\n    &#125;\n\n    times(...args) &#123;\n        const init = this.hasInitValue ? this.value : args.shift();\n        const value = args.reduce((pv, cv) =&gt; pv * cv, init);\n        return new Math(value);\n    &#125;\n\n    divide(...args) &#123;\n        const init = this.hasInitValue ? this.value : args.shift();\n        const value = args.reduce((pv, cv) =&gt; pv / cv, init);\n        return new Math(value);\n    &#125;\n\n    toJSON() &#123;\n        return this.valueOf();\n    &#125;\n\n    toString() &#123;\n        return String(this.valueOf());\n    &#125;\n\n    valueOf() &#123;\n        return this.value;\n    &#125;\n\n    [Symbol.toPrimitive](hint) &#123;\n        const value = this.value;\n        if (hint === &#39;string&#39;) &#123;\n            return String(value);\n        &#125; else &#123;\n            return value;\n        &#125;\n    &#125;\n&#125;\n\nexport default new Math();\n</code></pre>\n</blockquote>\n<h3 id=\"183-请简述-ES6-代码转成-ES5-代码的实现思路。\"><a href=\"#183-请简述-ES6-代码转成-ES5-代码的实现思路。\" class=\"headerlink\" title=\"183. 请简述 ES6 代码转成 ES5 代码的实现思路。\"></a>183. 请简述 <em>ES6</em> 代码转成 <em>ES5</em> 代码的实现思路。</h3><blockquote>\n<p>参考答案：</p>\n<p>说到 <em>ES6</em> 代码转成 <em>ES5</em> 代码，我们肯定会想到 <em>Babel</em>。所以，我们可以参考 <em>Babel</em> 的实现方式。</p>\n<p>那么 <em>Babel</em> 是如何把 <em>ES6</em> 转成 <em>ES5</em> 呢，其大致分为三步：</p>\n<ul>\n<li>将代码字符串解析成抽象语法树，即所谓的 <em>AST</em></li>\n<li>对 <em>AST</em> 进行处理，在这个阶段可以对 <em>ES6</em> 代码进行相应转换，即转成 <em>ES5</em> 代码</li>\n<li>根据处理后的 <em>AST</em> 再生成代码字符串</li>\n</ul>\n</blockquote>\n<h3 id=\"184-下列代码的执行结果\"><a href=\"#184-下列代码的执行结果\" class=\"headerlink\" title=\"184. 下列代码的执行结果\"></a>184. 下列代码的执行结果</h3><pre><code class=\"javascript\">async function async1() &#123;\n    console.log(&#39;async1 start&#39;);\n    await async2();\n    console.log(&#39;async1 end&#39;);\n&#125;\nasync function async2() &#123;\n    console.log(&#39;async2&#39;);\n&#125;\nconsole.log(&#39;script start&#39;);\nsetTimeout(function () &#123;\n    console.log(&#39;setTimeout&#39;);\n&#125;, 0);\nasync1();\nnew Promise(function (resolve) &#123;\n    console.log(&#39;promise1&#39;);\n    resolve();\n&#125;).then(function () &#123;\n    console.log(&#39;promise2&#39;);\n&#125;);\nconsole.log(&#39;script end&#39;);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br>setTimeout</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>在此之前我们需要知道以下几点：</p>\n<ul>\n<li>setTimeout 属于宏任务</li>\n<li>Promise 本身是同步的立即执行函数，Promise.then 属于微任务</li>\n<li>async 方法执行时，遇到 await 会立即执行表达式，表达式之后的代码放到微任务执行</li>\n</ul>\n<p><strong>第一次执行</strong>：执行同步代码</p>\n<pre><code class=\"javascript\">Tasks(宏任务)：run script、 setTimeout callback\nMicrotasks(微任务)：await、Promise then\nJS stack(执行栈): script\nLog: script start、async1 start、async2、promise1、script end\n</code></pre>\n<p><strong>第二次执行</strong>：执行宏任务后，检测到<strong>微任务</strong>队列中不为空、一次性执行完所有微任务</p>\n<pre><code class=\"javascript\">Tasks(宏任务)：run script、 setTimeout callback\nMicrotasks(微任务)：Promise then\nJS stack(执行栈): await\nLog: script start、async1 start、async2、promise1、script end、async1 end、promise2\n</code></pre>\n<p><strong>第三次执行</strong>：当<strong>微任务</strong>队列中为空时，执行<strong>宏任务</strong>，执行<code>setTimeout callback</code>，打印日志。</p>\n<pre><code class=\"javascript\">Tasks(宏任务)：null\nMicrotasks(微任务)：null\nJS stack(执行栈):setTimeout callback\nLog: script start、async1 start、async2、promise1、script end、async1 end、promise2、setTimeout\n</code></pre>\n</blockquote>\n<h3 id=\"185-JS-有哪些内置对象？\"><a href=\"#185-JS-有哪些内置对象？\" class=\"headerlink\" title=\"185. JS 有哪些内置对象？\"></a>185. <em>JS</em> 有哪些内置对象？</h3><blockquote>\n<p>参考答案：</p>\n<p>数据封装类对象：<em>String，Boolean，Number，Array</em> 和 <em>Object</em></p>\n<p>其他对象：<em>Function，Arguments，Math，Date，RegExp，Error</em></p>\n</blockquote>\n<h3 id=\"186-DOM-怎样添加、移除、移动、复制、创建和查找节点\"><a href=\"#186-DOM-怎样添加、移除、移动、复制、创建和查找节点\" class=\"headerlink\" title=\"186. DOM 怎样添加、移除、移动、复制、创建和查找节点\"></a>186. <em>DOM</em> 怎样添加、移除、移动、复制、创建和查找节点</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面 <em>121</em> 题。</p>\n</blockquote>\n<h3 id=\"187-eval-是做什么的？\"><a href=\"#187-eval-是做什么的？\" class=\"headerlink\" title=\"187. eval 是做什么的？\"></a>187. <em>eval</em> 是做什么的？</h3><blockquote>\n<p>参考答案：</p>\n<p>此函数可以接受一个字符串 <em>str</em> 作为参数，并把此 <em>str</em> 当做一段 <em>javascript</em> 代码去执行，如果 <em>str</em> 执行结果是一个值则返回此值，否则返回 <em>undefined</em>。如果参数不是一个字符串，则直接返回该参数。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">eval(&quot;var a=1&quot;);//声明一个变量a并赋值1。\neval(&quot;2+3&quot;);//5执行加运算，并返回运算值。\neval(&quot;mytest()&quot;);//执行mytest()函数。\neval(&quot;&#123;b:2&#125;&quot;);//声明一个对象。\n</code></pre>\n</blockquote>\n<h3 id=\"188-null-和-undefined-的区别？\"><a href=\"#188-null-和-undefined-的区别？\" class=\"headerlink\" title=\"188. null 和 undefined 的区别？\"></a>188. <em>null</em> 和 <em>undefined</em> 的区别？</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>29</em> 题。</p>\n</blockquote>\n<h3 id=\"189-new-操作符具体干了什么呢？\"><a href=\"#189-new-操作符具体干了什么呢？\" class=\"headerlink\" title=\"189. new 操作符具体干了什么呢？\"></a>189. <em>new</em> 操作符具体干了什么呢？</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li>创建一个空对象 。</li>\n<li>由 this 变量引用该对象 。</li>\n<li>该对象继承该函数的原型(更改原型链的指向) 。</li>\n<li>把属性和方法加入到 this 引用的对象中。</li>\n<li>新创建的对象由 this 引用 ，最后隐式地返回 this，过程如下：</li>\n</ul>\n<pre><code class=\"javascript\">var obj = &#123;&#125;;\nobj.__proto__ = Base.prototype;\nBase.call(obj);\n</code></pre>\n</blockquote>\n<h3 id=\"190-去除字符串中的空格\"><a href=\"#190-去除字符串中的空格\" class=\"headerlink\" title=\"190. 去除字符串中的空格\"></a>190. 去除字符串中的空格</h3><blockquote>\n<p>参考答案：</p>\n<p>方法一：<em>replace</em>正则匹配方法</p>\n<p>代码示例：</p>\n<ul>\n<li>去除字符串内所有的空格：<code>str = str.replace(/\\s*/g,&quot;&quot;);</code></li>\n<li>去除字符串内两头的空格：<code>str = str.replace(/^\\s*|\\s*$/g,&quot;&quot;);</code></li>\n<li>去除字符串内左侧的空格：<code>str = str.replace(/^\\s*/,&quot;&quot;);</code></li>\n<li>去除字符串内右侧的空格：<code>str = str.replace(/(\\s*$)/g,&quot;&quot;);</code></li>\n</ul>\n<p>方法二：字符串原生 <em>trim</em> 方法</p>\n<p><em>trim</em> 方法能够去掉两侧空格返回新的字符串，不能去掉中间的空格</p>\n</blockquote>\n<h3 id=\"191-常见的内存泄露，以及解决方案\"><a href=\"#191-常见的内存泄露，以及解决方案\" class=\"headerlink\" title=\"191. 常见的内存泄露，以及解决方案\"></a>191. 常见的内存泄露，以及解决方案</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>内存泄露概念</strong></p>\n<p>内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>\n<p>内存泄漏通常情况下只能由获得程序源代码和程序员才能分析出来。然而，有不少人习惯于把任何不需要的内存使用的增加描述为内存泄漏，即使严格意义上来说这是不准确的。</p>\n<p><strong><em>JS</em> 垃圾收集机制</strong></p>\n<p><em>JS</em> 具有自动回收垃圾的机制，即执行环境会负责管理程序执行中使用的内存。在C和C++等其他语言中，开发者的需要手动跟踪管理内存的使用情况。在编写 <em>JS</em> 代码的时候，开发人员不用再关心内存使用的问题，所需内存的分配 以及无用的回收完全实现了自动管理。</p>\n<p>Js中最常用的垃圾收集方式是标记清除(mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。</p>\n<p><strong>常见内存泄漏以及解决方案</strong></p>\n<ol>\n<li>意外的全局变量</li>\n</ol>\n<p>Js处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是window。</p>\n<pre><code class=\"javascript\">function foo(arg) &#123; \n    bar = &quot;this is a hidden global variable&quot;; //等同于window.bar=&quot;this is a hidden global variable&quot;\n    this.bar2= &quot;potential accidental global&quot;;//这里的this 指向了全局对象（window）,等同于window.bar2=&quot;potential accidental global&quot;\n&#125;\n</code></pre>\n<p>解决方法：在 JavaScript 程序中添加，开启严格模式’use strict’，可以有效地避免上述问题。</p>\n<p>注意：那些用来临时存储大量数据的全局变量，确保在处理完这些数据后将其设置为null或重新赋值。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓 存内容无法被回收。</p>\n<ol start=\"2\">\n<li>循环引用</li>\n</ol>\n<p>在js的内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收 。</p>\n<pre><code class=\"javascript\">let obj1 = &#123; a: 1 &#125;; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1   \nlet obj2 = obj1; // A 的引用个数变为 2  \n\nobj1 = 0; // A 的引用个数变为 1  \nobj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了\n</code></pre>\n<p>但是引用计数有个最大的问题： 循环引用。 </p>\n<pre><code class=\"javascript\">function func() &#123;  \n    let obj1 = &#123;&#125;;  \n    let obj2 = &#123;&#125;;  \n\n    obj1.a = obj2; // obj1 引用 obj2  \n    obj2.a = obj1; // obj2 引用 obj1  \n\n&#125;\n</code></pre>\n<p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p>\n<pre><code class=\"javascript\">obj1 = null;  \nobj2 = null;\n</code></pre>\n<ol start=\"3\">\n<li>被遗忘的计时器和回调函数</li>\n</ol>\n<pre><code class=\"javascript\">let someResource = getData();  \nsetInterval(() =&gt; &#123;  \n    const node = document.getElementById(&#39;Node&#39;);  \n    if(node) &#123;  \n        node.innerhtml = JSON.stringify(someResource));  \n    &#125;  \n&#125;, 1000);\n</code></pre>\n<p>上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。</p>\n<p>但在 <em>setInterval</em> 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？</p>\n<p>就是调用了 <em>clearInterval</em>。如果回调函数内没有做什么事情，并且也没有被 <em>clear</em> 掉的话，就会造成内存泄漏。</p>\n<p>不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，<em>someResource</em> 就没法被回收。同样的，<em>setTiemout</em> 也会有同样的问题。所以，当不需要 <em>interval</em> 或者 <em>timeout</em> 时，最好调用 <em>clearInterval</em> 或者 <em>clearTimeout</em>。  </p>\n<ol start=\"4\">\n<li><em>DOM</em> 泄漏</li>\n</ol>\n<p>在 <em>JS</em> 中对<em>DOM</em>操作是非常耗时的。因为<em>JavaScript&#x2F;ECMAScript</em>引擎独立于渲染引擎，而<em>DOM</em>是位于渲染引擎，相互访问需要消耗一定的资源。  而 <em>IE</em> 的 <em>DOM</em> 回收机制便是采用引用计数的，以下主要针对 <em>IE</em> 而言的。</p>\n<p><strong>a. 没有清理的 DOM 元素引用</strong></p>\n<pre><code class=\"javascript\">var refA = document.getElementById(&#39;refA&#39;);\ndocument.body.removeChild(refA);\n// refA 不能回收，因为存在变量 refA 对它的引用。将其对 refA 引用释放，但还是无法回收 refA。\n</code></pre>\n<p>解决办法：<em>refA &#x3D; null;</em></p>\n<p><strong>b. 给 DOM 对象添加的属性是一个对象的引用</strong></p>\n<pre><code class=\"javascript\">var MyObject = &#123;&#125;; \ndocument.getElementById(&#39;mydiv&#39;).myProp = MyObject;\n</code></pre>\n<p>解决方法：<br>在 <em>window.onunload</em> 事件中写上: <em>document.getElementById(‘mydiv’).myProp &#x3D; null;</em>  </p>\n<p><strong>c. DOM 对象与 JS 对象相互引用</strong></p>\n<pre><code class=\"javascript\">function Encapsulator(element) &#123; \n    this.elementReference = element; \n    element.myProp = this; \n&#125; \nnew Encapsulator(document.getElementById(&#39;myDiv&#39;));\n</code></pre>\n<p>解决方法： 在 onunload 事件中写上: document.getElementById(‘myDiv’).myProp &#x3D; null;   </p>\n<p><strong>d. 给 DOM 对象用 attachEvent 绑定事件</strong></p>\n<pre><code class=\"javascript\">function doClick() &#123;&#125; \nelement.attachEvent(&quot;onclick&quot;, doClick);\n</code></pre>\n<p>解决方法： 在onunload事件中写上: element.detachEvent(‘onclick’, doClick);   </p>\n<p><strong>e. 从外到内执行 appendChild。这时即使调用 removeChild 也无法释放</strong></p>\n<pre><code class=\"javascript\">var parentDiv = document.createElement(&quot;div&quot;); \nvar childDiv = document.createElement(&quot;div&quot;); \ndocument.body.appendChild(parentDiv); \nparentDiv.appendChild(childDiv);\n</code></pre>\n<p>解决方法： 从内到外执行 appendChild:   </p>\n<pre><code class=\"javascript\">var parentDiv = document.createElement(&quot;div&quot;); \nvar childDiv = document.createElement(&quot;div&quot;); \nparentDiv.appendChild(childDiv); \ndocument.body.appendChild(parentDiv);\n</code></pre>\n<ol start=\"5\">\n<li><em>JS</em> 的闭包</li>\n</ol>\n<p>闭包在 <em>IE6</em> 下会造成内存泄漏，但是现在已经无须考虑了。值得注意的是闭包本身不会造成内存泄漏，但闭包过多很容易导致内存泄漏。闭包会造成对象引用的生命周期脱离当前函数的上下文，如果闭包如果使用不当，可以导致环形引用（<em>circular reference</em>），类似于死锁，只能避免，无法发生之后解决，即使有垃圾回收也还是会内存泄露。  </p>\n<ol start=\"6\">\n<li><em>console</em></li>\n</ol>\n<p>控制台日志记录对总体内存配置文件的影响可能是许多开发人员都未想到的极其重大的问题。记录错误的对象可以将大量数据保留在内存中。注意，这也适用于： </p>\n<p>(1) 在用户键入 JavaScript 时，在控制台中的一个交互式会话期间记录的对象。<br>(2) 由 console.log 和 console.dir 方法记录的对象。 </p>\n</blockquote>\n<h3 id=\"192-箭头函数和普通函数里面的-this-有什么区别\"><a href=\"#192-箭头函数和普通函数里面的-this-有什么区别\" class=\"headerlink\" title=\"192. 箭头函数和普通函数里面的 this 有什么区别\"></a>192. 箭头函数和普通函数里面的 <em>this</em> 有什么区别</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>24、25</em> 题</p>\n</blockquote>\n<h3 id=\"193-设计⼀个⽅法-isPalindrom-以判断是否回⽂-颠倒后的字符串和原来的字符串⼀样为回⽂\"><a href=\"#193-设计⼀个⽅法-isPalindrom-以判断是否回⽂-颠倒后的字符串和原来的字符串⼀样为回⽂\" class=\"headerlink\" title=\"193. 设计⼀个⽅法(isPalindrom)以判断是否回⽂(颠倒后的字符串和原来的字符串⼀样为回⽂)\"></a>193. 设计⼀个⽅法(<em>isPalindrom</em>)以判断是否回⽂(颠倒后的字符串和原来的字符串⼀样为回⽂)</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">function isPalindrome(str) &#123;\n    if (typeof str !== &#39;string&#39;) &#123;\n        return false\n    &#125;\n    return str.split(&#39;&#39;).reverse().join(&#39;&#39;) === str\n&#125;\n\n// 测试\nconsole.log(isPalindrome(&#39;HelleH&#39;)); // true\nconsole.log(isPalindrome(&#39;Hello&#39;)); // false\n</code></pre>\n</blockquote>\n<h3 id=\"194-设计⼀个⽅法-findMaxDuplicateChar-以统计字符串中出现最多次数的字符\"><a href=\"#194-设计⼀个⽅法-findMaxDuplicateChar-以统计字符串中出现最多次数的字符\" class=\"headerlink\" title=\"194. 设计⼀个⽅法(findMaxDuplicateChar)以统计字符串中出现最多次数的字符\"></a>194. 设计⼀个⽅法(<em>findMaxDuplicateChar</em>)以统计字符串中出现最多次数的字符</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">function findMaxDuplicateChar(str) &#123;\n    let cnt = &#123;&#125;,\t//用来记录所有的字符的出现频次\n        c = &#39;&#39;;\t\t//用来记录最大频次的字符\n    for (let i = 0; i &lt; str.length; i++) &#123;\n        let ci = str[i];\n        if (!cnt[ci]) &#123;\n            cnt[ci] = 1;\n        &#125; else &#123;\n            cnt[ci]++;\n        &#125;\n        if (c == &#39;&#39; || cnt[ci] &gt; cnt[c]) &#123;\n            c = ci;\n        &#125;\n    &#125;\n    console.log(cnt); // &#123; H: 1, e: 1, l: 3, o: 2, &#39; &#39;: 1, W: 1, r: 1, d: 1 &#125;\n    return c;\n&#125;\n\n// 测试\nconsole.log(findMaxDuplicateChar(&#39;Hello World&#39;)); // l\n</code></pre>\n</blockquote>\n<h3 id=\"195-设计⼀段代码，使得通过点击按钮可以在-span-中显示⽂本框中输⼊的值\"><a href=\"#195-设计⼀段代码，使得通过点击按钮可以在-span-中显示⽂本框中输⼊的值\" class=\"headerlink\" title=\"195. 设计⼀段代码，使得通过点击按钮可以在 span 中显示⽂本框中输⼊的值\"></a>195. 设计⼀段代码，使得通过点击按钮可以在 <em>span</em> 中显示⽂本框中输⼊的值</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"html\">&lt;body&gt;\n    &lt;span id=&quot;showContent&quot;&gt;在右侧输入框中输入内容&lt;/span&gt;\n    &lt;input type=&quot;text&quot; name=&quot;content&quot; id=&quot;content&quot;&gt;\n    &lt;button id=&quot;btn&quot;&gt;更新内容&lt;/button&gt;\n    &lt;script&gt;\n        btn.onclick = function()&#123;\n            var content = document.getElementById(&#39;content&#39;).value;\n            if(content)&#123;\n                document.getElementById(&#39;showContent&#39;).innerHTML = content;\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n</blockquote>\n<h3 id=\"196-map-和-forEach-的区别？\"><a href=\"#196-map-和-forEach-的区别？\" class=\"headerlink\" title=\"196. map 和 forEach 的区别？\"></a>196. <em>map</em> 和 <em>forEach</em> 的区别？</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>两者区别</strong></p>\n<p><code>forEach()</code>方法不会返回执行结果，而是<code>undefined</code>。</p>\n<p>也就是说，<code>forEach()</code>会修改原来的数组。而<code>map()</code>方法会得到一个新的数组并返回。</p>\n<p><strong>适用场景</strong></p>\n<p><code>forEach</code>适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。</p>\n<p><code>map()</code>适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(<em>composition</em>)(<em>map, filter, reduce</em> 等组合使用)来玩出更多的花样。</p>\n</blockquote>\n<h3 id=\"197-Array-的常用方法\"><a href=\"#197-Array-的常用方法\" class=\"headerlink\" title=\"197. Array 的常用方法\"></a>197. <em>Array</em> 的常用方法</h3><blockquote>\n<p>参考答案：</p>\n<p><em>Array</em> 的常用方法很多，挑选几个自己在实际开发中用的比较多的方法回答即可。</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-17-151325.png\" alt=\"image-20210817231325109\" style=\"zoom:50%;\" />\n\n<p>更多 <em>Array</em> 相关用法可以参阅：<em><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzcmVmL2pzcmVmX29ial9hcnJheS5hc3A=\">https://www.w3school.com.cn/jsref/jsref_obj_array.asp</span></em></p>\n</blockquote>\n<h3 id=\"198-数组去重的多种实现方式\"><a href=\"#198-数组去重的多种实现方式\" class=\"headerlink\" title=\"198. 数组去重的多种实现方式\"></a>198. 数组去重的多种实现方式</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>2</em> 题答案。</p>\n</blockquote>\n<h3 id=\"199-什么是预解析（预编译）\"><a href=\"#199-什么是预解析（预编译）\" class=\"headerlink\" title=\"199. 什么是预解析（预编译）\"></a>199. 什么是预解析（预编译）</h3><blockquote>\n<p>参考答案：</p>\n<p>所谓的预解析（预编译）就是：在当前作用域中，<em>JavaScript</em> 代码执行之前，浏览器首先会默认的把所有带 <em>var</em> 和 <em>function</em> 声明的变量进行提前的声明或者定义。</p>\n<p>另外，<em>var</em> 声明的变量和 <em>function</em> 声明的函数在预解析的时候有区别，<em>var</em> 声明的变量在预解析的时候只是提前的声明，<em>function</em> 声明的函数在预解析的时候会提前声明并且会同时定义。也就是说 <em>var</em> 声明的变量和 <em>function</em> 声明的函数的区别是在声明的同时有没有同时进行定义。</p>\n</blockquote>\n<h3 id=\"200-原始值类型和引用值类型的区别是什么？\"><a href=\"#200-原始值类型和引用值类型的区别是什么？\" class=\"headerlink\" title=\"200. 原始值类型和引用值类型的区别是什么？\"></a>200. 原始值类型和引用值类型的区别是什么？</h3><blockquote>\n<p>参考答案：</p>\n<p>可以参阅前面第 <em>26</em> 题</p>\n</blockquote>\n<h3 id=\"201-冒泡排序的思路，不用-sort\"><a href=\"#201-冒泡排序的思路，不用-sort\" class=\"headerlink\" title=\"201. 冒泡排序的思路，不用 sort\"></a>201. 冒泡排序的思路，不用 <em>sort</em></h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">var examplearr = [8, 94, 15, 88, 55, 76, 21, 39];\nfunction sortarr(arr) &#123;\n    for (i = 0; i &lt; arr.length - 1; i++) &#123;\n        for (j = 0; j &lt; arr.length - 1 - i; j++) &#123;\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            &#125;\n        &#125;\n    &#125;\n    return arr;\n&#125;\nsortarr(examplearr);\nconsole.log(examplearr); // [8, 15, 21, 39, 55, 76, 88, 94]\n</code></pre>\n</blockquote>\n<h3 id=\"202-symbol-用途\"><a href=\"#202-symbol-用途\" class=\"headerlink\" title=\"202. symbol 用途\"></a>202. <em>symbol</em> 用途</h3><blockquote>\n<p>参考答案：</p>\n<p>可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗?我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法(除了 Object.getOwnPropertySymbols 外)遍历到，所以可以用来模拟私有变量。</p>\n<p>主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</p>\n<p>Symbol.for() 可以在全局访问 symbol</p>\n</blockquote>\n<h3 id=\"203-什么是函数式编程，应用场景是什么\"><a href=\"#203-什么是函数式编程，应用场景是什么\" class=\"headerlink\" title=\"203. 什么是函数式编程，应用场景是什么\"></a>203. 什么是函数式编程，应用场景是什么</h3><blockquote>\n<p>参考答案：</p>\n<p>函数式编程和面向对象编程一样，是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。<br> 它主要有以下几个特点：</p>\n<ol>\n<li>函数是”一等公民”：函数优先，和其他数据类型一样。</li>\n<li>只用”表达式”，不用”语句”：通过表达式（<em>expression</em>）计算过程得到一个返回值，而不是通过一个语句（<em>statement</em>）修改某一个状态。</li>\n<li>无副作用：不污染变量，同一个输入永远得到同一个数据。</li>\n<li>不可变性：前面一提到，不修改变量，返回一个新的值。</li>\n</ol>\n<p>函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 <em>Haskell</em>，以及一些语言开始逐渐成为多范式编程语言，比如 <em>Swift</em>，还有 <em>Kotlin，Java，Js</em> 等都开始具备函数式编程的特性。</p>\n<p><strong>函数式编程在前端的应用场景</strong></p>\n<ul>\n<li><em>Stateless components</em>：<em>React</em> 在 <em>0.14</em> 之后推出的无状态组件</li>\n<li><em>Redux</em></li>\n</ul>\n<p><strong>函数式编程在后端的应用场景</strong></p>\n<ul>\n<li><em>Lambda</em> 架构</li>\n</ul>\n</blockquote>\n<h3 id=\"204-事件以及事件相关的兼容性问题\"><a href=\"#204-事件以及事件相关的兼容性问题\" class=\"headerlink\" title=\"204. 事件以及事件相关的兼容性问题\"></a>204. 事件以及事件相关的兼容性问题</h3><blockquote>\n<p>参考答案：</p>\n<p>事件最早是在 <em>IE3</em> 和  <em>Navigator2</em> 中出现的，当时是作为分担服务器运算负担的一种手段。要实现和网页的互动，就需要通过 <em>JavaScript</em> 里面的事件来实现。</p>\n<p>每次用户与一个网页进行交互，例如点击链接，按下一个按键或者移动鼠标时，就会触发一个事件。我们的程序可以检测这些事件，然后对此作出响应。从而形成一种交互。</p>\n<p>当我们绑定事件时，需要遵循事件三要素</p>\n<ul>\n<li>事件源：是指那个元素引发的事件。比如当你点击图标的时候，会跳转到百度首页。那么这个图标就是事件源。</li>\n<li>事件：事件是指执行的动作。例如，点击，鼠标划过，按下键盘，获得焦点。</li>\n<li>事件驱动程序：事件驱动程序即执行的结果。例如，当你点击图标的时候，会跳转到百度首页。那么跳转到百度首页就是事件的处理结果。</li>\n</ul>\n<pre><code class=\"javascript\">事件源.事件 = function() &#123;\n    事件处理函数\n&#125;\n</code></pre>\n<p>常见的兼容问题，可以参阅前面 <em>135</em> 题。</p>\n</blockquote>\n<h3 id=\"205-JS-小数不精准，如何计算\"><a href=\"#205-JS-小数不精准，如何计算\" class=\"headerlink\" title=\"205. JS 小数不精准，如何计算\"></a>205. <em>JS</em> 小数不精准，如何计算</h3><blockquote>\n<p>参考答案：</p>\n<p>方法一：指定要保留的小数位数(0.1+0.2).toFixed(1) &#x3D; 0.3;这个方法toFixed是进行四舍五入的也不是很精准，对于计算金额这种严谨的问题，不推荐使用，而且不同浏览器对toFixed的计算结果也存在差异。</p>\n<p>方法二：把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。 </p>\n</blockquote>\n<h3 id=\"206-写一个-mySetInterVal-fn-a-b-，每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal\"><a href=\"#206-写一个-mySetInterVal-fn-a-b-，每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal\" class=\"headerlink\" title=\"206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal\"></a>206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 <em>a,a+b,a+2b</em> 的时间，然后写一个 <em>myClear</em>，停止上面的 <em>mySetInterVal</em></h3><blockquote>\n<p>参考答案：</p>\n<p>该题的思路就是每一次在定时器中重启定时器并且在时间每一次都加 <em>b</em>，并且要把定时器返回回来，可以作为<em>myClear</em>的参数。</p>\n<p>代码如下：</p>\n<pre><code class=\"javascript\">var mySetInterVal = function (fn, a, b) &#123;\n  var timer = null;\n  var settimer = function (fn, a, b) &#123;\n    timer = setTimeout(() =&gt; &#123;\n      fn();\n      settimer(fn, a + b, b);\n    &#125;, a);\n  &#125;\n  settimer(fn, a, b);\n  return timer;\n&#125;\n\nvar timer = mySetInterVal(() =&gt; &#123; console.log(&#39;timer&#39;) &#125;, 1000, 1000);\nvar myClear = function (timer) &#123;\n  timer &amp;&amp; clearTimeout(timer);\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"207-合并二维有序数组成一维有序数组，归并排序的思路\"><a href=\"#207-合并二维有序数组成一维有序数组，归并排序的思路\" class=\"headerlink\" title=\"207. 合并二维有序数组成一维有序数组，归并排序的思路\"></a>207. 合并二维有序数组成一维有序数组，归并排序的思路</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">function merge(left, right) &#123;\n    let result = []\n    while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;\n        if (left[0] &lt; right[0]) &#123;\n            result.push(left.shift())\n        &#125; else &#123;\n            result.push(right.shift())\n        &#125;\n    &#125;\n    return result.concat(left).concat(right)\n&#125;\nfunction mergeSort(arr) &#123;\n    if (arr.length === 1) &#123;\n        return arr\n    &#125;\n    while (arr.length &gt; 1) &#123;\n        let arrayItem1 = arr.shift();\n        let arrayItem2 = arr.shift();\n        let mergeArr = merge(arrayItem1, arrayItem2);\n        arr.push(mergeArr);\n    &#125;\n    return arr[0]\n&#125;\n\nlet arr1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3], [4, 5, 6]];\nlet arr2 = [[1, 4, 6], [7, 8, 10], [2, 6, 9], [3, 7, 13], [1, 5, 12]];\nconsole.log(mergeSort(arr1))\nconsole.log(mergeSort(arr2))\n</code></pre>\n</blockquote>\n<h3 id=\"208-给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\"><a href=\"#208-给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\" class=\"headerlink\" title=\"208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\"></a>208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</h3><blockquote>\n<p>参考答案：</p>\n<p>首先，我们肯定需要封装一个函数，而这个函数接收一个字符串作为参数，返回不含有重复字符的子串长度。来看下面的示例：</p>\n<p>示例 1:</p>\n<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>\n<p>示例 2:</p>\n<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>\n<p>示例 3:</p>\n<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p>\n<p>示例代码：</p>\n<pre><code class=\"javascript\">var lengthOfLongestSubstring = function (s) &#123;\n    var y = [];\n    var temp = [];\n    var maxs = 0;\n    if (s == &quot;&quot;) &#123;\n        return 0;\n    &#125;\n    if (s.length == 1) &#123;\n        return 1;\n    &#125;\n    for (var i = 0; i &lt; s.length; i++) &#123;\n        if (temp.includes(s[i])) &#123;\n\n            y.push(temp.length);\n            temp.shift();\n            continue;\n        &#125; else &#123;\n            temp.push(s[i])\n            y.push(temp.length);\n        &#125;\n\n    &#125;\n    for (var j = 0; j &lt; y.length; j++) &#123;\n        if (maxs &lt;= y[j]) &#123;\n            maxs = y[j]\n        &#125;\n    &#125;\n    return maxs;\n&#125;;\n// 测试\nconsole.log(lengthOfLongestSubstring(&#39;abcabcbb&#39;)); // 3\nconsole.log(lengthOfLongestSubstring(&#39;bbbbb&#39;)); // 1\nconsole.log(lengthOfLongestSubstring(&#39;pwwkew&#39;)); // 3\n</code></pre>\n</blockquote>\n<h3 id=\"209-有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6-4-5-6-11-23-42-56-78-90）-滴滴-2020\"><a href=\"#209-有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6-4-5-6-11-23-42-56-78-90）-滴滴-2020\" class=\"headerlink\" title=\"209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 2020)\"></a>209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 <em>2020</em>)</h3><blockquote>\n<p>参考答案：</p>\n<p>本道题目是一道考察算法的题目，主要是考察编程基本功和一定的想像力。</p>\n<p>具体的实现如下：</p>\n<pre><code class=\"javascript\">const testArr = [11, 42, 23, 4, 5, 6, 4, 5, 6, 11, 23, 42, 56, 78, 90];\nfunction avarageSum(n, arr) &#123;\n //    找到平均值\n const sum = arr.reduce((a, b) =&gt; a + b, 0)\n const ava = Math.round(sum / n);\n // 生成一个长度为n的二维数组\n let target = new Array(n).fill(0).map(()=&gt;[])\n // const target = [[], [], []];\n let cursor;\n let max = 0;\n let maxIdx = 0;\n // 所有数组需要尽量加到ava\n while (arr.length &gt; 0) &#123;\n     // 得到当前arr数组最大的数\n     // 出数器\n     // 出数器负责拿出当前数组中最大的那个数\n     for (let i = 0; i &lt; arr.length; i++) &#123;\n         if (arr[i] &gt; max) &#123;\n             max = arr[i];\n             maxIdx = i\n         &#125;\n     &#125;\n     // arr数组中删除最大数\n     const temparr = arr.splice(maxIdx, 1);\n\n     // 计算差距的函数 找到差距(距离平均值)最大的那一组 返回下标\n     cursor = getMaxDis(target, ava);\n\n     // console.log(&quot;下标&quot;, cursor)\n     // 加入\n     target[cursor].push(temparr[0]);\n     // 重置\n     max = 0;\n     maxIdx = 0;\n &#125;\n return target.map(item=&gt;&#123;\n     // 返回累加结果\n     let sum = item.reduce((a,b)=&gt;a+b,0);\n     item.sum = sum\n     return item\n &#125;)\n\n&#125;\nfunction getMaxDis(origin, stand) &#123;\n // 计算origin数组中和stand最大差距的那一组\n const len = origin.length;\n let i = 0;\n let maxDis;\n let maxDisIdx;\n while (i &lt; len) &#123;\n     const sum = origin[i].reduce((a, b) =&gt; a + b, 0);\n     const dis = stand - sum;\n     if (i === 0) &#123;\n         maxDis = dis;\n         maxDisIdx = 0\n     &#125;\n     if (dis &gt; maxDis) &#123;\n         maxDis = dis;\n         maxDisIdx = i\n     &#125;\n     i++;\n &#125;\n return maxDisIdx\n\n&#125;\nconsole.log(avarageSum(3, testArr))\n/*\n  [\n      [ 90, 23, 11, 6, 5, sum: 135 ],\n      [ 78, 42, 11, 4, sum: 135 ],\n      [ 56, 42, 23, 6, 5, 4, sum: 136 ]\n   ]\n */\n</code></pre>\n</blockquote>\n<h3 id=\"210-手写发布订阅（头条2020）\"><a href=\"#210-手写发布订阅（头条2020）\" class=\"headerlink\" title=\"210. 手写发布订阅（头条2020）\"></a>210. 手写发布订阅（头条2020）</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">/*\n    1. 创建 Vue 构造函数\n        在 Vue 构造函数中，调用了 observer 函数，该函数的作用就是对数据进行劫持\n        劫持具体要做的事儿：复制一份数据，但是不是单纯的复制，而是增加了 getter、setter\n    2. 书写 compile 函数。该函数主要作用于模板，从模板里面要提取信息\n        提取的东西主要有两个：双大括号  和 v-model\n    3. 创建发布者 Dep 的构造函数，如果数据发生变化，发布者就会遍历内部的数组（花名册），通知订阅者修改数据\n    4. 创建订阅者 Watcher 的构造函数，如果有数据的变化，发布者就会通知订阅者，订阅者上面存在 update 方法，会进行修改\n */\n\nfunction Vue(options)&#123;\n    // this 代表 Vue 的实例对象，本例中就是 vm\n    // options.data 这就是实际的数据 &#123;msg : &#39;xiejie&#39;&#125;\n    observer(this,options.data);\n    this.$el = options.el;\n    compile(this);\n&#125;\n\n// 用于对模板进行信息提取，主要提取 双大括号  和 v-model，然后进行一些操作\n// 双大括号 会成为观察者，v-model 所对应的控件来绑定事件\nfunction compile(vm)&#123;\n    var el = document.querySelector(vm.$el); // el 所对应的值为 &lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;\n    var documentFragment = document.createDocumentFragment(); // 创建了一个空的文档碎片\n    var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 创建正则表达式 匹配 双大括号\n    while(el.childNodes[0])&#123;\n        var child = el.childNodes[0]; // 将第一个子节点存储到 child\n        if(child.nodeType == 1)&#123;\n            // 如果能够进入此 if，说明该节点是一个元素节点\n            for(var key in child.attributes)&#123;\n                // 遍历该元素节点的每一个属性，拿到的就是 type=&quot;text&quot; v-model=&quot;msg&quot;\n                var attrName = child.attributes[key].nodeName; // 获取属性名  type、v-model\n                if(attrName === &#39;v-model&#39;)&#123;\n                    var vmKey = child.attributes[key].nodeValue; // 先获取属性值，也就是 msg\n                    // 为该节点，也就是 &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt; 绑定一个 input 事件\n                    child.addEventListener(&#39;input&#39;, function (event) &#123;\n                        vm[vmKey] = event.target.value; // 获取用户输入的值，然后改变 vm 里面的 msg 属性对应的值，注意这里会触发 setter\n                    &#125;)\n                &#125;\n            &#125;\n        &#125;\n        if(child.nodeType == 3)&#123;\n            // 如果能进入此 if，说明该节点是一个文本节点\n            if(reg.test(child.nodeValue))&#123;\n                // 如果能够进入到此 if，说明是 双大括号，然后我们要让其成为订阅者\n                var vmKey = RegExp.$1; // 获取正则里面的捕获值，也就是 msg\n                // 实例化一个 Watcher（订阅者），接收 3 个参数：Vue 实例，该文本节点，捕获值 msg\n                new Watcher(vm, child, vmKey);\n            &#125;\n        &#125;\n        documentFragment.appendChild(el.childNodes[0]); // 将第一个子节点添加到文档碎片里面\n    &#125;\n    // 将文档碎片中节点重新添加到 el，也就是 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 下面\n    el.appendChild(documentFragment);\n&#125;\n\n// 新建发布者构造函数\nfunction Dep() &#123;\n    // 将观察者添加到发布者内部的数组里面\n    // 这样以便于通知所有的观察者去更新数据\n    this.subs = [];\n&#125;\n\nDep.prototype = &#123;\n    // 将 watcher 添加到发布者内置的数组里面\n    addSub: function (sub) &#123;\n        this.subs.push(sub);\n\n    &#125;,\n    // 遍历数组里面所有的 watcher，通知它们去更新数据\n    notify: function () &#123;\n        this.subs.forEach(function (sub) &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n\n// 新建观察者 Watcher 构造函数\n// 接收 3 个参数：Vue 实例，文本节点 以及捕获内容 msg\nfunction Watcher(vm, child, vmKey) &#123;\n    this.vm = vm; // vm \n    this.child = child; // 双大括号\n    this.vmKey = vmKey; // msg\n    Dep.target = this; // 将该观察者实例对象添加给 Dep.target\n    this.update(); // 执行节点更新方法\n    Dep.target = null; // 最后清空 Dep.target\n&#125;\nWatcher.prototype = &#123;\n    // 节点更新方法\n    update: function () &#123;\n        // 这样就更新了文本节点的值，由于这里在获取 vm.msg，所以会触发 getter\n        this.child.nodeValue = this.vm[this.vmKey];\n    &#125;\n&#125;\n\n// 该函数的作用是用于数据侦听\nfunction observer(vm,obj)&#123;\n    var dep = new Dep(); // 新增一个发布者:发布者的作用是告诉订阅者数据已经更改\n    // 遍历数据\n    for(var key in obj)&#123;\n        // 将数据的每一项添加到 vm 里面，至此，vm 也有了每一项数据\n        // 但是不是单纯的添加，而是设置了 getter 和 setter\n        // 在获取数据时触发 getter，在设置数据时触发 setter\n        Object.defineProperty(vm, key, &#123;\n            get() &#123;\n                console.log(&quot;触发get了&quot;);\n                // 触发 getter 时，将该 watcher 添加到发布者维护的数组里面\n                if (Dep.target) &#123;\n                    dep.addSub(Dep.target); // 往发布者的数组里面添加订阅者\n                &#125;\n                console.log(dep.subs);\n                return obj[key];\n            &#125;,\n            set(newVal) &#123;\n                console.log(&quot;触发set了&quot;);\n                obj[key] = newVal;\n                dep.notify(); // 发布者发出消息，通知订阅者修改数据\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"211-手写用-ES6proxy-如何实现-arr-1-的访问（滴滴2020）\"><a href=\"#211-手写用-ES6proxy-如何实现-arr-1-的访问（滴滴2020）\" class=\"headerlink\" title=\"211. 手写用 ES6proxy 如何实现 arr[-1] 的访问（滴滴2020）\"></a>211. 手写用 <em>ES6proxy</em> 如何实现 <em>arr[-1]</em> 的访问（滴滴2020）</h3><blockquote>\n<p>参考答案：</p>\n<p>示例代码如下：</p>\n<pre><code class=\"javascript\">const proxyArray = arr =&gt; &#123;\n    const length = arr.length;\n    return new Proxy(arr, &#123;\n        get(target, key) &#123;\n            key = +key;\n            while (key &lt; 0) &#123;\n                key += length;\n            &#125;\n            return target[key];\n        &#125;\n    &#125;)\n&#125;;\nvar a = proxyArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconsole.log(a[1]);  // 2\nconsole.log(a[-10]);  // 9\nconsole.log(a[-20]);  // 8\n</code></pre>\n</blockquote>\n<h3 id=\"212-下列代码执行结果\"><a href=\"#212-下列代码执行结果\" class=\"headerlink\" title=\"212. 下列代码执行结果\"></a>212. 下列代码执行结果</h3><pre><code class=\"javascript\">console.log(1);\nsetTimeout(() =&gt; &#123;\n    console.log(2);\n    process.nextTick(() =&gt; &#123;\n        console.log(3);\n    &#125;);\n    new Promise((resolve) =&gt; &#123;\n        console.log(4);\n        resolve();\n    &#125;).then(() =&gt; &#123;\n        console.log(5);\n    &#125;);\n&#125;);\nnew Promise((resolve) =&gt; &#123;\n    console.log(7);\n    resolve();\n&#125;).then(() =&gt; &#123;\n    console.log(8);\n&#125;);\nprocess.nextTick(() =&gt; &#123;\n    console.log(6);\n&#125;);\nsetTimeout(() =&gt; &#123;\n    console.log(9);\n    process.nextTick(() =&gt; &#123;\n        console.log(10);\n    &#125;);\n    new Promise((resolve) =&gt; &#123;\n        console.log(11);\n        resolve();\n    &#125;).then(() =&gt; &#123;\n        console.log(12);\n    &#125;);\n&#125;);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>1<br>7<br>6<br>8<br>2<br>4<br>3<br>5<br>9<br>11<br>10<br>12</p>\n</blockquote>\n<h3 id=\"213-Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办\"><a href=\"#213-Number-的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办\" class=\"headerlink\" title=\"213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办\"></a>213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办</h3><blockquote>\n<p>参考答案：</p>\n<p>Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。</p>\n</blockquote>\n<h3 id=\"214-事件是如何实现的？-字节2020\"><a href=\"#214-事件是如何实现的？-字节2020\" class=\"headerlink\" title=\"214. 事件是如何实现的？(字节2020)\"></a>214. 事件是如何实现的？(字节2020)</h3><blockquote>\n<p>参考答案：</p>\n<p>基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。</p>\n<p>比如点击按钮，这是个事件(Event)，而负责处理事件的代码段通常被称为事件处理程序(Event Handler)，也就是「启动对话框的显示」这个动作。</p>\n<p>在 Web 端，我们常见的就是 DOM 事件：</p>\n<ul>\n<li>DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick &#x3D; null，同一个事件只能有一个处理程序，后面的会覆盖前面的。</li>\n<li>DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件</li>\n<li>DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件</li>\n</ul>\n</blockquote>\n<h3 id=\"215-下列代码执行结果\"><a href=\"#215-下列代码执行结果\" class=\"headerlink\" title=\"215. 下列代码执行结果\"></a>215. 下列代码执行结果</h3><pre><code class=\"javascript\">Promise.resolve().then(() =&gt; &#123;\n    console.log(0);\n    return Promise.resolve(4);\n&#125;).then((res) =&gt; &#123;\n    console.log(res)\n&#125;)\n\nPromise.resolve().then(() =&gt; &#123;\n    console.log(1);\n&#125;).then(() =&gt; &#123;\n    console.log(2);\n&#125;).then(() =&gt; &#123;\n    console.log(3);\n&#125;).then(() =&gt; &#123;\n    console.log(5);\n&#125;).then(() =&gt;&#123;\n    console.log(6);\n&#125;)\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>0<br>1<br>2<br>3<br>4<br>5<br>6</p>\n</blockquote>\n<blockquote>\n<p>解析：</p>\n<p>照着代码，我们先来看初始任务。</p>\n<ul>\n<li><p>（初始任务）第一部分 Promise.resolve() 返回 「Promise { undefined }」。</p>\n</li>\n<li><p>（同任务，下同）继续调用 then，then 发现「Promise { undefined }」已解决，直接 enqueue 包含 console.log(0);return Promise.resolve(4) 的任务，之后返回新的「Promise { &lt;pending&gt; }」（设为 promise0）。被 enqueue 的任务之后会引发 promise0 的 resolve&#x2F;reject，详见 追加任务一 的 2. 3. 。</p>\n</li>\n<li><p>继续调用 promise0 上的 then，第二个 then 发现 promise0 还在 pending，因此不能直接 enqueue 新任务，而是将包含 console.log(res) 回调追加到 promise0 的 PromiseFulfillReactions 列表尾部，并返回新的「Promise { <pending> }」（设为 promiseRes）（该返回值在代码中被丢弃，但不影响整个过程）。</p>\n</li>\n<li><p>第二部分 Promise.resolve().then… 同理，只有包含 console.log(1) 的任务被 enqueue。中间结果分别设为 promise1（&#x3D;Promise.resolve().then(() &#x3D;&gt; {console.log(1);})）, promise2, promise3, promise5, promise6。当前任务执行完毕。</p>\n</li>\n</ul>\n<p>此时，任务列队上有两个新任务，分别包含有 console.log(0);return Promise.resolve(4) 和 console.log(1) 。我们用 「Job { ??? }」来指代。</p>\n<p>接下来，「Job { console.log(0);return Promise.resolve(4) }」先被 enqueue，所以先运行「Job { console.log(0);return Promise.resolve(4) }」。</p>\n<ul>\n<li><p>（追加任务一）此时「0」被 console.log(0) 输出。Promise.resolve(4) 返回已解决的「Promise { 4 }」，然后 return Promise.resolve(4) 将这个「Promise { 4 }」作为最开始的 Promise.resolve().then（对应 promise0）的 onfulfill 处理程序（即 then(onfulfill, onreject) 的参数 onfulfill）的返回值返回。</p>\n</li>\n<li><p>（同任务，下同）onfulfill 处理程序返回，触发了 promise0 的 Promise Resolve Function（以下简称某 promise（实例）的 resolve）。所谓触发，其实是和别的东西一起打包到「Job { console.log(0);return Promise.resolve(4) }」当中，按流程执行，onfulfill 返回后自然就到它了。（onfulfill 抛异常的话会被捕获并触发 reject，正常返回就是 resolve。）</p>\n</li>\n<li><p>promise0 的 resolve 检查 onfulfill 的返回值，发现该值包含<strong>可调用的</strong>「then」属性。这是当然的，因为是「Promise { 4 }」。无论该 Promise 实例是否解决，都将 enqueue 一个新任务包含调用该返回值的 then 的任务（即规范中的 NewPromiseResolveThenableJob(promiseToResolve, thenable, then)）。而这个任务才会触发后续操作，在本例中，最终会将 promise0 的 PromiseFulfillReactions （其中有包含 console.log(res) 回调）再打包成任务 enqueue 到任务列队上。当前任务执行完毕。</p>\n</li>\n</ul>\n<p>此时，任务列队上还是有两个任务（一进一出），「Job { console.log(1) }」和「NewPromiseResolveThenableJob(promise0, 「Promise { 4 }」, 「Promise { 4 }」.then)」。接下来执行「Job { console.log(1) }」。</p>\n<ul>\n<li><p>（追加任务二）「1」被输出。</p>\n</li>\n<li><p>（同任务，下同）onfulfill 处理程序返回 undefined。（JavaScript 的函数默认就是返回 undefined。）</p>\n</li>\n<li><p>promise1 的 resolve 发现 undefined 连 Object 都不是，自然不会有 then，所以将 undefined 作为 promise1 的解决结果。即 promise1 从「Promise { &lt;pending&gt; }」变为 「Promise { undefined }」（fulfill）。</p>\n</li>\n<li><p>resolve 继续查看 promise1 的 PromiseFulfillReactions。（reject 则会查看 PromiseRejectReactions。）有一个之前被 promise1.then 调用追加上的包含 console.log(2) 的回调。打包成任务入列。（如有多个则依次序分别打包入列。）当前任务执行完毕。</p>\n</li>\n</ul>\n<p>此时，任务列队上仍然有两个任务（一进一出）。「NewPromiseResolveThenableJob(…)」和 「Job { console.log(2) }」。执行「NewPromiseResolveThenableJob(…)」。</p>\n<ul>\n<li><p>（追加任务三）调用 「Promise { 4 }」的 then。这个调用的参数（处理程序 onfulfill 和 onreject） 用的正是 promise0 的 resolve 和 reject。</p>\n</li>\n<li><p>由于「Promise { 4 }」的 then 是标准的，行为和其他的 then 一致。（可参见初始任务的步骤 2. 。）它发现「Promise { 4 }」已解决，结果是 4。于是直接 enqueue 包含 promise0 的 resolve 的任务，参数是 4。理论上同样返回一个「Promise { <pending> }」，由于是在内部，不被外部观察，也不产生别的影响。）当前任务执行完毕。</p>\n</li>\n</ul>\n<p>此时，任务列队上依旧有两个任务（一进一出）。「Job { console.log(2) }」和 「Job { promise0 的 resolve }」。执行「Job { console.log(2) }」。</p>\n<ul>\n<li>（追加任务四）过程类似「Job { console.log(1) }」的执行。「2」被输出。「Job { console.log(3) }」入列。其余不再赘述。当前任务执行完毕。</li>\n</ul>\n<p>此时，任务列队上依然有两个任务（一进一出）。「Job { promise0 的 resolve }」和「Job { console.log(3) }」。执行「Job { promise0 的 resolve }」。</p>\n<ul>\n<li>（追加任务五）promise0 的 resolve 查看 PromiseFulfillReactions 发现有被 promise0.then 追加的回调。打包成任务入列。该任务包含 console.log(res)，其中传递 promise0 解决结果 4 给参数 res。当前任务执行完毕。</li>\n</ul>\n<p>此时，任务列队上还是两个任务（一进一出）。「Job { console.log(3) }」和「Job { console.log(res) }」。</p>\n<ul>\n<li>（追加任务六）输出「3」。「Job { console.log(5) }」入列。</li>\n</ul>\n<p>此时，任务列队上还是两个任务（一进一出）。「Job { console.log(res) }」和「Job { console.log(5) }」。</p>\n<ul>\n<li>（追加任务七）输出「4」。由于 promiseRes 没有被 then 追加回调。就此打住。</li>\n</ul>\n<p>此时，任务列队上终于不再是两个任务了。下剩「Job { console.log(5) }」。</p>\n<ul>\n<li>（追加任务八）输出「5」。「Job { console.log(6) }」入列。</li>\n</ul>\n<p>最后一个任务（追加任务九）输出「6」。任务列队清空。</p>\n<p>因此，输出的顺序是「0 1 2 3 4 5 6」。</p>\n<p>总结一下，除去初始任务，总共 enqueue 了 9 个任务。其中，第一串 Promise + then… enqueue 了 4 个。第二串 Promise + then… enqueue 了 5 个。分析可知，每增加一个 then 就会增加一个任务入列。</p>\n<p>而且，第一串的 return Promise.resolve(4) 的写法额外 enqueue 了 2 个任务，分别在 promise0 的 resolve 时（追加任务一 3.）和调用「Promise { 4 }」的 then 本身时（追加任务三 2.）。</p>\n<p>根据规范，它就该这样。说不上什么巧合，可以算是有意为之。处理程序里返回 thenable 对象就会导致增加两个任务入列。</p>\n</blockquote>\n<h3 id=\"216-判断数组的方法，请分别介绍它们之间的区别和优劣\"><a href=\"#216-判断数组的方法，请分别介绍它们之间的区别和优劣\" class=\"headerlink\" title=\"216. 判断数组的方法，请分别介绍它们之间的区别和优劣\"></a>216. 判断数组的方法，请分别介绍它们之间的区别和优劣</h3><blockquote>\n<p>参考答案：</p>\n<p>方法一：<strong>instanceof 操作符判断</strong></p>\n<p><strong>用法：arr instanceof Array</strong></p>\n<p><strong>instanceof 主要是用来判断某个实例是否属于某个对象</strong></p>\n<pre><code class=\"javascript\">let arr = [];\nconsole.log(arr instanceof Array); // true\n</code></pre>\n<p>缺点：instanceof是判断类型的prototype是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。并且也不能判断对象和数组的区别</p>\n<p>方法二：<strong>对象构造函数的 constructor判断</strong></p>\n<p><strong>用法：arr.constructor &#x3D;&#x3D;&#x3D; Array</strong></p>\n<p><strong>Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数</strong></p>\n<pre><code class=\"javascript\">let arr = [];\nconsole.log(arr.constructor === Array); // true\n</code></pre>\n<p>方法三：<strong>Array 原型链上的 isPrototypeOf</strong></p>\n<p><strong>用法：Array.prototype.isPrototypeOf(arr</strong>)</p>\n<p><strong>Array.prototype  属性表示 Array 构造函数的原型</strong></p>\n<p>其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。</p>\n<pre><code class=\"javascript\">let arr = [];\nconsole.log(Array.prototype.isPrototypeOf(arr)); // true\n</code></pre>\n<p>方法四：<strong>Object.getPrototypeOf</strong></p>\n<p><strong>用法：Object.getPrototypeOf(arr) &#x3D;&#x3D;&#x3D; Array.prototype</strong></p>\n<p><strong>Object.getPrototypeOf() 方法返回指定对象的原型</strong></p>\n<p>所以只要跟Array的原型比较即可</p>\n<pre><code class=\"javascript\">let arr = [];\nconsole.log(Object.getPrototypeOf(arr) === Array.prototype); // true\n</code></pre>\n<p>方法五：<strong>Object.prototype.toString</strong></p>\n<p><strong>用法：Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; ‘[object Array]’</strong></p>\n<p>虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。</p>\n<pre><code class=\"javascript\">let arr = [];\nconsole.log(Object.prototype.toString.call(arr) === &#39;[object Array]&#39;); // true\n</code></pre>\n<p>缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]</p>\n<p>方法六：<strong>Array.isArray</strong></p>\n<p><strong>用法：Array.isArray(arr)</strong></p>\n<p><strong>ES5中新增了Array.isArray方法,IE8及以下不支持</strong></p>\n<p>Array.isArray ( arg )<br>isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 “Array”, 返回布尔值 true；否则它返回 false。</p>\n<pre><code class=\"javascript\">let arr = [];\nconsole.log(Array.isArray(arr)); // true\n</code></pre>\n<p>缺点：Array.isArray是ES 5.1推出的，<strong>不支持IE6~8</strong>，所以在使用的时候需要注意兼容性问题。</p>\n</blockquote>\n<h3 id=\"217-JavaScript-中的数组和函数在内存中是如何存储的？\"><a href=\"#217-JavaScript-中的数组和函数在内存中是如何存储的？\" class=\"headerlink\" title=\"217. JavaScript 中的数组和函数在内存中是如何存储的？\"></a>217. JavaScript 中的数组和函数在内存中是如何存储的？</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>JavaScript</em> 中，数组不是以一段连续的区域存储在内存中，而是一种哈希映射的形式存储在堆内容里面。它可以通过多种数据结构实现，其中一种是链表。如下图所示：</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-18-125006.png\" alt=\"image-20210818205006459\" style=\"zoom:50%;\" />\n\n<p>JavaScript 中的函数是存储在堆内存中的，具体的步骤如下：</p>\n<ol>\n<li>开辟堆内存（<em>16</em> 进制得到内存地址）</li>\n<li>声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）</li>\n<li>把函数的代码以字符串的形式存储在堆内存中（函数再不执行的情况下，只是存储在堆内存中的字符串）</li>\n<li>将函数堆的地址，放在栈中供变量调用（函数名）</li>\n</ol>\n</blockquote>\n<h3 id=\"218-JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？\"><a href=\"#218-JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？\" class=\"headerlink\" title=\"218. JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？\"></a>218. <em>JavaScript</em> 是如何运行的？解释型语言和编译型语言的差异是什么？</h3><blockquote>\n<p>参考答案：</p>\n<p>关于第一个问题，这不是三言两语或者几行文字就能够讲清楚的，这里放上一篇博文地址：</p>\n<p><em><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxOTUzMDEwOQ==\">https://segmentfault.com/a/1190000019530109</span></em></p>\n<p>之后在直播课或者录屏课进行详细的讲解</p>\n<p>第二个问题：解释型语言和编译型语言的差异是什么？</p>\n<p>电脑能认得的是二进制数，不能够识别高级语言。所有高级语言在电脑上执行都需要先转变为机器语言。但是高级语言有两种类型：编译型语言和解释型语言。常见的编译型语言语言有C&#x2F;C++、Pascal&#x2F;Object 等等。常见的解释性语言有python、JavaScript等等。</p>\n<p>编译型语言先要进行编译，然后转为特定的可执行文件，这个可执行文件是针对平台的（CPU类型），可以这么理解你在PC上编译一个C源文件，需要经过预处理，编译，汇编等等过程生成一个可执行的二进制文件。当你需要再次运行改代码时，不需要重新编译代码，只需要运行该可执行的二进制文件。优点，编译一次，永久执行。还有一个优点是，你不需要提供你的源代码，你只需要发布你的可执行文件就可以为客户提供服务，从而保证了你的源代码的安全性。但是，如果你的代码需要迁移到linux、ARM下时，这时你的可执行文件就不起作用了，需要根据新的平台编译出一个可执行的文件。这也就是多个平台需要软件的多个版本。缺点是，跨平台能力差。</p>\n<p>解释型语言需要一个解释器，在源代码执行的时候被解释器翻译为一个与平台无关的中间代码，解释器会把这些代码翻译为及其语言。打个比方，编译型中的编译相当于一个翻译官，它只能翻译英语，而且中文文章翻译一次就不需要重新对文章进行二次翻译了，但是如果需要叫这个翻译官翻译德语就不行了。而解释型语言中的解释器相当于一个会各种语言的机器人，而且这个机器人回一句一句的翻译你的语句。对于不同的国家，翻译成不同的语言，所以，你只需要带着这个机器人就可以。解释型语言的有点是，跨平台，缺点是运行时需要源代码，知识产权保护性差，运行效率低。</p>\n</blockquote>\n<h3 id=\"219-列举你所了解的编程范式？\"><a href=\"#219-列举你所了解的编程范式？\" class=\"headerlink\" title=\"219. 列举你所了解的编程范式？\"></a>219. 列举你所了解的编程范式？</h3><blockquote>\n<p>参考答案：</p>\n<p>编程范式 <em>Programming paradigm</em> 是指计算机中编程的典范模式或方法。</p>\n<p>常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程等。</p>\n<p>不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的，如 <em>Smalltalk</em> 和 <em>Java</em> 支持面向对象编程。而 <em>Haskell</em> 和 <em>Scheme</em> 则支持函数式编程。现代编程语言的发展趋势是支持多种范型，例如 <em>ES</em> 支持函数式编程的同时也支持面向对象编程。</p>\n</blockquote>\n<h3 id=\"220-什么是面向切面（AOP）的编程？\"><a href=\"#220-什么是面向切面（AOP）的编程？\" class=\"headerlink\" title=\"220. 什么是面向切面（AOP）的编程？\"></a>220. 什么是面向切面（AOP）的编程？</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>什么是AOP？</strong></p>\n<p>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。</p>\n<p><strong>AOP能给我们带来什么好处？</strong></p>\n<p>AOP的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 </p>\n<p><strong>JavaScript实现AOP的思路？</strong></p>\n<p>通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，下面我用扩展 Function.prototype 来做到这一点。 </p>\n<p>主要就是两个函数，在Function的原型上加上before与after，作用就是字面的意思，在函数的前面或后面执行，相当于<strong>无侵入</strong>把一个函数插入到另一个函数的前面或后面，应用得当可以很好的实现代码的解耦，js中的代码实现如下：</p>\n<pre><code class=\"javascript\">//Aop构造器\nfunction Aop(options)&#123;\n    this.options = options\n&#125;\n//业务方法执行前钩子\nAop.prototype.before = function(cb)&#123;\n    cb.apply(this)\n&#125;\n//业务方法执行后钩子\nAop.prototype.after = function(cb)&#123;\n    cb.apply(this)\n&#125;\n//业务方法执行器\nAop.prototype.execute = function(beforeCb,runner,afterCb)&#123;\n    this.before(beforeCb)\n    runner.apply(this)\n    this.after(afterCb)\n&#125;\n\nvar aop = new Aop(&#123;\n    afterInfo:&#39;执行后&#39;,\n    runnerInfo:&#39;执行中&#39;,\n    beforeInfo:&#39;执行前&#39;\n&#125;)\n\nvar beforeCb = function()&#123;\n    console.log(this.options.beforeInfo)\n&#125;\nvar afterCb = function()&#123;\n    console.log(this.options.afterInfo)\n&#125;\nvar runnerCb = function()&#123;\n    console.log(this.options.runnerInfo)\n&#125;\n\naop.execute(beforeCb,runnerCb,afterCb)\n</code></pre>\n<p>应用的一些例子：</p>\n<ol>\n<li>为 <em>window.onload</em> 添加方法，防止 <em>window.onload</em> 被二次覆盖</li>\n<li>无侵入统计某个函数的执行时间</li>\n<li>表单校验</li>\n<li>统计埋点</li>\n<li>防止 <em>csrf</em> 攻击</li>\n</ol>\n</blockquote>\n<h3 id=\"221-JavaScript-中的-const-数组可以进行-push-操作吗？为什么？\"><a href=\"#221-JavaScript-中的-const-数组可以进行-push-操作吗？为什么？\" class=\"headerlink\" title=\"221. JavaScript 中的 const 数组可以进行 push 操作吗？为什么？\"></a>221. <em>JavaScript</em> 中的 <em>const</em> 数组可以进行 <em>push</em> 操作吗？为什么？</h3><blockquote>\n<p>参考答案：</p>\n<p>可以进行 <em>push</em> 操作。虽然 <em>const</em> 表示常量，但是当我们把一个数组赋值给 <em>const</em> 声明的变量时，实际上是把这个数组的地址赋值给该变量。而 <em>push</em> 操作是在数组地址所指向的堆区添加元素，地址本身并没有发生改变。</p>\n<p>示例代码：</p>\n<pre><code class=\"javascript\">const arr = [1];\narr.push(2);\nconsole.log(arr); // [1, 2]\n</code></pre>\n</blockquote>\n<h3 id=\"222-JavaScript-中对象的属性描述符有哪些？分别有什么作用？\"><a href=\"#222-JavaScript-中对象的属性描述符有哪些？分别有什么作用？\" class=\"headerlink\" title=\"222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？\"></a>222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？</h3><blockquote>\n<p>参考答案：</p>\n<p>从<em>ES5</em>开始，添加了对对象<strong>属性描述符</strong>的支持。现在<em>JavaScript</em>中支持 <em>4</em> 种属性描述符:</p>\n<ul>\n<li><strong>configurable:</strong> 当且仅当该属性的<em>configurable</em>键值为<em>true</em>时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</li>\n<li><strong>enumerable:</strong> 当且仅当该属性的<em>enumerable</em>键值为<em>true</em>时，该属性才会出现在对象的枚举属性中。</li>\n<li><strong>value:</strong> 该属性对应的值。可以是任何有效的 <em>JavaScript</em> 值（数值，对象，函数等）。</li>\n<li><strong>writable:</strong> 当且仅当该属性的<em>writable</em>键值为<em>true</em>时，属性的值，也就是上面的value，才能被赋值运算符改变。</li>\n</ul>\n</blockquote>\n<h3 id=\"223-JavaScript-中-console-有哪些-api\"><a href=\"#223-JavaScript-中-console-有哪些-api\" class=\"headerlink\" title=\"223. JavaScript 中 console 有哪些 api ?\"></a>223. <em>JavaScript</em> 中 <em>console</em> 有哪些 <em>api</em> ?</h3><blockquote>\n<p>参考答案：</p>\n<p><strong>console.assert(expression, object[, object…])</strong></p>\n<p>接收至少两个参数，第一个参数的值或返回值为<code>false</code>的时候，将会在控制台上输出后续参数的值。</p>\n<p><strong>console.count([label])</strong></p>\n<p>输出执行到该行的次数，可选参数 label 可以输出在次数之前。</p>\n<p><strong>console.dir(object)</strong></p>\n<p>将传入对象的属性，包括子对象的属性以列表形式输出。</p>\n<p><strong>console.error(object[, object…])</strong></p>\n<p>用于输出错误信息，用法和常见的<code>console.log</code>一样，不同点在于输出内容会标记为错误的样式，便于分辨。</p>\n<p><strong>console.group</strong></p>\n<p>这是个有趣的方法，它能够让控制台输出的语句产生不同的层级嵌套关系，每一个<code>console.group()</code>会增加一层嵌套，相反要减少一层嵌套可以使用<code>console.groupEnd()</code>方法。</p>\n<p><strong>console.info(object[, object…])</strong></p>\n<p>此方法与之前说到的<code>console.error</code>一样，用于输出信息，没有什么特别之处。</p>\n<p><strong>console.table()</strong></p>\n<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>\n<p><strong>console.log(object[, object…])</strong></p>\n<p>输入一段 <em>log</em> 信息。</p>\n<p><strong>console.profile([profileLabel])</strong></p>\n<p>这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及<code>console.profile()</code>方法我们可以很方便地监控运行性能。</p>\n<p><strong>console.time(name)</strong><br>计时器，可以将成对的<code>console.time()</code>和<code>console.timeEnd()</code>之间代码的运行时间输出到控制台上，<code>name</code>参数可作为标签名。</p>\n<p><strong>console.trace()</strong></p>\n<p><code>console.trace()</code>用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，<code>console.trace()</code>方法可以将函数的被调用过程清楚地输出到控制台上。</p>\n<p><strong>console.warn(object[, object…])</strong></p>\n<p>输出参数的内容，作为警告提示。</p>\n</blockquote>\n<h3 id=\"224-简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？\"><a href=\"#224-简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？\" class=\"headerlink\" title=\"224. 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？\"></a>224. 简单对比一下 <em>Callback、Promise、Generator、Async</em> 几个异步 <em>API</em> 的优劣？</h3><blockquote>\n<p>参考答案：</p>\n<p>请参阅前面第 <em>31</em> 题答案。</p>\n</blockquote>\n<h3 id=\"225-Object-defineProperty-有哪几个参数？各自都有什么作用\"><a href=\"#225-Object-defineProperty-有哪几个参数？各自都有什么作用\" class=\"headerlink\" title=\"225. Object.defineProperty 有哪几个参数？各自都有什么作用\"></a>225. <em>Object.defineProperty</em> 有哪几个参数？各自都有什么作用</h3><blockquote>\n<p>参考答案：</p>\n<p>在 <em>JavaScript</em> 中，通过 <em>Object.defineProperty</em> 方法可以设置对象属性的特性，选项如下：</p>\n<ul>\n<li><em>get</em>：一旦目标属性被访问时，就会调用相应的方法</li>\n<li><em>set</em>：一旦目标属性被设置时，就会调用相应的方法</li>\n<li><em>value</em>：这是属性的值，默认是 <em>undefined</em></li>\n<li><em>writable</em>：这是一个布尔值，表示一个属性是否可以被修改，默认是 <em>true</em></li>\n<li><em>enumerable</em>：这是一个布尔值，表示在用 <em>for-in</em> 循环遍历对象的属性时，该属性是否可以显示出来，默认值为 <em>true</em></li>\n<li><em>configurable</em>：这是一个布尔值，表示我们是否能够删除一个属性或者修改属性的特性，默认值为 <em>true</em></li>\n</ul>\n</blockquote>\n<h3 id=\"226-Object-defineProperty-和-ES6-的-Proxy-有什么区别？\"><a href=\"#226-Object-defineProperty-和-ES6-的-Proxy-有什么区别？\" class=\"headerlink\" title=\"226. Object.defineProperty 和 ES6 的 Proxy 有什么区别？\"></a>226. <em>Object.defineProperty</em> 和 <em>ES6</em> 的 <em>Proxy</em> 有什么区别？</h3><blockquote>\n<p>参考答案：</p>\n<h5 id=\"1、Object-defineproperty\"><a href=\"#1、Object-defineproperty\" class=\"headerlink\" title=\"1、Object.defineproperty\"></a>1、<em>Object.defineproperty</em></h5><p>可以用于监听对象的数据变化</p>\n<p>语法： <em><strong>Object.defineproperty(obj, key, descriptor)</strong></em></p>\n<pre><code class=\"javascript\">let obj = &#123;\n    age: 11\n&#125;\nlet value = &#39;xiaoxiao&#39;;\n//defineproperty 有 gettter 和 setter\nObject.defineproperty(obj, &#39;name&#39;, &#123;\n    get() &#123;\n        return value\n    &#125;,\n    set(newValue) &#123;\n        value = newValue\n    &#125;\n&#125;)\nobj.name = &#39;pengpeng&#39;;\n</code></pre>\n<p>此外 还有以下配置项 ：</p>\n<ul>\n<li><em>configurable</em></li>\n<li><em>enumerable</em></li>\n<li><em>value</em></li>\n</ul>\n<p>缺点：</p>\n<ol>\n<li><p>无法监听数组变化</p>\n</li>\n<li><p>只能劫持对象的属性，属性值也是对象那么需要深度遍历</p>\n</li>\n</ol>\n<h5 id=\"2、proxy-：可以理解为在被劫持的对象之前-加了一层拦截\"><a href=\"#2、proxy-：可以理解为在被劫持的对象之前-加了一层拦截\" class=\"headerlink\" title=\"2、proxy ：可以理解为在被劫持的对象之前 加了一层拦截\"></a>2、<em>proxy</em> ：可以理解为在被劫持的对象之前 加了一层拦截</h5><pre><code class=\"javascript\">let proxy = new Proxy(&#123;&#125;, &#123;\n    get(obj, prop) &#123;\n        return obj[prop]\n    &#125;,\n    set(obj, prop, val) &#123;\n        obj[prop] = val\n    &#125;\n&#125;)\n</code></pre>\n<ul>\n<li><em>proxy</em> 返回的是一个新对象， 可以通过操作返回的新的对象达到目的</li>\n<li><em>proxy</em> 有多达 <em>13</em> 种拦截方法</li>\n</ul>\n<p><strong>总结：</strong></p>\n<ul>\n<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li>\n<li><em>Object.defineProperty</em> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<em>Proxy</em> 可以劫持整个对象，并返回一个新的对象。</li>\n<li><em>Proxy</em> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>\n</ul>\n</blockquote>\n<h3 id=\"227-intanceof-操作符的实现原理及实现\"><a href=\"#227-intanceof-操作符的实现原理及实现\" class=\"headerlink\" title=\"227. intanceof 操作符的实现原理及实现\"></a>227. <em>intanceof</em> 操作符的实现原理及实现</h3><blockquote>\n<p>参考答案：</p>\n<p><em>instanceof</em> 主要作用就是判断一个实例是否属于某种类型</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">let Dog = function()&#123;&#125;\nlet tidy = new Dog()\ntidy instanceof Dog //true\n</code></pre>\n<p><em>intanceof</em> 操作符实现原理</p>\n<pre><code class=\"javascript\">function wonderFulInstanceOf(instance, constructorFn) &#123; \n    let constructorFnProto = constructorFn.prototype; // 取右表达式的 prototype 值，函数构造器指向的function \n    instanceProto = instance.__proto__; // 取左表达式的__proto__值，实例的__proto__\n    while (true) &#123;\n        if (instanceProto === null) &#123;\n            return false;\t\n        &#125;\n        if (instanceProto === constructorFnProto) &#123;\n            return true;\t\n        &#125; \n        instanceProto = instanceProto.__proto__ \n    &#125;\n&#125;\n</code></pre>\n<p>其实 <em>instanceof</em> 主要的实现原理就是只要 <em>constructorFn</em> 的 <em>prototype</em> 在<em>instance</em>的原型链上即可。</p>\n<p>因此，<em>instanceof</em> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <em>prototype</em>，如果查找失败，则会返回 <em>false</em>，告诉我们左边变量并非是右边变量的实例。</p>\n</blockquote>\n<h3 id=\"228-强制类型转换规则？\"><a href=\"#228-强制类型转换规则？\" class=\"headerlink\" title=\"228. 强制类型转换规则？\"></a>228. 强制类型转换规则？</h3><blockquote>\n<p>参考答案：</p>\n<p>首先需要参阅前面第 <em>104</em> 题答案。了解隐式转换所调用的函数。</p>\n<p>当程序员显式调用 Boolean(value)、Number(value)、String(value) 完成的类型转换，叫做显示类型转换。</p>\n<p>当通过 new Boolean(value)、new Number(value)、new String(value) 传入各自对应的原始类型的值，可以实现“装箱”，将原始类型封装成一个对象。</p>\n<p>其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：</p>\n<pre><code class=\"javascript\">Boolean(&#39;sdfsd&#39;);  //  true\nNumber(&quot;23&quot;);  //  23\nString(&#123;a:24&#125;);  //  &quot;[object Object]&quot;\n</code></pre>\n<p>其实这三个函数用于类型转换的时候，调用的就是 js 内部的 <em>ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )</em> 方法，从而达到显式转换的效果。</p>\n</blockquote>\n<h3 id=\"229-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别\"><a href=\"#229-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别\" class=\"headerlink\" title=\"229. Object.is( ) 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别\"></a>229. <em>Object.is</em>( ) 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>&#x3D;&#x3D; (或者 !&#x3D;) 操作在需要的情况下自动进行了类型转换。&#x3D;&#x3D;&#x3D; (或 !&#x3D;&#x3D;)操作不会执行任何转换。</p>\n<p>&#x3D;&#x3D;&#x3D;在比较值和类型时，可以说比&#x3D;&#x3D;更快。</p>\n<p>而在<em>ES6</em>中，<em>Object.is</em>( ) 类似于 &#x3D;&#x3D;&#x3D;，但在三等号判等的基础上特别处理了 <em>NaN</em> 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 <em>Object.is(NaN, NaN)</em> 会返回 <em>true</em>。</p>\n</blockquote>\n<h3 id=\"230-操作符什么时候用于字符串的拼接？\"><a href=\"#230-操作符什么时候用于字符串的拼接？\" class=\"headerlink\" title=\"230. + 操作符什么时候用于字符串的拼接？\"></a>230. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><blockquote>\n<p>参考答案：</p>\n<p>在有一边操作数是字符串时会进行字符串拼接。</p>\n<p>示例代码：</p>\n<pre><code class=\"javascript\">console.log(5 + &#39;5&#39;, typeof (5 + &#39;5&#39;)); // 55  string\n</code></pre>\n</blockquote>\n<h3 id=\"231-object-assign-和扩展运算法是深拷贝还是浅拷贝\"><a href=\"#231-object-assign-和扩展运算法是深拷贝还是浅拷贝\" class=\"headerlink\" title=\"231. object.assign 和扩展运算法是深拷贝还是浅拷贝\"></a>231. <em>object.assign</em> 和扩展运算法是深拷贝还是浅拷贝</h3><blockquote>\n<p>参考答案：</p>\n<p>这两个方式都是浅拷贝。</p>\n<p>在拷贝的对象只有一层时是深拷贝，但是一旦对象的属性值又是一个对象，也就是有两层或者两层以上时，就会发现这两种方式都是浅拷贝。</p>\n</blockquote>\n<h3 id=\"232-const-对象的属性可以修改吗\"><a href=\"#232-const-对象的属性可以修改吗\" class=\"headerlink\" title=\"232. const 对象的属性可以修改吗\"></a>232. <em>const</em> 对象的属性可以修改吗</h3><blockquote>\n<p>参考答案：</p>\n<p>可以修改，具体原因可以参阅前面第 <em>231</em> 题。</p>\n</blockquote>\n<h3 id=\"233-如果-new-一个箭头函数的会怎么样\"><a href=\"#233-如果-new-一个箭头函数的会怎么样\" class=\"headerlink\" title=\"233. 如果 new 一个箭头函数的会怎么样\"></a>233. 如果 <em>new</em> 一个箭头函数的会怎么样</h3><blockquote>\n<p>参考答案：</p>\n<p>会报错，因为箭头函数无法作为构造函数。</p>\n</blockquote>\n<h3 id=\"234-扩展运算符的作用及使用场景\"><a href=\"#234-扩展运算符的作用及使用场景\" class=\"headerlink\" title=\"234. 扩展运算符的作用及使用场景\"></a>234. 扩展运算符的作用及使用场景</h3><blockquote>\n<p>参考答案：</p>\n<p>扩展运算符是三个点(…)，主要用于展开数组，将一个数组转为参数序列。</p>\n<p>扩展运算符使用场景：</p>\n<ul>\n<li>代替数组的 <em>apply</em> 方法</li>\n<li>合并数组</li>\n<li>复制数组</li>\n<li>把 <em>arguments</em> 或 <em>NodeList</em> 转为数组</li>\n<li>与解构赋值结合使用</li>\n<li>将字符串转为数组</li>\n</ul>\n</blockquote>\n<h3 id=\"235-Proxy-可以实现什么功能？\"><a href=\"#235-Proxy-可以实现什么功能？\" class=\"headerlink\" title=\"235. Proxy 可以实现什么功能？\"></a>235. <em>Proxy</em> 可以实现什么功能？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>Proxy</em> 是 <em>ES6</em> 中新增的一个特性。<em>Proxy</em> 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p>\n<p><em>Proxy</em> 在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截。</p>\n<p>使用 <em>Proxy</em> 的好处是对象只需关注于核心逻辑，一些非核心的逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 <em>Proxy</em> 来做。从而达到关注点分离，降级对象复杂度的目的。</p>\n<p><em>Proxy</em> 的基本语法如下：</p>\n<pre><code class=\"javascript\">var proxy = new Proxy(target, handler);\n</code></pre>\n<p>通过构造函数来生成 <em>Proxy</em> 实例，构造函数接收两个参数。<em>target</em> 参数是要拦截的目标对象，<em>handler</em> 参数也是一个对象，用来定制拦截行为。</p>\n<p><em>Vue 3.0</em> 主要就采用的 <em>Proxy</em> 特性来实现响应式，相比以前的 <em>Object.defineProperty</em> 有以下优点：</p>\n<ul>\n<li>可以劫持整个对象，并返回一个新的对象</li>\n<li>有 <em>13</em> 种劫持操作</li>\n</ul>\n</blockquote>\n<h3 id=\"236-对象与数组的解构的理解\"><a href=\"#236-对象与数组的解构的理解\" class=\"headerlink\" title=\"236. 对象与数组的解构的理解\"></a>236. 对象与数组的解构的理解</h3><blockquote>\n<p>参考答案：</p>\n<p>解构是 <em>ES6</em> 的一种语法规则，可以将一个对象或数组的某个属性提取到某个变量中。</p>\n<p>解构对象示例：</p>\n<pre><code class=\"javascript\">//  var/let/const&#123;属性名&#125;=被解构的对象\nconst user = &#123;\n    name: &quot;abc&quot;,\n    age: 18,\n    sex: &quot;男&quot;,\n    address: &#123;\n        province: &quot;重庆&quot;,\n        city: &quot;重庆&quot;\n    &#125;\n&#125;\nlet &#123; name, age, sex, address&#125; = user;\nconsole.log(name, age, sex, address);\n</code></pre>\n<p>解构数组示例：</p>\n<pre><code class=\"javascript\">const [a, b, c] = [1, 2, 3];\n</code></pre>\n</blockquote>\n<h3 id=\"237-如何提取高度嵌套的对象里的指定属性？\"><a href=\"#237-如何提取高度嵌套的对象里的指定属性？\" class=\"headerlink\" title=\"237. 如何提取高度嵌套的对象里的指定属性？\"></a>237. 如何提取高度嵌套的对象里的指定属性？</h3><blockquote>\n<p>参考答案：</p>\n<p>一般会使用递归的方式来进行查找。下面是一段示例代码：</p>\n<pre><code class=\"javascript\">function findKey(data, field) &#123;\n    let finding = &#39;&#39;;\n    for (const key in data) &#123;\n        if (key === field) &#123;\n            finding = data[key];\n        &#125;\n        if (typeof (data[key]) === &#39;object&#39;) &#123;\n            finding = findKey(data[key], field);\n        &#125;\n        if (finding) &#123;\n            return finding;\n        &#125;\n    &#125;\n    return null;\n&#125;\n// 测试\nconsole.log(findKey(&#123;\n    name: &#39;zhangsan&#39;,\n    age: 18,\n    stuInfo: &#123;\n        stuNo: 1,\n        classNo: 2,\n        score: &#123;\n            htmlScore: 100,\n            cssScore: 90,\n            jsScore: 95\n        &#125;\n    &#125;\n&#125;, &#39;cssScore&#39;)); // 90\n</code></pre>\n</blockquote>\n<h3 id=\"238-Unicode、UTF-8、UTF-16、UTF-32-的区别？\"><a href=\"#238-Unicode、UTF-8、UTF-16、UTF-32-的区别？\" class=\"headerlink\" title=\"238. Unicode、UTF-8、UTF-16、UTF-32 的区别？\"></a>238. <em>Unicode、UTF-8、UTF-16、UTF-32</em> 的区别？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>Unicode</em> <strong>为世界上所有字符都分配了一个唯一的数字编号</strong>，这个编号范围从 <em>0x000000</em> 到 <em>0x10FFFF</em> (十六进制)，有 <em>110</em> 多万，每个字符都有一个唯一的 <em>Unicode</em> 编号，这个编号一般写成 <em>16</em> 进制，在前面加上 U+。例如：“马”的 <em>Unicode</em> 是 <em>U+9A6C</em>。<br><em>Unicode</em> 就相当于一张表，建立了字符与编号之间的联系。</p>\n<img data-src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-17-080125.png\" alt=\"image-20210817160125144\" style=\"zoom:50%;\" />\n\n<p><strong><em>Unicode</em> 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</strong></p>\n<p>那我们可以直接把 <em>Unicode</em> 编号直接转换成二进制进行存储，怎么对应到二进制表示呢？</p>\n<p><em>Unicode</em> 可以使用的编码有三种，分别是：</p>\n<ul>\n<li><em>UFT-8</em>：一种变长的编码方案，使用 <em>1~6</em> 个字节来存储；</li>\n<li><em>UFT-32</em>：一种固定长度的编码方案，不管字符编号大小，始终使用 <em>4</em> 个字节来存储；</li>\n<li><em>UTF-16</em>：介于 <em>UTF-8</em> 和 <em>UTF-32</em> 之间，使用 <em>2</em> 个或者 <em>4</em> 个字节来存储，长度既固定又可变。</li>\n</ul>\n</blockquote>\n<h3 id=\"239-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组\"><a href=\"#239-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组\" class=\"headerlink\" title=\"239. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?\"></a>239. 为什么函数的 <em>arguments</em> 参数是类数组而不是数组？如何遍历类数组?</h3><blockquote>\n<p>参考答案：</p>\n<p>首先了解一下什么是数组对象和类数组对象。</p>\n<p>数组对象：使用单独的变量名来存储一系列的值。从 <em>Array</em> 构造函数中继承了一些用于进行数组操作的方法。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">var mycars = new Array();\nmycars[0] = &quot;zhangsan&quot;;\nmycars[1] = &quot;lisi&quot;;\nmycars[2] = &quot;wangwu&quot;;\n</code></pre>\n<p>类数组对象：<strong>对于一个普通的对象来说，如果它的所有 property 名均为正整数，同时也有相应的length属性，那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。</strong></p>\n<p><strong>两者区别</strong></p>\n<ul>\n<li><p>一个是对象，一个是数组</p>\n</li>\n<li><p>数组的<em>length</em>属性，当新的元素添加到列表中的时候，其值会自动更新。类数组对象的不会。</p>\n</li>\n<li><p>设置数组的<em>length</em>属性可以扩展或截断数组。</p>\n</li>\n<li><p>数组也是<em>Array</em>的实例可以调用<em>Array</em>的方法，比如<em>push、pop</em>等等</p>\n</li>\n</ul>\n<p>所以说<em>arguments</em>对象不是一个 <em>Array</em> 。它类似于<em>Array</em>，但除了<em>length</em>属性和索引元素之外没有任何<em>Array</em>属性。</p>\n<p>可以使用 <em>for…in</em> 来遍历 <em>arguments</em> 这个类数组对象。</p>\n</blockquote>\n<h3 id=\"240-escape、encodeURI、encodeURIComponent-的区别\"><a href=\"#240-escape、encodeURI、encodeURIComponent-的区别\" class=\"headerlink\" title=\"240. escape、encodeURI、encodeURIComponent 的区别\"></a>240. <em>escape、encodeURI、encodeURIComponent</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p><em>escape</em> 除了 <em>ASCII</em> 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对 <em>URL</em> 编码，最好不要使用此方法。</p>\n<p><em>encodeURI</em> 用于编码整个 <em>URI</em>，因为 <em>URI</em> 中的合法字符都不会被编码转换。</p>\n<p><em>encodeURIComponent</em> 方法在编码单个<em>URIComponent</em>（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个 <em>URL</em>。</p>\n</blockquote>\n<h3 id=\"241-use-strict-是什么意思-使用它区别是什么？\"><a href=\"#241-use-strict-是什么意思-使用它区别是什么？\" class=\"headerlink\" title=\"241. use strict 是什么意思 ? 使用它区别是什么？\"></a>241. <em>use strict</em> 是什么意思 ? 使用它区别是什么？</h3><blockquote>\n<p>参考答案：</p>\n<p> <em>use strict</em> 代表开启严格模式，这种模式使得 <em>Javascript</em> 在更严格的条件下运行，实行更严格解析和错误处理。</p>\n<p>开启“严格模式”的优点：</p>\n<ul>\n<li>消除 <em>Javascript</em> 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的 <em>Javascript</em> 做好铺垫。</li>\n</ul>\n</blockquote>\n<h3 id=\"242-for…in-和-for…of-的区别\"><a href=\"#242-for…in-和-for…of-的区别\" class=\"headerlink\" title=\"242. for…in 和 for…of 的区别\"></a>242. <em>for…in</em> 和 <em>for…of</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JavaScript</em> 原有的 <em>for…in</em> 循环，只能获得对象的键名，不能直接获取键值。<em>ES6</em> 提供 <em>for…of</em> 循环，允许遍历获得键值。</p>\n<p>例如：</p>\n<pre><code class=\"javascript\">var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];\n\nfor (let a in arr) &#123;\n  console.log(a); // 0 1 2 3\n&#125;\n\nfor (let a of arr) &#123;\n  console.log(a); // a b c d\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"243-ajax、axios、fetch-的区别\"><a href=\"#243-ajax、axios、fetch-的区别\" class=\"headerlink\" title=\"243. ajax、axios、fetch 的区别\"></a>243. <em>ajax、axios、fetch</em> 的区别</h3><blockquote>\n<p>参考答案：</p>\n<p><em>ajax</em> 是指一种创建交互式网页应用的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。</p>\n<p>使用 <em>ajax</em> 发送请求是依靠于一个对象，叫 <em>XmlHttpRequest</em> 对象，通过这个对象我们可以从服务器获取到数据，然后再渲染到我们的页面上。现在几乎所有的浏览器都有这个对象，只有 <em>IE7</em> 以下的没有，而是通过 <em>ActiveXObject</em> 这个对象来创建的。</p>\n<p><em>Fetch</em> 是 <em>ajax</em> 非常好的一个替代品，基于 <em>Promise</em> 设计，使用 <em>Fetch</em> 来获取数据时，会返回给我们一个 <em>Pormise</em> 对象，但是 <em>Fetch</em> 是一个低层次的 <em>API</em>，想要很好的使用 <em>Fetch</em>，需要做一些封装处理。</p>\n<p>下面是 <em>Fetch</em> 的一些缺点</p>\n<ul>\n<li><em>Fetch</em> 只对网络请求报错，对 <em>400，500</em> 都当做成功的请求，需要封装去处理</li>\n<li><em>Fetch</em> 默认不会带 <em>cookie</em>，需要添加配置项。</li>\n<li><em>Fetch</em> 不支持 <em>abort</em>，不支持超时控制，使用 <em>setTimeout</em> 及 <em>Promise.reject</em> 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。</li>\n<li><em>Fetch</em> 没有办法原生监测请求的进度，而 <em>XHR</em> 可以。</li>\n</ul>\n<p><em>Vue2.0</em> 之后，<em>axios</em> 开始受到更多的欢迎了。其实 <em>axios</em> 也是对原生 <em>XHR</em> 的一种封装，不过是 <em>Promise</em> 实现版本。它可以用于浏览器和 <em>nodejs</em> 的 <em>HTTP</em> 客户端，符合最新的 <em>ES</em> 规范。</p>\n</blockquote>\n<h3 id=\"244-下面代码的输出是什么？（-D-）\"><a href=\"#244-下面代码的输出是什么？（-D-）\" class=\"headerlink\" title=\"244. 下面代码的输出是什么？（ D ）\"></a>244. 下面代码的输出是什么？（ <em>D</em> ）</h3><pre><code class=\"javascript\">function sayHi() &#123;\n  console.log(name);\n  console.log(age);\n  var name = &quot;Lydia&quot;;\n  let age = 21;\n&#125;\n\nsayHi();\n</code></pre>\n<ul>\n<li>A: <em>Lydia</em> 和 <em>undefined</em></li>\n<li>B: <em>Lydia</em> 和 <em>ReferenceError</em></li>\n<li>C: <em>ReferenceError</em> 和 <em>21</em></li>\n<li>D: <em>undefined</em> 和 <em>ReferenceError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>在 <em>sayHi</em> 函数内部，通过 <em>var</em> 声明的变量 <em>name</em> 会发生变量提升，<em>var name</em> 会提升到函数作用域的顶部，其默认值为 <em>undefined</em>。因此输出 <em>name</em> 时得到的值为 <em>undefined</em>；</p>\n<p><em>let</em> 声明的 <em>age</em> 不会发生变量提升，在输出 <em>age</em> 时该变量还未声明，因此会抛出 <em>ReferenceError</em> 的报错。</p>\n</blockquote>\n<h3 id=\"245-下面代码的输出是什么？（-C-）\"><a href=\"#245-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"245. 下面代码的输出是什么？（ C ）\"></a>245. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">for (var i = 0; i &lt; 3; i++) &#123;\n  setTimeout(() =&gt; console.log(i), 1);\n&#125;\n\nfor (let i = 0; i &lt; 3; i++) &#123;\n  setTimeout(() =&gt; console.log(i), 1);\n&#125;\n</code></pre>\n<ul>\n<li>A: <em>0 1 2</em> 和 <em>0 1 2</em></li>\n<li>B: <em>0 1 2</em> 和 <em>3 3 3</em></li>\n<li>C: <em>3 3 3</em> 和 <em>0 1 2</em></li>\n</ul>\n<blockquote>\n<p>分析：</p>\n<p><em>JavaScript</em> 中的执行机制，<em>setTimeout</em> 为异步代码，因此在 <em>setTimeout</em> 执行时，<em>for</em> 循环已经执行完毕。</p>\n<p>第一个 <em>for</em> 循环中的变量 <em>i</em> 通过 <em>var</em> 声明， 为全局变量，因此每一次的 <em>i++</em> 都会将全局变量 <em>i</em> 的值加 <em>1</em>，当第一个 <em>for</em> 执行完成后 <em>i</em> 的值为 <em>3</em>。所以再执行 <em>setTimeout</em> 时，输出 <em>i</em> 的值都为 <em>3</em>；</p>\n<p>第二个 <em>for</em> 循环中的变量 <em>i</em> 通过 <em>let</em> 声明，为局部变量，因此每一次 <em>for</em> 循环时都会产生一个块级作用域，用来存储本次循环中新产生的 <em>i</em> 的值。当循环结束后，<em>setTimeout</em> 会沿着作用域链去对应的块级作用域中寻找对应的 <em>i</em> 值。</p>\n</blockquote>\n<h3 id=\"246-下面代码的输出是什么？（-B-）\"><a href=\"#246-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"246. 下面代码的输出是什么？（ B ）\"></a>246. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">const shape = &#123;\n  radius: 10,\n  diameter() &#123;\n    return this.radius * 2;\n  &#125;,\n  perimeter: () =&gt; 2 * Math.PI * this.radius\n&#125;;\n\nshape.diameter();\nshape.perimeter();\n</code></pre>\n<ul>\n<li>A: <em>20</em> 和 <em>62.83185307179586</em></li>\n<li>B: <em>20</em> 和 <em>NaN</em></li>\n<li>C: <em>20</em> 和 <em>63</em></li>\n<li>D: <em>NaN</em> 和 <em>63</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>diameter</em> 作为对象的方法，其内部的 <em>this</em> 指向调用该方法的对象，因此 <em>this.raduus</em> 获取到的是 <em>shape.radius</em> 的值 <em>10</em>，再乘以 <em>2</em> 输出的值即为 <em>20</em>；</p>\n<p><em>perimeter</em> 是一个箭头函数，其内部的 <em>this</em> 应该继承声明时所在上下文中的 <em>this</em>，在这里即继承全局的 <em>this</em>，因此 <em>this.radius</em> 值的为 <em>undefined</em>，<em>undefined</em> 与数值相乘后值为 <em>NaN</em>。</p>\n</blockquote>\n<h3 id=\"247-下面代码的输出是什么？（-A-）\"><a href=\"#247-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"247. 下面代码的输出是什么？（ A ）\"></a>247. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code>+true;\n!&quot;Lydia&quot;;\n</code></pre>\n<ul>\n<li>A: <em>1</em> 和 <em>false</em></li>\n<li>B: <em>false</em> 和 <em>NaN</em></li>\n<li>C: <em>false</em> 和 <em>false</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>一元加号会将数据隐式转换为 <em>number</em> 类型，<em>true</em> 转换为数值为 <em>1</em>；</p>\n<p>非运算符 <em>!</em> 会将数据隐式转换为 <em>boolean</em> 类型后进行取反，*”Lydia”* 转换为布尔值为 <em>true</em>，取反后为 <em>false</em>。</p>\n</blockquote>\n<h3 id=\"248-哪个选项是不正确的？（-A-）\"><a href=\"#248-哪个选项是不正确的？（-A-）\" class=\"headerlink\" title=\"248. 哪个选项是不正确的？（ A ）\"></a>248. 哪个选项是不正确的？（ <em>A</em> ）</h3><pre><code class=\"javascript\">const bird = &#123;\n  size: &quot;small&quot;\n&#125;;\n\nconst mouse = &#123;\n  name: &quot;Mickey&quot;,\n  small: true\n&#125;;\n</code></pre>\n<ul>\n<li>A: <em>mouse.bird.size</em></li>\n<li>B: <em>mouse[bird.size]</em></li>\n<li>C: <em>mouse[bird[“size”]]</em></li>\n<li>D: 以上选项都对</li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>mouse</em> 对象中没有 <em>bird</em> 属性，当访问一个对象不存在的属性时值为 <em>undefined</em>，因此 <em>mouse.bird</em> 的值为 <em>undefined</em>，而 <em>undefined</em> 作为原始数据类型没有 <em>size</em> 属性，因此再访问 <em>undefined.size</em> 时会报错。</p>\n</blockquote>\n<h3 id=\"249-下面代码的输出是什么？（-A-）\"><a href=\"#249-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"249. 下面代码的输出是什么？（ A ）\"></a>249. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">let c = &#123; greeting: &quot;Hey!&quot; &#125;;\nlet d;\n\nd = c;\nc.greeting = &quot;Hello&quot;;\nconsole.log(d.greeting);\n</code></pre>\n<ul>\n<li>A: <em>Hello</em></li>\n<li>B: <em>undefined</em></li>\n<li>C: <em>ReferenceError</em></li>\n<li>D: <em>TypeError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>在 <em>JavaScript</em> 中，复杂类型数据在进行赋值操作时，进行的是「引用传递」，因此变量 <em>d</em> 和 <em>c</em> 指向的是同一个引用。当 <em>c</em> 通过引用去修改了数据后，<em>d</em> 再通过引用去访问数据，获取到的实际就是 <em>c</em> 修改后的数据。</p>\n</blockquote>\n<h3 id=\"250-下面代码的输出是什么？（-C-）\"><a href=\"#250-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"250. 下面代码的输出是什么？（ C ）\"></a>250. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n</code></pre>\n<ul>\n<li>A: <em>true</em>  <em>false</em>  <em>true</em></li>\n<li>B: <em>false</em>  <em>false</em>  <em>true</em></li>\n<li>C: <em>true</em>  <em>false</em>  <em>false</em></li>\n<li>D: <em>false</em>  <em>true</em>  <em>true</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>new Number()</em> 是 <em>JavaScript</em> 中一个内置的构造函数。变量 <em>b</em> 虽然看起来像一个数字，但它并不是一个真正的数字：它有一堆额外的功能，是一个对象。</p>\n<p>&#x3D;&#x3D; 会触发隐式类型转换，右侧的对象类型会自动转换为 <em>Number</em> 类型，因此最终返回 <em>true</em>。</p>\n<p>&#x3D;&#x3D;&#x3D; 不会触发隐式类型转换，因此在比较时由于数据类型不相等而返回 <em>false</em>。</p>\n</blockquote>\n<h3 id=\"251-下面代码的输出是什么？（-D-）\"><a href=\"#251-下面代码的输出是什么？（-D-）\" class=\"headerlink\" title=\"251. 下面代码的输出是什么？（ D ）\"></a>251. 下面代码的输出是什么？（ <em>D</em> ）</h3><pre><code class=\"javascript\">class Chameleon &#123;\n  static colorChange(newColor) &#123;\n    this.newColor = newColor;\n  &#125;\n\n  constructor(&#123; newColor = &quot;green&quot; &#125; = &#123;&#125;) &#123;\n    this.newColor = newColor;\n  &#125;\n&#125;\n\nconst freddie = new Chameleon(&#123; newColor: &quot;purple&quot; &#125;);\nfreddie.colorChange(&quot;orange&quot;);\n</code></pre>\n<ul>\n<li>A: <em>orange</em></li>\n<li>B: <em>purple</em></li>\n<li>C: <em>green</em></li>\n<li>D: <em>TypeError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析</strong>：</p>\n<p><em>colorChange</em> 方法是静态的。 静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。 由于 <em>freddie</em> 是一个子级对象，函数不会传递，所以在 <em>freddie</em> 实例上不存在 <em>colorChange</em> 方法：抛出<em>TypeError</em>。</p>\n</blockquote>\n<h3 id=\"252-下面代码的输出是什么？（-A-）\"><a href=\"#252-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"252. 下面代码的输出是什么？（ A ）\"></a>252. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">let greeting;\ngreetign = &#123;&#125;; // Typo!\nconsole.log(greetign);\n</code></pre>\n<ul>\n<li>A: <em>{}</em></li>\n<li>B: <em>ReferenceError: greetign is not defined</em></li>\n<li>C: <em>undefined</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>控制台会输出空对象，因为我们刚刚在全局对象上创建了一个空对象！</p>\n<p>当我们错误地将 <em>greeting</em> 输入为 <em>greetign</em> 时，<em>JS</em> 解释器实际上在浏览器中将其视为 *window.greetign &#x3D; {}*。</p>\n</blockquote>\n<h3 id=\"253-当我们执行以下代码时会发生什么？（-A-）\"><a href=\"#253-当我们执行以下代码时会发生什么？（-A-）\" class=\"headerlink\" title=\"253. 当我们执行以下代码时会发生什么？（ A ）\"></a>253. 当我们执行以下代码时会发生什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">function bark() &#123;\nconsole.log(&quot;Woof!&quot;);\n&#125;\n\nbark.animal = &quot;dog&quot;;\n</code></pre>\n<ul>\n<li>A 什么都不会发生</li>\n<li>B: <em>SyntaxError. You cannot add properties to a function this way.</em></li>\n<li>C: <em>undefined</em></li>\n<li>D: <em>ReferenceError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>因为函数也是对象！（原始类型之外的所有东西都是对象）</p>\n<p>函数是一种特殊类型的对象，我们可以给函数添加属性，且此属性是可调用的。</p>\n</blockquote>\n<h3 id=\"254-下面代码的输出是什么？（-A-）\"><a href=\"#254-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"254. 下面代码的输出是什么？（ A ）\"></a>254. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">function Person(firstName, lastName) &#123;\n  this.firstName = firstName;\n  this.lastName = lastName;\n&#125;\n\nconst member = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);\nPerson.getFullName = () =&gt; this.firstName + this.lastName;\n\nconsole.log(member.getFullName());\n</code></pre>\n<ul>\n<li>A: <em>TypeError</em></li>\n<li>B: <em>SyntaxError</em></li>\n<li>C: <em>Lydia Hallie</em></li>\n<li>D: <em>undefined</em>  <em>undefined</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>Person.getFullName</em> 是将方法添加到了函数身上，因此当我们通过实例对象 <em>member</em> 去调用该方法时并不能找到该方法。</p>\n</blockquote>\n<h3 id=\"255-下面代码的输出是什么？（-A-）\"><a href=\"#255-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"255. 下面代码的输出是什么？（ A ）\"></a>255. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">function Person(firstName, lastName) &#123;\n  this.firstName = firstName;\n  this.lastName = lastName;\n&#125;\n\nconst lydia = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);\nconst sarah = Person(&quot;Sarah&quot;, &quot;Smith&quot;);\n\nconsole.log(lydia);\nconsole.log(sarah);\n</code></pre>\n<ul>\n<li>A: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>undefined</em></li>\n<li>B: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>Person { firstName: “Sarah”, lastName: “Smith” }</em></li>\n<li>C: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>{}</em></li>\n<li>D: <em>Person { firstName: “Lydia”, lastName: “Hallie” }</em> 和 <em>ReferenceError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>lydia</em> 是调用构造函数后得到的实例对象，拥有 <em>firstName</em> 和 <em>lastName</em> 属性；</p>\n<p><em>sarah</em> 是调用普通函数后得到的返回值，而 <em>Person</em> 作为普通函数没有返回值；</p>\n</blockquote>\n<h3 id=\"256-事件传播的三个阶段是什么？（-D-）\"><a href=\"#256-事件传播的三个阶段是什么？（-D-）\" class=\"headerlink\" title=\"256. 事件传播的三个阶段是什么？（ D ）\"></a>256. 事件传播的三个阶段是什么？（ <em>D</em> ）</h3><ul>\n<li>A: 目标 &gt; 捕获 &gt; 冒泡</li>\n<li>B: 冒泡 &gt; 目标 &gt; 捕获</li>\n<li>C: 目标 &gt; 冒泡 &gt; 捕获</li>\n<li>D: 捕获 &gt; 目标 &gt; 冒泡</li>\n</ul>\n<h3 id=\"257-下面代码的输出是什么？（-C-）\"><a href=\"#257-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"257. 下面代码的输出是什么？（ C ）\"></a>257. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">function sum(a, b) &#123;\n  return a + b;\n&#125;\n\nsum(1, &quot;2&quot;);\n</code></pre>\n<ul>\n<li>A: <em>NaN</em></li>\n<li>B: <em>TypeError</em></li>\n<li>C: <em>“12”</em></li>\n<li>D: <em>3</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>任意数据类型在跟 <em>String</em> 做 + 运算时，都会隐式转换为 <em>String</em> 类型。</p>\n<p>即 <em>a</em> 所对应的 <em>Number</em> 值 <em>1</em>，被隐式转换为了 <em>String</em> 值 “1”，最终字符串拼接的到 “12”。  </p>\n</blockquote>\n<h3 id=\"258-下面代码的输出是什么？（-C-）\"><a href=\"#258-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"258. 下面代码的输出是什么？（ C ）\"></a>258. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);\n</code></pre>\n<ul>\n<li>A: <em>1  1  2</em></li>\n<li>B: <em>1  2  2</em></li>\n<li>C: <em>0  2  2</em></li>\n<li>D: <em>0  1  2</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>++ 后置时，先输出，后加 <em>1</em>；++ 前置时，先加 <em>1</em>，后输出；</p>\n<p>第一次输出的值为 0，输出完成后 <em>number</em> 加 <em>1</em> 变为 <em>1</em>。</p>\n<p>第二次输出，<em>number</em> 先加 <em>1</em> 变为 <em>2</em>，然后输出值 <em>2</em>。</p>\n<p>第三次输出，<em>number</em> 值没有变化，还是 <em>2</em>。</p>\n</blockquote>\n<h3 id=\"259-下面代码的输出是什么？（-B-）\"><a href=\"#259-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"259. 下面代码的输出是什么？（ B ）\"></a>259. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">function getPersonInfo(one, two, three) &#123;\n  console.log(one);\n  console.log(two);\n  console.log(three);\n&#125;\n\nconst person = &quot;Lydia&quot;;\nconst age = 21;\n\ngetPersonInfo`$&#123;person&#125; is $&#123;age&#125; years old`;\n</code></pre>\n<ul>\n<li>A: <em>Lydia</em>   <em>21</em>   <em>[“”, “is”, “years old”]</em></li>\n<li>B:  <em>[“”, “is”, “years old”]</em>  <em>Lydia</em>   <em>21</em></li>\n<li>C:  <em>Lydia</em>  <em>[“”, “is”, “years old”]</em>    <em>21</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值！</p>\n</blockquote>\n<h3 id=\"260-下面代码的输出是什么？（-C-）\"><a href=\"#260-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"260. 下面代码的输出是什么？（ C ）\"></a>260. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">function checkAge(data) &#123;\n  if (data === &#123; age: 18 &#125;) &#123;\n    console.log(&quot;You are an adult!&quot;);\n  &#125; else if (data == &#123; age: 18 &#125;) &#123;\n    console.log(&quot;You are still an adult.&quot;);\n  &#125; else &#123;\n    console.log(`Hmm.. You don&#39;t have an age I guess`);\n  &#125;\n&#125;\n\ncheckAge(&#123; age: 18 &#125;);\n</code></pre>\n<ul>\n<li>A: <em>You are an adult!</em></li>\n<li>B: <em>You are still an adult.</em></li>\n<li>C: <em>Hmm.. You don’t have an age I guess</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>在比较相等性时，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。</p>\n<p><em>data</em> 和条件中的 <em>{ age: 18 }</em> 两个不同引用的对象，因此永远都不相等。</p>\n</blockquote>\n<h3 id=\"261-下面代码的输出是什么？（-C-）\"><a href=\"#261-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"261. 下面代码的输出是什么？（ C ）\"></a>261. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">function getAge(...args) &#123;\n  console.log(typeof args);\n&#125;\n\ngetAge(21);\n</code></pre>\n<ul>\n<li>A: <em>“number”</em></li>\n<li>B: <em>“array”</em></li>\n<li>C: <em>“object”</em></li>\n<li>D: <em>“NaN”</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>ES6</em> 中的不定参数（…<em>args</em>）返回的是一个数组。</p>\n<p><em>typeof</em> 检查数组的类型返回的值是 <em>object</em>。</p>\n</blockquote>\n<h3 id=\"262-下面代码的输出是什么？（-C-）\"><a href=\"#262-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"262. 下面代码的输出是什么？（ C ）\"></a>262. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">function getAge() &#123;\n  &quot;use strict&quot;;\n  age = 21;\n  console.log(age);\n&#125;\n\ngetAge();\n</code></pre>\n<ul>\n<li>A: <em>21</em></li>\n<li>B: <em>undefined</em></li>\n<li>C: <em>ReferenceError</em></li>\n<li>D: <em>TypeError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>“use strict”</em> 严格模式中，使用未声明的变量会引发报错。</p>\n</blockquote>\n<h3 id=\"263-下面代码的输出是什么？（-A-）\"><a href=\"#263-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"263. 下面代码的输出是什么？（ A ）\"></a>263. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">const sum = eval(&quot;10*10+5&quot;);\n</code></pre>\n<ul>\n<li>A: <em>105</em></li>\n<li>B: <em>“105”</em></li>\n<li>C: <em>TypeError</em></li>\n<li>D: <em>“10*10+5”</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>eval</em> 方法会将字符串当作 <em>JavaScript</em> 代码进行解析。</p>\n</blockquote>\n<h3 id=\"264-cool-secret-可以访问多长时间？（-B-）\"><a href=\"#264-cool-secret-可以访问多长时间？（-B-）\" class=\"headerlink\" title=\"264. cool_secret 可以访问多长时间？（ B ）\"></a>264. <em>cool_secret</em> 可以访问多长时间？（ <em>B</em> ）</h3><pre><code class=\"javascript\">sessionStorage.setItem(&quot;cool_secret&quot;, 123);\n</code></pre>\n<ul>\n<li>A：永远，数据不会丢失。</li>\n<li>B：用户关闭选项卡时。</li>\n<li>C：当用户关闭整个浏览器时，不仅是选项卡。</li>\n<li>D：用户关闭计算机时。</li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>sessionStorage</em> 是会话级别的本地存储，当窗口关闭，则会话结束，数据删除。</p>\n</blockquote>\n<h3 id=\"265-下面代码的输出是什么？（-B-）\"><a href=\"#265-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"265. 下面代码的输出是什么？（ B ）\"></a>265. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">var num = 8;\nvar num = 10;\n\nconsole.log(num);\n</code></pre>\n<ul>\n<li>A: <em>8</em></li>\n<li>B: <em>10</em></li>\n<li>C: <em>SyntaxError</em></li>\n<li>D: <em>ReferenceError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>var</em> 声明的变量允许重复声明，但后面的值会覆盖前面的值。</p>\n</blockquote>\n<h3 id=\"266-下面代码的输出是什么？（-C-）\"><a href=\"#266-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"266. 下面代码的输出是什么？（ C ）\"></a>266. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">const obj = &#123; 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot; &#125;;\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(&quot;1&quot;);\nobj.hasOwnProperty(1);\nset.has(&quot;1&quot;);\nset.has(1);\n</code></pre>\n<ul>\n<li>A: <em>false</em>  <em>true</em>  <em>false</em>  <em>true</em></li>\n<li>B: <em>false</em>  <em>true</em>  <em>true</em>  <em>true</em></li>\n<li>C: <em>true</em>  <em>true</em>  <em>false</em>  <em>true</em></li>\n<li>D: <em>true</em>  <em>true</em>  <em>true</em>  <em>true</em></li>\n</ul>\n<h3 id=\"267-下面代码的输出是什么？（-C-）\"><a href=\"#267-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"267. 下面代码的输出是什么？（ C ）\"></a>267. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">const obj = &#123; a: &quot;one&quot;, b: &quot;two&quot;, a: &quot;three&quot; &#125;;\nconsole.log(obj);\n</code></pre>\n<ul>\n<li>A: <em>{ a: “one”, b: “two” }</em></li>\n<li>B: <em>{ b: “two”, a: “three” }</em></li>\n<li>C: <em>{ a: “three”, b: “two” }</em></li>\n<li>D: <em>SyntaxError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>如果对象有两个具有相同名称的键，则后面的将替前面的键。它仍将处于第一个位置，但具有最后指定的值。</p>\n</blockquote>\n<h3 id=\"268-下面代码的输出是什么？（-C-）\"><a href=\"#268-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"268. 下面代码的输出是什么？（ C ）\"></a>268. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">for (let i = 1; i &lt; 5; i++) &#123;\n  if (i === 3) continue;\n  console.log(i);\n&#125;\n</code></pre>\n<ul>\n<li>A: <em>1  2</em></li>\n<li>B: <em>1  2  3</em></li>\n<li>C: <em>1  2  4</em></li>\n<li>D: <em>1  3  4</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>当 <em>i</em> 的值为 <em>3</em> 时，进入 <em>if</em> 语句执行 <em>continue</em>，结束本次循环，立即进行下一次循环。</p>\n</blockquote>\n<h3 id=\"269-下面代码的输出是什么？（-A-）\"><a href=\"#269-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"269. 下面代码的输出是什么？（ A ）\"></a>269. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">String.prototype.giveLydiaPizza = () =&gt; &#123;\n  return &quot;Just give Lydia pizza already!&quot;;\n&#125;;\n\nconst name = &quot;Lydia&quot;;\n\nname.giveLydiaPizza();\n</code></pre>\n<ul>\n<li>A: <em>“Just give Lydia pizza already!”</em></li>\n<li>B: <em>TypeError: not a function</em></li>\n<li>C: <em>SyntaxError</em></li>\n<li>D: <em>undefined</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>String</em> 是一个内置的构造函数，我们可以为它添加属性。 我们给它的原型添加了一个方法。 原始类型的字符串自动转换为字符串对象，由字符串原型函数生成。 因此，所有字符串（字符串对象）都可以访问该方法！</p>\n<p>当使用基本类型的字符串调用 <em>giveLydiaPizza</em> 时，实际上发生了下面的过程：</p>\n<ul>\n<li>创建一个 <em>String</em> 的包装类型实例</li>\n<li>在实例上调用 <em>substring</em> 方法</li>\n<li>销毁实例</li>\n</ul>\n</blockquote>\n<h3 id=\"270-下面代码的输出是什么？（-B-）\"><a href=\"#270-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"270. 下面代码的输出是什么？（ B ）\"></a>270. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">const a = &#123;&#125;;\nconst b = &#123; key: &quot;b&quot; &#125;;\nconst c = &#123; key: &quot;c&quot; &#125;;\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n</code></pre>\n<ul>\n<li>A: <em>123</em></li>\n<li>B: <em>456</em></li>\n<li>C: <em>undefined</em></li>\n<li>D: <em>ReferenceError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>当 <em>b</em> 和 <em>c</em> 作为一个对象的键时，会自动转换为字符串，而对象自动转换为字符串化时，结果都为 *[Object object]*。因此 <em>a[b]</em> 和 <em>a[c]</em> 其实都是同一个属性 *a[“Object object”]*。</p>\n<p>对象同名的属性后面的值会覆盖前面的，因此最终 <em>a[“Object object”]</em> 的值为 <em>456</em>。</p>\n</blockquote>\n<h3 id=\"271-下面代码的输出是什么？（-B-）\"><a href=\"#271-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"271. 下面代码的输出是什么？（ B ）\"></a>271. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">const foo = () =&gt; console.log(&quot;First&quot;);\nconst bar = () =&gt; setTimeout(() =&gt; console.log(&quot;Second&quot;));\nconst baz = () =&gt; console.log(&quot;Third&quot;);\n\nbar();\nfoo();\nbaz();\n</code></pre>\n<ul>\n<li>A: <em>First</em>  <em>Second</em>  <em>Third</em></li>\n<li>B: <em>First</em>  <em>Third</em>  <em>Second</em></li>\n<li>C: <em>Second</em>  <em>First</em>  <em>Third</em></li>\n<li>D: <em>Second</em>  <em>Third</em>  <em>First</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>bar</em> 函数中执行的是一段异步代码，按照 <em>JavaScript</em> 中的事件循环机制，主线程中的所有同步代码执行完成后才会执行异步代码。因此 <em>“Second”</em> 最后输出。</p>\n</blockquote>\n<h3 id=\"272-单击按钮时-event-target-是什么？（-C-）\"><a href=\"#272-单击按钮时-event-target-是什么？（-C-）\" class=\"headerlink\" title=\"272. 单击按钮时 event.target 是什么？（ C ）\"></a>272. 单击按钮时 <em>event.target</em> 是什么？（ <em>C</em> ）</h3><pre><code class=\"html\">&lt;div onclick=&quot;console.log(&#39;first div&#39;)&quot;&gt;\n  &lt;div onclick=&quot;console.log(&#39;second div&#39;)&quot;&gt;\n    &lt;button onclick=&quot;console.log(&#39;button&#39;)&quot;&gt;\n      Click!\n    &lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<ul>\n<li>A: <em>div</em> 外部</li>\n<li>B: <em>div</em> 内部</li>\n<li>C: <em>button</em></li>\n<li>D: 所有嵌套元素的数组</li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>event.target</em> 指向的是事件目标，即触发事件的元素。因此点击 <em>&lt;button&gt;</em> 触发事件的也就是  *&lt;button&gt;*。</p>\n</blockquote>\n<h3 id=\"273-单击下面的-html-片段打印的内容是什么？（-A-）\"><a href=\"#273-单击下面的-html-片段打印的内容是什么？（-A-）\" class=\"headerlink\" title=\"273. 单击下面的 html 片段打印的内容是什么？（ A ）\"></a>273. 单击下面的 <em>html</em> 片段打印的内容是什么？（ <em>A</em> ）</h3><pre><code class=\"html\">&lt;div onclick=&quot;console.log(&#39;div&#39;)&quot;&gt;\n  &lt;p onclick=&quot;console.log(&#39;p&#39;)&quot;&gt;\n    Click here!\n  &lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<ul>\n<li>A: <em>p</em>  <em>div</em></li>\n<li>B: <em>div</em>  <em>p</em></li>\n<li>C: <em>p</em></li>\n<li>D: <em>div</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>onclick</em> 绑定的事件为冒泡型事件。因此当点击 <em>p</em> 标签时，事件会从事件目标开始依次往外触发。</p>\n</blockquote>\n<h3 id=\"274-下面代码的输出是什么？（-D-）\"><a href=\"#274-下面代码的输出是什么？（-D-）\" class=\"headerlink\" title=\"274. 下面代码的输出是什么？（ D ）\"></a>274. 下面代码的输出是什么？（ <em>D</em> ）</h3><pre><code class=\"javascript\">const person = &#123; name: &quot;Lydia&quot; &#125;;\n\nfunction sayHi(age) &#123;\n  console.log(`$&#123;this.name&#125; is $&#123;age&#125;`);\n&#125;\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);\n</code></pre>\n<ul>\n<li>A: <em>undefined is 21</em>   <em>Lydia is 21</em></li>\n<li>B: <em>function</em>   <em>function</em></li>\n<li>C: <em>Lydia is 21</em>   <em>Lydia is 21</em></li>\n<li>D: <em>Lydia is 21</em>   <em>function</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>call</em> 和 <em>bind</em> 都可以修改 <em>this</em> 的指向，但区别在于 <em>call</em> 方法会立即执行，而 <em>bind</em> 会返回一个修改后的新函数。</p>\n</blockquote>\n<h3 id=\"275-下面代码的输出是什么？（-B-）\"><a href=\"#275-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"275. 下面代码的输出是什么？（ B ）\"></a>275. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">function sayHi() &#123;\n  return (() =&gt; 0)();\n&#125;\n\ntypeof sayHi();\n</code></pre>\n<ul>\n<li>A: <em>“object”</em></li>\n<li>B: <em>“number”</em></li>\n<li>C: <em>“function”</em></li>\n<li>D: <em>“undefined”</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>return</em> 后是一个 <em>IIFE</em>，其返回值是 <em>0</em>，因此 <em>sayHi</em> 函数中返回的是一个 <em>0</em>。<em>typeof</em> 检测 <em>sayHi</em> 返回值类型即为 <em>number</em>。</p>\n</blockquote>\n<h3 id=\"276-下面这些值哪些是假值？（-A-）\"><a href=\"#276-下面这些值哪些是假值？（-A-）\" class=\"headerlink\" title=\"276. 下面这些值哪些是假值？（ A ）\"></a>276. 下面这些值哪些是假值？（ <em>A</em> ）</h3><pre><code class=\"javascript\">0;\nnew Number(0);\n(&quot;&quot;);\n(&quot; &quot;);\nnew Boolean(false);\nundefined;\n</code></pre>\n<ul>\n<li>A: <em>0</em>   <em>“”</em>    <em>undefined</em></li>\n<li>B: <em>0</em>   <em>new Number(0)</em>   <em>“”</em>   <em>new Boolean(false)</em>   <em>undefined</em></li>\n<li>C: <em>0</em>   <em>“”</em>   <em>new Boolean(false)</em>   <em>undefined</em></li>\n<li>D: 所有都是假值。</li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>JavaScript</em> 中假值只有 <em>6</em> 个：<em>false</em>、*””<em>、</em>null<em>、</em>undefined<em>、</em>NaN<em>、</em>0*</p>\n</blockquote>\n<h3 id=\"278-下面代码的输出是什么？（-B-）\"><a href=\"#278-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"278. 下面代码的输出是什么？（ B ）\"></a>278. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">console.log(typeof typeof 1);\n</code></pre>\n<ul>\n<li>A: <em>“number”</em></li>\n<li>B: <em>“string”</em></li>\n<li>C: <em>“object”</em></li>\n<li>D: <em>“undefined”</em></li>\n</ul>\n<blockquote>\n<p>分析：</p>\n<p><em>typeof 1</em> 返回 <em>“number”<em>，</em>typeof “number”</em> 返回 <em>“string”</em></p>\n</blockquote>\n<h3 id=\"279-下面代码的输出是什么？（-C-）\"><a href=\"#279-下面代码的输出是什么？（-C-）\" class=\"headerlink\" title=\"279. 下面代码的输出是什么？（ C ）\"></a>279. 下面代码的输出是什么？（ <em>C</em> ）</h3><pre><code class=\"javascript\">const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n</code></pre>\n<ul>\n<li>A: <em>[1, 2, 3, 7 x null, 11]</em></li>\n<li>B: <em>[1, 2, 3, 11]</em></li>\n<li>C: <em>[1, 2, 3, 7 x empty, 11]</em></li>\n<li>D: <em>SyntaxError</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>当你为数组中的元素设置一个超过数组长度的值时，<em>JavaScript</em> 会创建一个名为“空插槽”的东西。 这些位置的值实际上是 <em>undefined</em>，但你会看到类似的东西：</p>\n<pre><code>[1, 2, 3, 7 x empty, 11]\n</code></pre>\n<p>这取决于你运行它的位置（每个浏览器有可能不同）。</p>\n</blockquote>\n<h3 id=\"280-下面代码的输出是什么？（-A-）\"><a href=\"#280-下面代码的输出是什么？（-A-）\" class=\"headerlink\" title=\"280. 下面代码的输出是什么？（ A ）\"></a>280. 下面代码的输出是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">(() =&gt; &#123;\n  let x, y;\n  try &#123;\n    throw new Error();\n  &#125; catch (x) &#123;\n    (x = 1), (y = 2);\n    console.log(x);\n  &#125;\n  console.log(x);\n  console.log(y);\n&#125;)();\n</code></pre>\n<ul>\n<li>A: <em>1</em>   <em>undefined</em>   <em>2</em></li>\n<li>B: <em>undefined</em>   <em>undefined</em>   <em>undefined</em></li>\n<li>C: <em>1</em>   <em>1</em>   <em>2</em>  </li>\n<li>D: <em>1</em>   <em>undefined</em>   <em>undefined</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>catch</em> 块接收参数 <em>x</em>。当我们传递参数时，这与变量的 <em>x</em> 不同。这个变量 <em>x</em> 是属于 <em>catch</em> 作用域的。</p>\n<p>之后，我们将这个块级作用域的变量设置为 <em>1</em>，并设置变量 <em>y</em> 的值。 现在，我们打印块级作用域的变量 <em>x</em>，它等于 <em>1</em>。</p>\n<p>在<em>catch</em> 块之外，<em>x</em> 仍然是 <em>undefined</em>，而 <em>y</em> 是 <em>2</em>。 当我们想在 <em>catch</em> 块之外的 <em>console.log(x)</em> 时，它返回<em>undefined</em>，而 <em>y</em> 返回 <em>2</em>。</p>\n</blockquote>\n<h3 id=\"281-JavaScript-中的所有内容都是…（-A-）\"><a href=\"#281-JavaScript-中的所有内容都是…（-A-）\" class=\"headerlink\" title=\"281. JavaScript 中的所有内容都是…（ A ）\"></a>281. <em>JavaScript</em> 中的所有内容都是…（ <em>A</em> ）</h3><ul>\n<li>A：原始或对象</li>\n<li>B：函数或对象</li>\n<li>C：技巧问题！只有对象</li>\n<li>D：数字或对象</li>\n</ul>\n<blockquote>\n<p>分析：</p>\n<p><em>JavaScript</em> 只有原始类型和对象。</p>\n</blockquote>\n<h3 id=\"282-下面代码的输出是什么\"><a href=\"#282-下面代码的输出是什么\" class=\"headerlink\" title=\"282. 下面代码的输出是什么?\"></a>282. 下面代码的输出是什么?</h3><pre><code class=\"javascript\">[[0, 1], [2, 3]].reduce(\n  (acc, cur) =&gt; &#123;\n    return acc.concat(cur);\n  &#125;,\n  [1, 2]\n);\n</code></pre>\n<ul>\n<li>A: <em>[0, 1, 2, 3, 1, 2]</em></li>\n<li>B: <em>[6, 1, 2]</em></li>\n<li>C: <em>[1, 2, 0, 1, 2, 3]</em></li>\n<li>D: <em>[1, 2, 6]</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>[1,2]</em> 是我们的初始值。 这是我们开始执行 <em>reduce</em> 函数的初始值，以及第一个 <em>acc</em> 的值。 在第一轮中，<em>acc</em> 是 <em>[1,2]<em>，</em>cur</em> 是 *[0,1]*。 我们将它们连接起来，结果是 *[1,2,0,1]*。</p>\n<p>然后，<em>acc</em> 的值为 <em>[1,2,0,1]<em>，</em>cur</em> 的值为 *[2,3]*。 我们将它们连接起来，得到 *[1,2,0,1,2,3]*。</p>\n</blockquote>\n<h3 id=\"283-下面代码的输出是什么？（-B-）\"><a href=\"#283-下面代码的输出是什么？（-B-）\" class=\"headerlink\" title=\"283. 下面代码的输出是什么？（ B ）\"></a>283. 下面代码的输出是什么？（ <em>B</em> ）</h3><pre><code class=\"javascript\">!!null;\n!!&quot;&quot;;\n!!1;\n</code></pre>\n<ul>\n<li>A: <em>false</em>   <em>true</em>   <em>false</em></li>\n<li>B: <em>false</em>   <em>false</em>   <em>true</em></li>\n<li>C: <em>false</em>   <em>true</em>   <em>true</em></li>\n<li>D: <em>true</em>   <em>true</em>   <em>false</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p><em>null</em> 是假值。 <em>!null</em> 返回 <em>true</em>。 <em>!true</em> 返回 <em>false</em>。</p>\n<p><em>“”</em> 是假值。 <em>!””</em> 返回 <em>true</em>。 <em>!true</em> 返回 <em>false</em>。</p>\n<p><em>1</em> 是真值。 <em>!1</em> 返回 <em>false</em>。 <em>!false</em> 返回 <em>true</em>。</p>\n</blockquote>\n<h3 id=\"284-setInterval-方法的返回值什么？（-A-）\"><a href=\"#284-setInterval-方法的返回值什么？（-A-）\" class=\"headerlink\" title=\"284. setInterval 方法的返回值什么？（ A ）\"></a>284. <em>setInterval</em> 方法的返回值什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">setInterval(() =&gt; console.log(&quot;Hi&quot;), 1000);\n</code></pre>\n<ul>\n<li>A：一个唯一的 <em>id</em></li>\n<li>B：指定的毫秒数</li>\n<li>C：传递的函数</li>\n<li>D：<em>undefined</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>它返回一个唯一的 <em>id</em>。 此 <em>id</em> 可用于使用 <em>clearInterval()</em> 函数清除该定时器。</p>\n</blockquote>\n<h3 id=\"285-下面代码的返回值是什么？（-A-）\"><a href=\"#285-下面代码的返回值是什么？（-A-）\" class=\"headerlink\" title=\"285. 下面代码的返回值是什么？（ A ）\"></a>285. 下面代码的返回值是什么？（ <em>A</em> ）</h3><pre><code class=\"javascript\">[...&quot;Lydia&quot;];\n</code></pre>\n<ul>\n<li>A: <em>[“L”, “y”, “d”, “i”, “a”]</em></li>\n<li>B: <em>[“Lydia”]</em></li>\n<li>C: <em>[[], “Lydia”]</em></li>\n<li>D: <em>[[“L”, “y”, “d”, “i”, “a”]]</em></li>\n</ul>\n<blockquote>\n<p><strong>分析：</strong></p>\n<p>字符串是可迭代的。 扩展运算符将迭代的每个字符映射到一个元素。</p>\n</blockquote>\n<h3 id=\"286-document-write-和-innerHTML-有哪些区别？\"><a href=\"#286-document-write-和-innerHTML-有哪些区别？\" class=\"headerlink\" title=\"286. document.write 和 innerHTML 有哪些区别？\"></a>286. <em>document.write</em> 和 <em>innerHTML</em> 有哪些区别？</h3><blockquote>\n<p>参考答案：</p>\n<p><em>document.write</em> 和 <em>innerHTML</em> 都能将 <em>HTML</em> 字符串解析为 <em>DOM</em> 树，再将 <em>DOM</em> 树插入到某个位置，但两种在执行细节上还是有许多不同。</p>\n<p>1）<em>write()</em> 方法存在于 <em>Document</em> 对象中，<em>innerHTML</em> 属性存在于 <em>Element</em> 对象中；</p>\n<p>2）<em>document.write</em> 会将解析后的 <em>DOM</em> 树插入到文档中调用它的脚本元素的位置，而 <em>innerHTML</em> 会将 <em>DOM</em> 树插入到指定的元素内；</p>\n<p>3）<em>document.write</em> 会将多次调用的字符串参数自动连接起来，<em>innerHTML</em> 要用赋值运算符 <em>“+&#x3D;”</em> 拼接；</p>\n<p>4）只有当文档还在解析时，才能使用 <em>document.write</em>，否则 <em>document.write</em> 的值会将当前文档覆盖掉，而 <em>innerHTML</em> 属性则没有这个限制；</p>\n</blockquote>\n<blockquote>\n<p>注：也可以参阅前面第 <em>157</em> 题答案</p>\n</blockquote>\n<h3 id=\"287-假设有两个变量-a-和-b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？\"><a href=\"#287-假设有两个变量-a-和-b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？\" class=\"headerlink\" title=\"287. 假设有两个变量 a 和 b，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？\"></a>287. 假设有两个变量 <em>a</em> 和 <em>b</em>，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？</h3><blockquote>\n<p>参考答案：</p>\n<p>方法一：</p>\n<pre><code class=\"javascript\">a = a + b;\nb = a - b;\na = a - b; \n</code></pre>\n<p>方法二（<em>ES6</em> 中的解构）：</p>\n<pre><code class=\"javascript\">[a, b] = [b, a]\n</code></pre>\n</blockquote>\n<h3 id=\"288-前端为什么提倡模块化开发？\"><a href=\"#288-前端为什么提倡模块化开发？\" class=\"headerlink\" title=\"288. 前端为什么提倡模块化开发？\"></a>288. 前端为什么提倡模块化开发？</h3><blockquote>\n<p>参考答案：</p>\n<p>模块化能将一个复杂的大型系统分解成一个个高内聚、低耦合的简单模块，并且每个模块都是独立的，用于完成特定的功能。模块化后的系统变得更加可控、可维护、可扩展，程序代码也更简单直观，可读性也很高，有利于团队协作开发。<em>ES6</em> 模块化的出现，使得前端能更容易、更快速的实现模块化开发。</p>\n</blockquote>\n<h3 id=\"289-请解释-JSONP-的原理，并用代码描述其过程。\"><a href=\"#289-请解释-JSONP-的原理，并用代码描述其过程。\" class=\"headerlink\" title=\"289. 请解释 JSONP 的原理，并用代码描述其过程。\"></a>289. 请解释 <em>JSONP</em> 的原理，并用代码描述其过程。</h3><blockquote>\n<p>参考答案：</p>\n<p><em>JSONP（JSON with padding）</em>是一种借助 <em>&lt;script&gt;</em> 元素实现跨域的技术，它不会使用 <em>XHR</em> 对象。之所以能实现跨域，主要是因为 <em>&lt;script&gt;</em> 元素有以下两个特点：</p>\n<p>1）它的 <em>src</em> 属性能够访问任何 <em>URL</em> 资源，不会受同源策略的限制；</p>\n<p>2）如果访问的资源包含 <em>JavaScript</em> 代码，那么在下载下来后会自动执行；</p>\n<p><em>JSONP</em> 就是基于这两点，再与服务器配合来实现跨域请求的，它的执行步骤可分为以下 <em>6</em> 步：</p>\n<p>1）定义一个回调函数；</p>\n<p>2）用 <em>DOM</em> 方法动态创建一个 <em>&lt;script&gt;</em> 元素；</p>\n<p>3）通过 <em>&lt;script&gt;</em> 元素的 <em>src</em> 属性指定要请求的 <em>URL</em>，并且将回调函数的名称作为一个参数传递过去；</p>\n<p>4）将 <em>&lt;script&gt;</em> 元素插入到当前文档中，开始请求；</p>\n<p>5）服务器接收到传递过来的参数，然后将回调函数和数据以调用的形式输出；</p>\n<p>6）当 <em>&lt;script&gt;</em> 元素接收到响应中的脚本代码后，就会自动的执行它们；</p>\n</blockquote>\n<h3 id=\"290-列举几种-JavaScript-中数据类型的强制转换和隐式转换。\"><a href=\"#290-列举几种-JavaScript-中数据类型的强制转换和隐式转换。\" class=\"headerlink\" title=\"290. 列举几种 JavaScript 中数据类型的强制转换和隐式转换。\"></a>290. 列举几种 <em>JavaScript</em> 中数据类型的强制转换和隐式转换。</h3><blockquote>\n<p>参考答案：</p>\n<p>强制转换：</p>\n<ul>\n<li>转换为 <em>number</em>：<em>parseInt()<em>、</em>parseFloat()<em>、</em>Number()</em></li>\n<li>转换为 <em>string</em>：<em>String()<em>、</em>toString()</em></li>\n<li>转换为 <em>boolean</em>：<em>Boolean()</em></li>\n</ul>\n<p>隐式转换：</p>\n<ul>\n<li>隐式转换为 <em>number</em>：算术运算&#x2F;比较运算，例如加、减、乘、除、相等（&#x3D;&#x3D;）、大于、小于等；</li>\n<li>隐式转换为 <em>string</em>：与字符串拼接，例如 + “”；</li>\n<li>隐式转换为 <em>boolean</em>：逻辑运算，例如或（||）、与（&amp;&amp;）、非（!）；</li>\n</ul>\n</blockquote>\n<h3 id=\"291-分析以下代码的执行结果并解释为什么。\"><a href=\"#291-分析以下代码的执行结果并解释为什么。\" class=\"headerlink\" title=\"291. 分析以下代码的执行结果并解释为什么。\"></a>291. 分析以下代码的执行结果并解释为什么。</h3><pre><code class=\"javascript\">var a = &#123;n: 1&#125;;\nvar b = a;\na.x = a = &#123;n: 2&#125;;\n\nconsole.log(a.x) \t\nconsole.log(b.x)\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>运行结果：</p>\n<p><em>undefined</em>、*{n: 2}*</p>\n<p>分析：</p>\n<p>首先，<em>a</em> 和 <em>b</em> 同时引用了 <em>{n: 1}</em> 对象，接着执行到 <em>a.x &#x3D; a &#x3D; {n: 2}</em> 语句，虽然赋值是从右到左执行，但是点（.）的优先级比赋值符（&#x3D;）要高，所以这里首先执行 <em>a.x</em>，相当于为 <em>a</em>（或者 <em>b</em>）所指向的 <em>{n:1}</em> 对象新增了一个属性 <em>x</em>，即此时对象将变为 *{n: 1; x: undefined}*。然后按正常情况，从右到左进行赋值，此时执行 <em>a &#x3D; {n: 2}</em> 的时候，a的引用改变，指向了新对象 *{n: 2}*，而 <em>b</em> 依然指向的是旧对象 *{n: 1; x: undefined}*。之后再执行 <em>a.x &#x3D; {n: 2}</em> 的时候，并不会重新解析一遍 <em>a</em>，而是沿用最初解析 <em>a.x</em> 时候的 <em>a</em>，即旧对象 *{n: 1; x: undefined}<em>，故此时旧对象的 <em>x</em> 的值变为</em>{n: 2}*，旧对象为 n: 1; x: {n: 2}，它依然被 <em>b</em> 引用着。 </p>\n<p>最后，<em>a</em> 指向的对象为  <em>{n: 2}<em>，</em>b</em> 指向的对象为 *{n: 1; x: n: 2}*。因此输出 <em>a.x</em> 值为 <em>undefined</em>，输出 <em>b.x</em> 值为 *{n: 2}*。</p>\n</blockquote>\n<h3 id=\"292-分析以下代码的执行结果并解释为什么。\"><a href=\"#292-分析以下代码的执行结果并解释为什么。\" class=\"headerlink\" title=\"292. 分析以下代码的执行结果并解释为什么。\"></a>292. 分析以下代码的执行结果并解释为什么。</h3><pre><code class=\"javascript\">// example 1\nvar a = &#123;&#125;, b = &#39;123&#39;, c = 123;  \na[b] = &#39;b&#39;;\na[c] = &#39;c&#39;;  \nconsole.log(a[b]);\n\n// example 2\nvar a = &#123;&#125;, b = Symbol(&#39;123&#39;), c = Symbol(&#39;123&#39;);  \na[b] = &#39;b&#39;;\na[c] = &#39;c&#39;;  \nconsole.log(a[b]);\n\n// example 3\nvar a = &#123;&#125;, b = &#123;key:&#39;123&#39;&#125;, c = &#123;key:&#39;456&#39;&#125;;  \na[b] = &#39;b&#39;;\na[c] = &#39;c&#39;;  \nconsole.log(a[b]);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>运行结果：</p>\n<p><em>example 1</em>：<em>c</em></p>\n<p><em>example 2</em>：<em>b</em></p>\n<p><em>example 3</em>：<em>c</em></p>\n<p>分析：</p>\n<p>这题考察的是对象的键名的转换。</p>\n<ul>\n<li>对象的键名只能是字符串和 <em>Symbol</em> 类型。</li>\n<li>其他类型的键名会被转换成字符串类型。</li>\n<li>对象转字符串默认会调用 <em>String</em> 方法。</li>\n</ul>\n<p>因此 <em>example 1</em> 中 <em>c</em> 作为键名后也是 <em>‘123’<em>，直接覆盖 <em>a[b]</em> 的值；而 <em>example 2</em> 中，</em>Symbol</em> 作为 <em>ES6</em> 中新增的基本数据类型，它的特点就是唯一，<em>Symbol()</em> 方法生成的值都是唯一的，里面的参数不会影响结果。因此在 <em>example 2</em> 中 <em>b</em> 和 <em>c</em> 是两个不同的键名；<em>example 3</em> 中，对象不能作为键名，因此 <em>b</em> 和 <em>c</em> 都会通过 <em>String()</em> 方法转为字符串 *[object Object]*。</p>\n</blockquote>\n<h3 id=\"293-下面的代码打印什么内容？为什么？\"><a href=\"#293-下面的代码打印什么内容？为什么？\" class=\"headerlink\" title=\"293. 下面的代码打印什么内容？为什么？\"></a>293. 下面的代码打印什么内容？为什么？</h3><pre><code class=\"javascript\">var b = 10;\n(function b() &#123;\n  b = 20;\n  console.log(b)\n&#125;)()\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>运行结果：</p>\n<p><em>function b() { b &#x3D; 20; console.log(b) }</em><br>分析：</p>\n<p>当 <em>JavaScript</em> 解释器遇到非匿名立即执行函数（题目中的 <em>b</em>）时，会创建一个辅助的特定对象，然后将函数名称当作这个对象的属性，因此函数内部可以访问到 <em>b</em>，但是这个值又是只读的，所以对他的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>\n</blockquote>\n<h3 id=\"294-下面代码中，a-在什么情况下会执行输出语句打印-1-？\"><a href=\"#294-下面代码中，a-在什么情况下会执行输出语句打印-1-？\" class=\"headerlink\" title=\"294. 下面代码中，a 在什么情况下会执行输出语句打印 1 ？\"></a>294. 下面代码中，<em>a</em> 在什么情况下会执行输出语句打印 <em>1</em> ？</h3><pre><code class=\"javascript\">var a = ?;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123;\n     console.log(1);\n&#125;\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>分析：</p>\n<p>这道题考查的知识点是：相等运算符（&#x3D;&#x3D;）在作比较时会进行隐式转换，而如果操作数是引用类型，则会调用 <em>toString()</em> 或 <em>valueOf()</em> 方法对引用类型数据进行隐式转换。</p>\n<pre><code class=\"javascript\">// 方法一：利用 toString()\nlet a = &#123;\n  i: 1,\n  toString () &#123;\n    return a.i++;\n  &#125;\n&#125;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;\n  console.log(&#39;1&#39;);\n&#125;\n\n// 方法二：利用 valueOf()\nlet a = &#123;\n  i: 1,\n  valueOf () &#123;\n    return a.i++\n  &#125;\n&#125;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;\n  console.log(&#39;1&#39;);\n&#125;\n\n// 方法三：利用数组（这个是真的骚）\nvar a = [1,2,3];\na.join = a.shift;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;\n  console.log(&#39;1&#39;);\n&#125;\n\n// 方法四：利用 Symbol\nlet a = &#123;[Symbol.toPrimitive]: ((i) =&gt; () =&gt; ++i) (0)&#125;;\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;\n  console.log(&#39;1&#39;);\n&#125;\n</code></pre>\n<p>方法一和方法二没啥解释的了，解释下方法三和方法四。</p>\n<p>方法三：</p>\n<p><em>a.join &#x3D; a.shift</em> 的目的是将数组的 <em>join</em> 方法替换成 <em>shift</em> 方法。因为数组在参与相等比较时也会通过 <em>toString()</em> 将数组转为字符串，而该字符串实际上是数组中每个元素的 <em>toString()</em> 返回值经调用 <em>join()</em> 方法拼接（由逗号隔开）组成。现在我们将 <em>join()</em> 方法替换为了 <em>shift()</em> 方法，也就意味着数组在通过 <em>toString()</em> 隐式转换后，得到是 <em>shift()</em> 的返回值，每次返回数组中的第一个元素，而原数组删除第一个值，正好可以使判断成立。</p>\n<p>方法四：</p>\n<p><em>ES6</em> 中提供了 <em>11</em> 个内置的 <em>Symbo</em> 值，指向语言内部使用的方法。<em>Symbol.toPrimitive</em> 就是其中一个，它指向一个方法，当该对象被转为原始类型的值时，会调用这个方法，并返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个闭包返回的函数。</p>\n</blockquote>\n<h3 id=\"295-介绍前端模块化的发展。\"><a href=\"#295-介绍前端模块化的发展。\" class=\"headerlink\" title=\"295. 介绍前端模块化的发展。\"></a>295. 介绍前端模块化的发展。</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li><p><em>IIFE</em>：使用自执行函数来编写模块化（特点：在一个单独的函数作用域中执行代码，避免变量冲突）。</p>\n<pre><code class=\"javascript\">(function()&#123;\n  return &#123; data:[] &#125;\n&#125;)()\n</code></pre>\n</li>\n<li><p><em>AMD</em>：使用 <em>requireJS</em> 来编写模块化（特点：依赖必须提前声明好）。</p>\n<pre><code class=\"javascript\">define(&#39;./index.js&#39;,function(code)&#123;\n    // code 就是index.js 返回的内容\n&#125;)\n</code></pre>\n</li>\n<li><p><em>CMD</em>：使用 <em>seaJS</em> 来编写模块化（特点：支持动态引入依赖文件）。</p>\n<pre><code class=\"javascript\">define(function(require, exports, module) &#123;  \n  var indexCode = require(&#39;./index.js&#39;);\n&#125;);\n</code></pre>\n</li>\n<li><p><em>CommonJS</em>：<em>nodejs</em> 中自带的模块化。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n</code></pre>\n</li>\n<li><p><em>UMD</em>：通用模块规范，整合了 <em>AMD</em> 和 <em>CommonJS</em> 模块化。</p>\n<pre><code class=\"javascript\">(function (global, factory) &#123;\n  if (typeof exports === &#39;object&#39; &amp;&amp; typeof module !== undefined) &#123; //检查CommonJS是否可用\n    module.exports = factory(require(&#39;jquery&#39;));\n  &#125; else if (typeof define === &#39;function&#39; &amp;&amp; define.amd) &#123;      //检查AMD是否可用\n    define(&#39;toggler&#39;, [&#39;jquery&#39;, factory])\n  &#125; else &#123;       //两种都不能用，把模块添加到JavaScript的全局命名空间中。\n    global.toggler = factory(global, factory);\n  &#125;\n&#125;)(this, function ($) &#123;\n  function init() &#123;\n\n  &#125;\n  return &#123;\n    init: init\n  &#125;\n&#125;);\n</code></pre>\n</li>\n<li><p><em>webpack(require.ensure)<em>：</em>webpack 2.x</em> 版本中的代码分割。</p>\n</li>\n<li><p><em>ES Modules</em>： <em>ES6</em> 引入的模块化，支持 <em>import</em> 来引入另一个 <em>js</em> 。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"296-请指出-document-onload-和-document-ready-两个事件的区别\"><a href=\"#296-请指出-document-onload-和-document-ready-两个事件的区别\" class=\"headerlink\" title=\"296. 请指出 document.onload 和 document.ready 两个事件的区别\"></a>296. 请指出 <em>document.onload</em> 和 document.ready 两个事件的区别</h3><blockquote>\n<p>参考答案：</p>\n<p>页面加载完成有两种事件：一是 <em>ready</em>，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；二是 <em>onload</em>，指示页面包含图片等文件在内的所有元素都加载完成。</p>\n</blockquote>\n<h3 id=\"297-表单元素的readonly-和-disabled-两个属性有什么区别？\"><a href=\"#297-表单元素的readonly-和-disabled-两个属性有什么区别？\" class=\"headerlink\" title=\"297. 表单元素的readonly 和 disabled 两个属性有什么区别？\"></a>297. 表单元素的<em>readonly</em> 和 <em>disabled</em> 两个属性有什么区别？</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li><em>readonly</em>：<ul>\n<li>不可编辑，但可以选择和复制；</li>\n<li>值可以传递到后台；</li>\n</ul>\n</li>\n<li>disabled：<ul>\n<li>不能编辑，不能复制，不能选择；</li>\n<li>值不可以传递到后台；</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"298-列举几种你知道的数组排序的方法。\"><a href=\"#298-列举几种你知道的数组排序的方法。\" class=\"headerlink\" title=\"298. 列举几种你知道的数组排序的方法。\"></a>298. 列举几种你知道的数组排序的方法。</h3><blockquote>\n<p>参考答案：</p>\n<pre><code class=\"javascript\">// 方法一：选择排序\nlet ary = [5, 7, 8, 11, 3, 6, 4];\nfor (let i = 0; i &lt; ary.length - 1; i++) &#123;\n  for (let j = i + 1; j &lt; ary.length; j++) &#123;\n    if (ary[i] &lt; ary[j]) &#123;\n      [ary[i], ary[j]] = [ary[j], ary[i]];\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">// 方法二：冒泡排序\nlet ary = [5, 7, 8, 11, 3, 6, 4];\nfor (let i = 1; i &lt; ary.length; i++) &#123; \n  for (let j = 0; j &lt; ary.length - i; j++) &#123;  \n    if (ary[j] &lt; ary[j + 1]) &#123;\n      [ary[j], ary[j + 1]] = [ary[j + 1], ary[j]]\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n</blockquote>\n<h3 id=\"299-区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\"><a href=\"#299-区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\" class=\"headerlink\" title=\"299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\"></a>299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li>客户区坐标：鼠标指针在可视区中的水平坐标 (<em>clientX</em>) 和垂直坐标 (<em>clientY</em>)；</li>\n<li>页面坐标：鼠标指针在页面布局中的水平坐标 (<em>pageX</em>) 和垂直坐标 (<em>pageY</em>)；</li>\n<li>屏幕坐标：设备物理屏幕的水平坐标 (<em>screenX</em>) 和垂直坐标 (<em>screenY</em>)；</li>\n</ul>\n</blockquote>\n<h3 id=\"300-如何编写高性能的-JavaScript？\"><a href=\"#300-如何编写高性能的-JavaScript？\" class=\"headerlink\" title=\"300. 如何编写高性能的 JavaScript？\"></a>300. 如何编写高性能的 <em>JavaScript</em>？</h3><blockquote>\n<p>参考答案：</p>\n<ul>\n<li>遵循严格模式：”use strict”</li>\n<li>将 <em>JavaScript</em> 本放在页面底部，加快渲染页面</li>\n<li>将 <em>JavaScript</em> 脚本将脚本成组打包，减少请求</li>\n<li>使用非阻塞方式下载 <em>JavaScript</em> 脚本</li>\n<li>尽量使用局部变量来保存全局变量</li>\n<li>尽量减少使用闭包</li>\n<li>使用 <em>window</em> 对象属性方法时，省略 <em>window</em></li>\n<li>尽量减少对象成员嵌套</li>\n<li>缓存 <em>DOM</em> 节点的访问</li>\n<li>通过避免使用 <em>eval()</em> 和 <em>Function()</em> 构造器</li>\n<li>给 <em>setTimeout()</em> 和 <em>setInterval()</em> 传递函数而不是字符串作为参数</li>\n<li>尽量使用直接量创建对象和数组</li>\n<li>最小化重绘 (<em>repaint</em>) 和回流 (<em>reflow</em>)</li>\n</ul>\n</blockquote>\n<h3 id=\"301-下面的代码输出什么？\"><a href=\"#301-下面的代码输出什么？\" class=\"headerlink\" title=\"301. 下面的代码输出什么？\"></a>301. 下面的代码输出什么？</h3><pre><code class=\"javascript\">var a = function () &#123; return 5 &#125;\na.toString = function () &#123; return 3 &#125;\nconsole.log(a + 7);\n</code></pre>\n<blockquote>\n<p>参考答案：</p>\n<p>10</p>\n<p>因为会自动调用 a 函数的 <em>toString</em> 方法。</p>\n</blockquote>\n","categories":["面试题"],"tags":["面试题"]},{"title":"三方库","url":"/2024/04/16/%E4%B8%89%E6%96%B9%E5%8C%85/","content":"<h1 id=\"脚手架开发\"><a href=\"#脚手架开发\" class=\"headerlink\" title=\"脚手架开发\"></a><strong>脚手架开发</strong></h1><p><strong>常见工具包</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29tbWFuZGVy\">Commander</span></strong></th>\n<th><strong>提供一个连贯的 <code>API</code>，用于定义 <code>CLI</code> 应用程序的各个方面，如命令、选项、别名和帮助。简化了命令行应用程序的创建。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UveWFyZ3M=\">yargs</span></strong></td>\n<td><strong>脚手架开发框架，通过解析参数和生成优雅的用户界面来帮助您构建交互式命令行工具。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGVybmE=\">lerna</span></strong></td>\n<td><strong>多package管理</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW5xdWlyZXI=\">Inquirer</span></strong></td>\n<td><strong>一个易于嵌入且美观的 <code>Node.js</code> 命令行界面。 提供了很棒的查询会话流程。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2hhbGs=\">Chalk</span></strong></td>\n<td><strong><code>Chalk</code> 是一个非常简单的库，创建它的目的很简单——给你的终端字符串添加样式。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29sb3Jz\">colors</span></strong></td>\n<td><strong>打印<code>不同颜色的log信息</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb3Jh\">ora</span></strong></td>\n<td><strong>命令行<code>中高级的</code>、<code>功能丰富的高可定制化加载动画</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xpLXNwaW5uZXI=\">cli-spinner</span></strong></td>\n<td><strong>命令行中<code>轻量的符号加载动画</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnBtbG9n\">npmlog</span></strong></td>\n<td><strong>执行 npm 的日志记录。它支持<code>自定义级别和彩色输出</code>。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1wb3J0LWxvY2Fs\">import-local</span></strong></td>\n<td><strong>当与全局冲突的时候，比如全局和本地都有这个脚手架时可以使用，<code>判断使用的是否是本地版本</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmluZHVw\">findup</span></strong></td>\n<td><strong><code>向上查找指定文件</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGF0aC1leGlzdHM=\">path-exists</span></strong></td>\n<td><strong><code>判断文件是否存在</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVidWc=\">Debug</span></strong></td>\n<td><strong>一个很小的 <code>JavaScript</code> 调试实用程序。 只需将一个函数的名称传递给模块，它就会返回一个经过修饰的 <code>console.error</code> 版本，以便你将调试语句传递给该模块</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZnMtZXh0cmE=\">fs-extra</span></strong></td>\n<td><strong>fs模块的扩展，支持更多文件操作功能</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VtdmVy\">semver</span></strong></td>\n<td><strong><code>版本比对工具</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmlnbGV0\">figlet</span></strong></td>\n<td><strong>输出一些独特的大型<code>ASCII文本横幅</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdXNlci1ob21l\">user-home</span></strong></td>\n<td><strong>获取<code>用户主目录</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG90ZW52\">dotenv</span></strong></td>\n<td><strong>获取<code>环境变量</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcm9vdC1jaGVjaw==\">root-check</span></strong></td>\n<td><strong>检查是否是<code>管理员权限启动并自动降级</code>，防止后续因普通权限导致无法使用。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGtnLWRpcg==\">pkg-dir</span></strong></td>\n<td><strong>从某个目录开始向上查找，直到找到存在<code>package.json</code>的目录，并返回该目录。如果未找到则返回null</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWluaW1pc3Q=\">minimist</span></strong></td>\n<td><strong>用来<code>解析命令行参数和选项的库</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnBtaW5zdGFsbA==\">npminstall</span></strong></td>\n<td><strong><code>安装npm上的包</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG93bmxvYWQtZ2l0LXJlcG8=\">download-git-repo</span></strong></td>\n<td><strong><code>安装git仓库中的包</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWpz\">ejs</span></strong></td>\n<td><strong><code>xml模板数据动态渲染</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2xvYg==\">glob</span></strong></td>\n<td><strong>根据<code>文件路径进行遍历和匹配文件</code>，拿到文件的内容。</strong></td>\n</tr>\n</tbody></table>\n<p><strong>底层原理包</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>readline（node内置库）</strong></th>\n<th><strong>命令行的输入输出</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>events（node内置库）</strong></td>\n<td><strong>事件驱动</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3RyZWFt\">stream</span></strong></td>\n<td><strong>输入输出流</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYW5zaS1lc2NhcGVz\">ansi-escapes</span></strong></td>\n<td><strong>自定义<code>命令行文字样式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvcnhqcw==\">rxjs</span></strong></td>\n<td><strong><code>处理异步事件流</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYnVzYm95\">busboy</span></strong></td>\n<td><strong><code>多文件上传底层库</code>，尤其用于流式文件上传。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWNvbXBvbmVudHM=\">styled-components</span></strong></td>\n<td><strong>css-in-js理论工具，在<code>js中书写css样式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWpzeA==\">styled-jsx</span></strong></td>\n<td><strong>css-in-js理论工具，在<code>js中书写css样式</code>（ts支持不友好）</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZW1vdGlvbg==\">emotion</span></strong></td>\n<td><strong>css-in-js理论工具，在<code>js中书写css样式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3Qtcm91dGVyLWRvbQ==\">react-router-dom</span></strong></td>\n<td><strong>react在dom环境下的<code>路由工具</code></strong></td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a><strong>Vue</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQG53c2VlL2NvcmU=\">https://www.npmjs.com/package/@nwsee/core</span></strong></th>\n<th><strong>vue项目插件，用于页面性能监控</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a><strong>React</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGV4Y2FsaWRyYXcvZXhjYWxpZHJhdw==\">excalidraw</span></strong></th>\n<th><strong><code>画板、流程图和思维导图</code>等</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZDM=\">d3</span></strong></td>\n<td><strong><code>可视化数据图表库</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW1tZXI=\">immer</span></strong></td>\n<td><strong>改变了react<code>设置state状态的方式</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xhc3NuYW1lcw==\">classnames</span></strong></td>\n<td><strong>有条件地将 <code>classNames 连接</code>在一起</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYWhvb2tz\">ahooks</span></strong></td>\n<td><strong>国内常用的<code>react-hooks函数集</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY3JhY28=\">craco</span></strong></td>\n<td><strong>用于<code>create-react-app项目中的各种配置和重写</code></strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a><strong>Node.js</strong></h1><table>\n<thead>\n<tr>\n<th align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXhwcmVzcw==\">Express</span></strong></th>\n<th align=\"left\"><strong>轻量级web框架</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGhhcGkvaGFwaQ==\">Hapi</span></strong></td>\n<td align=\"left\"><strong>以最小的开销和完全开箱急用的功能构建强大的、拓展性强的应用程序</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2FpbHM=\">Sails</span></strong></td>\n<td align=\"left\"><strong>最流行的Node.js的MVC框架</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua29hanMubmV0Lw==\">Koa</span></strong></td>\n<td align=\"left\"><strong>下一代web开发框架</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZnMtZXh0cmE=\">Fs-extra</span></strong></td>\n<td align=\"left\"><strong>fs -extra<code>包含了</code>Node.js<code> </code>fs<code>包中没有包含的方法，比如</code>copy()<code>, </code>remove()<code>, </code>mkdirs()</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZS1jYWNoZQ==\">Node-cache</span></strong></td>\n<td align=\"left\"><strong>一个简单的缓存模块，具有设置，获取和删除方法的功能，类似于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZW1jYWNoZWQub3JnLw==\">memcached</span>。 key 值可以具有一个超时设置（ttl），在此时间之后它们将过期并从缓存中删除。</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2hhcnA=\">sharp</span></strong></td>\n<td align=\"left\"><strong><code>node图片处理</code>解决方案</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9hZHRlc3Q=\">Loadtest</span></strong></td>\n<td align=\"left\"><strong>node.js<code>压力测试工具</code>，模拟高并发场景。</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZS1zY2hlZHVsZQ==\">node-schedule</span></strong></td>\n<td align=\"left\"><strong>node.js中进行定时任务</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"Vite\"><a href=\"#Vite\" class=\"headerlink\" title=\"Vite\"></a><strong>Vite</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHR0cC1wcm94eQ==\">http-proxy</span></strong></th>\n<th><strong>vite代理服务器的底层，用于转发http请求到响应给客户端</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a><strong>HTML</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdzMuanM=\">w3.js</span></strong></th>\n<th><strong>w3.js是solidity abi的method_id和param解释器，可用于直接操作DOM元素</strong></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a><strong>css</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGFpbHdpbmRjc3M=\">Tailwind</span></strong></th>\n<th><strong>原子化css</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3R5bGVkLWNvbXBvbmVudHM=\">Styled-components</span></strong></td>\n<td><strong>css-in-js，js中书写css</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a><strong>AI</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3NlYXJjaD9xPUBtZWRpYXBpcGU=\">@mediapipe</span></strong></th>\n<th><strong>ai识别模型集</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3NlYXJjaD9xPUB4ZW5vdmE=\">@xenova</span></strong></td>\n<td><strong>ai识别模型</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h1><table>\n<thead>\n<tr>\n<th><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9uYWNvLWVkaXRvcg==\">monaco-editor</span></th>\n<th>web端vscode编辑器，各技术栈都有对应的接入包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a><strong>日志</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9yZ2Fu\">Morgan</span></strong></th>\n<th><strong>具体来说，它是一个 <code>HTTP</code> 请求记录器，存储 <code>HTTP</code> 请求，并为你提供有关应用程序如何使用以及可能存在潜在错误的简要信息。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2luc3Rvbg==\">Winston</span></strong></td>\n<td><strong>一个几乎所有内容的日志记录器，支持多种传输方式。它存储的时间比 <code>Morgan</code> 长，它也有一个更大的维护者社区和更多的下载。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9nNGpz\">log4js</span></strong></td>\n<td><strong>用于在js中生成日志信息，可以输出到终端，也可以生成日志文件</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a><strong>数据库</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9uZ29vc2U=\">Mongoose</span></strong></th>\n<th><strong><code>Mongoose</code> 是一个 <code>MongoDB</code> 对象建模工具，设计用于在异步环境中工作。<code>Mongoose</code> 支持 <code>Promise</code> 和回调。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VxdWVsaXpl\">Sequelize</span></strong></td>\n<td><strong><code>Sequelize</code> 是一个基于 <code>Promise</code> 的 <code>Node.js</code> <code>ORM</code> 工具，适用于 <code>Postgres</code>、MySQL、MariaDB、SQLite 和 Microsoft SQL Server。它具有可靠的事务支持、关系、即时和延迟加载、读取复制等特性。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYnJvd3Nlci1zeW5j\">browser-sync</span></strong></td>\n<td><strong><code>开启浏览器服务</code>，打开文件（html）,当执行文件改变时，自动刷新浏览器</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXlzcWwy\">mysql2</span></strong></td>\n<td><strong>用于连接mysql和编写sql语句</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uva25leA==\">knex</span></strong></td>\n<td><strong>node中ORM库，使用JavaScript代码来与关系型数据库进行交互</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcmlzbWEueW9nYS9nZXR0aW5nLXN0YXJ0ZWQv\">prisma</span></strong></td>\n<td><strong>node中ORM库，与TypeScript紧密集成，提供强大的类型安全保证</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW9yZWRpcw==\">ioredis</span></strong></td>\n<td><strong>在node.js中与Redis客户端进行交互。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a><strong>浏览器</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcHRyLmRldi8=\">Puppeteer</span></strong></th>\n<th><strong>通过DevTools协议控制浏览器，默认以无头模式运行（Chrome的无头版本），同时可以用于编写网络怕中和数据抓取脚本。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNkb20=\">jsdom</span></strong></td>\n<td><strong>许多Web标准的纯JavaScript实现，用于<code>node.js中模拟浏览器环境</code></strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a><strong>授权</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGFzc3BvcnQ=\">Passport</span></strong></th>\n<th><strong><code>Passport</code> 的目的是通过一组可扩展的插件(称为策略)对请求进行身份验证。向<code>Passport</code> 提供一个身份验证请求，<code>Passport</code> 提供钩子来控制身份验证成功或失败时发生的操作。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGFzc3BvcnQtand0\">Passport-jwt</span></strong></td>\n<td><strong>Passport库的一个插件，用于支持使用JSON Web Token (JWT) 进行身份验证和授权</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmNyeXB0\">Bcrypt</span></strong></td>\n<td><strong>它是可以帮助你生成哈希密码的库。<code>Bcrypt</code> 是由 <code>Niels Provos</code> 和 <code>David Mazieres</code> 基于 <code>Blowfish cipher</code> 设计的密码哈希函数，并于 1999 年在 USENIX 上展出。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNvbndlYnRva2Vu\">JSONWebToken</span></strong></td>\n<td><strong><code>JSON Web</code> 令牌(JWT)是一种开放的、行业标准的 <code>RFC 7519</code> 方法，用于在双方之间安全地表示声明。这个包允许你解码、验证和生成 JWT。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"静态网站生成\"><a href=\"#静态网站生成\" class=\"headerlink\" title=\"静态网站生成\"></a><strong>静态网站生成</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2F0c2J5\">Gatsby</span></strong></th>\n<th><strong>一个现代的网站生成器，可以创建快速，高质量，动态的 <code>React</code> 应用程序，从博客到电子商务网站再到用户仪表板。具有很棒的插件生态系统和模板。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmV4dA==\">NextJS</span></strong></td>\n<td><strong><code>NextJS</code> 首先支持服务器渲染以及静态生成的内容。 你还可以将 <code>serverless</code> 功能定义为 <code>API</code> 端点。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbnV4dA==\">NuxtJS</span></strong></td>\n<td><strong>在 <code>Vue</code> 的生态系统中，<code>NuxtJS</code> 基本上是 <code>NextJS</code> 的替代品。<code>NuxtJS</code> 的目标是让 <code>web</code> 开发功能强大，并且让开发者具有良好的开发意识。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a><strong>模板语法</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVzdGFjaGU=\">Mustache</span></strong></th>\n<th><strong><code>Mustache</code> 是一种无逻辑的模板语法。它可以用于 <code>HTML</code>，配置文件，源代码等任何东西。它的工作原理是使用 hash 或对象中提供的值在模板中展开标记。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGFuZGxlYmFycw==\">Handlebars</span></strong></td>\n<td><strong>使用模板和输入对象生成 <code>HTML</code> 或其他文本格式。<code>Handlebars</code> 模板看起来像一个嵌入了把手表达式的正则文本。<code>Handlebars</code> 很大程度上与 <code>Mustache</code> 模板兼容。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWpz\">EJS</span></strong></td>\n<td><strong><code>EJS</code> 是一种简单的模板语言，可让你使用简单的语法，快速的执行和简单的调试 <code>JavaScript</code> 来生成 <code>HTML</code> 标记。 <code>EJS</code> 拥有大量的活跃用户社区，并且该库正在积极开发中。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"mock数据\"><a href=\"#mock数据\" class=\"headerlink\" title=\"mock数据\"></a><strong>mock数据</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdXVpZA==\">Uuid</span></strong></th>\n<th><strong>方便而且体积小的包，可以快速、轻松地生成更复杂的通用惟一标识符(UUIDs)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFrZXI=\">Faker</span></strong></td>\n<td><strong>实用的 <code>npm</code> 包，用于在浏览器和 <code>Node.js</code> 中制造大量假数据。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNvbi1zZXJ2ZXI=\">jsonServer</span></strong></td>\n<td><strong>mock开发服务器数据</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmFub2lk\">nanoid</span></strong></td>\n<td><strong><code>字符串 ID 生成器</code> ,没有其余依赖。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"表单文件和邮件\"><a href=\"#表单文件和邮件\" class=\"headerlink\" title=\"表单文件和邮件\"></a><strong>表单文件和邮件</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdmFsaWRhdG9y\">Validator</span></strong></th>\n<th><strong>便捷的字符串验证器，使程序更加健壮的库。许多有用方法，例如 <code>isEmail()</code>， <code>isCreditCard()</code>，<code>isDate()</code> 和 <code>isURL()</code>。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZm9ybWlr\">Formik</span></strong></td>\n<td><strong><code>Formik</code> 是 <code>React</code> 和 <code>React Native</code> 的一个流行开源表单库。它具有易于使用、声明性和适应性的特点。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVsdGVy\">Multer</span></strong></td>\n<td><strong><code>Multer</code> 是用于 <code>multipart/form-data</code> 数据格式的 <code>Node.js</code> 中间件，主要用于上传文件。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1haWxlcg==\">Nodemailer</span></strong></td>\n<td><strong><code>Nodemailer</code> 是 <code>Node.js</code> 应用程序的一个模块，允许轻松发送电子邮件。这个项目从 2010 年就开始了，现在它是大多数 <code>Node.js</code> 用户默认使用的解决方案。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"pdf\"><a href=\"#pdf\" class=\"headerlink\" title=\"pdf\"></a><strong>pdf</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGRma2l0\">pdfkit</span></strong></th>\n<th><strong>适用于node和浏览器的<code>pdf生成库</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGRmLWxpYg==\">pdf-lib</span></strong></td>\n<td><strong>任何JavaScript环境中<code>创建和修改pdf</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanNwZGY=\">jspdf</span></strong></td>\n<td><strong>用<code>JavaScript生成pdf</code>的库</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"富文本编辑器\"><a href=\"#富文本编辑器\" class=\"headerlink\" title=\"富文本编辑器\"></a><strong>富文本编辑器</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ucG1kb2Mub3JnL3RpbnltY2V6aG9uZ3dlbndlbmRhbmd0aW55bWNlLWpzemhvbmd3ZW5qaWFvY2hlbmdqaWV4aS5odG1s\">tinymce</span></strong></th>\n<th><strong>富文本编辑，可商用，具有美感</strong></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"图表可视化\"><a href=\"#图表可视化\" class=\"headerlink\" title=\"图表可视化\"></a><strong>图表可视化</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWNoYXJ0cw==\">echarts</span></strong></th>\n<th><strong>图表可视化</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZDM=\">d3</span></strong></td>\n<td><strong>轻量的图表可视化</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFwYm94\">mapbox</span></strong></td>\n<td><strong>地图框架可视化</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lY29tZmUuZ2l0aHViLmlvL3pyZW5kZXIv\">zrender</span></strong></td>\n<td><strong>提供给echarts使用的轻量级图形库</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><strong>测试</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvamVzdA==\">Jest</span></strong></th>\n<th><strong><code>Jest</code> 是一个令人愉快的 <code>JavaScript</code> 测试框架，专注于简洁明快。它允许你使用易于使用、熟悉且功能丰富的 <code>API</code> 编写测试，从而快速获得结果。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9jaGE=\">Mocha</span></strong></td>\n<td><strong><code>Mocha</code> 是一个 <code>JavaScript</code> 测试框架，使得异步测试简单而有趣。<code>Mocha</code> 测试是串行运行的，在将未捕获的异常映射到正确的测试用例的同时，允许进行灵活和准确的报告。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a><strong>代码规范</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXNsaW50\">ESLint</span></strong></th>\n<th><strong><code>ESLint</code> 是用于识别和报告 <code>ECMAScript / JavaScript</code> 代码中的书写方式的工具。 <code>ESLint</code> 是完全插件化的，每个规则都是一个插件，你可以在运行时添加更多内容。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcHJldHRpZXI=\">Prettier</span></strong></td>\n<td><strong><code>Prettier</code> 是一种固执己见的代码格式化程序。它通过解析代码并使用自己的规则(考虑到最大行的长度)重新打印代码，以及在必要时包装代码，来强制执行一致的样式。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UveWVvbWFu\">yeoman</span></strong></td>\n<td><strong><code>生成eslint插件开发模板</code>的工具</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"打包和压缩\"><a href=\"#打包和压缩\" class=\"headerlink\" title=\"打包和压缩\"></a><strong>打包和压缩</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2VicGFjaw==\">Webpack</span></strong></th>\n<th><strong>一个著名的功能强大的模块打包器。它的主要目的是将 <code>JavaScript</code> 文件打包以便在浏览器中使用，但它也能够转换、捆绑或打包任何资源。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHRtbC1taW5pZmllcg==\">HTML-Minifier</span></strong></td>\n<td><strong>轻巧，高度可配置且经过良好测试的基于 <code>Javascript</code> 的 <code>HTML</code> 压缩器&#x2F;压缩器（支持 <code>Node.js</code>）。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2xlYW4tY3Nz\">Clean-CSS</span></strong></td>\n<td><strong>适用于 <code>Node.js</code> 平台和任何现代浏览器的快速高效的 <code>CSS</code> 优化器。 具有高度可配置和多种兼容模式。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdWdsaWZ5LWpz\">UglifyJS2</span></strong></td>\n<td><strong><code>JavaScript</code> 解析器，压缩程序和美化工具包。 它可以使用多个输入文件，并支持许多配置选项。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a><strong>进程管理</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1vbg==\">Nodemon</span></strong></th>\n<th><strong>在 <code>Node.js</code> 应用程序的开发过程中使用的简单的监控脚本。对于开发非常有用，因为它非常容易重启，并且默认启用了文件监听</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcG0y\">PM2</span></strong></td>\n<td><strong>带有内置负载均衡的 <code>Node.JS</code> 应用程序的生产进程管理器。 更全面，更适合生产，给你很多参数以进行调整功能</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29uY3VycmVudGx5\">Concurrently</span></strong></td>\n<td><strong>简单而直接——这是同时运行多个命令的有用工具。</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"桌面端\"><a href=\"#桌面端\" class=\"headerlink\" title=\"桌面端\"></a><strong>桌面端</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY3JlYXRlLXRhdXJpLWFwcA==\">create-tauri-app</span></strong></th>\n<th><strong>创建<code>桌面端应用程序</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"跨语言通信\"><a href=\"#跨语言通信\" class=\"headerlink\" title=\"跨语言通信\"></a><strong>跨语言通信</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ncnBjLmlvLw==\">grpc</span></strong></th>\n<th><strong>跨语言通信库</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a><strong>ORM</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvZ2V0dGluZy1zdGFydGVk\">Prisma ORM</span></strong></th>\n<th><strong>下一代Node.js 和 TypeScript ORM（对象关系映射）</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tb25nb29zZS5ub2RlanMuY24v\">Mongoose</span></strong></td>\n<td><strong>mongodb数据库ODM（对象文档映射）</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"解析和语法转换\"><a href=\"#解析和语法转换\" class=\"headerlink\" title=\"解析和语法转换\"></a><strong>解析和语法转换</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanMteWFtbA==\">js-yaml</span></strong></th>\n<th><strong>用于将JavaScript语言解析为<code>yaml</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGJhYmVsL3BhcnNlcg==\">@babel&#x2F;parser</span></strong></td>\n<td><strong>将<code>JavaScript代码转换为抽象语法树</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGJhYmVsL3RyYXZlcnNl\">@babel&#x2F;traverse</span></strong></td>\n<td><strong>用于遍历和<code>操作抽象语法树</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQGJhYmVsL2NvcmU=\">@babel&#x2F;core</span></strong></td>\n<td><strong>babel核心功能集，例如将抽象语法树转为JavaScript代码。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHJvbGx1cC9wbHVnaW4tbm9kZS1yZXNvbHZl\">@rollup&#x2F;plugin-node-resolve</span></strong></td>\n<td><strong>rollup插件，用于告诉<code>rollup如何处理导入导出语句（路径补全）</code>。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHJvbGx1cC9wbHVnaW4tY29tbW9uanM=\">@rollup&#x2F;plugin-commonjs</span></strong></td>\n<td><strong>rollup插件，用于<code>允许rollup将CommonJS模块</code>打包为ES语法</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHJvbGx1cC9wbHVnaW4tdHlwZXNjcmlwdA==\">@rollup&#x2F;plugin-typescript</span></strong></td>\n<td><strong>rollup插件，用于<code>rollup处理TypeScript文件</code></strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"音视频\"><a href=\"#音视频\" class=\"headerlink\" title=\"音视频\"></a><strong>音视频</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdGV4dC10by1zcGVlY2g=\">text-to-speech</span></strong></th>\n<th><strong>文本转语音</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><strong>其他</strong></h1><table>\n<thead>\n<tr>\n<th><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYXhpb3M=\">Axios</span></strong></th>\n<th><strong>基于 <code>Promise</code> 的 <code>HTTP</code> 客户端，用于浏览器和 <code>Node.js</code>。 与 <code>JS</code> 内置 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSQ==\">Fetch API</span> 相比，它易于设置，直观且简化了很多工作。</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><a href=\"https//www.npmjs.com/package/socket.io\">Socket.io</a></strong></td>\n<td><strong><code>Socket.IO</code> 支持实时，双向和基于事件的通信。 它可以在每个平台，浏览器或其他设备上运行，并同时关注可靠性和速度。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd3M=\">WS</span></strong></td>\n<td><strong>简单易用，快速且经过全面测试的 <code>WebSocket</code> 客户端和服务器实现。 一个很好的，不太抽象的，<code>Socket.io</code> 的替代方案</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGF5anM=\">DayJS</span></strong></td>\n<td><strong><code>DayJS</code> 是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9tZW50\">MomentJS</span> （自2020年9月起处于维护模式）的一种快速、轻巧的替代方案。它们的 <code>API</code> 使用类似，如果你使用过<code>MomentJS</code>，则已经知道如何使用大多数 <code>DayJS</code>。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbG9kYXNo\">Lodash</span></strong></td>\n<td><strong>现代化的 <code>JavaScript</code> 实用程序库，提供模块化，高性能以及其他功能。 公开关于 <code>JavaScript</code> 数组，对象和其他数据结构的许多有用方法。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvdW5kZXJzY29yZQ==\">Underscore</span></strong></td>\n<td><strong><code>Underscore</code> 提供了许多常用的功能工具以及更专业的工具：函数绑定，<code>javascript</code> 模板，创建快速索引，深度相等测试等。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYXN5bmM=\">Async</span></strong></td>\n<td><strong><code>Async</code> 是一个实用模块，它为异步 <code>JavaScript</code> 提供了直接、强大的功能。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2Vk\">Marked</span></strong></td>\n<td><strong>用于解析 <code>markdown</code> 而不需要缓存或长时间阻塞的低级编译器。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmFuZG9tY29sb3I=\">Randomcolor</span></strong></td>\n<td><strong>一个用于生成有吸引力的随机颜色的小脚本。 你可以传递选项对象从而决定其产生的颜色类型。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcGx1cmFsaXpl\">Pluralize</span></strong></td>\n<td><strong>该模块使用预先定义的规则列表，按顺序应用这些规则给指定单词单数或复数。 在许多情况下这很有用，例如基于用户输入的任何自动化。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVkZW50\">dedent</span></strong></td>\n<td><strong>从多行字符串中去除缩进（空格）</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXM=\">ms</span></strong></td>\n<td><strong>将易理解的时间转换为毫秒数。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaG90a2V5cy1qcw==\">hotkeys-js</span></strong></td>\n<td><strong><code>键盘事件</code>使用库。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXM=\">qs</span></strong></td>\n<td><strong><code>查询字符串解析和字符串化库</code>，具有一些附加的安全性</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFjZS1hcGk=\">face-api</span></strong></td>\n<td><strong>用于<code>人脸识别</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcXJjb2RlanM=\">qrcode</span></strong></td>\n<td><strong>用于将<code>文本转二维码</code>，并用canvas绘制出来</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbGxxcmNvZGU=\">llqrcode</span></strong></td>\n<td><strong>将扫描二维码，将二维码转为文本</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9mZm1wZWcucDJocC5jb20vZG93bmxvYWQuaHRtbA==\">FFmpeg</span></strong></td>\n<td><strong><code>跨平台多媒体处理工具</code>，可以采用命令行的方式<code>解码、编码转码复用、流式、过滤</code>和播放几乎任何机器创建的东西（如视频转码、剪辑、提取、合并）等。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wbmdxdWFudC5vcmcv\">pngquant</span></strong></td>\n<td><strong>压缩 PNG 图像文件的工具,同时保持图像质量和透明度。<code>pngquant</code> 提供命令行接口和库，可轻松集成到各种应用程序和脚本中。</strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaHR0cC1wcm94eS1taWRkbGV3YXJl\">http-proxy-middleware</span></strong></td>\n<td><strong>代理中间件，<code>用于将特定的请求进行转发</code></strong></td>\n</tr>\n<tr>\n<td><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWltZQ==\">mime</span></strong></td>\n<td><strong>用于根据文件或路径后缀，<code>得到对应的mime类型</code>。</strong></td>\n</tr>\n<tr>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW52YXJpYW50\">invariant</span></td>\n<td>类型断言函数，不满足给定条件时抛出错误</td>\n</tr>\n</tbody></table>\n","categories":["三方库"],"tags":["三方库"]}]