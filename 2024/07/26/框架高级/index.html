<!-- build time:Mon Aug 05 2024 09:34:21 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="杜明清的个人博客" href="https://dmqweb.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="杜明清的个人博客" href="https://dmqweb.cn/atom.xml"><link rel="alternate" type="application/json" title="杜明清的个人博客" href="https://dmqweb.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="框架高级"><link rel="canonical" href="https://dmqweb.cn/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/"><title>框架高级 - 框架高级 | Web blog = 杜明清的个人博客 = 👻欢迎一起交流学习👻</title><meta name="keywords" content="前端开发, HTML, CSS, JavaScript, 博客"><meta name="description" content="探索前端开发的无限可能。本博客提供最新的前端知识库，以及实用的开发技巧和最佳实践。加入我们的社区，共同成长。"><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">框架高级</h1><div class="meta"><span class="item" title="创建时间：2024-07-26 12:24:04"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-07-26T12:24:04+08:00">2024-07-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>14k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>13 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Web blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/05/05d9a07e0d190274.webp"></li><li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/07/6e43985af4997748.jpg"></li><li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/06/63e9f1e7097ba6fb.jpg"></li><li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/25/0edddbac6c1e1908.webp"></li><li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/07/5a293b82670a4885.webp"></li><li class="item" data-background-image="https://s3.uuu.ovh/imgs/2024/04/07/d94cad8780c8c094.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/" itemprop="item" rel="index" title="分类于 框架高级"><span itemprop="name">框架高级</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://dmqweb.cn/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="dmq"><meta itemprop="description" content="👻欢迎一起交流学习👻, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="杜明清的个人博客"></span><div class="body md" itemprop="articleBody"><h1 id="vue高级用法"><a class="anchor" href="#vue高级用法">#</a> vue 高级用法</h1><h3 id="watcheffect函数"><a class="anchor" href="#watcheffect函数">#</a> watchEffect 函数</h3><blockquote><p>立即运行传入的函数，同时自动追踪其依赖，并在依赖更改时重新执行。<br>watchEffect 的返回值是用于清除该副作用的函数。</p></blockquote><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> stop <span class="token operator">=</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>value<span class="token punctuation">,</span><span class="token string">'data变化了'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除响应性监听</span></pre></td></tr></table></figure><blockquote><p>watchEffect 的第二个参数是 options 配置项，可以配置 flush、onTrack 函数和 onTrigger 函数</p></blockquote><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token literal-property property">flush</span><span class="token operator">:</span><span class="token string">"post"</span><span class="token punctuation">,</span> <span class="token comment">//flush 配置项配置回调函数的刷新时机，post 会在 DOM 渲染之后触发、sync 会在 vue 进行任何更新之前进行触发</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">onTrack</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">debugger</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">debugger</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="watchsynceffect函数"><a class="anchor" href="#watchsynceffect函数">#</a> watchSyncEffect 函数</h3><blockquote><p>回调函数会在 DOM 渲染之后触发，相当于 watchEffect 中配置了 fulsh:&quot;post&quot;</p></blockquote><h3 id="watchsynceffect函数-2"><a class="anchor" href="#watchsynceffect函数-2">#</a> watchSyncEffect 函数</h3><blockquote><p>回调函数在 vue 进行任何更新之前触发，相当于 watchEffect 中配置了 fulsh:&quot;sync&quot;</p></blockquote><h3 id="effectscope函数"><a class="anchor" href="#effectscope函数">#</a> effectScope 函数</h3><blockquote><p>effectScope 函数创建一个 effect 作用域，可以捕获其中所创建的响应式副作用（即计算属性和侦听器），这样捕获到的副作用可以一起处理。</p></blockquote><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> scope <span class="token operator">=</span> <span class="token function">effectScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>scope<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">const</span> doubled <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> counter<span class="token punctuation">.</span>value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">watch</span><span class="token punctuation">(</span>doubled<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doubled<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Count: '</span><span class="token punctuation">,</span> doubled<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>scope<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除掉作用域内所有的 effect</span></pre></td></tr></table></figure><h3 id="getcurrentscope函数"><a class="anchor" href="#getcurrentscope函数">#</a> getCurrentScope 函数</h3><blockquote><p>获取当前活跃的 effect 作用域</p></blockquote><h3 id="onscopedispost函数"><a class="anchor" href="#onscopedispost函数">#</a> onScopeDispost 函数</h3><blockquote><p>在当前活跃的 effect 作用域上注册一个处理回调函数。当相关的 effect 作用域停止时会调用这个回调函数。</p></blockquote><h3 id="shallowref函数"><a class="anchor" href="#shallowref函数">#</a> shallowRef 函数</h3><blockquote><p>用于浅层响应式，避免深层比较带来的效率问题</p></blockquote><h3 id="triggerref函数"><a class="anchor" href="#triggerref函数">#</a> triggerRef 函数</h3><blockquote><p>强制触发依赖于一个浅层 ref 的副作用，通常在对浅引用的内部值进行深度变更后使用</p></blockquote><h3 id="customref函数"><a class="anchor" href="#customref函数">#</a> customRef 函数</h3><blockquote><p>customRef 函数创建一个自定义的 ref，显示声明对其依赖追踪和更新触发的控制方式。预期接受一个工厂函数作为参数，这个工厂函数接收 track 和 trigger 两个函数作为参数，并返回一个带有 get 和 set 方法的对象</p></blockquote><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义一个返回懒执行响应式数据的函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">useDebouncedRef</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>delay<span class="token operator">=</span><span class="token number">200</span></span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">let</span> timeout<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">customRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">track<span class="token punctuation">,</span>trigger</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">return</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    value <span class="token operator">=</span> newValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>     </pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="shallowreactive"><a class="anchor" href="#shallowreactive">#</a> shallowReactive</h3><blockquote><p>shallowReactive 是 reactive 的浅层作用形式，只有跟级别的属性是响应式的，属性的值会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。</p></blockquote><h3 id="shallowreadonly"><a class="anchor" href="#shallowreadonly">#</a> shallowReadonly</h3><blockquote><p>shallowReadonly 是 readonly 的浅层作用形式。</p></blockquote><h3 id="isref函数"><a class="anchor" href="#isref函数">#</a> isRef 函数</h3><blockquote><p>用于检查某个值是否是 ref</p></blockquote><h3 id="unref函数"><a class="anchor" href="#unref函数">#</a> unref 函数</h3><blockquote><p>如果是 ref，返回 ref 内部的值，否则返回参数本身</p></blockquote><h3 id="toref函数"><a class="anchor" href="#toref函数">#</a> toRef 函数</h3><ul><li>传入 ref 返回 ref 本身</li><li>传入 props.key 创建一个只读的 ref</li><li>传入 number 或者 string 相当于 ref 函数</li><li>传入响应式数据和键值会封装为一个 ref，但是相比于直接封装 ref 来说，会与源属性进行同步<figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">bar</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> fooRef <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//fooRef 会和 state 的响应性相关联</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> fooRef2 <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//fooRef2 不会和 state.foo 的响应性相关联</span></pre></td></tr></table></figure></li></ul><h3 id="torefs函数"><a class="anchor" href="#torefs函数">#</a> toRefs 函数</h3><blockquote><p>vue3 中的 ref 将 reactive 响应性绑定到.value 属性上，其本质就是为了防止开发者错误的将响应式数据进行解构后的变量又其当作响应式数据。所以加了一层隔离。toRefs 函数也是用于解决这个问题。<br>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef 创建的</p></blockquote><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">"张三"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> stateAsRefs <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>state<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"李四"</span><span class="token punctuation">;</span> <span class="token comment">//toRefs 返回的响应式数据和原响应式数据相互关联</span></pre></td></tr><tr><td data-num="7"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stateAsRefs<span class="token punctuation">.</span>name<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 李四</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//toRefs 的存在是为了保证 reactive 响应式被解构之后仍然存在响应性</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">const</span> <span class="token punctuation">&#123;</span>name<span class="token punctuation">,</span>age<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 解构之后的 name 和 age 都是响应式对象</span></pre></td></tr></table></figure><h3 id="toraw函数"><a class="anchor" href="#toraw函数">#</a> toRaw 函数</h3><blockquote><p>toRaw 返回由 reactive、readonly、shallowReactive 或者 shallowReadonly 创建的代理对应的原始对象（栈赋值），返回的对象不再具有响应式，栈赋值时不会影响到页面的展示，但如果改变该对象的堆中的属性，原对象的依赖项也会随之变化</p></blockquote><h3 id="markraw函数"><a class="anchor" href="#markraw函数">#</a> markRaw 函数</h3><blockquote><p>将一个对象标记为不可被转为代理，返回该对象本身</p></blockquote><h3 id="tovalue函数"><a class="anchor" href="#tovalue函数">#</a> toValue 函数</h3><blockquote><p>将值、函数、或响应式数据规范化为普通值，toValue (ref (1)) ---&gt; 1</p></blockquote><h3 id="isproxy函数"><a class="anchor" href="#isproxy函数">#</a> isProxy 函数</h3><blockquote><p>检查一个对象是否是由 reactive、readonly、shallowReactive 或者 shallowReadonly 创建的代理。</p></blockquote><h3 id="isreactive函数"><a class="anchor" href="#isreactive函数">#</a> isReactive 函数</h3><blockquote><p>检查一个对象是否是由 reactive 或 shallowReactive 创建的代理</p></blockquote><h3 id="isreadonly函数"><a class="anchor" href="#isreadonly函数">#</a> isreadonly 函数</h3><blockquote><p>检查传入的值是否是只读对象，只读对象的属性可以更改，但是不能通过传入的对象直接赋值。</p></blockquote><h3 id="transition组件"><a class="anchor" href="#transition组件">#</a> Transition 组件</h3><ul><li>使用过渡样式</li><li>mode 属性定义动画进行的顺序，常用 out-in</li><li>name 属性定义动画的名称，配合 css 使用</li><li>appear 属性初次渲染过渡</li><li>生命周期钩子用于自定义过渡中执行过程，依次是 before-enter,enter,after-enter,enter-cancelled,before-leave,leave,leave-cancelled, 可用的参数有 el 和 done ()</li><li>css 样式过渡:name-enter-from\name-enter-active\name-enter-to\name-leave-from\name-leave-active\name-leave-to 定义对应时期的样式 (只对可以过渡变化的样式生效)</li></ul><h3 id="transitiongroup组件"><a class="anchor" href="#transitiongroup组件">#</a> TransitionGroup 组件</h3><ul><li>TransitionGroup 组件用于对 v-for 列表中的元素或组件插入 、移除或顺序变化添加动画效果.</li><li>属性和生命周期和 Transition 一样</li><li>tag 属性可以指定 TransitionGroup 为一个容器</li></ul><h3 id="keepalive组件"><a class="anchor" href="#keepalive组件">#</a> KeepAlive 组件</h3><ul><li>KeepAlive 用于在多个组件间切换状态时缓存被移除的组件实例 (使组件保存状态)</li><li>KeepAlive 的原理就是当 KeepAlive 中的组件被移除时，用变量将整个组件缓存起来，需要切换时直接使用缓存起来的变量</li><li>include 和 exclude 属性用于包含或排除对应的组件 name</li><li>KeepAlive 的组件包含 onActivated 和 onDeactived 两个生命周期钩子</li></ul><h3 id="teleport组件"><a class="anchor" href="#teleport组件">#</a> Teleport 组件</h3><ul><li>Teleport 组件，用于将组件内部的一部分模板传送到外部结构中去</li><li>to 属性用于指定传送到的组件或者 DOM 元素</li></ul><h3 id="suspense组件"><a class="anchor" href="#suspense组件">#</a> Suspense 组件</h3><ul><li>Suspense 组件用于显示异步组件加载中的显示状态</li><li>Suspense 组件中 fallback 具名插槽用于显示加载内容</li><li>Suspense 组件嵌套 Suspense 组件时，给内部 Suspense 组件加上 suspensible 属性表示为异步组件，否则则会被父级 Suspense 组件视为同步组件</li></ul><h3 id="watch的options配置项"><a class="anchor" href="#watch的options配置项">#</a> watch 的 options 配置项</h3><blockquote><p>watch 的 options 配置项中可以使用:</p></blockquote><ul><li>immediate, 为 true 时会在初始化时立即执行一次</li><li>deep, 为 true 时会深度监听对象堆中变化</li><li>flush, 调整回调函数的执行时机</li><li>once, 回调函数只会执行一次</li><li>onTrack 函数，当响应式被收集时进行触发<strong>只在开发模式下有效</strong></li><li>onTrigger 函数，当依赖项变更时进行触发<strong>只在开发模式下有效</strong></li></ul><h3 id="computed的options配置项"><a class="anchor" href="#computed的options配置项">#</a> computed 的 options 配置项</h3><ul><li>onTrack 函数，当响应式被收集时进行触发<strong>只在开发模式下有效</strong></li><li>onTrigger 函数，当依赖项变更时进行触发<strong>只在开发模式下有效</strong></li></ul><h3 id="vue对jsx的支持友好"><a class="anchor" href="#vue对jsx的支持友好">#</a> vue 对 jsx 的支持友好</h3><ul><li>在 vue 中也可以很方便的去集成 jsx 或 tsx 语法，tsx 语法需要在 tsconfig.json 中配置：jsx：preserve，最终的 jsx 语法会被转换为 h 函数</li><li>对于事件和案件修饰符，可以使用 vue 中的 withModifiers 函数</li></ul><h3 id="vue对web-component的支持友好"><a class="anchor" href="#vue对web-component的支持友好">#</a> vue 对 web component 的支持友好</h3><ul><li>在 Vue 应用中使用自定义元素基本上与使用原生 HTML 元素的效果相同</li><li>需要在构建工具中配置 compilerOptions.isCustomElement 这个选项</li><li>传递 ODM 属性时，需要使用 v-bind 绑定，通过.prop 修饰符进行设置<figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-element</span> <span class="token attr-name">:user.prop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123; name: 'jack' &#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-element</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">&lt;!-- 等价简写 --></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-element</span> <span class="token attr-name">.user</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123; name: 'jack' &#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-element</span><span class="token punctuation">></span></span></pre></td></tr></table></figure></li><li>使用 vue 构建 web component 需要使用 defineCustomElement 这个方法定义出组件，然后通过 customElement.define 这个方法将 vue 组件添加标签到 HTML 中</li></ul><h3 id="web-component的优缺点"><a class="anchor" href="#web-component的优缺点">#</a> web component 的优缺点</h3><ul><li>全部使用自定义元素来构建应用的方式可以使得应用永不过时和多平台、框架共享</li><li>但是设想与显示总是存在偏差：</li><li><ul><li>1、原生 web component 并不具备响应式的系统</li></ul></li><li><ul><li>2、原生 web component 并不具备一个声明式的、高效的模板系统</li></ul></li><li><ul><li>3、SSR 渲染时，web component 需要在 node.js 中模拟出 DOM，这将增大服务器端的压力</li></ul></li><li><ul><li>4、当下要想使用 shadow DOM 书写局部作用域的 CSS，必须要将样式嵌入到 JavaScript 中才可以在运行时注入到 shadow root 上，这将导致 SSR 场景下需要渲染大量重复的样式标签。</li></ul></li></ul><h3 id="vue结合js动画库"><a class="anchor" href="#vue结合js动画库">#</a> vue 结合 js 动画库</h3><ul><li>以 gsap 为例，vue 结合 js 动画库实现动画效果时，不能直接对响应式变量进行动画设置，因为是响应式完成之后才被监听到，此时响应式变量已经是最新的值，所以应该再来一个响应式变量中转一下，页面动画效果绑定的是中转的变量。</li></ul><h3 id="vue生命周期"><a class="anchor" href="#vue生命周期">#</a> vue 生命周期</h3><ul><li>vue3 中 setup 替代了 beforeCreate 和 created</li><li>beforeMount、monuted、beforeUpdate、updated、beforeUnmount、unMounted</li><li>错误捕获钩子：onErrorCaptured，如果在 onErrorCaptured 中抛出一个错误，则会被 app.config.errorHandler 捕获到</li><li>开发时钩子：onRenderTracked（组件渲染过程中追踪到响应式依赖时调用）和 onRenderTriggered（当响应式依赖触发了组件渲染时调用）</li><li>SSR 钩子：onServerPrefetch（注册一个异步函数，在组件实例在服务器上被渲染之前调用），SSR 渲染时，组件作为初始请求的一部分被渲染，这时可以在服务器上预请求数据，因为它比在客户端上更快。</li><li>keepAlive 组件下的钩子：onActivated 和 onDeactivated 两个，用于当组件激活和失活时调用</li></ul><h1 id="react"><a class="anchor" href="#react">#</a> React</h1><h2 id="fiber"><a class="anchor" href="#fiber">#</a> Fiber</h2><blockquote><p>Fiber 架构：Fiber 架构是一个增量渲染，架构风格类似协程，Fiber 架构出现的原因是由于 JS 单线程执行的特性当遇到繁琐的执行任务时，原来 React15 的协调过程就会很长，从而延迟 DOM 的渲染更新，进而出现掉帧。Fiber 架构将任务分给一个个的迭代器进行执行，并且使迭代器的执行过程发生在浏览器的空闲时间，从而最大程度利用了这部分资源，使得 UI 渲染不会被大量执行任务所阻塞。<br>fiber 树：fiber 树是一个数据结构，架构在虚拟 DOM 转换到真实 DOM 之间，在 Fiber 结构中的任务是可以中断执行的，继续执行时会丢弃掉原来的工作从头再来，并且重新执行中断的任务，对用于来说也是无感的，因为 Fiber 架构的视图更新是后缓冲区视图 替换 前缓冲区视图的过程。<br>由于 Fiber 架构下的 reconciler 协调阶段是异步可中断的，且会被反复重新执行，使得反复执行时有可能触发的生命周期钩子被废弃，例如：componentWillMount、componentWillReceiveProps、componentWillUpdate 这些。<br>fiber 树（fiber 节点构成的树状链表）的遍历与执行：</p></blockquote><ul><li>fiber 树遍历：children 子节点 ----sibling 兄弟节点 ----return 父节点</li><li>fiber 树的执行：遍历到最底层子节点 A----A 的兄弟节点 -----A 的父节点 B------B 的兄弟节点（深度优先遍历）</li></ul><blockquote><p>fiber 节点（对象）：一个 fiber 节点对应一个 React 组件，fiber 节点里包含了组件的 work 任务等信息，比如组件的 Hooks 执行逻辑（它是一个链表，可以通过 memorizedState 拿到跟节点，Hooks 执行逻辑里面存储了 state）、生命周期、对于 html 组件的增删改查等副作用<br>当执行 fiber 节点中的任务时，每次执行完之后 React 就会检查当前帧还剩多少时间，没有时间就会将控制权让出去。</p></blockquote><h3 id="fiber树-vdom和diff算法"><a class="anchor" href="#fiber树-vdom和diff算法">#</a> fiber 树、VDOM 和 diff 算法</h3><blockquote><p>fiber 树就是 VDOM,fiber 树的变化反映了组件的状态变化<br>diff 算法的本质就是：对比 <code>current fiber</code> 和 <code>JSX对象</code> 生成 <code>work-in-progress-fiber</code><br>即使是最前沿的算法，完全对比两棵树的时间复杂度也需要 O (n^3), 其中</p></blockquote><h2 id="hooks"><a class="anchor" href="#hooks">#</a> Hooks</h2><blockquote><p>注意：react Hooks 只能在件顶层进行调用并且不能写在条件判断中，这是因为 hooks 以链表的形式存放在 fiber 节点中（类组件的副作用也存在 fiber 节点中），每次更新时会基于链表的顺序进行调用，而调用 hooks 所产生的 state 就存在于 hooks 节点之中，如果 hooks 写在条件判断中则导致 hooks 链表执行混乱，使得状态更新出错。</p></blockquote><h2 id="workloop工作循环"><a class="anchor" href="#workloop工作循环">#</a> workLoop 工作循环</h2><blockquote><p>workLoop 中会根据当前帧的剩余时间去执行 fiber 节点中的任务，如果时间不够就将控制权转给 UI 渲染，并保存当期的执行上下文 (包括当前 fiber 节点的状态), 当 UI 渲染完毕后，恢复其执行 (执行到一半的任务会重新执行)</p></blockquote><h2 id="双缓冲策略"><a class="anchor" href="#双缓冲策略">#</a> 双缓冲策略</h2><blockquote><p>双缓冲策略是用于减少组件渲染过程中的闪烁和卡顿。双缓冲策略是对于 fiber 树来说的<br>双缓冲策略会维护两个 Fiber 树：Work-in-progress-fiber 树 和 current-fiber 树。协调过程中 React 会比较新旧两个 fiber 树的差异，从而确定哪些组件需要更新。一旦新的 fiber 树构建完成，React 就会使用 diff 算法去更新真实 DOM。更新完成后会将工作 Fiber 树的根节点与当前 Fiber 树的根节点进行交换，这个过程叫做提交。</p></blockquote><h3 id="fiber更新的三个阶段"><a class="anchor" href="#fiber更新的三个阶段">#</a> Fiber 更新的三个阶段</h3><ul><li>开始阶段: <code>ReactFiberBeginWork</code></li><li><ul><li>这个阶段 react 需要决定哪些组件需要更新、哪些组件可以复用、哪些组件需要被挂载或卸载</li></ul></li><li><ul><li>React 通过比较新旧 Fiber 树来确定变化，这个过程称为协调算法（Reconciliation）。</li></ul></li><li><ul><li>此阶段会创建一个新的工作进度树（work-in-progress tree），表示 UI 的最新状态。</li></ul></li><li><ul><li>这个阶段是可中断的，React 可以决定挂起渲染过程，稍后再恢复。</li></ul></li><li>完成阶段: <code>ReactFiberCompeleteWork</code></li><li><ul><li>这个阶段发生在实际将更新应用到屏幕之前。</li></ul></li><li><ul><li>React 执行生命周期方法，如 getSnapshotBeforeUpdate，允许组件捕获当前的 DOM 状态或执行捕获操作。</li></ul></li><li><ul><li>这个阶段用于执行那些需要在提交前知道布局效果的副作用，例如，测量组件的尺寸或位置。</li></ul></li><li>提交阶段: <code>ReactFiberCommitWork</code></li><li><ul><li>这是实际将更改应用到真实 DOM 的阶段。</li></ul></li><li><ul><li>React 处理所有副作用，如 componentDidMount、componentDidUpdate 和 componentWillUnmount 生命周期方法。</li></ul></li><li><ul><li>更新 DOM 元素和属性，添加或删除 DOM 节点，以确保真实 DOM 与工作进度树同步。这个阶段是连续的，不能被中断，因为 DOM 更新通常需要原子性地完成。</li></ul></li></ul><h2 id="为什么hooks不能写在条件判断"><a class="anchor" href="#为什么hooks不能写在条件判断">#</a> 为什么 hooks 不能写在条件判断</h2><blockquote><p>hooks 函数最终会被存在组件对应的 fiber 节点的 memoizatedState 中，组件每次更新会按照顺序执行 (hooks 里面存着 state 状态)，如果组件每次更新时的 hooks 链表顺序乱了，就会导致 state 对应不上、状态混乱</p></blockquote><h2 id="react不可变数据"><a class="anchor" href="#react不可变数据">#</a> react 不可变数据</h2><blockquote><p>例如当 setData (data + 1) 副作用在组件内连续调用三次时，其实是相当于只调用了一次，这就是 react 不可变数据或者说：当前快照只能操作当前快照的值；<br>出现 react 不可变数据现象的原因是由于: hooks 执行逻辑最后会以链表的形式存储在 fiber 节点之中，而那里面不会有类似上面 data 这样的变量，data 会在 hooks 执行过程被存储之前转换为其具体的值，上例正确的写法是写成一个函数，这样在存储 hooks 执行逻辑到 fiber 节点中时就会先执行传入的这个函数，例如应该写成:setData (()=&gt;data+1)</p></blockquote><h2 id="reactfiberlane模型并发模式"><a class="anchor" href="#reactfiberlane模型并发模式">#</a> ReactFiberLane 模型 (并发模式)</h2><blockquote><p>React 并发模式：首先，并发和并行不一样，并行是同一时刻多件事情同时进行， <code>而并发是只要一段时间内同时发生多件事情就行</code> 。React 并发模式允许多个状态在同一时间段进行更新，Fiber 节点上的 Lanes 标记告诉 React 如何并发处理这些状态更新。<br>为了让高优先级的更新能先渲染，react 实现了并发模式。React 中更新 State 有两种模式：同步模式是循环处理 fiber 节点，并发模式多了个 shouldYield 的判断，每 5ms 打断一次，也就是时间分片。并且之后会重新调度渲染。<br>React 并发是指：对于每一个次 State 状态变化要执行的 Hooks 链表的更新，再循环执行时都会判断一下是否需要打断这次循环，从而将更新让给其他任务<br>这些并发特性的 api 都是通过设置 Lane 实现的，react 检测到对应的 Lane 就会开启 <code>带有时间分片的 workLoopConcurrent 循环</code> 。时间分片的 workLoop + 优先级调度，这就是 React 并发机制的实现原理。这就是 React 并发机制的实现原理。<br>基于 Lane 的优先级实现的 api, 例如:useTransition、useDeferredValue。当被用到 的时候，react 才会启用 workLoopConcurrent 带时间分片的循环。<br>被打断的 Hooks 链表的更新任务会被丢弃，由于没有渲染完所以需要再添加一个任务进任务队列<br>Lane 模型是 React 中的一种状态更新机制，目的是提高应用的性能和响应速度，核心思想是将 UI 中的状态变化抽象成一系列的 lane 变化，每个 lane 只描述了一个状态的变化，而不是一次完整得状态更新，这样可以使得状态变化更加清晰易于处理和维护<br>react 的并发模式的打断只会根据时间片，也就是每 5ms 就打断一次，并不会根据优先级来打断，优先级只会影响任务队列的任务排序。<br>React 通过 Scheduler 调度任务时，会先把 Lane 转为事件优先级，再把事件优先级转为 Scheduler 的五种优先级<br>所谓的并发渲染就是加了一个 5ms 一次的时间分片，react18 里同时存在着这两种循环方式，普通的循环和带时间分片的循环。也不是所有的特性都要时间分片，只有部分需要，如果这次 setState 更新里包含了并发特性，就是用 workLoopConcurrent，否则走 workLooSync 就好了。<br>比如上面有两个 setState，其中一个优先级高，另一个优先级低，那就把低的那个用 startTransition 包裹起来。就可以实现高优先级的那个优先渲染。 <code>实现原理是</code> ：在调用回调函数之前设置了更新的优先级为 ContinuousEvent 的优先级，也就是连续事件优先级，比 DiscreteEvent 离散事件优先级更低，所以会比另一个 setState 触发的渲染的优先级低，在调度的时候排在后面。这里设置的其实就是 Lane 的优先级：那渲染的时候就会走 <code>workLoopConcurrent 的带时间分片的循环</code> ，然后通过 Scheduler 对任务按照优先级排序，就实现了高优先级的渲染先执行的效果。<br>React 使用 31 位二进制来表示优先级车道，一共 31 条，位数越小 (1 的位置越靠右) 表示优先级越高.<br>React 每次更新状态会将同类型的 Lane (通过位运算与) 合并形成 Lanes (通过位运算或), 然后从同类型的 Lanes 中找出优先级最高的事件<br>当一个 Fiber 节点需要更新时，React 会根据状态得变化创建更新类型，通过更新类型在该节点上标记相应的 Lanes, 指示了该节点的优先级类型，React 这种并发模式允许多个更新同时进行处理，React 会根据 Fiber 节点上的 Lanes 来决定哪些更新可以并发执行，以及他们的执行顺序，如果一个高优先级的更新需要立即处理，React 可以中断当前正在进行的低优先级更新，转而处理高优先级的更新。一旦高优先级的更新完成，之前中断的更新可以恢复。</p></blockquote><h3 id="usestate钩子"><a class="anchor" href="#usestate钩子">#</a> useState 钩子</h3><blockquote><p>创建可以直接更新的状态变量</p></blockquote><h3 id="usereducer钩子"><a class="anchor" href="#usereducer钩子">#</a> useReducer 钩子</h3><blockquote><p>与 useState 相似，创建状态变量，同时可以自定义 reducer（内部变量变化的调度机制）</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 注意：reducer 中的返回值就是新的 state</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">const</span> <span class="token function-variable function">dataReducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> aciton</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>aciton<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token string">"你好"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token string">"世界"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token string">"你好世界"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token string">"世界你好"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> dispatchData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>dataReducer<span class="token punctuation">,</span> <span class="token string">"你好世界"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">return</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">dispatchData</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">你好</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">dispatchData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">世界</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="17"></td><td><pre>      &lt;button onClick = <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token function">dispatchData</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">>你好世界</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">dispatchData</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">世界你好</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="createcontext和usecontext钩子"><a class="anchor" href="#createcontext和usecontext钩子">#</a> createContext 和 useContext 钩子</h3><blockquote><p>createContext 和 useContext 直接使用相当于是创建可用的变量</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> testContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">"初始化数据"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 在组件中就可以拿到 testContextData, 然后使用:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> testContextData <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>testContext<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>createContext 和 useContext 高级用法本质上是依赖注入，他返回一个对象，对象的 Provider 属性是一个组件，用于注入数据（在 Provider 组件上绑定 value 属性），注入的数据可以通过 useContext 获取</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 context</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">MyPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">const</span> <span class="token punctuation">[</span>theme<span class="token punctuation">,</span> setTheme<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'dark'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 将依赖注入到组件内部</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">return</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>theme<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ThemeText</span></span> <span class="token punctuation">/></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ThemeContext.Provider</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 组件内部使用注入的依赖</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">function</span> <span class="token function">ThemeText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">const</span> themeData <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>themeData<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="useref钩子"><a class="anchor" href="#useref钩子">#</a> useRef 钩子</h3><blockquote><p>帮助引用一个不需要渲染的值 (不会触发组件重新渲染), 返回一个具有 current 属性的对象，通常用于保存 DOM 节点<br>注意，改变 ref 不会触发重新渲染，所以 ref 不适合用于存储期望显示在屏幕上的信息。如有需要，使用 state 代替。React 希望不要在渲染期间写入或者读取 ref.current, 如果不得不在渲染期间读取 或者写入，那么应该 使用 state 代替。</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">const</span> <span class="token function-variable function">inputFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ref</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">return</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>inputRef<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">inputFocus</span><span class="token punctuation">(</span>inputRef<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">聚焦输入框</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">export</span> <span class="token keyword">default</span> App</pre></td></tr></table></figure><h3 id="useeffect钩子"><a class="anchor" href="#useeffect钩子">#</a> useEffect 钩子</h3><blockquote><p>接收两个参数：副作用函数和依赖项数组，当依赖项变化时自动执行副作用函数，副作用函数的返回值是一个清理函数，会在每次组件更新前进行执行<br>useEffect 中第二个参数不传代表<strong>每次渲染组件后都执行一次</strong>，传空数组代表<strong>只会在第一次挂载后执行</strong>，传依赖项代表在 ** 依赖项变化时执行。** 并且默认组件挂载时就会自动执行一次，以便可以读取到依赖项<br>useEffect 依赖项中传入 ref 通常是无效的，因为 ref 相当于不使用渲染赋值的 state 状态，传递过去的 ref 引用始终相同（不随着快照的渲染而变化）。<br>某些逻辑不能放在 effect 中执行，因为 effect 的执行是和组件渲染强绑定的（例如不能在 effect 中写购买商品的逻辑，这样会导致组件以任何方式被渲染都会执行购买逻辑，这样是不对的）<br>effect 中 return 的函数会在下一次 effect 执行前被执行，常用于执行清理函数（清除定时器等）</p></blockquote><h3 id="uselayouteffect钩子"><a class="anchor" href="#uselayouteffect钩子">#</a> useLayoutEffect 钩子</h3><blockquote><p>在浏览器重新绘制屏幕前执行，可以在此处测量布局。</p></blockquote><h3 id="useinsertioneffect钩子"><a class="anchor" href="#useinsertioneffect钩子">#</a> useInsertionEffect 钩子</h3><blockquote><p>在 React 对 DOM 进行更改之前触发，库可以在此处插入动态 CSS。</p></blockquote><h3 id="usememo钩子"><a class="anchor" href="#usememo钩子">#</a> useMemo 钩子</h3><blockquote><p>缓存函数的计算结果，只有当依赖项发生变化时，才会重新计算</p></blockquote><h3 id="usecallback钩子"><a class="anchor" href="#usecallback钩子">#</a> useCallback 钩子</h3><blockquote><p>缓存函数的定义，接收的参数是：缓存函数和依赖项，只有当依赖项 (栈值) 发生变化时，才会更新</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">ProductPage</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> productId<span class="token punctuation">,</span> referrer<span class="token punctuation">,</span> theme <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 在多次渲染中缓存函数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">const</span> handleSubmit <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">orderDetails</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/product/'</span> <span class="token operator">+</span> productId <span class="token operator">+</span> <span class="token string">'/buy'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      referrer<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      orderDetails<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>productId<span class="token punctuation">,</span> referrer<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只要这些依赖没有改变</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>theme<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token punctuation">&#123;</span><span class="token comment">/* ShippingForm 就会收到同样的 props 并且跳过重新渲染 */</span><span class="token punctuation">&#125;</span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ShippingForm</span></span> <span class="token attr-name">onSubmit</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleSubmit<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>useCallback 是由 useMemo 封装而来: (useCallback 内部存储的不是原来的函数体，而是一个普通函数返回函数体被 useMemo 缓存的结果)</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">useCallback</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>dependencies</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>fn<span class="token punctuation">,</span>dependencies<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="usetransition钩子"><a class="anchor" href="#usetransition钩子">#</a> useTransition 钩子</h3><blockquote><p>允许将状态转换标记为非阻塞，并允许其他更新中断它。为了更好地控制组件更新和动画而设计</p></blockquote><h3 id="usedeferredvalue钩子"><a class="anchor" href="#usedeferredvalue钩子">#</a> useDeferredValue 钩子</h3><blockquote><p>允许延迟更新 UI 的非关键部分，以让其他部分先更新。</p></blockquote><h3 id="fragment组件"><a class="anchor" href="#fragment组件">#</a> Fragment 组件</h3><blockquote><p>&lt;Fragment&gt; 通常使用 &lt;&gt;...&lt;/&gt; 代替，它们都允许你在不添加额外节点的情况下将子元素组合。</p></blockquote><h3 id="profiler组件"><a class="anchor" href="#profiler组件">#</a> Profiler 组件</h3><blockquote><p>&lt;Profiler&gt; 允许你编程式测量 React 树的渲染性能。接受一个 id 用于表示测量的 UI 部分，接受一个回调函数，当包裹的组件树更新时会传入渲染信息进行调用。</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Profiler</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>App<span class="token punctuation">"</span></span> <span class="token attr-name">onRender</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>onRender<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Profiler</span></span><span class="token punctuation">></span></span></pre></td></tr></table></figure><h3 id="strictmode组件"><a class="anchor" href="#strictmode组件">#</a> StrictMode 组件</h3><blockquote><p>开启严格模式，开发阶段会渲染两次，使得尽早地发现组件中错误</p></blockquote><h3 id="suspense组件-2"><a class="anchor" href="#suspense组件-2">#</a> Suspense 组件</h3><blockquote><p>展示子组件加载完成前渲染的内容.</p></blockquote><figure class="highlight jsx"><figcaption data-lang="React JSX"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Loading</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AsyncComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text"></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">></span></span></pre></td></tr></table></figure><h3 id="memo方法"><a class="anchor" href="#memo方法">#</a> memo 方法</h3><blockquote><p>memo 允许你的组件在道具没有改变的情况下跳过重新渲染</p></blockquote><h3 id="createportal方法"><a class="anchor" href="#createportal方法">#</a> createPortal 方法</h3><blockquote><p>createPortal 允许你将 JSX 作为 children 渲染至 DOM 的指定部分。</p></blockquote><h3 id="createroot方法"><a class="anchor" href="#createroot方法">#</a> createRoot 方法</h3><blockquote><p>createRoot 允许在浏览器的 DOM 节点中创建根节点以显示 React 组件。</p></blockquote><h3 id="hydrateroot方法"><a class="anchor" href="#hydrateroot方法">#</a> hydrateRoot 方法</h3><blockquote><p>hydrateRoot 函数允许你在先前由 react-dom/server 生成的浏览器 HTML DOM 节点中展示 React 组件。</p></blockquote><h3 id="act方法"><a class="anchor" href="#act方法">#</a> act 方法</h3><blockquote><p>行为测试助手，用于测试</p></blockquote><h3 id="forwardref方法"><a class="anchor" href="#forwardref方法">#</a> forwardRef 方法</h3><blockquote><p>允许组件使用 ref 将 DOM 节点指向给父组件。</p></blockquote><h3 id="lazy方法"><a class="anchor" href="#lazy方法">#</a> lazy 方法</h3><blockquote><p>延迟加载组件 (懒加载)。常配合 Suspense 组件使用</p></blockquote><h3 id="starttransition方法"><a class="anchor" href="#starttransition方法">#</a> startTransition 方法</h3><blockquote><p>可以在不阻止 UI 的情况下更新状态。</p></blockquote><h1 id="vue和react比对"><a class="anchor" href="#vue和react比对">#</a> Vue 和 React 比对</h1><h3 id="setup和hooks"><a class="anchor" href="#setup和hooks">#</a> setup 和 Hooks</h3><ul><li>React Hooks 在组件每次更新时，如果不做优化就会重新调用，这也带来一些性能问题</li><li>Hooks 有严格的调用顺序，并且不能写在条件分支中，还必须要写在 react 组件里面</li><li>昂贵的计算需要使用 useMemo, 也需要传入正确的数组</li><li>要解决变量闭包导致的问题，再结合并发功能，使得很难推理出一段钩子代码是什么时候运行的，并且很不好处理需要在多次渲染间保持引用的可变状态</li></ul><h1 id="react类组件和函数式组件"><a class="anchor" href="#react类组件和函数式组件">#</a> react 类组件和函数式组件</h1><blockquote><p>类组件和函数式的比对实际上是：面向对象和函数式编程这两大编程思想的碰撞<br>函数式编程关心的是：需要做什么，而不是怎么去做，而面向对象关心的是：数据和对象</p></blockquote><h2 id="面向对象编程"><a class="anchor" href="#面向对象编程">#</a> 面向对象编程</h2><blockquote><p>完成某项任务关心的是：数据和对象<br>面向对象编程主要围绕着数据或者对象而不是功能和逻辑实现，他将 <code>关注点放在对于数据的操作方法</code> ， <code>面向对象将数据和操作方法封装为一个类中,这样有利于代码的可复用性和可扩展性</code><br>面向对象编程的优点是：效率高 (符合现实世界)、容易维护 (结构清晰)、易扩展 (面向对象的程序往往高内聚而低耦合)、可重用 (得益于对象的继承)<br>面型对象编程的缺点是：过度的对象化、状态过于共享导致推理复杂、状态共享导致的并发问题 (可变状态复杂的共享机制导致面向对象的代码几乎不可能并行化，需要复杂的线程锁定、互斥等机制)、消耗内存、性能低 (会创建很多的类和实例)</p></blockquote><h3 id="面向对象编程三大特点"><a class="anchor" href="#面向对象编程三大特点">#</a> 面向对象编程三大特点:</h3><ul><li>封装</li><li><ul><li><code>封装意味着所有的数据和方法都被封装在对象内</code> ，由开发者自己选择性的去公开哪些属性和方法，对于创建的实例来说他能访问的只能是这些公开的属性和方法，而对于其他对象来说是无权访问此类或者进行更改， <code>封装这一特性为程序提供了更高的安全性</code> 。</li></ul></li><li>继承</li><li><ul><li><code>继承意味着代码的可重用性</code> ，子类和父类这两个概念就是很好的体现，子类拥有父类所有的属性和方法避免数据和方法的重复定义，同时也能够保持独特的层析结构， <code>继承这一特性为程序提供了可重用性</code> 。</li></ul></li><li>多态</li><li><ul><li>多态意味着设计对象以共享行为，使用继承子类可以用新的方法去覆盖父类共享的行为，多态性允许同一个方法执行两种不同的行为：覆盖和重载。</li></ul></li></ul><h2 id="函数式编程"><a class="anchor" href="#函数式编程">#</a> 函数式编程</h2><blockquote><p>完成某项任务关心的是：需要做什么，而不是怎么去做<br>函数式编程又称声明式编程，最明显的特点就是我们 <code>不太关心函数的具体实现</code> ，而 <code>只关心自己的业务逻辑线路</code><br>函数式编程的优点是：代码可读性强、有一定的逻辑复用能力、并发速度快、出错率少易排查；<br>函数式编程的缺点是：性能消耗大 (主要是创建执行上下文的消耗) 和 资源占用大 (数据不可变导致要创建很多重复的对象), 同时不利于实现时间旅行等操作 (状态很难回滚)</p></blockquote><h3 id="函数式编程三大特点"><a class="anchor" href="#函数式编程三大特点">#</a> 函数式编程三大特点:</h3><ul><li>函数是一等公民：在 JS 中函数和其他数据类型一样处于平等地位，可以作为变量赋值给其他变量，并且可以作为参数和返回值</li><li>声明式编程：函数式编程又称声明式编程，我们不太关心函数内部的具体实现，而是关心业务逻辑的执行流程</li><li>纯函数：纯函数特点：无副作用、引用透明 和 数据不可变</li><li><ul><li>无副作用：本身不会依赖和修改外部变量</li></ul></li><li><ul><li>引用透明：输入相同的值一定会得到相同的结果</li></ul></li><li><ul><li>数据不可变：针对引用数据类型的入参，最好的方式是重新生成一份数据</li></ul></li></ul><div class="tags"><a href="/tags/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/" rel="tag"><i class="ic i-tag"></i> 框架高级</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-08-02 15:10:44" itemprop="dateModified" datetime="2024-08-02T15:10:44+08:00">2024-08-02</time> </span><span id="2024/07/26/框架高级/" class="item leancloud_visitors" data-flag-title="框架高级" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="dmq 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="dmq 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>dmq <i class="ic i-at"><em>@</em></i>杜明清的个人博客</li><li class="link"><strong>本文链接：</strong> <a href="https://dmqweb.cn/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/" title="框架高级">https://dmqweb.cn/2024/07/26/框架高级/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.uuu.ovh&#x2F;imgs&#x2F;2024&#x2F;04&#x2F;25&#x2F;1276fcec5eb7990e.webp" title="操作系统"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 操作系统</span><h3>操作系统</h3></a></div><div class="item right"><a href="/2024/07/29/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.uuu.ovh&#x2F;imgs&#x2F;2024&#x2F;04&#x2F;05&#x2F;f0ab0ce587c99d2f.webp" title="架构风格"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 架构风格</span><h3>架构风格</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">vue 高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watcheffect%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">watchEffect 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchsynceffect%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">watchSyncEffect 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watchsynceffect%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.0.3.</span> <span class="toc-text">watchSyncEffect 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#effectscope%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.4.</span> <span class="toc-text">effectScope 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getcurrentscope%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.5.</span> <span class="toc-text">getCurrentScope 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onscopedispost%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.</span> <span class="toc-text">onScopeDispost 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shallowref%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.7.</span> <span class="toc-text">shallowRef 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#triggerref%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.8.</span> <span class="toc-text">triggerRef 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#customref%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.9.</span> <span class="toc-text">customRef 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shallowreactive"><span class="toc-number">1.0.10.</span> <span class="toc-text">shallowReactive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shallowreadonly"><span class="toc-number">1.0.11.</span> <span class="toc-text">shallowReadonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isref%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.12.</span> <span class="toc-text">isRef 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unref%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.13.</span> <span class="toc-text">unref 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toref%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.14.</span> <span class="toc-text">toRef 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torefs%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.15.</span> <span class="toc-text">toRefs 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toraw%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.16.</span> <span class="toc-text">toRaw 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#markraw%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.17.</span> <span class="toc-text">markRaw 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tovalue%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.18.</span> <span class="toc-text">toValue 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isproxy%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.19.</span> <span class="toc-text">isProxy 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isreactive%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.20.</span> <span class="toc-text">isReactive 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isreadonly%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.21.</span> <span class="toc-text">isreadonly 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transition%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.22.</span> <span class="toc-text">Transition 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transitiongroup%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.23.</span> <span class="toc-text">TransitionGroup 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keepalive%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.24.</span> <span class="toc-text">KeepAlive 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#teleport%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.25.</span> <span class="toc-text">Teleport 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suspense%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.26.</span> <span class="toc-text">Suspense 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E7%9A%84options%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">1.0.27.</span> <span class="toc-text">watch 的 options 配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed%E7%9A%84options%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">1.0.28.</span> <span class="toc-text">computed 的 options 配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%AF%B9jsx%E7%9A%84%E6%94%AF%E6%8C%81%E5%8F%8B%E5%A5%BD"><span class="toc-number">1.0.29.</span> <span class="toc-text">vue 对 jsx 的支持友好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%AF%B9web-component%E7%9A%84%E6%94%AF%E6%8C%81%E5%8F%8B%E5%A5%BD"><span class="toc-number">1.0.30.</span> <span class="toc-text">vue 对 web component 的支持友好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-component%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.0.31.</span> <span class="toc-text">web component 的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%BB%93%E5%90%88js%E5%8A%A8%E7%94%BB%E5%BA%93"><span class="toc-number">1.0.32.</span> <span class="toc-text">vue 结合 js 动画库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.33.</span> <span class="toc-text">vue 生命周期</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#react"><span class="toc-number">2.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fiber"><span class="toc-number">2.1.</span> <span class="toc-text">Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fiber%E6%A0%91-vdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">fiber 树、VDOM 和 diff 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hooks"><span class="toc-number">2.2.</span> <span class="toc-text">Hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#workloop%E5%B7%A5%E4%BD%9C%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.</span> <span class="toc-text">workLoop 工作循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.</span> <span class="toc-text">双缓冲策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fiber%E6%9B%B4%E6%96%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">Fiber 更新的三个阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88hooks%E4%B8%8D%E8%83%BD%E5%86%99%E5%9C%A8%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">2.5.</span> <span class="toc-text">为什么 hooks 不能写在条件判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE"><span class="toc-number">2.6.</span> <span class="toc-text">react 不可变数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reactfiberlane%E6%A8%A1%E5%9E%8B%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">ReactFiberLane 模型 (并发模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usestate%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.1.</span> <span class="toc-text">useState 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usereducer%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.2.</span> <span class="toc-text">useReducer 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createcontext%E5%92%8Cusecontext%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.3.</span> <span class="toc-text">createContext 和 useContext 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useref%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.4.</span> <span class="toc-text">useRef 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useeffect%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.5.</span> <span class="toc-text">useEffect 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uselayouteffect%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.6.</span> <span class="toc-text">useLayoutEffect 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useinsertioneffect%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.7.</span> <span class="toc-text">useInsertionEffect 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usememo%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.8.</span> <span class="toc-text">useMemo 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usecallback%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.9.</span> <span class="toc-text">useCallback 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usetransition%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.10.</span> <span class="toc-text">useTransition 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usedeferredvalue%E9%92%A9%E5%AD%90"><span class="toc-number">2.7.11.</span> <span class="toc-text">useDeferredValue 钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fragment%E7%BB%84%E4%BB%B6"><span class="toc-number">2.7.12.</span> <span class="toc-text">Fragment 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#profiler%E7%BB%84%E4%BB%B6"><span class="toc-number">2.7.13.</span> <span class="toc-text">Profiler 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strictmode%E7%BB%84%E4%BB%B6"><span class="toc-number">2.7.14.</span> <span class="toc-text">StrictMode 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#suspense%E7%BB%84%E4%BB%B6-2"><span class="toc-number">2.7.15.</span> <span class="toc-text">Suspense 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memo%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.16.</span> <span class="toc-text">memo 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createportal%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.17.</span> <span class="toc-text">createPortal 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createroot%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.18.</span> <span class="toc-text">createRoot 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hydrateroot%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.19.</span> <span class="toc-text">hydrateRoot 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#act%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.20.</span> <span class="toc-text">act 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forwardref%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.21.</span> <span class="toc-text">forwardRef 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lazy%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.22.</span> <span class="toc-text">lazy 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#starttransition%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.23.</span> <span class="toc-text">startTransition 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E5%92%8Creact%E6%AF%94%E5%AF%B9"><span class="toc-number">3.</span> <span class="toc-text">Vue 和 React 比对</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setup%E5%92%8Chooks"><span class="toc-number">3.0.1.</span> <span class="toc-text">setup 和 Hooks</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">react 类组件和函数式组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.1.</span> <span class="toc-text">面向对象编程三大特点:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">函数式编程三大特点:</span></a></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/07/26/%E6%A1%86%E6%9E%B6%E9%AB%98%E7%BA%A7/" rel="bookmark" title="框架高级">框架高级</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="dmq" data-src="/images/avatar.jpg"><p class="name" itemprop="name">dmq</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">84</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">68</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">104</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RtcTA/dGFiPXJlcG9zaXRvcmllcw==" title="https:&#x2F;&#x2F;github.com&#x2F;dmq0?tab&#x3D;repositories"><i class="ic i-github"></i></span> <span class="exturl item npm" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL35kbXEwMDA=" title="https:&#x2F;&#x2F;www.npmjs.com&#x2F;~dmq000"><i class="ic i-file"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9kLTg4LTYxLTgz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;d-88-61-83"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwMjc4OTk0OTE=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;8027899491"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS83NjI1OTAxNzE3" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7625901717"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjMyNjc4MDc1MTRAcXEuY29t" title="mailto:3267807514@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>介绍</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>工具</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/07/29/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/webpack%E9%AB%98%E7%BA%A7/" title="分类于 webpack高级">webpack高级</a></div><span><a href="/2023/12/21/webpack%E9%AB%98%E7%BA%A7/" title="webpack高级">webpack高级</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/" title="分类于 脚手架开发">脚手架开发</a></div><span><a href="/2024/04/12/%E8%84%9A%E6%89%8B%E6%9E%B6/" title="脚手架开发">脚手架开发</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="分类于 设计模式与设计原则">设计模式与设计原则</a></div><span><a href="/2024/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/" title="设计模式与设计原则">设计模式与设计原则</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/node-js/" title="分类于 node.js">node.js</a></div><span><a href="/2024/01/02/node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/" title="node.js内置模块">node.js内置模块</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/" title="分类于 脚手架开发">脚手架开发</a></div><span><a href="/2024/03/30/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/" title="本地文件链接">本地文件链接</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="分类于 前端工程化">前端工程化</a></div><span><a href="/2024/03/29/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" title="前端模块化">前端模块化</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="分类于 正则表达式">正则表达式</a></div><span><a href="/2023/02/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/json-server/" title="分类于 json-server">json-server</a></div><span><a href="/2023/01/09/json-server%E6%95%99%E7%A8%8B/" title="json-server">json-server</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E4%B8%AD%E5%89%8D%E5%8F%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="分类于 中前台解决方案">中前台解决方案</a></div><span><a href="/2023/02/12/%E4%B8%AD%E5%89%8D%E5%8F%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="中前台解决方案">中前台解决方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue-router%E5%8E%9F%E7%90%86/" title="分类于 vue-router原理">vue-router原理</a></div><span><a href="/2024/04/12/vue-router/" title="vue-router">vue-router</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">dmq @ Web blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">966k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">14:38</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/07/26/框架高级/",favicon:{show:"科技引领未来",hide:"欢迎与我交流"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://polyfill.alicdn.com/polyfill.min.js?features=Promise%2CArray.prototype.includes"></script><script src="//gcore.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?9ba187659e850a6910681214f0faa16b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html><!-- rebuild by hrmmi -->